
de1_ledos.elf:     file format elf32-littlenios2
de1_ledos.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x008001c4

Program Header:
    LOAD off    0x00001000 vaddr 0x00800000 paddr 0x00800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00800020 paddr 0x00800020 align 2**12
         filesz 0x00018998 memsz 0x00018998 flags r-x
    LOAD off    0x000199b8 vaddr 0x008189b8 paddr 0x0081a504 align 2**12
         filesz 0x00001b4c memsz 0x00001b4c flags rw-
    LOAD off    0x0001c050 vaddr 0x0081c050 paddr 0x0081c050 align 2**12
         filesz 0x00000000 memsz 0x00022ea0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00800000  00800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a4  00800020  00800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00017264  008001c4  008001c4  000011c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00001590  00817428  00817428  00018428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b4c  008189b8  0081a504  000199b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00022ea0  0081c050  0081c050  0001c050  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  0001b504  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001238  00000000  00000000  0001b530  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000025ab  00000000  00000000  0001c768  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0003403e  00000000  00000000  0001ed13  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000b159  00000000  00000000  00052d51  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00021b5c  00000000  00000000  0005deaa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000034fc  00000000  00000000  0007fa08  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003abb  00000000  00000000  00082f04  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00011fee  00000000  00000000  000869bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  000989b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000a90  00000000  00000000  000989c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 0000000c  00000000  00000000  0009ea42  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0009ea4e  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0009ea51  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0009ea52  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0009ea53  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0009ea57  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0009ea5b  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  0009ea5f  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000006  00000000  00000000  0009ea68  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000006  00000000  00000000  0009ea6e  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000a  00000000  00000000  0009ea74  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 0000002b  00000000  00000000  0009ea7e  2**0
                  CONTENTS, READONLY
 29 .jdi          00004bf6  00000000  00000000  0009eaa9  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00800000 l    d  .entry	00000000 .entry
00800020 l    d  .exceptions	00000000 .exceptions
008001c4 l    d  .text	00000000 .text
00817428 l    d  .rodata	00000000 .rodata
008189b8 l    d  .rwdata	00000000 .rwdata
0081c050 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
008001fc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 codec.c
0081c0b4 l     O .bss	00000016 codec_shadow_reg
0081a4b0 l     O .rwdata	00000008 bps2iwl_lookup
00817464 l     O .rodata	00000018 fs2sr_lookup
00000000 l    df *ABS*	00000000 acortex.c
00000000 l    df *ABS*	00000000 dac_drvr.c
008174c8 l     O .rodata	00000018 fs2div_lookup
008174e0 l     O .rodata	00000018 fs2mclk_lookup
00000000 l    df *ABS*	00000000 i2c_drvr.c
00000000 l    df *ABS*	00000000 prsr.c
00000000 l    df *ABS*	00000000 sram.c
00000000 l    df *ABS*	00000000 cortex.c
00000000 l    df *ABS*	00000000 fgyrus.c
00000000 l    df *ABS*	00000000 vcortex.c
00000000 l    df *ABS*	00000000 diskio.c
00800df8 l     F .text	00000078 rcvr_mmc
00800e70 l     F .text	0000002c deselect
00800e9c l     F .text	00000074 xmit_mmc
00800f50 l     F .text	00000090 rcvr_datablock
00800fe0 l     F .text	0000004c wait_ready
0080102c l     F .text	00000094 xmit_datablock
008010c0 l     F .text	00000050 select
00801110 l     F .text	0000013c send_cmd
0081a4b8 l     O .rwdata	00000001 Stat
0081c050 l     O .bss	00000001 CardType
00000000 l    df *ABS*	00000000 ff.c
00801798 l     F .text	00000024 mem_cpy
008017bc l     F .text	0000001c mem_set
00801824 l     F .text	000000f8 get_fileinfo
0081c054 l     O .bss	00000004 FatFs
0081c05a l     O .bss	00000001 CurrVol
00801ad8 l     F .text	00000054 validate
00801b2c l     F .text	000000e0 check_fs
00801c0c l     F .text	00000558 chk_mounted
0081c058 l     O .bss	00000002 Fsid
00802164 l     F .text	000000e8 move_window
008029c4 l     F .text	0000011c dir_sdi
00802ae0 l     F .text	00000060 dir_remove
00802b40 l     F .text	00000148 create_chain
0080316c l     F .text	000001c4 dir_next
00803330 l     F .text	000000c4 dir_register
008033f4 l     F .text	00000090 dir_read
0080377c l     F .text	0000043c follow_path
00803dc0 l     F .text	000000cc remove_chain
00803fb4 l     F .text	00000114 sync
00000000 l    df *ABS*	00000000 fft_cache.c
00000000 l    df *ABS*	00000000 ledos.c
0081c05c l     O .bss	00000004 aud_bytes_read
0081c0cc l     O .bss	00000540 AcidStack
0081c60c l     O .bss	00012140 ShellStack
00000000 l    df *ABS*	00000000 lsd.c
0080523c l     F .text	00000028 acid_sunshine
00817ca0 l     O .rodata	00000010 acid_box
00000000 l    df *ABS*	00000000 bash.c
0081a4bc l     O .rwdata	00000004 shell_cfg1
0081c06c l     O .bss	00000004 current_acid_str
0081c068 l     O .bss	00000004 current_acid
00805330 l     F .text	00000168 cmd_drop_acid
0081c060 l     O .bss	00000004 bash_tp
0081c064 l     O .bss	00000004 acid_tp
00805498 l     F .text	00000154 cmd_cath
008055ec l     F .text	000000c4 cmd_touch
008056b0 l     F .text	000001c4 cmd_perf
00805874 l     F .text	0000012c cmd_cat
008059a0 l     F .text	00000060 cmd_pwd
00805a00 l     F .text	00000118 cmd_ll
00805b18 l     F .text	0000008c cmd_cd
00805ba4 l     F .text	000000a0 cmd_mv
00805c44 l     F .text	00000074 cmd_mem
008180a4 l     O .rodata	00000058 commands
00000000 l    df *ABS*	00000000 shell.c
00805d84 l     F .text	00000040 list_commands
00805dc4 l     F .text	00000010 usage
00806114 l     F .text	000001d0 shell_thread
00805ef4 l     F .text	00000080 cmdexec
00805f74 l     F .text	00000028 cmd_systime
00805f9c l     F .text	000000ec cmd_info
00806088 l     F .text	0000008c _strtok
008189b8 l     O .rwdata	00000018 local_commands
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00806338 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 strcasecmp.c
00000000 l    df *ABS*	00000000 strpbrk.c
00000000 l    df *ABS*	00000000 strspn.c
00000000 l    df *ABS*	00000000 vfprintf.c
0080668c l     F .text	00000058 __sprint_r
00818346 l     O .rodata	00000010 blanks.3452
00818336 l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 ctype_.c
00818457 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 dtoa.c
00808708 l     F .text	00000244 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0080a130 l     F .text	00000058 std
0080a23c l     F .text	00000008 __fp_lock
0080a244 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
008189d0 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 locale.c
0081a4d0 l     O .rwdata	00000004 charset
008185fc l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mprec.c
00818744 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
0080e664 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 chdynamic.c
00000000 l    df *ABS*	00000000 chevents.c
00000000 l    df *ABS*	00000000 chheap.c
0082e774 l     O .bss	0000001c default_heap
00000000 l    df *ABS*	00000000 chmemcore.c
0081c094 l     O .bss	00000004 nextmem
0081c098 l     O .bss	00000004 endmem
00000000 l    df *ABS*	00000000 chmempools.c
00000000 l    df *ABS*	00000000 chmsg.c
008114fc l     F .text	00000060 queue_insert
008115fc l     F .text	00000050 fifo_remove
00000000 l    df *ABS*	00000000 chmtx.c
008118b0 l     F .text	0000004c dequeue
008118fc l     F .text	00000094 prio_insert
00811bc0 l     F .text	00000050 fifo_remove
00000000 l    df *ABS*	00000000 chschd.c
00812004 l     F .text	00000050 fifo_remove
00812054 l     F .text	000000b8 wakeup
0081210c l     F .text	0000004c dequeue
00000000 l    df *ABS*	00000000 chthreads.c
00812ab8 l     F .text	00000040 list_remove
00812b94 l     F .text	00000040 list_insert
00000000 l    df *ABS*	00000000 chvt.c
00812e8c l       .text	00000000 _port_thread_start_loop
00000000 l    df *ABS*	00000000 alt_close.c
00813008 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00813068 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0081316c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_getchar.c
00000000 l    df *ABS*	00000000 alt_isatty.c
008132c8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
008133a8 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00813508 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_read.c
008139ec l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0081a4f4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
00813ca4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0081938c l     O .rwdata	00001060 jtag_uart
0081a3ec l     O .rwdata	000000c4 uart_0
00813dc4 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00814004 l     F .text	00000228 altera_avalon_jtag_uart_irq
0081422c l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_performance_counter.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00814a30 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00814cf0 l     F .text	0000009c altera_avalon_uart_irq
00814d8c l     F .text	000000e0 altera_avalon_uart_rxirq
00814e6c l     F .text	0000015c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00815258 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00815480 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 perf_print_formatted_report.c
00000000 l    df *ABS*	00000000 chsys.c
0082e790 l     O .bss	00000048 mainthread.2251
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00815ba4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00815fb4 l     F .text	000000d8 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00816104 l     F .text	000000f8 alt_file_locked
00816388 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 chcore.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00816f38 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 refill.c
008172b0 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_exit.c
00817354 l     F .text	00000040 alt_sim_halt
00811234 g     F .text	00000060 chPoolInit
0080bf20 g     F .text	00000094 _mprec_log10
00800884 g     F .text	00000058 update_mclk
0080c00c g     F .text	00000088 __any_on
0080d838 g     F .text	00000070 _isatty_r
0081871c g     O .rodata	00000028 __mprec_tinytens
00813568 g     F .text	00000088 alt_main
00810424 g     F .text	000000b4 chEvtSignalFlagsI
00815854 g     F .text	0000012c chSysTimerHandlerI
008129b8 g     F .text	00000048 chThdExit
0081053c g     F .text	00000070 chEvtBroadcastFlagsI
00812158 g     F .text	00000090 chSchGoSleepTimeoutS
0083ec60 g     O .bss	00000100 alt_irq
00800ab8 g     F .text	00000030 prsr_get_bytes_read
0080d8a8 g     F .text	00000078 _lseek_r
00802424 g     F .text	00000184 get_fat
00800f10 g     F .text	00000040 dly_us
0081a504 g       *ABS*	00000000 __flash_rwdata_start
0080f184 g     F .text	00000088 __eqdf2
0081174c g     F .text	00000164 chMtxLockS
008100a4 g     F .text	000000d0 chThdCreateFromMemoryPool
0080096c g     F .text	00000020 disable_dac_drvr
0083eef0 g       *ABS*	00000000 __alt_heap_start
008064bc g     F .text	00000044 printf
008119f0 g     F .text	00000084 chMtxTryLockS
00810e90 g     F .text	00000188 chHeapFree
0080d27c g     F .text	00000068 __sseek
0080a198 g     F .text	000000a4 __sinit
00814a0c g     F .text	00000024 alt_get_cpu_freq
00816cb8 g     F .text	00000130 __swbuf_r
008103c0 g     F .text	00000064 chEvtSignalFlags
0081c070 g     O .bss	00000004 bash_rc
0080aea4 g     F .text	00000084 _setlocale_r
0080a298 g     F .text	0000009c __sfmoreglue
0080504c g     F .text	0000011c splash_ledos
00813610 g     F .text	00000020 __malloc_unlock
00800c0c g     F .text	00000058 sram_read16
008009a4 g     F .text	0000001c is_busy
0081020c g     F .text	000000a4 chEvtUnregister
00805270 g     F .text	00000008 get_usr_bash_config
0080b99c g     F .text	000000e0 memmove
008154e0 g     F .text	00000294 perf_print_formatted_report
0080a288 g     F .text	00000010 _cleanup
0080c094 g     F .text	000000bc _Balloc
00811f6c g     F .text	00000098 chSchGoSleepS
0080f294 g     F .text	00000088 __gtdf2
00000000  w      *UND*	00000000 __errno
00800260 g     F .text	00000050 codec_config_reg
00800000 g     F .entry	0000000c __reset
00800020 g       *ABS*	00000000 __flash_exceptions_start
0080d7c4 g     F .text	00000074 _fstat_r
00800ddc g     F .text	0000001c wait_on_spi
0081c090 g     O .bss	00000004 errno
00816ca4 g     F .text	00000014 __srget
008124f4 g     F .text	00000158 chThdCreateI
0081c0a0 g     O .bss	00000004 alt_argv
008224b0 g       *ABS*	00000000 _gp
0082e7e4 g     O .bss	00010000 bash_Buff
00800404 g     F .text	00000014 codec_dsp_if_inactivate
00800854 g     F .text	00000014 disable_mclk
00804ea4 g     F .text	000000fc printf_wave_hdr
00800328 g     F .text	00000014 codec_pwr_off_n_on
0080353c g     F .text	00000240 f_getcwd
008121e8 g     F .text	000000ac chSchWakeupS
00811e34 g     F .text	00000090 _scheduler_init
00812294 g     F .text	0000004c chSchRescheduleS
0081264c g     F .text	0000008c chThdCreateStatic
0081920c g     O .rwdata	00000180 alt_fd_list
00800b9c g     F .text	00000018 prsr_enable
00800314 g     F .text	00000014 codec_linein_pwr_dwn_n_up
00810344 g     F .text	0000007c chEvtAddFlags
00816968 g     F .text	00000090 _getc_r
00805cdc g     F .text	0000009c acid_thread
008168d0 g     F .text	00000098 getc
00816600 g     F .text	00000094 alt_find_dev
0080b8fc g     F .text	000000a0 memcpy
00800668 g     F .text	00000074 acortex_init
0080a27c g     F .text	0000000c _cleanup_r
0080f42c g     F .text	000000f8 __floatsidf
0081608c g     F .text	00000078 alt_io_redirect
0080f3a4 g     F .text	00000088 __ltdf2
00817428 g       *ABS*	00000000 __DTOR_END__
0080124c g     F .text	00000198 disk_initialize
00800950 g     F .text	0000001c enable_dac_drvr
00811ec4 g     F .text	000000a8 chSchReadyI
00800ae8 g     F .text	0000002c prsr_hdr_ram_read16
008165b0  w    F .text	00000028 port_halt
00812bd4 g     F .text	00000064 _vt_init
0080be70 g     F .text	000000b0 __ratio
0080042c g     F .text	00000070 codec_reset
0081118c g     F .text	0000007c chCoreAllocI
008040c8 g     F .text	00000210 f_rename
00814444 g     F .text	00000224 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00806500 g     F .text	00000034 _printf_r
00806474 g     F .text	00000008 __udivsi3
00813204 g     F .text	000000c4 isatty
00810bf4 g     F .text	0000005c _heap_init
008052c0 g     F .text	00000070 update_acid
0081862c g     O .rodata	000000c8 __mprec_tens
0080ae80 g     F .text	00000008 __locale_charset
00803d04 g     F .text	000000bc f_chdir
00804c1c g     F .text	00000058 read_fft_cache
0081c084 g     O .bss	00000004 __malloc_top_pad
008013e4 g     F .text	00000064 disk_status
008149ac g     F .text	00000040 perf_get_num_starts
008009c0 g     F .text	00000030 get_i2c_status
00803e8c g     F .text	00000128 f_truncate
0080ffe0 g     F .text	000000c4 chThdCreateFromHeap
0081a4cc g     O .rwdata	00000004 __mb_cur_max
00801968 g     F .text	00000170 decode_fres
0080ae88 g     F .text	0000000c _localeconv_r
0080c7f8 g     F .text	0000003c __i2b
0080a864 g     F .text	0000049c __sfvwrite_r
0080d204 g     F .text	00000070 _sbrk_r
00804c88 g     F .text	00000020 byte_swap16
0080d920 g     F .text	00000078 _read_r
00811018 g     F .text	000000c8 chHeapStatus
00801448 g     F .text	0000015c disk_ioctl
00818dd0 g     O .rwdata	0000000c __lc_ctype
00800bb4 g     F .text	00000058 sram_write16
0081a4ec g     O .rwdata	00000004 alt_max_fd
0080fc48 g     F .text	00000138 __unpack_d
0080d6a0 g     F .text	00000110 _fclose_r
0080a0fc g     F .text	00000034 fflush
0081c088 g     O .bss	00000004 __malloc_max_sbrked_mem
008002c4 g     F .text	00000014 codec_sr_update
0080eaf4 g     F .text	00000074 __adddf3
0080bd50 g     F .text	00000120 __b2d
00812a00 g     F .text	000000b8 chThdExitS
0080e004 g     F .text	00000660 __umoddi3
00813414 g     F .text	000000f4 lseek
0083e7e4 g     O .bss	0000001c bash_dir
0081a4c8 g     O .rwdata	00000004 _global_impure_ptr
0080cba0 g     F .text	000005f4 _realloc_r
0083eef0 g       *ABS*	00000000 __bss_end
00815ebc g     F .text	000000f8 alt_iic_isr_register
008131cc g     F .text	00000038 alt_getchar
00816480 g     F .text	00000110 alt_tick
0081c074 g     O .bss	00000004 shell_terminated
0080d998 g     F .text	0000066c __udivdi3
008186f4 g     O .rodata	00000028 __mprec_bigtens
0080ca80 g     F .text	00000120 __s2b
0080f5fc g     F .text	00000194 __floatunsidf
0080bc70 g     F .text	00000060 __mcmp
00814c28 g     F .text	000000c8 altera_avalon_uart_init
0081a4c0 g     O .rwdata	00000004 __ctype_ptr
0080a264 g     F .text	00000018 __fp_lock_all
00804480 g     F .text	0000017c f_unlink
00815e74 g     F .text	00000048 alt_ic_irq_enabled
00805d78 g     F .text	0000000c shellInit
008163e8 g     F .text	00000098 alt_alarm_stop
0081c0a8 g     O .bss	00000004 alt_irq_active
00804c74 g     F .text	00000014 update_aud_bytes_read
00812c38 g     F .text	00000114 chVTSetI
008000ec g     F .exceptions	000000d8 alt_irq_handler
008191e4 g     O .rwdata	00000028 alt_dev_null
00815ad4 g     F .text	0000001c alt_dcache_flush_all
0080bb3c g     F .text	00000070 __hi0bits
0080f524 g     F .text	000000d8 __fixdfsi
0083e800 g     O .bss	00000018 bash_fno
0081a504 g       *ABS*	00000000 __ram_rwdata_end
0081a4e4 g     O .rwdata	00000008 alt_dev_list
00813b80 g     F .text	00000124 write
00816b70 g     F .text	000000e8 _putc_r
0082e7d8 g     O .bss	0000000c shell_tel
008189b8 g       *ABS*	00000000 __ram_rodata_end
00813094 g     F .text	000000d8 fstat
00800930 g     F .text	00000020 disable_adc_drvr
008116f4 g     F .text	00000058 chMtxLock
00805ec4 g     F .text	00000030 shellCreateStatic
0080c960 g     F .text	00000120 __pow5mult
00811208 g     F .text	0000002c chCoreStatus
0081c078 g     O .bss	00000004 __nlocale_changed
0080647c g     F .text	00000008 __umodsi3
00812360 g     F .text	00000090 chSchDoReschedule
008157a4 g     F .text	000000b0 chSysInit
00801948 g     F .text	00000018 f_chdrive
00812868 g     F .text	0000005c chThdSleep
0083eef0 g       *ABS*	00000000 end
00800200 g     F .text	00000060 codec_dump_regs
00812dd4 g     F .text	000000a8 chTimeIsWithin
008152b8 g     F .text	000001c8 altera_avalon_uart_write
00813f44 g     F .text	000000c0 altera_avalon_jtag_uart_init
00817424 g       *ABS*	00000000 __CTOR_LIST__
01000000 g       *ABS*	00000000 __alt_stack_pointer
00814aa0 g     F .text	00000090 alt_avalon_timer_sc_init
00814b88 g     F .text	00000058 altera_avalon_uart_write_fd
0080f8b4 g     F .text	00000080 __clzsi2
00814be0 g     F .text	00000048 altera_avalon_uart_close_fd
008102b0 g     F .text	00000094 chEvtClearFlags
00814668 g     F .text	00000240 altera_avalon_jtag_uart_write
0080a188 g     F .text	00000004 __sfp_lock_acquire
0080b818 g     F .text	000000e4 memchr
00805264 g     F .text	0000000c get_acid_box
008066e4 g     F .text	00001ec4 ___vfprintf_internal_r
0080a550 g     F .text	00000314 _free_r
00813630 g     F .text	00000258 alt_printf
00811294 g     F .text	00000084 chPoolAllocI
00804fa0 g     F .text	000000ac wave_parse
00800dc0 g     F .text	00000004 disk_timerproc
00816c58 g     F .text	0000004c __srget_r
00816f3c g     F .text	000001b0 __call_exitprocs
00804cd8 g     F .text	000000ac chk_wav_hdr
0081c07c g     O .bss	00000004 __mlocale_changed
008046f4 g     F .text	0000002c f_close
0081a4d8 g     O .rwdata	00000004 __malloc_sbrk_base
008001c4 g     F .text	0000003c _start
008110e0 g     F .text	0000004c _core_init
0081c0ac g     O .bss	00000004 _alt_tick_rate
00811c10 g     F .text	00000120 chMtxUnlockS
00800ce4 g     F .text	00000020 get_fgyrus_status
008165d8 g     F .text	00000028 port_time_tick
008127a8 g     F .text	00000060 chThdResume
008172cc g     F .text	00000088 __floatundidf
00811990 g     F .text	00000060 chMtxTryLock
0080c458 g     F .text	0000014c __lshift
0081c0b0 g     O .bss	00000004 _alt_nticks
008138c8 g     F .text	00000124 read
00813d38 g     F .text	0000008c alt_sys_init
008008dc g     F .text	00000038 configure_dac_drvr_bps
00800b88 g     F .text	00000014 prsr_disable
00816e04 g     F .text	00000134 __register_exitproc
00811d30 g     F .text	00000104 chMtxUnlockAll
00802784 g     F .text	00000240 f_read
00811318 g     F .text	00000060 chPoolAlloc
0080c5a4 g     F .text	00000254 __multiply
00803484 g     F .text	000000b8 f_readdir
00810af4 g     F .text	00000100 chEvtWaitAllTimeout
008142dc g     F .text	00000074 altera_avalon_jtag_uart_close
00806484 g     F .text	00000038 __mulsi3
008189b8 g       *ABS*	00000000 __ram_rwdata_start
00817428 g       *ABS*	00000000 __ram_rodata_start
0082e74c g     O .bss	00000028 __malloc_current_mallinfo
0080c150 g     F .text	0000017c __d2b
00806534 g     F .text	000000b0 strcasecmp
00811438 g     F .text	000000c4 chMsgSend
008043ac g     F .text	000000d4 f_chmod
0080063c g     F .text	00000014 acortex_aud_src_sel
0083ea90 g     O .bss	00000010 vtlist
00813dfc g     F .text	00000058 altera_avalon_jtag_uart_read_fd
008167b4 g     F .text	000000d0 alt_get_fd
0080fd80 g     F .text	000000c8 __fpcmp_parts_d
00805278 g     F .text	00000048 init_bash
0081112c g     F .text	00000060 chCoreAlloc
0080d630 g     F .text	00000070 _close_r
008062e4 g     F .text	00000028 shellCreate
00810cd8 g     F .text	000001b8 chHeapAlloc
0080fe48 g     F .text	00000064 chThdAddRef
008148a8 g     F .text	000000b0 perf_get_section_time
008169f8 g     F .text	00000074 memcmp
00813eac g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0083eef0 g       *ABS*	00000000 __alt_stack_base
00813ef4 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
00812e90 g       .text	00000000 port_switch
008085cc g     F .text	0000013c __swsetup_r
00800d04 g     F .text	0000001c configure_post_norm
0080ef2c g     F .text	00000258 __divdf3
0080a334 g     F .text	000000f0 __sfp
008002ec g     F .text	00000014 codec_adc_hpf_enable
0080bfb4 g     F .text	00000058 __copybits
00814958 g     F .text	00000054 perf_get_total_time
00818ddc g     O .rwdata	00000408 __malloc_av_
0080a194 g     F .text	00000004 __sinit_lock_release
0080eb68 g     F .text	000003c4 __muldf3
0080d360 g     F .text	00000060 __sread
00801960 g     F .text	00000008 get_fattime
00816694 g     F .text	00000120 alt_find_file
00815af0 g     F .text	000000b4 alt_dev_llist_insert
008135f0 g     F .text	00000020 __malloc_lock
00813ac4 g     F .text	000000bc sbrk
00809f00 g     F .text	000001fc _fflush_r
0080d568 g     F .text	000000c8 _calloc_r
00805cb8 g     F .text	00000024 acidThreadCreateStatic
0081155c g     F .text	000000a0 chMsgWait
0081c050 g       *ABS*	00000000 __bss_start
008128c4 g     F .text	00000080 chThdSleepUntil
0080ba7c g     F .text	00000098 memset
0080630c g     F .text	0000002c main
0081c0a4 g     O .bss	00000004 alt_envp
0081c08c g     O .bss	00000004 __malloc_max_total_mem
00813e54 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0083ea70 g     O .bss	00000020 rlist
00816de8 g     F .text	0000001c __swbuf
008045fc g     F .text	000000f8 f_sync
00800cd0 g     F .text	00000014 get_full_fgyrus_addr
00804ca8 g     F .text	00000030 byte_swap32
0080049c g     F .text	000001a0 codec_init
0080d274 g     F .text	00000008 __sclose
01000000 g       *ABS*	00000000 __alt_heap_limit
008009f0 g     F .text	00000018 configure_i2c_clk
0080d7b0 g     F .text	00000014 fclose
0083ed60 g     O .bss	00000190 _atexit0
0080894c g     F .text	000015b4 _dtoa_r
0080b0d8 g     F .text	00000740 _malloc_r
00805168 g     F .text	000000d4 init_ledos
0081a4f0 g     O .rwdata	00000004 alt_errno
0080191c g     F .text	0000002c f_mount
008003a0 g     F .text	00000064 codec_dac_activate
0080adc8 g     F .text	000000b8 _fwalk
008116ac g     F .text	00000048 chMtxInit
00803c40 g     F .text	000000c4 f_opendir
00800d6c g     F .text	00000030 pwm_paint
00815774 g     F .text	00000030 _idle_thread
008104d8 g     F .text	00000064 chEvtBroadcastFlags
00816a6c g     F .text	00000104 putc
008063b4 g     F .text	00000060 __divsi3
00800d4c g     F .text	00000020 get_fgyrus_fsm_pstate
00818750 g     O .rodata	00000014 __thenan_df
0080a424 g     F .text	0000012c _malloc_trim_r
00817428 g       *ABS*	00000000 __CTOR_END__
0080d3c0 g     F .text	000000bc strcmp
00817428 g       *ABS*	00000000 __flash_rodata_start
00810658 g     F .text	000000dc chEvtWaitOne
00817428 g       *ABS*	00000000 __DTOR_LIST__
00812e7c g       .text	00000000 _port_thread_start
00811378 g     F .text	00000060 chPoolFreeI
0080224c g     F .text	000001d8 put_fat
0080f20c g     F .text	00000088 __nedf2
00800b14 g     F .text	00000074 get_wav_hdr_frm_prsr
00813d04 g     F .text	00000034 alt_irq_init
00813a4c g     F .text	00000078 alt_release_fd
00802c88 g     F .text	00000230 f_lseek
00818764 g     O .rodata	00000100 __clz_tab
0081c080 g     O .bss	00000004 _PathLocale
00816884 g     F .text	00000014 atexit
008107fc g     F .text	000000ac chEvtWaitAll
0080d4f0 g     F .text	00000078 _write_r
0080af28 g     F .text	0000001c setlocale
0081a4c4 g     O .rwdata	00000004 _impure_ptr
0081c09c g     O .bss	00000004 alt_argc
008105ac g     F .text	000000ac chEvtDispatch
00815c68 g     F .text	00000064 _do_dtors
00800418 g     F .text	00000014 codec_dsp_if_activate
00805dd4 g     F .text	000000f0 shellGetLine
0080feac g     F .text	00000134 chThdRelease
008108a8 g     F .text	00000130 chEvtWaitOneTimeout
008170ec g     F .text	000001c4 __srefill_r
00800c64 g     F .text	0000006c cortex_init
00800d20 g     F .text	00000014 disable_fgyrus
00800020 g       .exceptions	00000000 alt_irq_entry
0080098c g     F .text	00000018 get_i2c_clk
0083eaa0 g     O .bss	000001c0 _idle_thread_wa
0080bcd0 g     F .text	00000080 __ulp
0080d194 g     F .text	00000040 __isinfd
00803bb8 g     F .text	00000088 f_stat
0080a24c g     F .text	00000018 __fp_unlock_all
008113d8 g     F .text	00000060 chPoolFree
0081a4dc g     O .rwdata	00000008 alt_fs_list
00800d34 g     F .text	00000018 enable_fgyrus
0081164c g     F .text	00000060 chMsgRelease
0083e818 g     O .bss	00000024 bash_Fil
00800020 g       *ABS*	00000000 __ram_exceptions_start
0080ae94 g     F .text	00000010 localeconv
008017d8 g     F .text	0000004c clust2sect
00811a74 g     F .text	0000014c chMtxUnlock
00800828 g     F .text	0000002c update_fs_div
008109d8 g     F .text	0000011c chEvtWaitAnyTimeout
00815ce8 g     F .text	00000050 alt_ic_isr_register
0081a504 g       *ABS*	00000000 _edata
008042d8 g     F .text	000000d4 f_utime
00814b30 g     F .text	00000058 altera_avalon_uart_read_fd
0083eef0 g       *ABS*	00000000 _end
00810734 g     F .text	000000c8 chEvtWaitAny
008001c4 g       *ABS*	00000000 __ram_exceptions_end
00812d4c g     F .text	00000088 chVTResetI
00802eb8 g     F .text	000002b4 f_write
00814350 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
008006dc g     F .text	0000014c adc_cap
00800650 g     F .text	00000018 reset_acortex
00800a08 g     F .text	000000b0 i2c_xtn_write16
00815dd4 g     F .text	000000a0 alt_ic_irq_disable
00810174 g     F .text	00000098 chEvtRegisterMask
0080d2e4 g     F .text	0000007c __swrite
0081a4d4 g     O .rwdata	00000004 __malloc_trim_threshold
00804720 g     F .text	00000268 f_open
008149ec g     F .text	00000020 alt_get_performance_counter_base
008015a4 g     F .text	0000010c disk_write
00816590 g     F .text	00000020 altera_nios2_qsys_irq_init
00800dac g     F .text	00000014 enable_vcortex
00816898 g     F .text	00000038 exit
0080ad00 g     F .text	000000c8 _fwalk_reent
0080c2cc g     F .text	0000018c __mdiff
00806414 g     F .text	00000060 __modsi3
01000000 g       *ABS*	00000000 __alt_data_end
00800020 g     F .exceptions	00000000 alt_exception
0080a18c g     F .text	00000004 __sfp_lock_release
00800914 g     F .text	0000001c enable_adc_drvr
00800000 g       *ABS*	00000000 __alt_mem_sdram
008126d8 g     F .text	000000d0 chThdSetPriority
00818356 g     O .rodata	00000101 _ctype_
00812af8 g     F .text	0000009c chThdWait
00804988 g     F .text	00000294 f_mkdir
00814fc8 g     F .text	00000060 altera_avalon_uart_close
008122e0 g     F .text	00000080 chSchIsPreemptionRequired
00817394 g     F .text	00000024 _exit
0080d1d4 g     F .text	00000030 __isnand
00815980 g     F .text	00000154 alt_alarm_start
00806634 g     F .text	00000058 strspn
0080f790 g     F .text	00000124 __muldi3
008002d8 g     F .text	00000014 codec_adc_pwr_dwn_n_up
008123f0 g     F .text	00000104 _thread_init
0080af44 g     F .text	00000194 __smakebuf_r
0080d47c g     F .text	00000074 strlen
008016b0 g     F .text	000000e8 disk_read
008161fc g     F .text	0000018c open
0080f31c g     F .text	00000088 __gedf2
00813888 g     F .text	00000040 alt_putchar
00812944 g     F .text	00000074 chThdYield
00804d84 g     F .text	00000120 prep_cortex
00815ccc g     F .text	0000001c alt_icache_flush_all
008025a8 g     F .text	000001dc f_getfree
0083e83c g     O .bss	00000234 bash_Fatfs
0080033c g     F .text	00000064 codec_dac_inactivate
0081a4f8 g     O .rwdata	00000004 alt_priority_mask
00800868 g     F .text	0000001c enable_mclk
00810c50 g     F .text	00000088 chHeapInit
008002b0 g     F .text	00000014 codec_iwl_update
00815d38 g     F .text	0000009c alt_ic_irq_enable
00800300 g     F .text	00000014 codec_lineout_pwr_dwn_n_up
008085a8 g     F .text	00000024 __vfprintf_internal
00815028 g     F .text	00000230 altera_avalon_uart_read
0080ea74 g     F .text	00000080 __subdf3
0080bbac g     F .text	000000c4 __lo0bits
00800dc4 g     F .text	00000018 init_port
0081a4fc g     O .rwdata	00000008 alt_alarm_list
00815c04 g     F .text	00000064 _do_ctors
00800d9c g     F .text	00000010 disable_vcortex
00812f08 g     F .text	00000100 close
00812808 g     F .text	00000060 chThdTerminate
00813328 g     F .text	00000080 alt_load
0080f934 g     F .text	00000314 __pack_d
008065e4 g     F .text	00000050 strpbrk
00000000  w      *UND*	00000000 free
0080a190 g     F .text	00000004 __sinit_lock_acquire
0080c834 g     F .text	0000012c __multadd
0080bb14 g     F .text	00000028 _Bfree



Disassembly of section .entry:

00800000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  800000:	00402034 	movhi	at,128
    ori r1, r1, %lo(_start)
  800004:	08407114 	ori	at,at,452
    jmp r1
  800008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00800020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
  800020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
  800024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
  800028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  80002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  800030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  800034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  800038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  80003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  800040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
  800044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
  800048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  80004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  800050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  800054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  800058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  80005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  800060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  800064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  800068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  80006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  800070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  800074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  800078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  80007c:	10000326 	beq	r2,zero,80008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  800080:	20000226 	beq	r4,zero,80008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  800084:	08000ec0 	call	8000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  800088:	00000306 	br	800098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  80008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  800090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  800094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  800098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  80009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  8000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  8000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  8000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  8000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  8000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  8000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  8000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  8000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  8000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
  8000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  8000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  8000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  8000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  8000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  8000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  8000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  8000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
  8000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  8000e8:	ef80083a 	eret

008000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  8000ec:	defff904 	addi	sp,sp,-28
  8000f0:	dfc00615 	stw	ra,24(sp)
  8000f4:	df000515 	stw	fp,20(sp)
  8000f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  8000fc:	0005313a 	rdctl	r2,ipending
  800100:	e0bffc15 	stw	r2,-16(fp)

  return active;
  800104:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  800108:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
  80010c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  800110:	00800044 	movi	r2,1
  800114:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  800118:	e0ffff17 	ldw	r3,-4(fp)
  80011c:	e0bffe17 	ldw	r2,-8(fp)
  800120:	1884703a 	and	r2,r3,r2
  800124:	1005003a 	cmpeq	r2,r2,zero
  800128:	1000161e 	bne	r2,zero,800184 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  80012c:	e0bffd17 	ldw	r2,-12(fp)
  800130:	00c02134 	movhi	r3,132
  800134:	18fb1804 	addi	r3,r3,-5024
  800138:	100490fa 	slli	r2,r2,3
  80013c:	10c5883a 	add	r2,r2,r3
  800140:	11400017 	ldw	r5,0(r2)
  800144:	e0bffd17 	ldw	r2,-12(fp)
  800148:	00c02134 	movhi	r3,132
  80014c:	18fb1804 	addi	r3,r3,-5024
  800150:	100490fa 	slli	r2,r2,3
  800154:	10c5883a 	add	r2,r2,r3
  800158:	10800104 	addi	r2,r2,4
  80015c:	11000017 	ldw	r4,0(r2)
  800160:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800164:	0005313a 	rdctl	r2,ipending
  800168:	e0bffb15 	stw	r2,-20(fp)

  return active;
  80016c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  800170:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
  800174:	e0bfff17 	ldw	r2,-4(fp)
  800178:	1004c03a 	cmpne	r2,r2,zero
  80017c:	103fe31e 	bne	r2,zero,80010c <alt_irq_handler+0x20>
  800180:	00000706 	br	8001a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  800184:	e0bffe17 	ldw	r2,-8(fp)
  800188:	1085883a 	add	r2,r2,r2
  80018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
  800190:	e0bffd17 	ldw	r2,-12(fp)
  800194:	10800044 	addi	r2,r2,1
  800198:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  80019c:	003fde06 	br	800118 <alt_irq_handler+0x2c>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  8001a0:	08122e00 	call	8122e0 <chSchIsPreemptionRequired>
  8001a4:	1005003a 	cmpeq	r2,r2,zero
  8001a8:	1000011e 	bne	r2,zero,8001b0 <alt_irq_handler+0xc4>
  8001ac:	08123600 	call	812360 <chSchDoReschedule>
}
  8001b0:	e037883a 	mov	sp,fp
  8001b4:	dfc00117 	ldw	ra,4(sp)
  8001b8:	df000017 	ldw	fp,0(sp)
  8001bc:	dec00204 	addi	sp,sp,8
  8001c0:	f800283a 	ret

Disassembly of section .text:

008001c4 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  8001c4:	06c04034 	movhi	sp,256
    ori sp, sp, %lo(__alt_stack_pointer)
  8001c8:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
  8001cc:	068020b4 	movhi	gp,130
    ori gp, gp, %lo(_gp)
  8001d0:	d6892c14 	ori	gp,gp,9392
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  8001d4:	00802074 	movhi	r2,129
    ori r2, r2, %lo(__bss_start)
  8001d8:	10b01414 	ori	r2,r2,49232

    movhi r3, %hi(__bss_end)
  8001dc:	00c020f4 	movhi	r3,131
    ori r3, r3, %lo(__bss_end)
  8001e0:	18fbbc14 	ori	r3,r3,61168

    beq r2, r3, 1f
  8001e4:	10c00326 	beq	r2,r3,8001f4 <_start+0x30>

0:
    stw zero, (r2)
  8001e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  8001ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  8001f0:	10fffd36 	bltu	r2,r3,8001e8 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  8001f4:	08133280 	call	813328 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  8001f8:	08135680 	call	813568 <alt_main>

008001fc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  8001fc:	003fff06 	br	8001fc <alt_after_alt_main>

00800200 <codec_dump_regs>:

I2C_RES codec_iwl_update(CODEC_IWL val){
	return codec_config_reg(CODEC_IWL_IDX, CODEC_IWL_OFFST, CODEC_IWL_MSK, val);
}

void codec_dump_regs(){
  800200:	defffd04 	addi	sp,sp,-12
	alt_u8 i;

	alt_printf("CODEC Regs - \r\n");
  800204:	01002074 	movhi	r4,129
  800208:	211d0a04 	addi	r4,r4,29736

I2C_RES codec_iwl_update(CODEC_IWL val){
	return codec_config_reg(CODEC_IWL_IDX, CODEC_IWL_OFFST, CODEC_IWL_MSK, val);
}

void codec_dump_regs(){
  80020c:	dc400115 	stw	r17,4(sp)
  800210:	dc000015 	stw	r16,0(sp)
  800214:	dfc00215 	stw	ra,8(sp)
	alt_u8 i;

	alt_printf("CODEC Regs - \r\n");
  800218:	0021883a 	mov	r16,zero
  80021c:	08136300 	call	813630 <alt_printf>
  800220:	044020b4 	movhi	r17,130
  800224:	8c702d04 	addi	r17,r17,-16204

	for(i=0; i<NO_OF_CODEC_REGS; i++){
		alt_printf("REG[0x%x] - 0x%x\r\n",i,codec_shadow_reg[i]);
  800228:	8980000b 	ldhu	r6,0(r17)
  80022c:	800b883a 	mov	r5,r16
  800230:	01002074 	movhi	r4,129
  800234:	211d0e04 	addi	r4,r4,29752
  800238:	08136300 	call	813630 <alt_printf>
  80023c:	84000044 	addi	r16,r16,1
void codec_dump_regs(){
	alt_u8 i;

	alt_printf("CODEC Regs - \r\n");

	for(i=0; i<NO_OF_CODEC_REGS; i++){
  800240:	008002c4 	movi	r2,11
		alt_printf("REG[0x%x] - 0x%x\r\n",i,codec_shadow_reg[i]);
  800244:	8c400084 	addi	r17,r17,2
void codec_dump_regs(){
	alt_u8 i;

	alt_printf("CODEC Regs - \r\n");

	for(i=0; i<NO_OF_CODEC_REGS; i++){
  800248:	80bff71e 	bne	r16,r2,800228 <codec_dump_regs+0x28>
		alt_printf("REG[0x%x] - 0x%x\r\n",i,codec_shadow_reg[i]);
	}

	return;
}
  80024c:	dfc00217 	ldw	ra,8(sp)
  800250:	dc400117 	ldw	r17,4(sp)
  800254:	dc000017 	ldw	r16,0(sp)
  800258:	dec00304 	addi	sp,sp,12
  80025c:	f800283a 	ret

00800260 <codec_config_reg>:
	return I2C_OK;

}

I2C_RES	codec_config_reg(alt_u8 idx, alt_u8 offst, alt_u8 msk, alt_u8 val){
	codec_shadow_reg[idx]	&=	~(alt_u16)(msk	<<	offst);
  800260:	22003fcc 	andi	r8,r4,255
  800264:	29403fcc 	andi	r5,r5,255
  800268:	30803fcc 	andi	r2,r6,255
  80026c:	00c020b4 	movhi	r3,130
  800270:	18f02d04 	addi	r3,r3,-16204
  800274:	4211883a 	add	r8,r8,r8
  800278:	40d1883a 	add	r8,r8,r3
	codec_shadow_reg[idx]	|=	(alt_u16)((val & msk)	<<	offst);
  80027c:	398e703a 	and	r7,r7,r6
	return I2C_OK;

}

I2C_RES	codec_config_reg(alt_u8 idx, alt_u8 offst, alt_u8 msk, alt_u8 val){
	codec_shadow_reg[idx]	&=	~(alt_u16)(msk	<<	offst);
  800280:	1144983a 	sll	r2,r2,r5
  800284:	40c0000b 	ldhu	r3,0(r8)
	codec_shadow_reg[idx]	|=	(alt_u16)((val & msk)	<<	offst);
  800288:	39c03fcc 	andi	r7,r7,255
  80028c:	394e983a 	sll	r7,r7,r5
	return I2C_OK;

}

I2C_RES	codec_config_reg(alt_u8 idx, alt_u8 offst, alt_u8 msk, alt_u8 val){
	codec_shadow_reg[idx]	&=	~(alt_u16)(msk	<<	offst);
  800290:	0084303a 	nor	r2,zero,r2
  800294:	10c4703a 	and	r2,r2,r3
	codec_shadow_reg[idx]	|=	(alt_u16)((val & msk)	<<	offst);
  800298:	11c4b03a 	or	r2,r2,r7

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[idx]);
  80029c:	11bfffcc 	andi	r6,r2,65535
  8002a0:	01004034 	movhi	r4,256
  8002a4:	01400d04 	movi	r5,52

}

I2C_RES	codec_config_reg(alt_u8 idx, alt_u8 offst, alt_u8 msk, alt_u8 val){
	codec_shadow_reg[idx]	&=	~(alt_u16)(msk	<<	offst);
	codec_shadow_reg[idx]	|=	(alt_u16)((val & msk)	<<	offst);
  8002a8:	4080000d 	sth	r2,0(r8)

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[idx]);
  8002ac:	0800a081 	jmpi	800a08 <i2c_xtn_write16>

008002b0 <codec_iwl_update>:
I2C_RES codec_sr_update(SR_SEL val){
	return codec_config_reg(CODEC_SR_IDX, CODEC_SR_OFFST, CODEC_SR_MSK, val);
}

I2C_RES codec_iwl_update(CODEC_IWL val){
	return codec_config_reg(CODEC_IWL_IDX, CODEC_IWL_OFFST, CODEC_IWL_MSK, val);
  8002b0:	21c03fcc 	andi	r7,r4,255
  8002b4:	01400084 	movi	r5,2
  8002b8:	010001c4 	movi	r4,7
  8002bc:	018000c4 	movi	r6,3
  8002c0:	08002601 	jmpi	800260 <codec_config_reg>

008002c4 <codec_sr_update>:
I2C_RES codec_adc_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_ADCPD_IDX, CODEC_ADCPD_OFFST, CODEC_ADCPD_MSK, val);
}

I2C_RES codec_sr_update(SR_SEL val){
	return codec_config_reg(CODEC_SR_IDX, CODEC_SR_OFFST, CODEC_SR_MSK, val);
  8002c4:	21c03fcc 	andi	r7,r4,255
  8002c8:	01400084 	movi	r5,2
  8002cc:	01000204 	movi	r4,8
  8002d0:	018003c4 	movi	r6,15
  8002d4:	08002601 	jmpi	800260 <codec_config_reg>

008002d8 <codec_adc_pwr_dwn_n_up>:
I2C_RES codec_adc_hpf_enable(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_ADC_HPD_IDX, CODEC_ADC_HPD_OFFST, CODEC_ADC_HPD_MSK, val);
}

I2C_RES codec_adc_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_ADCPD_IDX, CODEC_ADCPD_OFFST, CODEC_ADCPD_MSK, val);
  8002d8:	21c03fcc 	andi	r7,r4,255
  8002dc:	01400084 	movi	r5,2
  8002e0:	01000184 	movi	r4,6
  8002e4:	01800044 	movi	r6,1
  8002e8:	08002601 	jmpi	800260 <codec_config_reg>

008002ec <codec_adc_hpf_enable>:
I2C_RES codec_lineout_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_OUTPD_IDX, CODEC_OUTPD_OFFST, CODEC_OUTPD_MSK, val);
}

I2C_RES codec_adc_hpf_enable(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_ADC_HPD_IDX, CODEC_ADC_HPD_OFFST, CODEC_ADC_HPD_MSK, val);
  8002ec:	21c03fcc 	andi	r7,r4,255
  8002f0:	000b883a 	mov	r5,zero
  8002f4:	01000144 	movi	r4,5
  8002f8:	01800044 	movi	r6,1
  8002fc:	08002601 	jmpi	800260 <codec_config_reg>

00800300 <codec_lineout_pwr_dwn_n_up>:
I2C_RES codec_linein_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){	//0->Power up, 1->Power Down
	return codec_config_reg(CODEC_LINEINPD_IDX, CODEC_LINEINPD_OFFST, CODEC_LINEINPD_MSK, val);
}

I2C_RES codec_lineout_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){
	return codec_config_reg(CODEC_OUTPD_IDX, CODEC_OUTPD_OFFST, CODEC_OUTPD_MSK, val);
  800300:	21c03fcc 	andi	r7,r4,255
  800304:	01400104 	movi	r5,4
  800308:	01000184 	movi	r4,6
  80030c:	01800044 	movi	r6,1
  800310:	08002601 	jmpi	800260 <codec_config_reg>

00800314 <codec_linein_pwr_dwn_n_up>:
I2C_RES codec_pwr_off_n_on(CODEC_PWR_ON_OFF val){	//0->Power up, 1->Power Down
	return codec_config_reg(CODEC_PWROFF_IDX, CODEC_PWROFF_OFFST, CODEC_PWROFF_MSK, val);
}

I2C_RES codec_linein_pwr_dwn_n_up(CODEC_PWR_ON_OFF val){	//0->Power up, 1->Power Down
	return codec_config_reg(CODEC_LINEINPD_IDX, CODEC_LINEINPD_OFFST, CODEC_LINEINPD_MSK, val);
  800314:	21c03fcc 	andi	r7,r4,255
  800318:	000b883a 	mov	r5,zero
  80031c:	01000184 	movi	r4,6
  800320:	01800044 	movi	r6,1
  800324:	08002601 	jmpi	800260 <codec_config_reg>

00800328 <codec_pwr_off_n_on>:
	return I2C_OK;

}

I2C_RES codec_pwr_off_n_on(CODEC_PWR_ON_OFF val){	//0->Power up, 1->Power Down
	return codec_config_reg(CODEC_PWROFF_IDX, CODEC_PWROFF_OFFST, CODEC_PWROFF_MSK, val);
  800328:	21c03fcc 	andi	r7,r4,255
  80032c:	014001c4 	movi	r5,7
  800330:	01000184 	movi	r4,6
  800334:	01800044 	movi	r6,1
  800338:	08002601 	jmpi	800260 <codec_config_reg>

0080033c <codec_dac_inactivate>:
	return I2C_OK;
}

I2C_RES codec_dac_inactivate(){

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x1))	return	I2C_NACK_DETECTED;
  80033c:	01800044 	movi	r6,1
  800340:	300f883a 	mov	r7,r6
	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x0))	return	I2C_NACK_DETECTED;

	return I2C_OK;
}

I2C_RES codec_dac_inactivate(){
  800344:	deffff04 	addi	sp,sp,-4

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x1))	return	I2C_NACK_DETECTED;
  800348:	01000144 	movi	r4,5
  80034c:	014000c4 	movi	r5,3
	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x0))	return	I2C_NACK_DETECTED;

	return I2C_OK;
}

I2C_RES codec_dac_inactivate(){
  800350:	dfc00015 	stw	ra,0(sp)

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x1))	return	I2C_NACK_DETECTED;
  800354:	08002600 	call	800260 <codec_config_reg>

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x0))	return	I2C_NACK_DETECTED;
  800358:	01000104 	movi	r4,4
  80035c:	200b883a 	mov	r5,r4
  800360:	01800044 	movi	r6,1
  800364:	000f883a 	mov	r7,zero
	return I2C_OK;
}

I2C_RES codec_dac_inactivate(){

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x1))	return	I2C_NACK_DETECTED;
  800368:	1000091e 	bne	r2,zero,800390 <codec_dac_inactivate+0x54>

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x0))	return	I2C_NACK_DETECTED;
  80036c:	08002600 	call	800260 <codec_config_reg>

	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x1))	return	I2C_NACK_DETECTED;
  800370:	01800044 	movi	r6,1
  800374:	01000184 	movi	r4,6
  800378:	014000c4 	movi	r5,3
  80037c:	300f883a 	mov	r7,r6
I2C_RES codec_dac_inactivate(){

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x1))	return	I2C_NACK_DETECTED;

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x0))	return	I2C_NACK_DETECTED;
  800380:	1000031e 	bne	r2,zero,800390 <codec_dac_inactivate+0x54>

	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x1))	return	I2C_NACK_DETECTED;
  800384:	08002600 	call	800260 <codec_config_reg>
  800388:	1004c03a 	cmpne	r2,r2,zero
  80038c:	00000106 	br	800394 <codec_dac_inactivate+0x58>
  800390:	00800044 	movi	r2,1

	return I2C_OK;

}
  800394:	dfc00017 	ldw	ra,0(sp)
  800398:	dec00104 	addi	sp,sp,4
  80039c:	f800283a 	ret

008003a0 <codec_dac_activate>:

I2C_RES codec_dsp_if_inactivate(){
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x0);
}

I2C_RES codec_dac_activate(){
  8003a0:	deffff04 	addi	sp,sp,-4
	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x0))	return	I2C_NACK_DETECTED;
  8003a4:	01000184 	movi	r4,6
  8003a8:	014000c4 	movi	r5,3
  8003ac:	01800044 	movi	r6,1
  8003b0:	000f883a 	mov	r7,zero

I2C_RES codec_dsp_if_inactivate(){
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x0);
}

I2C_RES codec_dac_activate(){
  8003b4:	dfc00015 	stw	ra,0(sp)
	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x0))	return	I2C_NACK_DETECTED;
  8003b8:	08002600 	call	800260 <codec_config_reg>

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x1))	return	I2C_NACK_DETECTED;
  8003bc:	01000104 	movi	r4,4
  8003c0:	01800044 	movi	r6,1
  8003c4:	200b883a 	mov	r5,r4
  8003c8:	300f883a 	mov	r7,r6
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x0);
}

I2C_RES codec_dac_activate(){
	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x0))	return	I2C_NACK_DETECTED;
  8003cc:	1000091e 	bne	r2,zero,8003f4 <codec_dac_activate+0x54>

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x1))	return	I2C_NACK_DETECTED;
  8003d0:	08002600 	call	800260 <codec_config_reg>

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x0))	return	I2C_NACK_DETECTED;
  8003d4:	01000144 	movi	r4,5
  8003d8:	014000c4 	movi	r5,3
  8003dc:	01800044 	movi	r6,1
  8003e0:	000f883a 	mov	r7,zero
I2C_RES codec_dac_activate(){
	//Referpg44 of WM8731 datasheet
	if(codec_config_reg(CODEC_DACPD_IDX, CODEC_DACPD_OFFST, CODEC_DACPD_MSK, 0x0))	return	I2C_NACK_DETECTED;

	//Refer pg26 of WM8731 datasheet
	if(codec_config_reg(CODEC_DAC_SEL_IDX, CODEC_DAC_SEL_OFFST, CODEC_DAC_SEL_MSK, 0x1))	return	I2C_NACK_DETECTED;
  8003e4:	1000031e 	bne	r2,zero,8003f4 <codec_dac_activate+0x54>

	if(codec_config_reg(CODEC_DAC_MU_IDX, CODEC_DAC_MU_OFFST, CODEC_DAC_MU_MSK, 0x0))	return	I2C_NACK_DETECTED;
  8003e8:	08002600 	call	800260 <codec_config_reg>
  8003ec:	1004c03a 	cmpne	r2,r2,zero
  8003f0:	00000106 	br	8003f8 <codec_dac_activate+0x58>
  8003f4:	00800044 	movi	r2,1

	return I2C_OK;
}
  8003f8:	dfc00017 	ldw	ra,0(sp)
  8003fc:	dec00104 	addi	sp,sp,4
  800400:	f800283a 	ret

00800404 <codec_dsp_if_inactivate>:
I2C_RES codec_dsp_if_activate(){
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x1);
}

I2C_RES codec_dsp_if_inactivate(){
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x0);
  800404:	01000244 	movi	r4,9
  800408:	000b883a 	mov	r5,zero
  80040c:	01800044 	movi	r6,1
  800410:	000f883a 	mov	r7,zero
  800414:	08002601 	jmpi	800260 <codec_config_reg>

00800418 <codec_dsp_if_activate>:

	return I2C_OK;
}

I2C_RES codec_dsp_if_activate(){
	return codec_config_reg(CODEC_ACTIVE_IDX, CODEC_ACTIVE_OFFST, CODEC_ACTIVE_MSK, 0x1);
  800418:	01800044 	movi	r6,1
  80041c:	01000244 	movi	r4,9
  800420:	000b883a 	mov	r5,zero
  800424:	300f883a 	mov	r7,r6
  800428:	08002601 	jmpi	800260 <codec_config_reg>

0080042c <codec_reset>:
	codec_shadow_reg[9]   = 0x1200;
	codec_shadow_reg[10]  = 0x1e00;
*/

	//All the below values are default values given in spec
	codec_shadow_reg[0]	  =	0x97;
  80042c:	00c020b4 	movhi	r3,130
  800430:	18f02d04 	addi	r3,r3,-16204
	codec_shadow_reg[5]   = 0xa08;
	codec_shadow_reg[6]   = 0xc9f;
	codec_shadow_reg[7]   = 0xe0a;
	codec_shadow_reg[8]   = 0x1000;
	codec_shadow_reg[9]   = 0x1200;
	codec_shadow_reg[10]  = 0x1e00;
  800434:	00878004 	movi	r2,7680
  800438:	1880050d 	sth	r2,20(r3)
	codec_shadow_reg[9]   = 0x1200;
	codec_shadow_reg[10]  = 0x1e00;
*/

	//All the below values are default values given in spec
	codec_shadow_reg[0]	  =	0x97;
  80043c:	008025c4 	movi	r2,151
  800440:	1880000d 	sth	r2,0(r3)
	codec_shadow_reg[1]   = 0x297;
  800444:	0080a5c4 	movi	r2,663
  800448:	1880008d 	sth	r2,2(r3)
	codec_shadow_reg[2]   = 0x479;
  80044c:	00811e44 	movi	r2,1145
  800450:	1880010d 	sth	r2,4(r3)
	codec_shadow_reg[3]   = 0x679;
  800454:	00819e44 	movi	r2,1657
  800458:	1880018d 	sth	r2,6(r3)
	codec_shadow_reg[4]   = 0x80a;
  80045c:	00820284 	movi	r2,2058
  800460:	1880020d 	sth	r2,8(r3)
	codec_shadow_reg[5]   = 0xa08;
  800464:	00828204 	movi	r2,2568
  800468:	1880028d 	sth	r2,10(r3)
	codec_shadow_reg[6]   = 0xc9f;
  80046c:	008327c4 	movi	r2,3231
  800470:	1880030d 	sth	r2,12(r3)
	codec_shadow_reg[7]   = 0xe0a;
  800474:	00838284 	movi	r2,3594
  800478:	1880038d 	sth	r2,14(r3)
	codec_shadow_reg[8]   = 0x1000;
  80047c:	00840004 	movi	r2,4096
  800480:	1880040d 	sth	r2,16(r3)
	codec_shadow_reg[9]   = 0x1200;
	codec_shadow_reg[10]  = 0x1e00;

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RESET_IDX]);
  800484:	01004034 	movhi	r4,256
	codec_shadow_reg[4]   = 0x80a;
	codec_shadow_reg[5]   = 0xa08;
	codec_shadow_reg[6]   = 0xc9f;
	codec_shadow_reg[7]   = 0xe0a;
	codec_shadow_reg[8]   = 0x1000;
	codec_shadow_reg[9]   = 0x1200;
  800488:	00848004 	movi	r2,4608
	codec_shadow_reg[10]  = 0x1e00;

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RESET_IDX]);
  80048c:	01400d04 	movi	r5,52
  800490:	01878004 	movi	r6,7680
	codec_shadow_reg[4]   = 0x80a;
	codec_shadow_reg[5]   = 0xa08;
	codec_shadow_reg[6]   = 0xc9f;
	codec_shadow_reg[7]   = 0xe0a;
	codec_shadow_reg[8]   = 0x1000;
	codec_shadow_reg[9]   = 0x1200;
  800494:	1880048d 	sth	r2,18(r3)
	codec_shadow_reg[10]  = 0x1e00;

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RESET_IDX]);
  800498:	0800a081 	jmpi	800a08 <i2c_xtn_write16>

0080049c <codec_init>:
	codec_shadow_reg[idx]	|=	(alt_u16)((val & msk)	<<	offst);

	return	i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[idx]);
}

I2C_RES codec_init(BPS_T bps, FS_T fs){
  80049c:	defffc04 	addi	sp,sp,-16
  8004a0:	dc800215 	stw	r18,8(sp)
  8004a4:	dc400115 	stw	r17,4(sp)
  8004a8:	dfc00315 	stw	ra,12(sp)
  8004ac:	dc000015 	stw	r16,0(sp)
  8004b0:	2023883a 	mov	r17,r4
  8004b4:	2825883a 	mov	r18,r5

	if(codec_reset())	return I2C_NACK_DETECTED;
  8004b8:	080042c0 	call	80042c <codec_reset>
  8004bc:	1000581e 	bne	r2,zero,800620 <codec_init+0x184>

	chThdSleepMilliseconds(100);
  8004c0:	01001904 	movi	r4,100
  8004c4:	08128680 	call	812868 <chThdSleep>

	//Read Power On Sequence spec

	codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]	=	0xc10;
  8004c8:	040020b4 	movhi	r16,130
  8004cc:	84302d04 	addi	r16,r16,-16204
  8004d0:	00830404 	movi	r2,3088
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]))	return I2C_NACK_DETECTED;
  8004d4:	01004034 	movhi	r4,256
  8004d8:	01400d04 	movi	r5,52
  8004dc:	01830404 	movi	r6,3088

	chThdSleepMilliseconds(100);

	//Read Power On Sequence spec

	codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]	=	0xc10;
  8004e0:	8080030d 	sth	r2,12(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]))	return I2C_NACK_DETECTED;
  8004e4:	0800a080 	call	800a08 <i2c_xtn_write16>
  8004e8:	10004d1e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]=	0x17;
  8004ec:	008005c4 	movi	r2,23
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;
  8004f0:	01004034 	movhi	r4,256
  8004f4:	01400d04 	movi	r5,52
  8004f8:	018005c4 	movi	r6,23

	codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]	=	0xc10;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]=	0x17;
  8004fc:	8080000d 	sth	r2,0(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;
  800500:	0800a080 	call	800a08 <i2c_xtn_write16>
  800504:	1000461e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]=	0x217;
  800508:	008085c4 	movi	r2,535
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;
  80050c:	01004034 	movhi	r4,256
  800510:	01400d04 	movi	r5,52
  800514:	018085c4 	movi	r6,535

	codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]=	0x17;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]=	0x217;
  800518:	8080008d 	sth	r2,2(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;
  80051c:	0800a080 	call	800a08 <i2c_xtn_write16>
  800520:	10003f1e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]=	0x4f9;
  800524:	00813e44 	movi	r2,1273
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;
  800528:	01004034 	movhi	r4,256
  80052c:	01400d04 	movi	r5,52
  800530:	01813e44 	movi	r6,1273

	codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]=	0x217;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_LINE_IN_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]=	0x4f9;
  800534:	8080010d 	sth	r2,4(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;
  800538:	0800a080 	call	800a08 <i2c_xtn_write16>
  80053c:	1000381e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]=	0x6f9;
  800540:	0081be44 	movi	r2,1785
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;
  800544:	01004034 	movhi	r4,256
  800548:	01400d04 	movi	r5,52
  80054c:	0181be44 	movi	r6,1785

	codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]=	0x4f9;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_LEFT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]=	0x6f9;
  800550:	8080018d 	sth	r2,6(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;
  800554:	0800a080 	call	800a08 <i2c_xtn_write16>
  800558:	1000311e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]=	0xa00;
  80055c:	00828004 	movi	r2,2560
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]))	return I2C_NACK_DETECTED;
  800560:	01004034 	movhi	r4,256
  800564:	01400d04 	movi	r5,52
  800568:	01828004 	movi	r6,2560

	codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]=	0x6f9;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_RIGHT_HP_OUT_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]=	0xa00;
  80056c:	8080028d 	sth	r2,10(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]))	return I2C_NACK_DETECTED;
  800570:	0800a080 	call	800a08 <i2c_xtn_write16>
  800574:	10002a1e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_DIGITAL_AUD_IF_FMT_REG_IDX]=	0xe0f;
  800578:	008383c4 	movi	r2,3599
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_DIGITAL_AUD_IF_FMT_REG_IDX]))	return I2C_NACK_DETECTED;
  80057c:	01004034 	movhi	r4,256
  800580:	01400d04 	movi	r5,52
  800584:	018383c4 	movi	r6,3599

	codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]=	0xa00;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_DIGITAL_AUD_PATH_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_DIGITAL_AUD_IF_FMT_REG_IDX]=	0xe0f;
  800588:	8080038d 	sth	r2,14(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_DIGITAL_AUD_IF_FMT_REG_IDX]))	return I2C_NACK_DETECTED;
  80058c:	0800a080 	call	800a08 <i2c_xtn_write16>
  800590:	1000231e 	bne	r2,zero,800620 <codec_init+0x184>


	//Misc
	if(codec_iwl_update(bps2iwl_lookup[bps]))	return I2C_NACK_DETECTED;
  800594:	8c45883a 	add	r2,r17,r17
  800598:	1085883a 	add	r2,r2,r2
  80059c:	d0e00004 	addi	r3,gp,-32768
  8005a0:	10c5883a 	add	r2,r2,r3
  8005a4:	11000017 	ldw	r4,0(r2)
  8005a8:	08002b00 	call	8002b0 <codec_iwl_update>
  8005ac:	10001c1e 	bne	r2,zero,800620 <codec_init+0x184>

	if(codec_sr_update(fs2sr_lookup[fs]))	return I2C_NACK_DETECTED;
  8005b0:	9485883a 	add	r2,r18,r18
  8005b4:	1085883a 	add	r2,r2,r2
  8005b8:	00c02074 	movhi	r3,129
  8005bc:	18dd1904 	addi	r3,r3,29796
  8005c0:	10c5883a 	add	r2,r2,r3
  8005c4:	11000017 	ldw	r4,0(r2)
  8005c8:	08002c40 	call	8002c4 <codec_sr_update>
  8005cc:	1000141e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]=	0x1201;
  8005d0:	00848044 	movi	r2,4609
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]))	return I2C_NACK_DETECTED;
  8005d4:	01004034 	movhi	r4,256
  8005d8:	01400d04 	movi	r5,52
  8005dc:	01848044 	movi	r6,4609
	if(codec_iwl_update(bps2iwl_lookup[bps]))	return I2C_NACK_DETECTED;

	if(codec_sr_update(fs2sr_lookup[fs]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]=	0x1201;
  8005e0:	8080048d 	sth	r2,18(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]))	return I2C_NACK_DETECTED;
  8005e4:	0800a080 	call	800a08 <i2c_xtn_write16>
  8005e8:	10000d1e 	bne	r2,zero,800620 <codec_init+0x184>


	codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]	=	0xc00;
  8005ec:	00830004 	movi	r2,3072
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]))	return I2C_NACK_DETECTED;
  8005f0:	01004034 	movhi	r4,256
  8005f4:	01400d04 	movi	r5,52
  8005f8:	01830004 	movi	r6,3072

	codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]=	0x1201;
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_ACTIVE_CTRL_REG_IDX]))	return I2C_NACK_DETECTED;


	codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]	=	0xc00;
  8005fc:	8080030d 	sth	r2,12(r16)
	if(i2c_xtn_write16(CORTEX_MM_SL_BASE, CODEC_I2C_WRITE_ADDR, codec_shadow_reg[CODEC_POWER_DOWN_REG_IDX]))	return I2C_NACK_DETECTED;
  800600:	0800a080 	call	800a08 <i2c_xtn_write16>
  800604:	1000061e 	bne	r2,zero,800620 <codec_init+0x184>

	//Debug ...
	codec_dump_regs();
  800608:	08002000 	call	800200 <codec_dump_regs>

	alt_printf("[codec_init] Success\r\n");
  80060c:	01002074 	movhi	r4,129
  800610:	211d1304 	addi	r4,r4,29772
  800614:	08136300 	call	813630 <alt_printf>
  800618:	0005883a 	mov	r2,zero
  80061c:	00000106 	br	800624 <codec_init+0x188>

	return I2C_OK;
  800620:	00800044 	movi	r2,1
}
  800624:	dfc00317 	ldw	ra,12(sp)
  800628:	dc800217 	ldw	r18,8(sp)
  80062c:	dc400117 	ldw	r17,4(sp)
  800630:	dc000017 	ldw	r16,0(sp)
  800634:	dec00404 	addi	sp,sp,16
  800638:	f800283a 	ret

0080063c <acortex_aud_src_sel>:

    return;
}

void acortex_aud_src_sel(alt_u32 base,ACORTEX_AUDIO_SRC_SEL_VAL val){
	IOWR_ACORTEX_AUDIO_SRC_SEL_REG(base,val);
  80063c:	008000b4 	movhi	r2,2
  800640:	109c0004 	addi	r2,r2,28672
  800644:	2089883a 	add	r4,r4,r2
  800648:	21400035 	stwio	r5,0(r4)
}
  80064c:	f800283a 	ret

00800650 <reset_acortex>:
#include "ch.h"
#include "sys/alt_stdio.h"


void reset_acortex(alt_u32 base){
	IOWR_32DIRECT(base, ACORTEX_RESET_ADDR, 0x0);	//a write to this address resets the acortex
  800650:	008000f4 	movhi	r2,3
  800654:	10a00004 	addi	r2,r2,-32768
  800658:	2089883a 	add	r4,r4,r2
  80065c:	20000035 	stwio	zero,0(r4)

    chThdSleepMilliseconds(1);
  800660:	01000044 	movi	r4,1
  800664:	08128681 	jmpi	812868 <chThdSleep>

00800668 <acortex_init>:
		rcap_bffr[i]	+=	(IORD_ADC_RCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
	}

}

void acortex_init(alt_32 base, FS_T fs, BPS_T bps){
  800668:	defffc04 	addi	sp,sp,-16
  80066c:	dfc00315 	stw	ra,12(sp)
  800670:	dc800215 	stw	r18,8(sp)
  800674:	dc400115 	stw	r17,4(sp)
  800678:	2825883a 	mov	r18,r5
  80067c:	3023883a 	mov	r17,r6
  800680:	dc000015 	stw	r16,0(sp)
  800684:	2021883a 	mov	r16,r4
	reset_acortex(base);
  800688:	08006500 	call	800650 <reset_acortex>

	configure_i2c_clk(base, ACORTEX_I2C_CLK_DIV_VAL);
  80068c:	01401904 	movi	r5,100
  800690:	8009883a 	mov	r4,r16
  800694:	08009f00 	call	8009f0 <configure_i2c_clk>

	configure_dac_drvr_bps(base,bps);
  800698:	8009883a 	mov	r4,r16
  80069c:	880b883a 	mov	r5,r17
  8006a0:	08008dc0 	call	8008dc <configure_dac_drvr_bps>

	update_fs_div(base,fs);
  8006a4:	8009883a 	mov	r4,r16
  8006a8:	900b883a 	mov	r5,r18
  8006ac:	08008280 	call	800828 <update_fs_div>

	update_mclk(base,fs);
  8006b0:	8009883a 	mov	r4,r16
  8006b4:	900b883a 	mov	r5,r18
  8006b8:	08008840 	call	800884 <update_mclk>


	alt_printf("ACORTEX Init done\r\n");
  8006bc:	01002074 	movhi	r4,129
  8006c0:	211d1f04 	addi	r4,r4,29820

	return;
}
  8006c4:	dfc00317 	ldw	ra,12(sp)
  8006c8:	dc800217 	ldw	r18,8(sp)
  8006cc:	dc400117 	ldw	r17,4(sp)
  8006d0:	dc000017 	ldw	r16,0(sp)
  8006d4:	dec00404 	addi	sp,sp,16
	update_fs_div(base,fs);

	update_mclk(base,fs);


	alt_printf("ACORTEX Init done\r\n");
  8006d8:	08136301 	jmpi	813630 <alt_printf>

008006dc <adc_cap>:

void acortex_aud_src_sel(alt_u32 base,ACORTEX_AUDIO_SRC_SEL_VAL val){
	IOWR_ACORTEX_AUDIO_SRC_SEL_REG(base,val);
}

void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
  8006dc:	defffb04 	addi	sp,sp,-20
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture
  8006e0:	008000b4 	movhi	r2,2
  8006e4:	10980004 	addi	r2,r2,24576

void acortex_aud_src_sel(alt_u32 base,ACORTEX_AUDIO_SRC_SEL_VAL val){
	IOWR_ACORTEX_AUDIO_SRC_SEL_REG(base,val);
}

void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
  8006e8:	dcc00315 	stw	r19,12(sp)
  8006ec:	dc800215 	stw	r18,8(sp)
  8006f0:	dc400115 	stw	r17,4(sp)
  8006f4:	dc000015 	stw	r16,0(sp)
  8006f8:	2023883a 	mov	r17,r4
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture
  8006fc:	20a1883a 	add	r16,r4,r2

void acortex_aud_src_sel(alt_u32 base,ACORTEX_AUDIO_SRC_SEL_VAL val){
	IOWR_ACORTEX_AUDIO_SRC_SEL_REG(base,val);
}

void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
  800700:	2825883a 	mov	r18,r5
  800704:	3027883a 	mov	r19,r6
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture
  800708:	00800044 	movi	r2,1

void acortex_aud_src_sel(alt_u32 base,ACORTEX_AUDIO_SRC_SEL_VAL val){
	IOWR_ACORTEX_AUDIO_SRC_SEL_REG(base,val);
}

void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
  80070c:	dfc00415 	stw	ra,16(sp)
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture
  800710:	80800035 	stwio	r2,0(r16)
  800714:	00000306 	br	800724 <adc_cap+0x48>

	while(IORD_ADC_START_CAPTURE_REG(base)	&	ADC_CAPTURE_BUSY_MSK){	//wait for capture to complete
	    alt_printf("[adc_cap] capture busy\n");
  800718:	08136300 	call	813630 <alt_printf>
		chThdSleepMilliseconds(1);
  80071c:	01000044 	movi	r4,1
  800720:	08128680 	call	812868 <chThdSleep>
void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture

	while(IORD_ADC_START_CAPTURE_REG(base)	&	ADC_CAPTURE_BUSY_MSK){	//wait for capture to complete
  800724:	80800037 	ldwio	r2,0(r16)
	    alt_printf("[adc_cap] capture busy\n");
  800728:	01002074 	movhi	r4,129
  80072c:	211d2404 	addi	r4,r4,29840
void adc_cap(alt_u32 base, alt_u32 * lcap_bffr, alt_u32 * rcap_bffr){
	alt_u8 i,cap_addr;

	IOWR_ADC_START_CAPTURE_REG(base, ADC_START_CAPTURE_EN_MSK);	//trigger ADC capture

	while(IORD_ADC_START_CAPTURE_REG(base)	&	ADC_CAPTURE_BUSY_MSK){	//wait for capture to complete
  800730:	1080004c 	andi	r2,r2,1
  800734:	103ff81e 	bne	r2,zero,800718 <adc_cap+0x3c>
	    alt_printf("[adc_cap] capture busy\n");
		chThdSleepMilliseconds(1);
	}

    alt_printf("[adc_cap] capture completed\n");
  800738:	01002074 	movhi	r4,129
  80073c:	211d2a04 	addi	r4,r4,29864
  800740:	08136300 	call	813630 <alt_printf>
  800744:	008000b4 	movhi	r2,2
  800748:	10900004 	addi	r2,r2,16384
  80074c:	888b883a 	add	r5,r17,r2
  800750:	000d883a 	mov	r6,zero
  800754:	01c02004 	movi	r7,128

	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;
  800758:	3189883a 	add	r4,r6,r6

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to LS 16b
  80075c:	20803fcc 	andi	r2,r4,255
  800760:	28800035 	stwio	r2,0(r5)

		lcap_bffr[i]	=	IORD_ADC_LCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  800764:	30c03fcc 	andi	r3,r6,255
  800768:	18c7883a 	add	r3,r3,r3
  80076c:	18c7883a 	add	r3,r3,r3
  800770:	90c7883a 	add	r3,r18,r3
  800774:	28800037 	ldwio	r2,0(r5)

		cap_addr++;

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  800778:	21000044 	addi	r4,r4,1
	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to LS 16b

		lcap_bffr[i]	=	IORD_ADC_LCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  80077c:	10bfffcc 	andi	r2,r2,65535

		cap_addr++;

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  800780:	21003fcc 	andi	r4,r4,255
	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to LS 16b

		lcap_bffr[i]	=	IORD_ADC_LCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  800784:	18800015 	stw	r2,0(r3)

		cap_addr++;

		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  800788:	29000035 	stwio	r4,0(r5)

		lcap_bffr[i]	+=	(IORD_ADC_LCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
  80078c:	19000017 	ldw	r4,0(r3)
  800790:	28800037 	ldwio	r2,0(r5)
  800794:	1004943a 	slli	r2,r2,16
  800798:	31800044 	addi	r6,r6,1
  80079c:	2089883a 	add	r4,r4,r2
  8007a0:	19000015 	stw	r4,0(r3)
		chThdSleepMilliseconds(1);
	}

    alt_printf("[adc_cap] capture completed\n");

	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
  8007a4:	31ffec1e 	bne	r6,r7,800758 <adc_cap+0x7c>
  8007a8:	008000b4 	movhi	r2,2
  8007ac:	10940004 	addi	r2,r2,20480
  8007b0:	888b883a 	add	r5,r17,r2
  8007b4:	000d883a 	mov	r6,zero
  8007b8:	01c02004 	movi	r7,128

		lcap_bffr[i]	+=	(IORD_ADC_LCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
	}

	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;
  8007bc:	3189883a 	add	r4,r6,r6

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to LS 16b
  8007c0:	20803fcc 	andi	r2,r4,255
  8007c4:	28800035 	stwio	r2,0(r5)

		rcap_bffr[i]	=	IORD_ADC_RCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  8007c8:	30c03fcc 	andi	r3,r6,255
  8007cc:	18c7883a 	add	r3,r3,r3
  8007d0:	18c7883a 	add	r3,r3,r3
  8007d4:	98c7883a 	add	r3,r19,r3
  8007d8:	28800037 	ldwio	r2,0(r5)

		cap_addr++;

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  8007dc:	21000044 	addi	r4,r4,1
	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to LS 16b

		rcap_bffr[i]	=	IORD_ADC_RCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  8007e0:	10bfffcc 	andi	r2,r2,65535

		cap_addr++;

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  8007e4:	21003fcc 	andi	r4,r4,255
	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
		cap_addr	=	i << 1;

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to LS 16b

		rcap_bffr[i]	=	IORD_ADC_RCAPTURE_DATA(base)	&	0xffff;	//Read LS 16b
  8007e8:	18800015 	stw	r2,0(r3)

		cap_addr++;

		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to MS 16b
  8007ec:	29000035 	stwio	r4,0(r5)

		rcap_bffr[i]	+=	(IORD_ADC_RCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
  8007f0:	19000017 	ldw	r4,0(r3)
  8007f4:	28800037 	ldwio	r2,0(r5)
  8007f8:	1004943a 	slli	r2,r2,16
  8007fc:	31800044 	addi	r6,r6,1
  800800:	2089883a 	add	r4,r4,r2
  800804:	19000015 	stw	r4,0(r3)
		IOWR_ADC_LCAPTURE_DATA(base, cap_addr);	//point to MS 16b

		lcap_bffr[i]	+=	(IORD_ADC_LCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
	}

	for(i=0; i<ACORTEX_ADC_CAP_DEPTH; i++){
  800808:	31ffec1e 	bne	r6,r7,8007bc <adc_cap+0xe0>
		IOWR_ADC_RCAPTURE_DATA(base, cap_addr);	//point to MS 16b

		rcap_bffr[i]	+=	(IORD_ADC_RCAPTURE_DATA(base)	&	0xffff)	<<	16;	//Read MS 16b
	}

}
  80080c:	dfc00417 	ldw	ra,16(sp)
  800810:	dcc00317 	ldw	r19,12(sp)
  800814:	dc800217 	ldw	r18,8(sp)
  800818:	dc400117 	ldw	r17,4(sp)
  80081c:	dc000017 	ldw	r16,0(sp)
  800820:	dec00504 	addi	sp,sp,20
  800824:	f800283a 	ret

00800828 <update_fs_div>:

	enable_mclk(base);
}

void update_fs_div(alt_u32 base, FS_T val){
	IOWR_DAC_DRVR_FS_DIV(base, fs2div_lookup[val]);
  800828:	294b883a 	add	r5,r5,r5
  80082c:	00802074 	movhi	r2,129
  800830:	109d3204 	addi	r2,r2,29896
  800834:	294b883a 	add	r5,r5,r5
  800838:	288b883a 	add	r5,r5,r2
  80083c:	28c00017 	ldw	r3,0(r5)
  800840:	008000b4 	movhi	r2,2
  800844:	108c0804 	addi	r2,r2,12320
  800848:	2089883a 	add	r4,r4,r2
  80084c:	20c00035 	stwio	r3,0(r4)
}
  800850:	f800283a 	ret

00800854 <disable_mclk>:
	//alt_printf("[enable_mclk] Reg post - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

}

void disable_mclk(alt_u32 base){
	IOWR_DAC_DRVR_MCLK_SEL(base, 0x0);
  800854:	008000b4 	movhi	r2,2
  800858:	108c0c04 	addi	r2,r2,12336
  80085c:	2089883a 	add	r4,r4,r2
  800860:	20000035 	stwio	zero,0(r4)

	//alt_printf("[disable_mclk] Reg - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

}
  800864:	f800283a 	ret

00800868 <enable_mclk>:
}

void enable_mclk(alt_u32 base){
	//alt_printf("[enable_mclk] Reg pre - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

	IOWR_DAC_DRVR_MCLK_SEL(base, IORD_DAC_DRVR_MCLK_SEL(base)	|	DAC_DRVR_MCLK_EN_MSK);
  800868:	008000b4 	movhi	r2,2
  80086c:	108c0c04 	addi	r2,r2,12336
  800870:	2089883a 	add	r4,r4,r2
  800874:	20800037 	ldwio	r2,0(r4)
  800878:	10a00014 	ori	r2,r2,32768
  80087c:	20800035 	stwio	r2,0(r4)

	//alt_printf("[enable_mclk] Reg post - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

}
  800880:	f800283a 	ret

00800884 <update_mclk>:

	//alt_printf("[disable_mclk] Reg - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

}

void update_mclk(alt_u32 base, FS_T val){
  800884:	defffd04 	addi	sp,sp,-12
  800888:	dc000115 	stw	r16,4(sp)
	disable_mclk(base);
  80088c:	d9400015 	stw	r5,0(sp)

	//alt_printf("[disable_mclk] Reg - 0x%x\n",IORD_DAC_DRVR_MCLK_SEL(base));

}

void update_mclk(alt_u32 base, FS_T val){
  800890:	2021883a 	mov	r16,r4
  800894:	dfc00215 	stw	ra,8(sp)
	disable_mclk(base);
  800898:	08008540 	call	800854 <disable_mclk>

	IOWR_DAC_DRVR_MCLK_SEL(base, fs2mclk_lookup[val]);
  80089c:	d9400017 	ldw	r5,0(sp)
  8008a0:	00802074 	movhi	r2,129
  8008a4:	109d3804 	addi	r2,r2,29920
  8008a8:	294b883a 	add	r5,r5,r5
  8008ac:	294b883a 	add	r5,r5,r5
  8008b0:	288b883a 	add	r5,r5,r2
  8008b4:	28c00017 	ldw	r3,0(r5)
  8008b8:	008000b4 	movhi	r2,2
  8008bc:	108c0c04 	addi	r2,r2,12336
  8008c0:	8085883a 	add	r2,r16,r2
  8008c4:	10c00035 	stwio	r3,0(r2)

	enable_mclk(base);
  8008c8:	8009883a 	mov	r4,r16
}
  8008cc:	dfc00217 	ldw	ra,8(sp)
  8008d0:	dc000117 	ldw	r16,4(sp)
  8008d4:	dec00304 	addi	sp,sp,12
void update_mclk(alt_u32 base, FS_T val){
	disable_mclk(base);

	IOWR_DAC_DRVR_MCLK_SEL(base, fs2mclk_lookup[val]);

	enable_mclk(base);
  8008d8:	08008681 	jmpi	800868 <enable_mclk>

008008dc <configure_dac_drvr_bps>:
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	ADC_DRVR_EN_MSK);
}

void configure_dac_drvr_bps(alt_u32 base, BPS_T val){
	if(val){	//32bps
		IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	DAC_DRVR_BPS_MSK);
  8008dc:	008000b4 	movhi	r2,2
  8008e0:	108c0004 	addi	r2,r2,12288
  8008e4:	2087883a 	add	r3,r4,r2
	}
	else{		//16bps
		IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) &	~DAC_DRVR_BPS_MSK);
  8008e8:	1809883a 	mov	r4,r3
void enable_adc_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	ADC_DRVR_EN_MSK);
}

void configure_dac_drvr_bps(alt_u32 base, BPS_T val){
	if(val){	//32bps
  8008ec:	28000426 	beq	r5,zero,800900 <configure_dac_drvr_bps+0x24>
		IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	DAC_DRVR_BPS_MSK);
  8008f0:	18800037 	ldwio	r2,0(r3)
  8008f4:	10800114 	ori	r2,r2,4
  8008f8:	18800035 	stwio	r2,0(r3)
  8008fc:	f800283a 	ret
	}
	else{		//16bps
		IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) &	~DAC_DRVR_BPS_MSK);
  800900:	18800037 	ldwio	r2,0(r3)
  800904:	00fffec4 	movi	r3,-5
  800908:	10c4703a 	and	r2,r2,r3
  80090c:	20800035 	stwio	r2,0(r4)
  800910:	f800283a 	ret

00800914 <enable_adc_drvr>:
void disable_adc_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) & ~ADC_DRVR_EN_MSK);
}

void enable_adc_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	ADC_DRVR_EN_MSK);
  800914:	008000b4 	movhi	r2,2
  800918:	108c0004 	addi	r2,r2,12288
  80091c:	2089883a 	add	r4,r4,r2
  800920:	20800037 	ldwio	r2,0(r4)
  800924:	10800094 	ori	r2,r2,2
  800928:	20800035 	stwio	r2,0(r4)
}
  80092c:	f800283a 	ret

00800930 <disable_adc_drvr>:
void enable_dac_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	DAC_DRVR_EN_MSK);
}

void disable_adc_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) & ~ADC_DRVR_EN_MSK);
  800930:	008000b4 	movhi	r2,2
  800934:	108c0004 	addi	r2,r2,12288
  800938:	2089883a 	add	r4,r4,r2
  80093c:	20800037 	ldwio	r2,0(r4)
  800940:	00ffff44 	movi	r3,-3
  800944:	10c4703a 	and	r2,r2,r3
  800948:	20800035 	stwio	r2,0(r4)
}
  80094c:	f800283a 	ret

00800950 <enable_dac_drvr>:
void disable_dac_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) & ~DAC_DRVR_EN_MSK);
}

void enable_dac_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) |	DAC_DRVR_EN_MSK);
  800950:	008000b4 	movhi	r2,2
  800954:	108c0004 	addi	r2,r2,12288
  800958:	2089883a 	add	r4,r4,r2
  80095c:	20800037 	ldwio	r2,0(r4)
  800960:	10800054 	ori	r2,r2,1
  800964:	20800035 	stwio	r2,0(r4)
}
  800968:	f800283a 	ret

0080096c <disable_dac_drvr>:
#include "alt_types.h"
#include "sys/alt_stdio.h"


void disable_dac_drvr(alt_u32 base){
	IOWR_DAC_DRVR_CTRL(base, IORD_DAC_DRVR_CTRL(base) & ~DAC_DRVR_EN_MSK);
  80096c:	008000b4 	movhi	r2,2
  800970:	108c0004 	addi	r2,r2,12288
  800974:	2089883a 	add	r4,r4,r2
  800978:	20800037 	ldwio	r2,0(r4)
  80097c:	00ffff84 	movi	r3,-2
  800980:	10c4703a 	and	r2,r2,r3
  800984:	20800035 	stwio	r2,0(r4)
}
  800988:	f800283a 	ret

0080098c <get_i2c_clk>:
	return;
}


alt_u8 	get_i2c_clk(alt_u32 base){
	return IORD_I2C_CLK_DIV(base);
  80098c:	008000b4 	movhi	r2,2
  800990:	10800c04 	addi	r2,r2,48
  800994:	2089883a 	add	r4,r4,r2
  800998:	20800037 	ldwio	r2,0(r4)
}
  80099c:	10803fcc 	andi	r2,r2,255
  8009a0:	f800283a 	ret

008009a4 <is_busy>:
	return I2C_IDLE;
}


I2C_RES	is_busy(alt_u32 base){
	alt_u16	reg	=	IORD_I2C_STATUS(base);
  8009a4:	008000b4 	movhi	r2,2
  8009a8:	2089883a 	add	r4,r4,r2
  8009ac:	20800037 	ldwio	r2,0(r4)

	if(reg	&	I2C_DRIVER_STATUS_BUSY_MSK){
  8009b0:	0084303a 	nor	r2,zero,r2
  8009b4:	1080004c 	andi	r2,r2,1
		return I2C_BUSY;
	}

	return I2C_IDLE;

}
  8009b8:	10800084 	addi	r2,r2,2
  8009bc:	f800283a 	ret

008009c0 <get_i2c_status>:
#include "ch.h"
#include "sys/alt_stdio.h"


I2C_RES	get_i2c_status(alt_u32 base){
	alt_u16	reg	=	IORD_I2C_STATUS(base);
  8009c0:	008000b4 	movhi	r2,2
  8009c4:	2089883a 	add	r4,r4,r2
  8009c8:	20800037 	ldwio	r2,0(r4)

	if(reg	&	I2C_DRIVER_STATUS_NACK_MSK){
  8009cc:	00c00044 	movi	r3,1
  8009d0:	10bfffcc 	andi	r2,r2,65535
		return I2C_NACK_DETECTED;
	}
	else if(reg	&	I2C_DRIVER_STATUS_BUSY_MSK){
  8009d4:	0088303a 	nor	r4,zero,r2


I2C_RES	get_i2c_status(alt_u32 base){
	alt_u16	reg	=	IORD_I2C_STATUS(base);

	if(reg	&	I2C_DRIVER_STATUS_NACK_MSK){
  8009d8:	1080008c 	andi	r2,r2,2
  8009dc:	1000021e 	bne	r2,zero,8009e8 <get_i2c_status+0x28>
		return I2C_NACK_DETECTED;
	}
	else if(reg	&	I2C_DRIVER_STATUS_BUSY_MSK){
  8009e0:	20c0004c 	andi	r3,r4,1
  8009e4:	18c00084 	addi	r3,r3,2
		return I2C_BUSY;
	}

	return I2C_IDLE;
}
  8009e8:	1805883a 	mov	r2,r3
  8009ec:	f800283a 	ret

008009f0 <configure_i2c_clk>:
	return I2C_OK;
}


void configure_i2c_clk(alt_u32 base, alt_u8 clk_val){
	IOWR_I2C_CLK_DIV(base, clk_val);
  8009f0:	008000b4 	movhi	r2,2
  8009f4:	10800c04 	addi	r2,r2,48
  8009f8:	2089883a 	add	r4,r4,r2
  8009fc:	29403fcc 	andi	r5,r5,255
  800a00:	21400035 	stwio	r5,0(r4)

	return;
}
  800a04:	f800283a 	ret

00800a08 <i2c_xtn_write16>:
	return I2C_IDLE;

}


I2C_RES	i2c_xtn_write16(alt_u32 base, alt_u8 addr, alt_u16 data){
  800a08:	defffb04 	addi	sp,sp,-20
  800a0c:	dcc00315 	stw	r19,12(sp)
  800a10:	dc800215 	stw	r18,8(sp)
  800a14:	dc400115 	stw	r17,4(sp)
  800a18:	2827883a 	mov	r19,r5
  800a1c:	2023883a 	mov	r17,r4
  800a20:	3025883a 	mov	r18,r6
  800a24:	dfc00415 	stw	ra,16(sp)
  800a28:	dc000015 	stw	r16,0(sp)
  800a2c:	00000106 	br	800a34 <i2c_xtn_write16+0x2c>

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
		//alt_printf("Waiting for I2C driver to be free\n");
	    chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  800a30:	08128680 	call	812868 <chThdSleep>
}


I2C_RES	i2c_xtn_write16(alt_u32 base, alt_u8 addr, alt_u16 data){

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
  800a34:	008000b4 	movhi	r2,2
  800a38:	88a1883a 	add	r16,r17,r2
  800a3c:	80800037 	ldwio	r2,0(r16)
		//alt_printf("Waiting for I2C driver to be free\n");
	    chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  800a40:	01000044 	movi	r4,1
}


I2C_RES	i2c_xtn_write16(alt_u32 base, alt_u8 addr, alt_u16 data){

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
  800a44:	1104703a 	and	r2,r2,r4
  800a48:	103ff91e 	bne	r2,zero,800a30 <i2c_xtn_write16+0x28>
	    chThdSleepMilliseconds(1);	//wait for I2C driver to be free
	}
	//alt_printf("I2C driver is free\n");


	IOWR_I2C_DATA(base, data);
  800a4c:	008000b4 	movhi	r2,2
  800a50:	10800804 	addi	r2,r2,32
  800a54:	8885883a 	add	r2,r17,r2
  800a58:	90ffffcc 	andi	r3,r18,65535
  800a5c:	10c00035 	stwio	r3,0(r2)
	IOWR_I2C_ADDR(base, addr	&	0xfe);	//forcing bit[0] to ground for write op
  800a60:	008000b4 	movhi	r2,2
  800a64:	10800404 	addi	r2,r2,16
  800a68:	8885883a 	add	r2,r17,r2
  800a6c:	98c03f8c 	andi	r3,r19,254
  800a70:	10c00035 	stwio	r3,0(r2)

	IOWR_I2C_STATUS(base, 0x0);	//writing to Status register triggers I2C xtn
  800a74:	80000035 	stwio	zero,0(r16)
  800a78:	00000106 	br	800a80 <i2c_xtn_write16+0x78>

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
		//alt_printf("Waiting for I2C driver to be free\n");

		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  800a7c:	08128680 	call	812868 <chThdSleep>
	IOWR_I2C_DATA(base, data);
	IOWR_I2C_ADDR(base, addr	&	0xfe);	//forcing bit[0] to ground for write op

	IOWR_I2C_STATUS(base, 0x0);	//writing to Status register triggers I2C xtn

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
  800a80:	80800037 	ldwio	r2,0(r16)
		//alt_printf("Waiting for I2C driver to be free\n");

		chThdSleepMilliseconds(1);	//wait for I2C driver to be free
  800a84:	01000044 	movi	r4,1
	IOWR_I2C_DATA(base, data);
	IOWR_I2C_ADDR(base, addr	&	0xfe);	//forcing bit[0] to ground for write op

	IOWR_I2C_STATUS(base, 0x0);	//writing to Status register triggers I2C xtn

	while(IORD_I2C_STATUS(base) & I2C_DRIVER_STATUS_BUSY_MSK){
  800a88:	1104703a 	and	r2,r2,r4
  800a8c:	103ffb1e 	bne	r2,zero,800a7c <i2c_xtn_write16+0x74>

	//alt_printf("I2C driver is free\n");
	//alt_printf("I2C status 0x%x\n",IORD_I2C_STATUS(base));


	if(IORD_I2C_STATUS(base)	&	I2C_DRIVER_STATUS_NACK_MSK){
  800a90:	80800037 	ldwio	r2,0(r16)
  800a94:	1104d83a 	srl	r2,r2,r4

		return I2C_NACK_DETECTED;
	}

	return I2C_OK;
}
  800a98:	1104703a 	and	r2,r2,r4
  800a9c:	dfc00417 	ldw	ra,16(sp)
  800aa0:	dcc00317 	ldw	r19,12(sp)
  800aa4:	dc800217 	ldw	r18,8(sp)
  800aa8:	dc400117 	ldw	r17,4(sp)
  800aac:	dc000017 	ldw	r16,0(sp)
  800ab0:	dec00504 	addi	sp,sp,20
  800ab4:	f800283a 	ret

00800ab8 <prsr_get_bytes_read>:

	return;
}

alt_u32	prsr_get_bytes_read(alt_u32 base){
	return	(alt_u32)(((IORD_PRSR_BYTES_READ_H(base) & 0xffff) << 16) + (IORD_PRSR_BYTES_READ_L(base) & 0xffff));
  800ab8:	008000b4 	movhi	r2,2
  800abc:	10880804 	addi	r2,r2,8224
  800ac0:	2085883a 	add	r2,r4,r2
  800ac4:	10c00037 	ldwio	r3,0(r2)
  800ac8:	008000b4 	movhi	r2,2
  800acc:	10880c04 	addi	r2,r2,8240
  800ad0:	2089883a 	add	r4,r4,r2
  800ad4:	20800037 	ldwio	r2,0(r4)
  800ad8:	1806943a 	slli	r3,r3,16
  800adc:	10bfffcc 	andi	r2,r2,65535
}
  800ae0:	1885883a 	add	r2,r3,r2
  800ae4:	f800283a 	ret

00800ae8 <prsr_hdr_ram_read16>:
	IOWR_PRSR_CTRL(base, 0x0);
	return;
}

alt_u16 prsr_hdr_ram_read16(alt_u32 base, alt_u8 addr){
	IOWR_PRSR_HDR_RAM_RD_ADDR(base, addr);
  800ae8:	008000b4 	movhi	r2,2
  800aec:	10881004 	addi	r2,r2,8256
  800af0:	2085883a 	add	r2,r4,r2
  800af4:	29403fcc 	andi	r5,r5,255
  800af8:	11400035 	stwio	r5,0(r2)

	return (alt_u16)(IORD_PRSR_HDR_RAM_RD_DATA(base)	&	0xffff);
  800afc:	008000b4 	movhi	r2,2
  800b00:	10881404 	addi	r2,r2,8272
  800b04:	2089883a 	add	r4,r4,r2
  800b08:	20800037 	ldwio	r2,0(r4)
}
  800b0c:	10bfffcc 	andi	r2,r2,65535
  800b10:	f800283a 	ret

00800b14 <get_wav_hdr_frm_prsr>:

void	get_wav_hdr_frm_prsr(alt_u32 base, alt_u16 *bffr){
  800b14:	defffc04 	addi	sp,sp,-16
  800b18:	dc800215 	stw	r18,8(sp)
  800b1c:	dc000015 	stw	r16,0(sp)
  800b20:	2025883a 	mov	r18,r4
  800b24:	2821883a 	mov	r16,r5
  800b28:	dfc00315 	stw	ra,12(sp)
  800b2c:	dc400115 	stw	r17,4(sp)
  800b30:	00000106 	br	800b38 <get_wav_hdr_frm_prsr+0x24>
	alt_u8	i;

	while(prsr_get_bytes_read(base) < 48){
		chThdSleepMilliseconds(1);	//wait for sufficient data to be read
  800b34:	08128680 	call	812868 <chThdSleep>
}

void	get_wav_hdr_frm_prsr(alt_u32 base, alt_u16 *bffr){
	alt_u8	i;

	while(prsr_get_bytes_read(base) < 48){
  800b38:	9009883a 	mov	r4,r18
  800b3c:	0800ab80 	call	800ab8 <prsr_get_bytes_read>
  800b40:	00c00bc4 	movi	r3,47
		chThdSleepMilliseconds(1);	//wait for sufficient data to be read
  800b44:	01000044 	movi	r4,1
}

void	get_wav_hdr_frm_prsr(alt_u32 base, alt_u16 *bffr){
	alt_u8	i;

	while(prsr_get_bytes_read(base) < 48){
  800b48:	18bffa2e 	bgeu	r3,r2,800b34 <get_wav_hdr_frm_prsr+0x20>
  800b4c:	0023883a 	mov	r17,zero
		chThdSleepMilliseconds(1);	//wait for sufficient data to be read
	}

	for(i=0;i<23;i++){
		bffr[i]	=	prsr_hdr_ram_read16(base, i);
  800b50:	880b883a 	mov	r5,r17
  800b54:	9009883a 	mov	r4,r18
  800b58:	0800ae80 	call	800ae8 <prsr_hdr_ram_read16>
  800b5c:	8080000d 	sth	r2,0(r16)
  800b60:	8c400044 	addi	r17,r17,1

	while(prsr_get_bytes_read(base) < 48){
		chThdSleepMilliseconds(1);	//wait for sufficient data to be read
	}

	for(i=0;i<23;i++){
  800b64:	008005c4 	movi	r2,23
		bffr[i]	=	prsr_hdr_ram_read16(base, i);
  800b68:	84000084 	addi	r16,r16,2

	while(prsr_get_bytes_read(base) < 48){
		chThdSleepMilliseconds(1);	//wait for sufficient data to be read
	}

	for(i=0;i<23;i++){
  800b6c:	88bff81e 	bne	r17,r2,800b50 <get_wav_hdr_frm_prsr+0x3c>
		bffr[i]	=	prsr_hdr_ram_read16(base, i);
	}

	return;
}
  800b70:	dfc00317 	ldw	ra,12(sp)
  800b74:	dc800217 	ldw	r18,8(sp)
  800b78:	dc400117 	ldw	r17,4(sp)
  800b7c:	dc000017 	ldw	r16,0(sp)
  800b80:	dec00404 	addi	sp,sp,16
  800b84:	f800283a 	ret

00800b88 <prsr_disable>:
	IOWR_PRSR_CTRL(base, PRSR_EN_MSK);
	return;
}

void	prsr_disable(alt_u32 base){
	IOWR_PRSR_CTRL(base, 0x0);
  800b88:	008000b4 	movhi	r2,2
  800b8c:	10880004 	addi	r2,r2,8192
  800b90:	2089883a 	add	r4,r4,r2
  800b94:	20000035 	stwio	zero,0(r4)
	return;
}
  800b98:	f800283a 	ret

00800b9c <prsr_enable>:
 */
#include "prsr.h"
#include "alt_types.h"

void	prsr_enable(alt_u32 base){
	IOWR_PRSR_CTRL(base, PRSR_EN_MSK);
  800b9c:	008000b4 	movhi	r2,2
  800ba0:	10880004 	addi	r2,r2,8192
  800ba4:	2089883a 	add	r4,r4,r2
  800ba8:	00800044 	movi	r2,1
  800bac:	20800035 	stwio	r2,0(r4)
	return;
}
  800bb0:	f800283a 	ret

00800bb4 <sram_write16>:
	return IORD_SRAM_ACC_DATA(base);
}

void	sram_write16(alt_u32 base, alt_u32 addr, alt_u16 data){

	IOWR_SRAM_ACC_ADDR_H(base, (addr >> 16) & SRAM_ADDR_H_MSK);
  800bb4:	2806d43a 	srli	r3,r5,16
  800bb8:	008000b4 	movhi	r2,2
  800bbc:	10840804 	addi	r2,r2,4128
  800bc0:	2085883a 	add	r2,r4,r2
  800bc4:	18c000cc 	andi	r3,r3,3
  800bc8:	10c00035 	stwio	r3,0(r2)
	IOWR_SRAM_ACC_ADDR_L(base, addr & SRAM_ADDR_L_MSK);
  800bcc:	008000b4 	movhi	r2,2
  800bd0:	10840c04 	addi	r2,r2,4144
  800bd4:	2085883a 	add	r2,r4,r2
  800bd8:	297fffcc 	andi	r5,r5,65535
  800bdc:	11400035 	stwio	r5,0(r2)

	IOWR_SRAM_ACC_DATA(base, data);
  800be0:	008000b4 	movhi	r2,2
  800be4:	10841004 	addi	r2,r2,4160
  800be8:	2085883a 	add	r2,r4,r2
  800bec:	31bfffcc 	andi	r6,r6,65535
  800bf0:	11800035 	stwio	r6,0(r2)

	IOWR_SRAM_ACC_CTRL(base, SRAM_MM_WR_EN_MSK);
  800bf4:	008000b4 	movhi	r2,2
  800bf8:	10840404 	addi	r2,r2,4112
  800bfc:	2089883a 	add	r4,r4,r2
  800c00:	00800084 	movi	r2,2
  800c04:	20800035 	stwio	r2,0(r4)

	return;
}
  800c08:	f800283a 	ret

00800c0c <sram_read16>:
#include "sram.h"
#include "alt_types.h"

alt_u16 sram_read16(alt_u32 base, alt_u32 addr){

	IOWR_SRAM_ACC_ADDR_H(base, (addr >> 16) & SRAM_ADDR_H_MSK);
  800c0c:	2806d43a 	srli	r3,r5,16
  800c10:	008000b4 	movhi	r2,2
  800c14:	10840804 	addi	r2,r2,4128
  800c18:	2085883a 	add	r2,r4,r2
  800c1c:	18c000cc 	andi	r3,r3,3
  800c20:	10c00035 	stwio	r3,0(r2)
	IOWR_SRAM_ACC_ADDR_L(base, addr & SRAM_ADDR_L_MSK);
  800c24:	008000b4 	movhi	r2,2
  800c28:	10840c04 	addi	r2,r2,4144
  800c2c:	2085883a 	add	r2,r4,r2
  800c30:	297fffcc 	andi	r5,r5,65535
  800c34:	11400035 	stwio	r5,0(r2)

	IOWR_SRAM_ACC_CTRL(base, SRAM_MM_RD_EN_MSK);
  800c38:	008000b4 	movhi	r2,2
  800c3c:	10840404 	addi	r2,r2,4112
  800c40:	2085883a 	add	r2,r4,r2
  800c44:	00c00044 	movi	r3,1
  800c48:	10c00035 	stwio	r3,0(r2)

	return IORD_SRAM_ACC_DATA(base);
  800c4c:	008000b4 	movhi	r2,2
  800c50:	10841004 	addi	r2,r2,4160
  800c54:	2089883a 	add	r4,r4,r2
  800c58:	20800037 	ldwio	r2,0(r4)
}
  800c5c:	10bfffcc 	andi	r2,r2,65535
  800c60:	f800283a 	ret

00800c64 <cortex_init>:
 *      Author: Gregory
 */
#include "cortex.h"
#include "sys/alt_stdio.h"

void cortex_init(alt_32 base, FS_T fs, BPS_T bps){
  800c64:	defffc04 	addi	sp,sp,-16
  800c68:	dc400115 	stw	r17,4(sp)
  800c6c:	dc000015 	stw	r16,0(sp)
	acortex_init(base,fs,bps);

	//Fgyrus
	configure_post_norm(CORTEX_MM_SL_BASE, LCHNL, NORM_64k);
  800c70:	04400144 	movi	r17,5
  800c74:	04004034 	movhi	r16,256
 *      Author: Gregory
 */
#include "cortex.h"
#include "sys/alt_stdio.h"

void cortex_init(alt_32 base, FS_T fs, BPS_T bps){
  800c78:	dfc00315 	stw	ra,12(sp)
  800c7c:	dc800215 	stw	r18,8(sp)
  800c80:	2025883a 	mov	r18,r4
	acortex_init(base,fs,bps);
  800c84:	08006680 	call	800668 <acortex_init>

	//Fgyrus
	configure_post_norm(CORTEX_MM_SL_BASE, LCHNL, NORM_64k);
  800c88:	880d883a 	mov	r6,r17
  800c8c:	8009883a 	mov	r4,r16
  800c90:	000b883a 	mov	r5,zero
  800c94:	0800d040 	call	800d04 <configure_post_norm>
	configure_post_norm(CORTEX_MM_SL_BASE, RCHNL, NORM_64k);
  800c98:	8009883a 	mov	r4,r16
  800c9c:	880d883a 	mov	r6,r17
  800ca0:	01400044 	movi	r5,1
  800ca4:	0800d040 	call	800d04 <configure_post_norm>

	enable_vcortex(base);
  800ca8:	9009883a 	mov	r4,r18
  800cac:	0800dac0 	call	800dac <enable_vcortex>

	alt_printf("Cortex Init done\r\n");
  800cb0:	01002074 	movhi	r4,129
  800cb4:	211d3e04 	addi	r4,r4,29944

	return;
}
  800cb8:	dfc00317 	ldw	ra,12(sp)
  800cbc:	dc800217 	ldw	r18,8(sp)
  800cc0:	dc400117 	ldw	r17,4(sp)
  800cc4:	dc000017 	ldw	r16,0(sp)
  800cc8:	dec00404 	addi	sp,sp,16
	configure_post_norm(CORTEX_MM_SL_BASE, LCHNL, NORM_64k);
	configure_post_norm(CORTEX_MM_SL_BASE, RCHNL, NORM_64k);

	enable_vcortex(base);

	alt_printf("Cortex Init done\r\n");
  800ccc:	08136301 	jmpi	813630 <alt_printf>

00800cd0 <get_full_fgyrus_addr>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800cd0:	20000226 	beq	r4,zero,800cdc <get_full_fgyrus_addr+0xc>
  800cd4:	00800074 	movhi	r2,1
  800cd8:	288b883a 	add	r5,r5,r2
}
  800cdc:	2805883a 	mov	r2,r5
  800ce0:	f800283a 	ret

00800ce4 <get_fgyrus_status>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800ce4:	00801004 	movi	r2,64
  800ce8:	28000226 	beq	r5,zero,800cf4 <get_fgyrus_status+0x10>
  800cec:	00800074 	movhi	r2,1
  800cf0:	10801004 	addi	r2,r2,64
}


FGYRUS_STATUS_TYPE	get_fgyrus_status(alt_u32 base, FGYRUS_TYPE fg){
	if(IORD_FGYRUS_STATUS(base, fg) & FGYRUS_BUSY_MSK){
  800cf4:	2085883a 	add	r2,r4,r2
  800cf8:	10800037 	ldwio	r2,0(r2)
		return DECIMATE; //As long as its not idle
	}
	else{
		return IDLE;
	}
}
  800cfc:	1080004c 	andi	r2,r2,1
  800d00:	f800283a 	ret

00800d04 <configure_post_norm>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800d04:	00801804 	movi	r2,96
  800d08:	28000226 	beq	r5,zero,800d14 <configure_post_norm+0x10>
  800d0c:	00800074 	movhi	r2,1
  800d10:	10801804 	addi	r2,r2,96
void disable_fgyrus(alt_u32 base, FGYRUS_TYPE fg){
	IOWR_FGYRUS_CTRL(base, fg, 0x0);
}

void configure_post_norm(alt_u32 base, FGYRUS_TYPE fg, FGYRUS_POST_NORM_TYPE val){
	IOWR_FGYRUS_POST_NORM(base, fg, val);
  800d14:	2085883a 	add	r2,r4,r2
  800d18:	11800035 	stwio	r6,0(r2)
}
  800d1c:	f800283a 	ret

00800d20 <disable_fgyrus>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800d20:	280ac03a 	cmpne	r5,r5,zero
  800d24:	280a943a 	slli	r5,r5,16
void enable_fgyrus(alt_u32 base, FGYRUS_TYPE fg){
	IOWR_FGYRUS_CTRL(base, fg, FGYRUS_EN_MSK);
}

void disable_fgyrus(alt_u32 base, FGYRUS_TYPE fg){
	IOWR_FGYRUS_CTRL(base, fg, 0x0);
  800d28:	2149883a 	add	r4,r4,r5
  800d2c:	20000035 	stwio	zero,0(r4)
}
  800d30:	f800283a 	ret

00800d34 <enable_fgyrus>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800d34:	280ac03a 	cmpne	r5,r5,zero
  800d38:	280a943a 	slli	r5,r5,16
FGYRUS_STATUS_TYPE	get_fgyrus_fsm_pstate(alt_u32 base, FGYRUS_TYPE fg){
	return IORD_FGYRUS_FSM_PSTATE(base, fg) & FGYRUS_FSM_PSTATE_MSK;
}

void enable_fgyrus(alt_u32 base, FGYRUS_TYPE fg){
	IOWR_FGYRUS_CTRL(base, fg, FGYRUS_EN_MSK);
  800d3c:	00800044 	movi	r2,1
  800d40:	2149883a 	add	r4,r4,r5
  800d44:	20800035 	stwio	r2,0(r4)
}
  800d48:	f800283a 	ret

00800d4c <get_fgyrus_fsm_pstate>:
#include "fgyrus.h"
#include "alt_types.h"


alt_u32	get_full_fgyrus_addr(FGYRUS_TYPE fg, alt_u32 addr){
	return	(fg == LCHNL) ? addr + FGYRUS_LCHNL_BLK_CODE : addr + FGYRUS_RCHNL_BLK_CODE;
  800d4c:	00800804 	movi	r2,32
  800d50:	28000226 	beq	r5,zero,800d5c <get_fgyrus_fsm_pstate+0x10>
  800d54:	00800074 	movhi	r2,1
  800d58:	10800804 	addi	r2,r2,32
	}
}


FGYRUS_STATUS_TYPE	get_fgyrus_fsm_pstate(alt_u32 base, FGYRUS_TYPE fg){
	return IORD_FGYRUS_FSM_PSTATE(base, fg) & FGYRUS_FSM_PSTATE_MSK;
  800d5c:	2085883a 	add	r2,r4,r2
  800d60:	10800037 	ldwio	r2,0(r2)
}
  800d64:	108001cc 	andi	r2,r2,7
  800d68:	f800283a 	ret

00800d6c <pwm_paint>:

void disable_vcortex(alt_u32 base){
	IOWR_VCORTEX_CTRL(base, 0x0);
}

void pwm_paint(alt_u32 base, alt_u16 * bffr){
  800d6c:	008000f4 	movhi	r2,3
  800d70:	10840004 	addi	r2,r2,4096
  800d74:	2089883a 	add	r4,r4,r2
  800d78:	0007883a 	mov	r3,zero
  800d7c:	01800404 	movi	r6,16


	for(i=0; i<VCORTEX_PWM_CHNNLS; i++){
		//alt_printf("[%x] = 0x%x | ",i,(alt_u32)bffr[i]);

		IOWR_32DIRECT(base, VCORTEX_PWM_RAM_BASE + (i<<4), (alt_u32)bffr[i]);
  800d80:	2880000b 	ldhu	r2,0(r5)
  800d84:	20800035 	stwio	r2,0(r4)
  800d88:	18c00044 	addi	r3,r3,1
  800d8c:	21000404 	addi	r4,r4,16
  800d90:	29400084 	addi	r5,r5,2

void pwm_paint(alt_u32 base, alt_u16 * bffr){
	alt_u8 i;


	for(i=0; i<VCORTEX_PWM_CHNNLS; i++){
  800d94:	19bffa1e 	bne	r3,r6,800d80 <pwm_paint+0x14>

		IOWR_32DIRECT(base, VCORTEX_PWM_RAM_BASE + (i<<4), (alt_u32)bffr[i]);
	}

	//alt_printf("\n");
}
  800d98:	f800283a 	ret

00800d9c <disable_vcortex>:
void enable_vcortex(alt_u32 base){
	IOWR_VCORTEX_CTRL(base, VCORTEX_CTRL_EN_MSK);
}

void disable_vcortex(alt_u32 base){
	IOWR_VCORTEX_CTRL(base, 0x0);
  800d9c:	008000f4 	movhi	r2,3
  800da0:	2089883a 	add	r4,r4,r2
  800da4:	20000035 	stwio	zero,0(r4)
}
  800da8:	f800283a 	ret

00800dac <enable_vcortex>:
#include "alt_types.h"
#include "sys/alt_stdio.h"


void enable_vcortex(alt_u32 base){
	IOWR_VCORTEX_CTRL(base, VCORTEX_CTRL_EN_MSK);
  800dac:	008000f4 	movhi	r2,3
  800db0:	2089883a 	add	r4,r4,r2
  800db4:	00800044 	movi	r2,1
  800db8:	20800035 	stwio	r2,0(r4)
}
  800dbc:	f800283a 	ret

00800dc0 <disk_timerproc>:
/* This function is defined for only project compatibility               */

void disk_timerproc (void)
{
	/* Nothing to do */
}
  800dc0:	f800283a 	ret

00800dc4 <init_port>:
#define DI_H()		PORT |= 0x04	/* Set MMC DI "high" */
#define DI_L()		PORT &= 0xFB	/* Set MMC DI "low" */
#define DO			(PORT &	0x08)	/* Test for MMC DO ('H':true, 'L':false) */

void init_port(){
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x0);
  800dc4:	00804434 	movhi	r2,272
  800dc8:	10882504 	addi	r2,r2,8340
  800dcc:	10000035 	stwio	zero,0(r2)
	IOWR_ALTERA_AVALON_SPI_STATUS(SDCARD_SPI_BASE,0x0);
  800dd0:	10bffd04 	addi	r2,r2,-12
  800dd4:	10000035 	stwio	zero,0(r2)
}
  800dd8:	f800283a 	ret

00800ddc <wait_on_spi>:
	}

	return;
}

void wait_on_spi(BYTE mask){
  800ddc:	21003fcc 	andi	r4,r4,255
  800de0:	00c04434 	movhi	r3,272
  800de4:	18c82204 	addi	r3,r3,8328
	//alt_printf("waiting on spi\n");

	//DLY_US(1);

	//wait for TRDY & RRDY bits to be set in SPI driver.
	while(!(IORD_ALTERA_AVALON_SPI_STATUS(SDCARD_SPI_BASE) & mask));
  800de8:	18800037 	ldwio	r2,0(r3)
  800dec:	1104703a 	and	r2,r2,r4
  800df0:	103ffd26 	beq	r2,zero,800de8 <wait_on_spi+0xc>
}
  800df4:	f800283a 	ret

00800df8 <rcvr_mmc>:
static
void rcvr_mmc (
	BYTE *buff,	/* Pointer to read buffer */
	UINT bc		/* Number of bytes to receive */
)
{
  800df8:	defffd04 	addi	sp,sp,-12
  800dfc:	dc400115 	stw	r17,4(sp)
  800e00:	dc000015 	stw	r16,0(sp)
  800e04:	dfc00215 	stw	ra,8(sp)
  800e08:	2023883a 	mov	r17,r4
  800e0c:	2821883a 	mov	r16,r5
	/*
		   * Discard any stale data present in the RXDATA register, in case
		   * previous communication was interrupted and stale data was left
		   * behind.
		   */
		  IORD_ALTERA_AVALON_SPI_RXDATA(SDCARD_SPI_BASE);
  800e10:	00804434 	movhi	r2,272
  800e14:	10882004 	addi	r2,r2,8320
  800e18:	10800037 	ldwio	r2,0(r2)

		do{
			wait_on_spi(ALTERA_AVALON_SPI_STATUS_TRDY_MSK);
  800e1c:	01001004 	movi	r4,64
  800e20:	0800ddc0 	call	800ddc <wait_on_spi>

	        IOWR_ALTERA_AVALON_SPI_TXDATA(SDCARD_SPI_BASE, 0xff);
  800e24:	00c03fc4 	movi	r3,255
  800e28:	00804434 	movhi	r2,272
  800e2c:	10882104 	addi	r2,r2,8324
  800e30:	10c00035 	stwio	r3,0(r2)

			wait_on_spi(ALTERA_AVALON_SPI_STATUS_RRDY_MSK);
  800e34:	01002004 	movi	r4,128
  800e38:	0800ddc0 	call	800ddc <wait_on_spi>
	        *buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SDCARD_SPI_BASE);
  800e3c:	00804434 	movhi	r2,272
  800e40:	10882004 	addi	r2,r2,8320
  800e44:	10800037 	ldwio	r2,0(r2)
	        --bc;
  800e48:	843fffc4 	addi	r16,r16,-1
			wait_on_spi(ALTERA_AVALON_SPI_STATUS_TRDY_MSK);

	        IOWR_ALTERA_AVALON_SPI_TXDATA(SDCARD_SPI_BASE, 0xff);

			wait_on_spi(ALTERA_AVALON_SPI_STATUS_RRDY_MSK);
	        *buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SDCARD_SPI_BASE);
  800e4c:	88800005 	stb	r2,0(r17)
  800e50:	8c400044 	addi	r17,r17,1
	        --bc;

		}while(bc>0);
  800e54:	803ff11e 	bne	r16,zero,800e1c <rcvr_mmc+0x24>


		/* Wait until the interface has finished transmitting */
		wait_on_spi(ALTERA_AVALON_SPI_STATUS_TMT_MSK);
  800e58:	01000804 	movi	r4,32

}
  800e5c:	dfc00217 	ldw	ra,8(sp)
  800e60:	dc400117 	ldw	r17,4(sp)
  800e64:	dc000017 	ldw	r16,0(sp)
  800e68:	dec00304 	addi	sp,sp,12

		}while(bc>0);


		/* Wait until the interface has finished transmitting */
		wait_on_spi(ALTERA_AVALON_SPI_STATUS_TMT_MSK);
  800e6c:	0800ddc1 	jmpi	800ddc <wait_on_spi>

00800e70 <deselect>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
  800e70:	defffe04 	addi	sp,sp,-8
	BYTE d;

	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x0);
  800e74:	00804434 	movhi	r2,272
  800e78:	10882504 	addi	r2,r2,8340
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
  800e7c:	dfc00115 	stw	ra,4(sp)
	BYTE d;

	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x0);
  800e80:	10000035 	stwio	zero,0(r2)
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
  800e84:	d809883a 	mov	r4,sp
  800e88:	01400044 	movi	r5,1
  800e8c:	0800df80 	call	800df8 <rcvr_mmc>

	//alt_printf("SD Card deselected\n");
}
  800e90:	dfc00117 	ldw	ra,4(sp)
  800e94:	dec00204 	addi	sp,sp,8
  800e98:	f800283a 	ret

00800e9c <xmit_mmc>:
static
void xmit_mmc (
	const BYTE* buff,	/* Data to be sent */
	UINT bc				/* Number of bytes to send */
)
{
  800e9c:	defffd04 	addi	sp,sp,-12
  800ea0:	dc400115 	stw	r17,4(sp)
  800ea4:	dc000015 	stw	r16,0(sp)
  800ea8:	dfc00215 	stw	ra,8(sp)
  800eac:	2023883a 	mov	r17,r4
  800eb0:	2821883a 	mov	r16,r5
	/*
	   * Discard any stale data present in the RXDATA register, in case
	   * previous communication was interrupted and stale data was left
	   * behind.
	   */
	  IORD_ALTERA_AVALON_SPI_RXDATA(SDCARD_SPI_BASE);
  800eb4:	00804434 	movhi	r2,272
  800eb8:	10882004 	addi	r2,r2,8320
  800ebc:	10800037 	ldwio	r2,0(r2)

	do{
		wait_on_spi(ALTERA_AVALON_SPI_STATUS_TRDY_MSK);
  800ec0:	01001004 	movi	r4,64
  800ec4:	0800ddc0 	call	800ddc <wait_on_spi>

        IOWR_ALTERA_AVALON_SPI_TXDATA(SDCARD_SPI_BASE, *buff++);
  800ec8:	88c00003 	ldbu	r3,0(r17)
  800ecc:	00804434 	movhi	r2,272
  800ed0:	10882104 	addi	r2,r2,8324
  800ed4:	8c400044 	addi	r17,r17,1
  800ed8:	10c00035 	stwio	r3,0(r2)
        --bc;

		wait_on_spi(ALTERA_AVALON_SPI_STATUS_RRDY_MSK);
  800edc:	01002004 	movi	r4,128
  800ee0:	0800ddc0 	call	800ddc <wait_on_spi>

	do{
		wait_on_spi(ALTERA_AVALON_SPI_STATUS_TRDY_MSK);

        IOWR_ALTERA_AVALON_SPI_TXDATA(SDCARD_SPI_BASE, *buff++);
        --bc;
  800ee4:	843fffc4 	addi	r16,r16,-1

		wait_on_spi(ALTERA_AVALON_SPI_STATUS_RRDY_MSK);
        IORD_ALTERA_AVALON_SPI_RXDATA(SDCARD_SPI_BASE); //flush out RX data
  800ee8:	00804434 	movhi	r2,272
  800eec:	10882004 	addi	r2,r2,8320
  800ef0:	10800037 	ldwio	r2,0(r2)

	}while(bc>0);
  800ef4:	803ff21e 	bne	r16,zero,800ec0 <xmit_mmc+0x24>


	/* Wait until the interface has finished transmitting */
	wait_on_spi(ALTERA_AVALON_SPI_STATUS_TMT_MSK);
  800ef8:	01000804 	movi	r4,32

}
  800efc:	dfc00217 	ldw	ra,8(sp)
  800f00:	dc400117 	ldw	r17,4(sp)
  800f04:	dc000017 	ldw	r16,0(sp)
  800f08:	dec00304 	addi	sp,sp,12

	}while(bc>0);


	/* Wait until the interface has finished transmitting */
	wait_on_spi(ALTERA_AVALON_SPI_STATUS_TMT_MSK);
  800f0c:	0800ddc1 	jmpi	800ddc <wait_on_spi>

00800f10 <dly_us>:
void init_port(){
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x0);
	IOWR_ALTERA_AVALON_SPI_STATUS(SDCARD_SPI_BASE,0x0);
}

void dly_us(USHORT n){
  800f10:	213fffcc 	andi	r4,r4,65535
  800f14:	0007883a 	mov	r3,zero
  800f18:	01c04434 	movhi	r7,272
  800f1c:	39c82904 	addi	r7,r7,8356
  800f20:	01800104 	movi	r6,4
  800f24:	00000706 	br	800f44 <dly_us+0x34>
	USHORT i;

	for(i=0;i<n;i++){
		//start the timer
		IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_1US_BASE,ALTERA_AVALON_TIMER_CONTROL_START_MSK);
  800f28:	39800035 	stwio	r6,0(r7)
  800f2c:	01404434 	movhi	r5,272
  800f30:	29482804 	addi	r5,r5,8352

		//loop as long as RUN bit is set in timer status register
		while(IORD_ALTERA_AVALON_TIMER_STATUS(TIMER_1US_BASE)	&	ALTERA_AVALON_TIMER_STATUS_RUN_MSK);
  800f34:	28800037 	ldwio	r2,0(r5)
  800f38:	1080008c 	andi	r2,r2,2
  800f3c:	103ffd1e 	bne	r2,zero,800f34 <dly_us+0x24>
}

void dly_us(USHORT n){
	USHORT i;

	for(i=0;i<n;i++){
  800f40:	18c00044 	addi	r3,r3,1
  800f44:	18bfffcc 	andi	r2,r3,65535
  800f48:	113ff71e 	bne	r2,r4,800f28 <dly_us+0x18>
		//loop as long as RUN bit is set in timer status register
		while(IORD_ALTERA_AVALON_TIMER_STATUS(TIMER_1US_BASE)	&	ALTERA_AVALON_TIMER_STATUS_RUN_MSK);
	}

	return;
}
  800f4c:	f800283a 	ret

00800f50 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
  800f50:	defffb04 	addi	sp,sp,-20
  800f54:	dc800315 	stw	r18,12(sp)
  800f58:	dc400215 	stw	r17,8(sp)
  800f5c:	dc000115 	stw	r16,4(sp)
  800f60:	dfc00415 	stw	ra,16(sp)
  800f64:	2025883a 	mov	r18,r4
  800f68:	2823883a 	mov	r17,r5
  800f6c:	0400fa04 	movi	r16,1000
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
  800f70:	d809883a 	mov	r4,sp
  800f74:	01400044 	movi	r5,1
  800f78:	0800df80 	call	800df8 <rcvr_mmc>
		if (d[0] != 0xFF) break;
  800f7c:	d8c00003 	ldbu	r3,0(sp)
  800f80:	00803fc4 	movi	r2,255
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
  800f84:	843fffc4 	addi	r16,r16,-1
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		DLY_US(100);
  800f88:	01001904 	movi	r4,100
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
  800f8c:	1880021e 	bne	r3,r2,800f98 <rcvr_datablock+0x48>
		DLY_US(100);
  800f90:	0800f100 	call	800f10 <dly_us>
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
  800f94:	803ff61e 	bne	r16,zero,800f70 <rcvr_datablock+0x20>
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		DLY_US(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
  800f98:	d8c00003 	ldbu	r3,0(sp)
  800f9c:	00803f84 	movi	r2,254
  800fa0:	18800226 	beq	r3,r2,800fac <rcvr_datablock+0x5c>
  800fa4:	0005883a 	mov	r2,zero
  800fa8:	00000706 	br	800fc8 <rcvr_datablock+0x78>

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
  800fac:	880b883a 	mov	r5,r17
  800fb0:	9009883a 	mov	r4,r18
  800fb4:	0800df80 	call	800df8 <rcvr_mmc>
	rcvr_mmc(d, 2);					/* Discard CRC */
  800fb8:	d809883a 	mov	r4,sp
  800fbc:	01400084 	movi	r5,2
  800fc0:	0800df80 	call	800df8 <rcvr_mmc>
  800fc4:	00800044 	movi	r2,1

	return 1;						/* Return with success */
}
  800fc8:	dfc00417 	ldw	ra,16(sp)
  800fcc:	dc800317 	ldw	r18,12(sp)
  800fd0:	dc400217 	ldw	r17,8(sp)
  800fd4:	dc000117 	ldw	r16,4(sp)
  800fd8:	dec00504 	addi	sp,sp,20
  800fdc:	f800283a 	ret

00800fe0 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
  800fe0:	defffd04 	addi	sp,sp,-12
  800fe4:	dc000115 	stw	r16,4(sp)
  800fe8:	dfc00215 	stw	ra,8(sp)
  800fec:	0404e204 	movi	r16,5000
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
		rcvr_mmc(&d, 1);
  800ff0:	d809883a 	mov	r4,sp
  800ff4:	01400044 	movi	r5,1
  800ff8:	0800df80 	call	800df8 <rcvr_mmc>
		if (d == 0xFF) break;
  800ffc:	d8c00003 	ldbu	r3,0(sp)
  801000:	00803fc4 	movi	r2,255
		DLY_US(100);
  801004:	01001904 	movi	r4,100
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
  801008:	18800326 	beq	r3,r2,801018 <wait_ready+0x38>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
  80100c:	843fffc4 	addi	r16,r16,-1
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
		DLY_US(100);
  801010:	0800f100 	call	800f10 <dly_us>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
  801014:	803ff61e 	bne	r16,zero,800ff0 <wait_ready+0x10>
		if (d == 0xFF) break;
		DLY_US(100);
	}

	return tmr ? 1 : 0;
}
  801018:	8004c03a 	cmpne	r2,r16,zero
  80101c:	dfc00217 	ldw	ra,8(sp)
  801020:	dc000117 	ldw	r16,4(sp)
  801024:	dec00304 	addi	sp,sp,12
  801028:	f800283a 	ret

0080102c <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
  80102c:	defffb04 	addi	sp,sp,-20
  801030:	dc400215 	stw	r17,8(sp)
  801034:	dc000115 	stw	r16,4(sp)
  801038:	2023883a 	mov	r17,r4
  80103c:	2821883a 	mov	r16,r5
  801040:	dfc00415 	stw	ra,16(sp)
  801044:	dc800315 	stw	r18,12(sp)
	BYTE d[2];


	if (!wait_ready()) return 0;
  801048:	0800fe00 	call	800fe0 <wait_ready>

	d[0] = token;
	xmit_mmc(d, 1);				/* Xmit a token */
  80104c:	d809883a 	mov	r4,sp
  801050:	01400044 	movi	r5,1
)
{
	BYTE d[2];


	if (!wait_ready()) return 0;
  801054:	000d883a 	mov	r6,zero
  801058:	10001226 	beq	r2,zero,8010a4 <xmit_datablock+0x78>

	d[0] = token;
  80105c:	dc000005 	stb	r16,0(sp)
	xmit_mmc(d, 1);				/* Xmit a token */
  801060:	0800e9c0 	call	800e9c <xmit_mmc>
	if (token != 0xFD) {		/* Is it data token? */
  801064:	80c03fcc 	andi	r3,r16,255
  801068:	00803f44 	movi	r2,253
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
  80106c:	8809883a 	mov	r4,r17
  801070:	01408004 	movi	r5,512

	if (!wait_ready()) return 0;

	d[0] = token;
	xmit_mmc(d, 1);				/* Xmit a token */
	if (token != 0xFD) {		/* Is it data token? */
  801074:	01800044 	movi	r6,1
  801078:	18800a26 	beq	r3,r2,8010a4 <xmit_datablock+0x78>
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
  80107c:	0800e9c0 	call	800e9c <xmit_mmc>
		rcvr_mmc(d, 2);			/* Xmit dummy CRC (0xFF,0xFF) */
  801080:	d809883a 	mov	r4,sp
  801084:	01400084 	movi	r5,2
  801088:	0800df80 	call	800df8 <rcvr_mmc>
		rcvr_mmc(d, 1);			/* Receive data response */
  80108c:	d809883a 	mov	r4,sp
  801090:	01400044 	movi	r5,1
  801094:	0800df80 	call	800df8 <rcvr_mmc>
  801098:	d8800003 	ldbu	r2,0(sp)
  80109c:	108007cc 	andi	r2,r2,31
  8010a0:	11800160 	cmpeqi	r6,r2,5
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
			return 0;
	}

	return 1;
}
  8010a4:	3005883a 	mov	r2,r6
  8010a8:	dfc00417 	ldw	ra,16(sp)
  8010ac:	dc800317 	ldw	r18,12(sp)
  8010b0:	dc400217 	ldw	r17,8(sp)
  8010b4:	dc000117 	ldw	r16,4(sp)
  8010b8:	dec00504 	addi	sp,sp,20
  8010bc:	f800283a 	ret

008010c0 <select>:
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
  8010c0:	defffd04 	addi	sp,sp,-12
  8010c4:	dc000115 	stw	r16,4(sp)
	BYTE d;

	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x1);
  8010c8:	00804434 	movhi	r2,272
  8010cc:	10882504 	addi	r2,r2,8340
  8010d0:	04000044 	movi	r16,1
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
  8010d4:	dfc00215 	stw	ra,8(sp)
	BYTE d;

	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SDCARD_SPI_BASE,0x1);
  8010d8:	14000035 	stwio	r16,0(r2)
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */
  8010dc:	d809883a 	mov	r4,sp
  8010e0:	800b883a 	mov	r5,r16
  8010e4:	0800df80 	call	800df8 <rcvr_mmc>

	if (wait_ready()){
  8010e8:	0800fe00 	call	800fe0 <wait_ready>
  8010ec:	8007883a 	mov	r3,r16
  8010f0:	1000021e 	bne	r2,zero,8010fc <select+0x3c>
		//alt_printf("SD Card selected\n");
		return 1;	/* OK */
	}
	deselect();
  8010f4:	0800e700 	call	800e70 <deselect>
  8010f8:	0007883a 	mov	r3,zero
	return 0;			/* Failed */
}
  8010fc:	1805883a 	mov	r2,r3
  801100:	dfc00217 	ldw	ra,8(sp)
  801104:	dc000117 	ldw	r16,4(sp)
  801108:	dec00304 	addi	sp,sp,12
  80110c:	f800283a 	ret

00801110 <send_cmd>:
)
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
  801110:	20803fcc 	andi	r2,r4,255
  801114:	1080201c 	xori	r2,r2,128
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
  801118:	defffa04 	addi	sp,sp,-24
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
  80111c:	10bfe004 	addi	r2,r2,-128
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
  801120:	dc800415 	stw	r18,16(sp)
  801124:	dc400315 	stw	r17,12(sp)
  801128:	dc000215 	stw	r16,8(sp)
  80112c:	dfc00515 	stw	ra,20(sp)
  801130:	2023883a 	mov	r17,r4
  801134:	2021883a 	mov	r16,r4
  801138:	2825883a 	mov	r18,r5
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
  80113c:	10000a0e 	bge	r2,zero,801168 <send_cmd+0x58>
		cmd &= 0x7F;
		n = send_cmd(CMD55, 0);
  801140:	01000dc4 	movi	r4,55
  801144:	000b883a 	mov	r5,zero
  801148:	08011100 	call	801110 <send_cmd>
		if (n > 1) return n;
  80114c:	10c03fcc 	andi	r3,r2,255
  801150:	00800044 	movi	r2,1
  801154:	10c00236 	bltu	r2,r3,801160 <send_cmd+0x50>
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
  801158:	8c001fcc 	andi	r16,r17,127
  80115c:	00000206 	br	801168 <send_cmd+0x58>
		n = send_cmd(CMD55, 0);
		if (n > 1) return n;
  801160:	1805883a 	mov	r2,r3
  801164:	00003306 	br	801234 <send_cmd+0x124>
	}

	/* Select the card and wait for ready */
	deselect();
  801168:	0800e700 	call	800e70 <deselect>
	if (!select()) return 0xFF;
  80116c:	08010c00 	call	8010c0 <select>
  801170:	1000021e 	bne	r2,zero,80117c <send_cmd+0x6c>
  801174:	00803fc4 	movi	r2,255
  801178:	00002e06 	br	801234 <send_cmd+0x124>

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
  80117c:	9006d63a 	srli	r3,r18,24
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
  801180:	9008d43a 	srli	r4,r18,16
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
  801184:	900ad23a 	srli	r5,r18,8
	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
  801188:	80801014 	ori	r2,r16,64
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
  80118c:	84403fcc 	andi	r17,r16,255
	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
  801190:	d8800045 	stb	r2,1(sp)
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
  801194:	d8c00085 	stb	r3,2(sp)
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
  801198:	d90000c5 	stb	r4,3(sp)
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
  80119c:	d9400105 	stb	r5,4(sp)
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
  8011a0:	dc800145 	stb	r18,5(sp)
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
  8011a4:	88001a26 	beq	r17,zero,801210 <send_cmd+0x100>
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
  8011a8:	00800204 	movi	r2,8
  8011ac:	d9000044 	addi	r4,sp,1
  8011b0:	88801b26 	beq	r17,r2,801220 <send_cmd+0x110>
	buf[5] = n;
  8011b4:	00800044 	movi	r2,1
	xmit_mmc(buf, 6);
  8011b8:	01400184 	movi	r5,6
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
  8011bc:	d8800185 	stb	r2,6(sp)
	xmit_mmc(buf, 6);
  8011c0:	0800e9c0 	call	800e9c <xmit_mmc>

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
  8011c4:	00800304 	movi	r2,12
  8011c8:	8880031e 	bne	r17,r2,8011d8 <send_cmd+0xc8>
  8011cc:	d809883a 	mov	r4,sp
  8011d0:	01400044 	movi	r5,1
  8011d4:	0800df80 	call	800df8 <rcvr_mmc>
  8011d8:	04000284 	movi	r16,10
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		rcvr_mmc(&d, 1);
  8011dc:	d809883a 	mov	r4,sp
  8011e0:	01400044 	movi	r5,1
  8011e4:	0800df80 	call	800df8 <rcvr_mmc>
	while ((d & 0x80) && --n);
  8011e8:	d9000003 	ldbu	r4,0(sp)
  8011ec:	843fffc4 	addi	r16,r16,-1
  8011f0:	80c03fcc 	andi	r3,r16,255
  8011f4:	20803fcc 	andi	r2,r4,255
  8011f8:	1080201c 	xori	r2,r2,128
  8011fc:	10bfe004 	addi	r2,r2,-128
  801200:	1000010e 	bge	r2,zero,801208 <send_cmd+0xf8>
  801204:	183ff51e 	bne	r3,zero,8011dc <send_cmd+0xcc>

	return d;			/* Return with the response value */
  801208:	20803fcc 	andi	r2,r4,255
  80120c:	00000906 	br	801234 <send_cmd+0x124>
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
	xmit_mmc(buf, 6);
  801210:	d9000044 	addi	r4,sp,1
  801214:	01400184 	movi	r5,6
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
  801218:	00bfe544 	movi	r2,-107
  80121c:	00000206 	br	801228 <send_cmd+0x118>
	xmit_mmc(buf, 6);
  801220:	01400184 	movi	r5,6
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	//n = 0xff;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
  801224:	00bfe1c4 	movi	r2,-121
  801228:	d8800185 	stb	r2,6(sp)
	xmit_mmc(buf, 6);
  80122c:	0800e9c0 	call	800e9c <xmit_mmc>
  801230:	003fe906 	br	8011d8 <send_cmd+0xc8>
	do
		rcvr_mmc(&d, 1);
	while ((d & 0x80) && --n);

	return d;			/* Return with the response value */
}
  801234:	dfc00517 	ldw	ra,20(sp)
  801238:	dc800417 	ldw	r18,16(sp)
  80123c:	dc400317 	ldw	r17,12(sp)
  801240:	dc000217 	ldw	r16,8(sp)
  801244:	dec00604 	addi	sp,sp,24
  801248:	f800283a 	ret

0080124c <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
  80124c:	defffb04 	addi	sp,sp,-20
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
  801250:	21003fcc 	andi	r4,r4,255
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
  801254:	dfc00415 	stw	ra,16(sp)
  801258:	dc800315 	stw	r18,12(sp)
  80125c:	dc400215 	stw	r17,8(sp)
  801260:	dc000115 	stw	r16,4(sp)
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
  801264:	20000226 	beq	r4,zero,801270 <disk_initialize+0x24>
  801268:	008000c4 	movi	r2,3
  80126c:	00005706 	br	8013cc <disk_initialize+0x180>

	INIT_PORT();				/* Initialize control port */
  801270:	0800dc40 	call	800dc4 <init_port>
  801274:	04000284 	movi	r16,10
	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* 80 dummy clocks */
  801278:	04400044 	movi	r17,1
  80127c:	d809883a 	mov	r4,sp
  801280:	880b883a 	mov	r5,r17
  801284:	843fffc4 	addi	r16,r16,-1
  801288:	0800df80 	call	800df8 <rcvr_mmc>
  80128c:	80803fcc 	andi	r2,r16,255
  801290:	103ff91e 	bne	r2,zero,801278 <disk_initialize+0x2c>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
  801294:	0009883a 	mov	r4,zero
  801298:	000b883a 	mov	r5,zero
  80129c:	08011100 	call	801110 <send_cmd>
  8012a0:	14003fcc 	andi	r16,r2,255
  8012a4:	8440411e 	bne	r16,r17,8013ac <disk_initialize+0x160>
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
  8012a8:	01000204 	movi	r4,8
  8012ac:	01406a84 	movi	r5,426
  8012b0:	08011100 	call	801110 <send_cmd>
  8012b4:	10803fcc 	andi	r2,r2,255
  8012b8:	1400221e 	bne	r2,r16,801344 <disk_initialize+0xf8>
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
  8012bc:	d809883a 	mov	r4,sp
  8012c0:	01400104 	movi	r5,4
  8012c4:	0800df80 	call	800df8 <rcvr_mmc>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
  8012c8:	d8800083 	ldbu	r2,2(sp)
  8012cc:	1400371e 	bne	r2,r16,8013ac <disk_initialize+0x160>
  8012d0:	d8c000c3 	ldbu	r3,3(sp)
  8012d4:	00802a84 	movi	r2,170
  8012d8:	1880341e 	bne	r3,r2,8013ac <disk_initialize+0x160>
  8012dc:	0400fa04 	movi	r16,1000
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
  8012e0:	01002a44 	movi	r4,169
  8012e4:	01500034 	movhi	r5,16384
  8012e8:	08011100 	call	801110 <send_cmd>
  8012ec:	10803fcc 	andi	r2,r2,255
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
  8012f0:	843fffc4 	addi	r16,r16,-1
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					DLY_US(1000);
  8012f4:	0100fa04 	movi	r4,1000
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
  8012f8:	10000326 	beq	r2,zero,801308 <disk_initialize+0xbc>
					DLY_US(1000);
  8012fc:	0800f100 	call	800f10 <dly_us>
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
  801300:	80002a26 	beq	r16,zero,8013ac <disk_initialize+0x160>
  801304:	003ff606 	br	8012e0 <disk_initialize+0x94>
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					DLY_US(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
  801308:	01000e84 	movi	r4,58
  80130c:	000b883a 	mov	r5,zero
  801310:	08011100 	call	801110 <send_cmd>
  801314:	10803fcc 	andi	r2,r2,255
  801318:	1000241e 	bne	r2,zero,8013ac <disk_initialize+0x160>
					rcvr_mmc(buf, 4);
  80131c:	d809883a 	mov	r4,sp
  801320:	01400104 	movi	r5,4
  801324:	0800df80 	call	800df8 <rcvr_mmc>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
  801328:	d8800003 	ldbu	r2,0(sp)
  80132c:	1080100c 	andi	r2,r2,64
  801330:	10000226 	beq	r2,zero,80133c <disk_initialize+0xf0>
  801334:	04400304 	movi	r17,12
  801338:	00001d06 	br	8013b0 <disk_initialize+0x164>
  80133c:	04400104 	movi	r17,4
  801340:	00001b06 	br	8013b0 <disk_initialize+0x164>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
  801344:	01002a44 	movi	r4,169
  801348:	000b883a 	mov	r5,zero
  80134c:	08011100 	call	801110 <send_cmd>
  801350:	10803fcc 	andi	r2,r2,255
  801354:	80800336 	bltu	r16,r2,801364 <disk_initialize+0x118>
  801358:	04400084 	movi	r17,2
  80135c:	04bfea44 	movi	r18,-87
  801360:	00000206 	br	80136c <disk_initialize+0x120>
  801364:	8025883a 	mov	r18,r16
  801368:	8023883a 	mov	r17,r16
  80136c:	0400fa04 	movi	r16,1000
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
  801370:	91003fcc 	andi	r4,r18,255
  801374:	000b883a 	mov	r5,zero
  801378:	08011100 	call	801110 <send_cmd>
  80137c:	10803fcc 	andi	r2,r2,255
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
  801380:	843fffc4 	addi	r16,r16,-1
				if (send_cmd(cmd, 0) == 0) break;
				DLY_US(1000);
  801384:	0100fa04 	movi	r4,1000
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
  801388:	10000326 	beq	r2,zero,801398 <disk_initialize+0x14c>
				DLY_US(1000);
  80138c:	0800f100 	call	800f10 <dly_us>
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
  801390:	80000626 	beq	r16,zero,8013ac <disk_initialize+0x160>
  801394:	003ff606 	br	801370 <disk_initialize+0x124>
				if (send_cmd(cmd, 0) == 0) break;
				DLY_US(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
  801398:	01000404 	movi	r4,16
  80139c:	01408004 	movi	r5,512
  8013a0:	08011100 	call	801110 <send_cmd>
  8013a4:	10803fcc 	andi	r2,r2,255
  8013a8:	10000126 	beq	r2,zero,8013b0 <disk_initialize+0x164>
  8013ac:	0023883a 	mov	r17,zero
				ty = 0;
		}
	}
	CardType = ty;
	s = ty ? 0 : STA_NOINIT;
  8013b0:	88803fcc 	andi	r2,r17,255
  8013b4:	1005003a 	cmpeq	r2,r2,zero
  8013b8:	1021883a 	mov	r16,r2
	Stat = s;
  8013bc:	d0a00205 	stb	r2,-32760(gp)
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
  8013c0:	d466e805 	stb	r17,-25696(gp)
	s = ty ? 0 : STA_NOINIT;
	Stat = s;

	deselect();
  8013c4:	0800e700 	call	800e70 <deselect>

	return s;
  8013c8:	80803fcc 	andi	r2,r16,255
}
  8013cc:	dfc00417 	ldw	ra,16(sp)
  8013d0:	dc800317 	ldw	r18,12(sp)
  8013d4:	dc400217 	ldw	r17,8(sp)
  8013d8:	dc000117 	ldw	r16,4(sp)
  8013dc:	dec00504 	addi	sp,sp,20
  8013e0:	f800283a 	ret

008013e4 <disk_status>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
  8013e4:	defffd04 	addi	sp,sp,-12
	DSTATUS s;
	BYTE d;


	if (drv) return STA_NOINIT;
  8013e8:	21003fcc 	andi	r4,r4,255
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
  8013ec:	dfc00215 	stw	ra,8(sp)
  8013f0:	dc000115 	stw	r16,4(sp)
	DSTATUS s;
	BYTE d;


	if (drv) return STA_NOINIT;
  8013f4:	00800044 	movi	r2,1
  8013f8:	20000f1e 	bne	r4,zero,801438 <disk_status+0x54>

	/* Check if the card is kept initialized */
	s = Stat;
  8013fc:	d4200203 	ldbu	r16,-32760(gp)
	if (!(s & STA_NOINIT)) {
		if (send_cmd(CMD13, 0))	/* Read card status */
  801400:	01000344 	movi	r4,13
  801404:	000b883a 	mov	r5,zero

	if (drv) return STA_NOINIT;

	/* Check if the card is kept initialized */
	s = Stat;
	if (!(s & STA_NOINIT)) {
  801408:	8080004c 	andi	r2,r16,1
  80140c:	1000081e 	bne	r2,zero,801430 <disk_status+0x4c>
		if (send_cmd(CMD13, 0))	/* Read card status */
  801410:	08011100 	call	801110 <send_cmd>
  801414:	10803fcc 	andi	r2,r2,255
			s = STA_NOINIT;
		rcvr_mmc(&d, 1);		/* Receive following half of R2 */
  801418:	d809883a 	mov	r4,sp
  80141c:	01400044 	movi	r5,1
	if (drv) return STA_NOINIT;

	/* Check if the card is kept initialized */
	s = Stat;
	if (!(s & STA_NOINIT)) {
		if (send_cmd(CMD13, 0))	/* Read card status */
  801420:	10000126 	beq	r2,zero,801428 <disk_status+0x44>
  801424:	04000044 	movi	r16,1
			s = STA_NOINIT;
		rcvr_mmc(&d, 1);		/* Receive following half of R2 */
  801428:	0800df80 	call	800df8 <rcvr_mmc>
		deselect();
  80142c:	0800e700 	call	800e70 <deselect>
	}
	Stat = s;
  801430:	d4200205 	stb	r16,-32760(gp)

	return s;
  801434:	80803fcc 	andi	r2,r16,255
}
  801438:	dfc00217 	ldw	ra,8(sp)
  80143c:	dc000117 	ldw	r16,4(sp)
  801440:	dec00304 	addi	sp,sp,12
  801444:	f800283a 	ret

00801448 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
  801448:	defff804 	addi	sp,sp,-32
	DRESULT res;
	BYTE n, csd[16];
	WORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
  80144c:	21003fcc 	andi	r4,r4,255
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
  801450:	dc800615 	stw	r18,24(sp)
  801454:	dc000415 	stw	r16,16(sp)
  801458:	dfc00715 	stw	ra,28(sp)
  80145c:	dc400515 	stw	r17,20(sp)
  801460:	3025883a 	mov	r18,r6
  801464:	2821883a 	mov	r16,r5
	DRESULT res;
	BYTE n, csd[16];
	WORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
  801468:	08013e40 	call	8013e4 <disk_status>
  80146c:	1080004c 	andi	r2,r2,1
  801470:	1005003a 	cmpeq	r2,r2,zero
  801474:	00c00044 	movi	r3,1
  801478:	1000021e 	bne	r2,zero,801484 <disk_ioctl+0x3c>
  80147c:	040000c4 	movi	r16,3
  801480:	00004106 	br	801588 <disk_ioctl+0x140>

	res = RES_ERROR;
	switch (ctrl) {
  801484:	84403fcc 	andi	r17,r16,255
  801488:	88c00a26 	beq	r17,r3,8014b4 <disk_ioctl+0x6c>
  80148c:	88c00436 	bltu	r17,r3,8014a0 <disk_ioctl+0x58>
  801490:	008000c4 	movi	r2,3
  801494:	88803626 	beq	r17,r2,801570 <disk_ioctl+0x128>
  801498:	04000104 	movi	r16,4
  80149c:	00003906 	br	801584 <disk_ioctl+0x13c>
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) {
  8014a0:	08010c00 	call	8010c0 <select>
  8014a4:	10003626 	beq	r2,zero,801580 <disk_ioctl+0x138>
				deselect();
  8014a8:	0800e700 	call	800e70 <deselect>
  8014ac:	0021883a 	mov	r16,zero
  8014b0:	00003406 	br	801584 <disk_ioctl+0x13c>
				res = RES_OK;
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
  8014b4:	01000244 	movi	r4,9
  8014b8:	000b883a 	mov	r5,zero
  8014bc:	08011100 	call	801110 <send_cmd>
  8014c0:	10803fcc 	andi	r2,r2,255
  8014c4:	10002e1e 	bne	r2,zero,801580 <disk_ioctl+0x138>
  8014c8:	d809883a 	mov	r4,sp
  8014cc:	01400404 	movi	r5,16
  8014d0:	0800f500 	call	800f50 <rcvr_datablock>
  8014d4:	10002a26 	beq	r2,zero,801580 <disk_ioctl+0x138>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
  8014d8:	d8800003 	ldbu	r2,0(sp)
  8014dc:	1004d1ba 	srli	r2,r2,6
  8014e0:	1440091e 	bne	r2,r17,801508 <disk_ioctl+0xc0>
					cs= csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)cs << 10;
  8014e4:	d8800203 	ldbu	r2,8(sp)
  8014e8:	d8c00243 	ldbu	r3,9(sp)
  8014ec:	0021883a 	mov	r16,zero
  8014f0:	1004923a 	slli	r2,r2,8
  8014f4:	88c7883a 	add	r3,r17,r3
  8014f8:	10c5883a 	add	r2,r2,r3
  8014fc:	10bfffcc 	andi	r2,r2,65535
  801500:	100492ba 	slli	r2,r2,10
  801504:	00001c06 	br	801578 <disk_ioctl+0x130>
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = (DWORD)cs << (n - 9);
  801508:	d8c00203 	ldbu	r3,8(sp)
  80150c:	d88001c3 	ldbu	r2,7(sp)
  801510:	d9400183 	ldbu	r5,6(sp)
  801514:	1806d1ba 	srli	r3,r3,6
  801518:	1085883a 	add	r2,r2,r2
  80151c:	d9800283 	ldbu	r6,10(sp)
  801520:	d9000243 	ldbu	r4,9(sp)
  801524:	1085883a 	add	r2,r2,r2
  801528:	10c5883a 	add	r2,r2,r3
  80152c:	d8c00143 	ldbu	r3,5(sp)
  801530:	294000cc 	andi	r5,r5,3
  801534:	280a92ba 	slli	r5,r5,10
  801538:	210000cc 	andi	r4,r4,3
  80153c:	300cd1fa 	srli	r6,r6,7
  801540:	18c003cc 	andi	r3,r3,15
  801544:	2109883a 	add	r4,r4,r4
  801548:	1445883a 	add	r2,r2,r17
  80154c:	1907883a 	add	r3,r3,r4
  801550:	288b883a 	add	r5,r5,r2
  801554:	30cd883a 	add	r6,r6,r3
  801558:	297fffcc 	andi	r5,r5,65535
  80155c:	31bffe44 	addi	r6,r6,-7
  801560:	298a983a 	sll	r5,r5,r6
  801564:	0021883a 	mov	r16,zero
  801568:	91400015 	stw	r5,0(r18)
  80156c:	00000506 	br	801584 <disk_ioctl+0x13c>
				res = RES_OK;
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
  801570:	0021883a 	mov	r16,zero
  801574:	00802004 	movi	r2,128
  801578:	90800015 	stw	r2,0(r18)
  80157c:	00000106 	br	801584 <disk_ioctl+0x13c>
			res = RES_OK;
			break;
  801580:	04000044 	movi	r16,1

		default:
			res = RES_PARERR;
	}

	deselect();
  801584:	0800e700 	call	800e70 <deselect>

	return res;
}
  801588:	8005883a 	mov	r2,r16
  80158c:	dfc00717 	ldw	ra,28(sp)
  801590:	dc800617 	ldw	r18,24(sp)
  801594:	dc400517 	ldw	r17,20(sp)
  801598:	dc000417 	ldw	r16,16(sp)
  80159c:	dec00804 	addi	sp,sp,32
  8015a0:	f800283a 	ret

008015a4 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
  8015a4:	defffc04 	addi	sp,sp,-16
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
  8015a8:	21003fcc 	andi	r4,r4,255
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
  8015ac:	dc800215 	stw	r18,8(sp)
  8015b0:	dc400115 	stw	r17,4(sp)
  8015b4:	dc000015 	stw	r16,0(sp)
  8015b8:	dfc00315 	stw	ra,12(sp)
  8015bc:	2825883a 	mov	r18,r5
  8015c0:	3023883a 	mov	r17,r6
  8015c4:	3821883a 	mov	r16,r7
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
  8015c8:	08013e40 	call	8013e4 <disk_status>
  8015cc:	1080004c 	andi	r2,r2,1
  8015d0:	1005003a 	cmpeq	r2,r2,zero
  8015d4:	1000021e 	bne	r2,zero,8015e0 <disk_write+0x3c>
  8015d8:	008000c4 	movi	r2,3
  8015dc:	00002e06 	br	801698 <disk_write+0xf4>
	if (!count) return RES_PARERR;
  8015e0:	81403fcc 	andi	r5,r16,255
  8015e4:	2800021e 	bne	r5,zero,8015f0 <disk_write+0x4c>
  8015e8:	00800104 	movi	r2,4
  8015ec:	00002a06 	br	801698 <disk_write+0xf4>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
  8015f0:	d0e6e803 	ldbu	r3,-25696(gp)
  8015f4:	1880020c 	andi	r2,r3,8
  8015f8:	1000011e 	bne	r2,zero,801600 <disk_write+0x5c>
  8015fc:	8822927a 	slli	r17,r17,9

	if (count == 1) {	/* Single block write */
  801600:	00800044 	movi	r2,1
  801604:	28800b1e 	bne	r5,r2,801634 <disk_write+0x90>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
  801608:	880b883a 	mov	r5,r17
  80160c:	01000604 	movi	r4,24
  801610:	08011100 	call	801110 <send_cmd>
  801614:	10803fcc 	andi	r2,r2,255
  801618:	10001c1e 	bne	r2,zero,80168c <disk_write+0xe8>
  80161c:	9009883a 	mov	r4,r18
  801620:	01403f84 	movi	r5,254
  801624:	080102c0 	call	80102c <xmit_datablock>
  801628:	10001826 	beq	r2,zero,80168c <disk_write+0xe8>
  80162c:	0021883a 	mov	r16,zero
  801630:	00001606 	br	80168c <disk_write+0xe8>
			&& xmit_datablock(buff, 0xFE))
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
  801634:	1880018c 	andi	r2,r3,6
  801638:	10000226 	beq	r2,zero,801644 <disk_write+0xa0>
  80163c:	010025c4 	movi	r4,151
  801640:	08011100 	call	801110 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
  801644:	880b883a 	mov	r5,r17
  801648:	01000644 	movi	r4,25
  80164c:	08011100 	call	801110 <send_cmd>
  801650:	10803fcc 	andi	r2,r2,255
  801654:	10000d1e 	bne	r2,zero,80168c <disk_write+0xe8>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
  801658:	9009883a 	mov	r4,r18
  80165c:	01403f04 	movi	r5,252
				buff += 512;
  801660:	94808004 	addi	r18,r18,512
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
  801664:	080102c0 	call	80102c <xmit_datablock>
  801668:	10000326 	beq	r2,zero,801678 <disk_write+0xd4>
				buff += 512;
			} while (--count);
  80166c:	843fffc4 	addi	r16,r16,-1
  801670:	80803fcc 	andi	r2,r16,255
  801674:	103ff81e 	bne	r2,zero,801658 <disk_write+0xb4>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
  801678:	0009883a 	mov	r4,zero
  80167c:	01403f44 	movi	r5,253
  801680:	080102c0 	call	80102c <xmit_datablock>
  801684:	1000011e 	bne	r2,zero,80168c <disk_write+0xe8>
  801688:	04000044 	movi	r16,1
				count = 1;
		}
	}
	deselect();
  80168c:	0800e700 	call	800e70 <deselect>

	return count ? RES_ERROR : RES_OK;
  801690:	80803fcc 	andi	r2,r16,255
  801694:	1004c03a 	cmpne	r2,r2,zero
}
  801698:	dfc00317 	ldw	ra,12(sp)
  80169c:	dc800217 	ldw	r18,8(sp)
  8016a0:	dc400117 	ldw	r17,4(sp)
  8016a4:	dc000017 	ldw	r16,0(sp)
  8016a8:	dec00404 	addi	sp,sp,16
  8016ac:	f800283a 	ret

008016b0 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
  8016b0:	defffc04 	addi	sp,sp,-16
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
  8016b4:	21003fcc 	andi	r4,r4,255
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..128) */
)
{
  8016b8:	dc400215 	stw	r17,8(sp)
  8016bc:	dc000115 	stw	r16,4(sp)
  8016c0:	2823883a 	mov	r17,r5
  8016c4:	dfc00315 	stw	ra,12(sp)
  8016c8:	3821883a 	mov	r16,r7
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
  8016cc:	d9800015 	stw	r6,0(sp)
  8016d0:	08013e40 	call	8013e4 <disk_status>
  8016d4:	1080004c 	andi	r2,r2,1
  8016d8:	1005003a 	cmpeq	r2,r2,zero
  8016dc:	d9400017 	ldw	r5,0(sp)
  8016e0:	1000021e 	bne	r2,zero,8016ec <disk_read+0x3c>
  8016e4:	008000c4 	movi	r2,3
  8016e8:	00002606 	br	801784 <disk_read+0xd4>
	if (!count) return RES_PARERR;
  8016ec:	80c03fcc 	andi	r3,r16,255
  8016f0:	1800021e 	bne	r3,zero,8016fc <disk_read+0x4c>
  8016f4:	00800104 	movi	r2,4
  8016f8:	00002206 	br	801784 <disk_read+0xd4>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
  8016fc:	d0a6e803 	ldbu	r2,-25696(gp)
  801700:	1080020c 	andi	r2,r2,8
  801704:	1000011e 	bne	r2,zero,80170c <disk_read+0x5c>
  801708:	280a927a 	slli	r5,r5,9

	if (count == 1) {	/* Single block read */
  80170c:	00800044 	movi	r2,1
  801710:	18800a1e 	bne	r3,r2,80173c <disk_read+0x8c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
  801714:	01000444 	movi	r4,17
  801718:	08011100 	call	801110 <send_cmd>
  80171c:	10803fcc 	andi	r2,r2,255
  801720:	1000151e 	bne	r2,zero,801778 <disk_read+0xc8>
  801724:	8809883a 	mov	r4,r17
  801728:	01408004 	movi	r5,512
  80172c:	0800f500 	call	800f50 <rcvr_datablock>
  801730:	10001126 	beq	r2,zero,801778 <disk_read+0xc8>
  801734:	0021883a 	mov	r16,zero
  801738:	00000f06 	br	801778 <disk_read+0xc8>
			&& rcvr_datablock(buff, 512))
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
  80173c:	01000484 	movi	r4,18
  801740:	08011100 	call	801110 <send_cmd>
  801744:	10803fcc 	andi	r2,r2,255
  801748:	10000b1e 	bne	r2,zero,801778 <disk_read+0xc8>
			do {
				if (!rcvr_datablock(buff, 512)) break;
  80174c:	8809883a 	mov	r4,r17
  801750:	01408004 	movi	r5,512
				buff += 512;
  801754:	8c408004 	addi	r17,r17,512
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
			do {
				if (!rcvr_datablock(buff, 512)) break;
  801758:	0800f500 	call	800f50 <rcvr_datablock>
  80175c:	10000326 	beq	r2,zero,80176c <disk_read+0xbc>
				buff += 512;
			} while (--count);
  801760:	843fffc4 	addi	r16,r16,-1
  801764:	80803fcc 	andi	r2,r16,255
  801768:	103ff81e 	bne	r2,zero,80174c <disk_read+0x9c>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
  80176c:	01000304 	movi	r4,12
  801770:	000b883a 	mov	r5,zero
  801774:	08011100 	call	801110 <send_cmd>
		}
	}
	deselect();
  801778:	0800e700 	call	800e70 <deselect>

	return count ? RES_ERROR : RES_OK;
  80177c:	80803fcc 	andi	r2,r16,255
  801780:	1004c03a 	cmpne	r2,r2,zero
}
  801784:	dfc00317 	ldw	ra,12(sp)
  801788:	dc400217 	ldw	r17,8(sp)
  80178c:	dc000117 	ldw	r16,4(sp)
  801790:	dec00404 	addi	sp,sp,16
  801794:	f800283a 	ret

00801798 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
  801798:	00ffffc4 	movi	r3,-1
  80179c:	00000406 	br	8017b0 <mem_cpy+0x18>
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  8017a0:	28800003 	ldbu	r2,0(r5)
  8017a4:	29400044 	addi	r5,r5,1
  8017a8:	20800005 	stb	r2,0(r4)
  8017ac:	21000044 	addi	r4,r4,1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  8017b0:	31bfffc4 	addi	r6,r6,-1
  8017b4:	30fffa1e 	bne	r6,r3,8017a0 <mem_cpy+0x8>
		*d++ = *s++;
}
  8017b8:	f800283a 	ret

008017bc <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
  8017bc:	00bfffc4 	movi	r2,-1
  8017c0:	00000206 	br	8017cc <mem_set+0x10>
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  8017c4:	21400005 	stb	r5,0(r4)
  8017c8:	21000044 	addi	r4,r4,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  8017cc:	31bfffc4 	addi	r6,r6,-1
  8017d0:	30bffc1e 	bne	r6,r2,8017c4 <mem_set+0x8>
		*d++ = (BYTE)val;
}
  8017d4:	f800283a 	ret

008017d8 <clust2sect>:
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  8017d8:	20800717 	ldw	r2,28(r4)

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
  8017dc:	defffe04 	addi	sp,sp,-8
	clst -= 2;
  8017e0:	297fff84 	addi	r5,r5,-2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  8017e4:	10bfff84 	addi	r2,r2,-2

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
  8017e8:	dc000015 	stw	r16,0(sp)
  8017ec:	dfc00115 	stw	ra,4(sp)
  8017f0:	2021883a 	mov	r16,r4
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  8017f4:	0007883a 	mov	r3,zero
	return clst * fs->csize + fs->database;
  8017f8:	2809883a 	mov	r4,r5
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  8017fc:	2880042e 	bgeu	r5,r2,801810 <clust2sect+0x38>
	return clst * fs->csize + fs->database;
  801800:	81400083 	ldbu	r5,2(r16)
  801804:	08064840 	call	806484 <__mulsi3>
  801808:	80c00b17 	ldw	r3,44(r16)
  80180c:	10c7883a 	add	r3,r2,r3
}
  801810:	1805883a 	mov	r2,r3
  801814:	dfc00117 	ldw	ra,4(sp)
  801818:	dc000017 	ldw	r16,0(sp)
  80181c:	dec00204 	addi	sp,sp,8
  801820:	f800283a 	ret

00801824 <get_fileinfo>:
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
	if (dj->sect) {
  801824:	20800417 	ldw	r2,16(r4)
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
  801828:	2811883a 	mov	r8,r5
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
  80182c:	29c00244 	addi	r7,r5,9
	if (dj->sect) {
  801830:	10003826 	beq	r2,zero,801914 <get_fileinfo+0xf0>
		dir = dj->dir;
  801834:	21800517 	ldw	r6,20(r4)
  801838:	02c00804 	movi	r11,32
  80183c:	0009883a 	mov	r4,zero
  801840:	02800144 	movi	r10,5
  801844:	02400204 	movi	r9,8
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  801848:	3105883a 	add	r2,r6,r4
  80184c:	10800003 	ldbu	r2,0(r2)
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
  801850:	017ff944 	movi	r5,-27
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
  801854:	10c03fcc 	andi	r3,r2,255
  801858:	1ac00626 	beq	r3,r11,801874 <get_fileinfo+0x50>
			if (c == NDDE) c = (TCHAR)DDE;
  80185c:	1a800126 	beq	r3,r10,801864 <get_fileinfo+0x40>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
  801860:	100b883a 	mov	r5,r2

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  801864:	21000044 	addi	r4,r4,1
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
  801868:	39400005 	stb	r5,0(r7)
  80186c:	39c00044 	addi	r7,r7,1

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  801870:	227ff51e 	bne	r4,r9,801848 <get_fileinfo+0x24>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
  801874:	30800203 	ldbu	r2,8(r6)
  801878:	00c00804 	movi	r3,32
  80187c:	10c00e26 	beq	r2,r3,8018b8 <get_fileinfo+0x94>
			*p++ = '.';
  801880:	00800b84 	movi	r2,46
  801884:	1815883a 	mov	r10,r3
  801888:	38800005 	stb	r2,0(r7)
  80188c:	3a400104 	addi	r9,r7,4
  801890:	38c00044 	addi	r3,r7,1
  801894:	3009883a 	mov	r4,r6
			for (i = 8; i < 11; i++) {
				c = dir[i];
  801898:	21400203 	ldbu	r5,8(r4)
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
  80189c:	21000044 	addi	r4,r4,1
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
  8018a0:	28803fcc 	andi	r2,r5,255
  8018a4:	12800326 	beq	r2,r10,8018b4 <get_fileinfo+0x90>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
  8018a8:	19400005 	stb	r5,0(r3)
  8018ac:	18c00044 	addi	r3,r3,1
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
  8018b0:	1a7ff91e 	bne	r3,r9,801898 <get_fileinfo+0x74>
  8018b4:	180f883a 	mov	r7,r3
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  8018b8:	308002c3 	ldbu	r2,11(r6)
  8018bc:	40800205 	stb	r2,8(r8)
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  8018c0:	308007c3 	ldbu	r2,31(r6)
  8018c4:	31000783 	ldbu	r4,30(r6)
  8018c8:	30c00743 	ldbu	r3,29(r6)
  8018cc:	1004963a 	slli	r2,r2,24
  8018d0:	2008943a 	slli	r4,r4,16
  8018d4:	31400703 	ldbu	r5,28(r6)
  8018d8:	1806923a 	slli	r3,r3,8
  8018dc:	1104b03a 	or	r2,r2,r4
  8018e0:	1144b03a 	or	r2,r2,r5
  8018e4:	1886b03a 	or	r3,r3,r2
  8018e8:	40c00015 	stw	r3,0(r8)
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  8018ec:	30800643 	ldbu	r2,25(r6)
  8018f0:	30c00603 	ldbu	r3,24(r6)
  8018f4:	1004923a 	slli	r2,r2,8
  8018f8:	10c4b03a 	or	r2,r2,r3
  8018fc:	4080010d 	sth	r2,4(r8)
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  801900:	308005c3 	ldbu	r2,23(r6)
  801904:	30c00583 	ldbu	r3,22(r6)
  801908:	1004923a 	slli	r2,r2,8
  80190c:	10c4b03a 	or	r2,r2,r3
  801910:	4080018d 	sth	r2,6(r8)
	}
	*p = 0;		/* Terminate SFN str by a \0 */
  801914:	38000005 	stb	zero,0(r7)
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
  801918:	f800283a 	ret

0080191c <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  80191c:	21003fcc 	andi	r4,r4,255
  801920:	008002c4 	movi	r2,11
  801924:	2000071e 	bne	r4,zero,801944 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  801928:	d0e6e917 	ldw	r3,-25692(gp)
		fs->fs_type = 0;		/* Clear new fs object */
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  80192c:	0005883a 	mov	r2,zero

	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */

	if (rfs) {
  801930:	18000126 	beq	r3,zero,801938 <f_mount+0x1c>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  801934:	18000005 	stb	zero,0(r3)
	}

	if (fs) {
  801938:	28000126 	beq	r5,zero,801940 <f_mount+0x24>
		fs->fs_type = 0;		/* Clear new fs object */
  80193c:	28000005 	stb	zero,0(r5)
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  801940:	d166e915 	stw	r5,-25692(gp)

	return FR_OK;
}
  801944:	f800283a 	ret

00801948 <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
  801948:	21003fcc 	andi	r4,r4,255
  80194c:	008002c4 	movi	r2,11
  801950:	2000021e 	bne	r4,zero,80195c <f_chdrive+0x14>

	CurrVol = drv;
  801954:	d026ea85 	stb	zero,-25686(gp)
  801958:	0005883a 	mov	r2,zero

	return FR_OK;
}
  80195c:	f800283a 	ret

00801960 <get_fattime>:
			| ((DWORD)1 << 21)				/* Month = 1 */
			| ((DWORD)1 << 16)				/* Day_m = 1*/
			| ((DWORD)0 << 11)				/* Hour = 0 */
			| ((DWORD)0 << 5)				/* Min = 0 */
			| ((DWORD)0 >> 1);				/* Sec = 0 */
}
  801960:	00900874 	movhi	r2,16417
  801964:	f800283a 	ret

00801968 <decode_fres>:

/*	Function to decode File Results	*/
const char * decode_fres(FRESULT res){
	switch(res)	{
  801968:	008004c4 	movi	r2,19
  80196c:	11001e36 	bltu	r2,r4,8019e8 <decode_fres+0x80>
  801970:	2105883a 	add	r2,r4,r4
  801974:	1085883a 	add	r2,r2,r2
  801978:	00c02034 	movhi	r3,128
  80197c:	18c66304 	addi	r3,r3,6540
  801980:	10c5883a 	add	r2,r2,r3
  801984:	10800017 	ldw	r2,0(r2)
  801988:	1000683a 	jmp	r2
  80198c:	008019f4 	movhi	r2,103
  801990:	00801a00 	call	801a0 <__reset-0x77fe60>
  801994:	00801a0c 	andi	r2,zero,104
  801998:	00801a18 	cmpnei	r2,zero,104
  80199c:	00801a24 	muli	r2,zero,104
  8019a0:	00801a30 	cmpltui	r2,zero,104
  8019a4:	00801a3c 	xorhi	r2,zero,104
  8019a8:	00801a48 	cmpgei	r2,zero,105
  8019ac:	00801a54 	movui	r2,105
  8019b0:	00801a60 	cmpeqi	r2,zero,105
  8019b4:	00801a6c 	andhi	r2,zero,105
  8019b8:	00801a78 	rdprs	r2,zero,105
  8019bc:	00801a84 	movi	r2,106
  8019c0:	00801a90 	cmplti	r2,zero,106
  8019c4:	00801a9c 	xori	r2,zero,106
  8019c8:	00801aa8 	cmpgeui	r2,zero,106
  8019cc:	00801ab4 	movhi	r2,106
  8019d0:	00801ac0 	call	801ac <__reset-0x77fe54>
  8019d4:	00801acc 	andi	r2,zero,107
  8019d8:	008019dc 	xori	r2,zero,103
  8019dc:	00802074 	movhi	r2,129
  8019e0:	109dfa04 	addi	r2,r2,30696
  8019e4:	f800283a 	ret
  8019e8:	00802074 	movhi	r2,129
  8019ec:	109f0f04 	addi	r2,r2,31804
  8019f0:	f800283a 	ret
  8019f4:	00802074 	movhi	r2,129
  8019f8:	109d4304 	addi	r2,r2,29964
  8019fc:	f800283a 	ret
	case	FR_OK:
		return	"Succeeded";
  801a00:	00802074 	movhi	r2,129
  801a04:	109d4604 	addi	r2,r2,29976
  801a08:	f800283a 	ret
	case	FR_DISK_ERR:
		return	"A hard error occured in the low level disk I/O layer";
  801a0c:	00802074 	movhi	r2,129
  801a10:	109d5404 	addi	r2,r2,30032
  801a14:	f800283a 	ret
	case	FR_INT_ERR:
		return	"Assertion failed";
  801a18:	00802074 	movhi	r2,129
  801a1c:	109d5904 	addi	r2,r2,30052
  801a20:	f800283a 	ret
	case	FR_NOT_READY:
		return	"The physical drive cannot work";
  801a24:	00802074 	movhi	r2,129
  801a28:	109d6104 	addi	r2,r2,30084
  801a2c:	f800283a 	ret
	case	FR_NO_FILE:
		return	"Could not find the file";
  801a30:	00802074 	movhi	r2,129
  801a34:	109d6704 	addi	r2,r2,30108
  801a38:	f800283a 	ret
	case	FR_NO_PATH:
		return	"Could not find the path";
  801a3c:	00802074 	movhi	r2,129
  801a40:	109d6d04 	addi	r2,r2,30132
  801a44:	f800283a 	ret
	case	FR_INVALID_NAME:
		return	"The path name format is invalid";
  801a48:	00802074 	movhi	r2,129
  801a4c:	109d7504 	addi	r2,r2,30164
  801a50:	f800283a 	ret
	case	FR_DENIED:
		return	"Access denied due to prohibited access or directory full";
  801a54:	00802074 	movhi	r2,129
  801a58:	109d8404 	addi	r2,r2,30224
  801a5c:	f800283a 	ret
	case	FR_EXIST:
		return	"Access denied due to prohibited access";
  801a60:	00802074 	movhi	r2,129
  801a64:	109d8e04 	addi	r2,r2,30264
  801a68:	f800283a 	ret
	case	FR_INVALID_OBJECT:
		return	"The file/directory object is invalid";
  801a6c:	00802074 	movhi	r2,129
  801a70:	109d9804 	addi	r2,r2,30304
  801a74:	f800283a 	ret
	case	FR_WRITE_PROTECTED:
		return	"The physical drive is write protected";
  801a78:	00802074 	movhi	r2,129
  801a7c:	109da204 	addi	r2,r2,30344
  801a80:	f800283a 	ret
	case	FR_INVALID_DRIVE:
		return	"The logical drive number is invalid";
  801a84:	00802074 	movhi	r2,129
  801a88:	109dab04 	addi	r2,r2,30380
  801a8c:	f800283a 	ret
	case	FR_NOT_ENABLED:
		return	"The volume has no work area";
  801a90:	00802074 	movhi	r2,129
  801a94:	109db204 	addi	r2,r2,30408
  801a98:	f800283a 	ret
	case	FR_NO_FILESYSTEM:
		return	"There is no valid FAT volume";
  801a9c:	00802074 	movhi	r2,129
  801aa0:	109dba04 	addi	r2,r2,30440
  801aa4:	f800283a 	ret
	case	FR_MKFS_ABORTED:
		return	"f_mkfs() aborted due to any parameter error";
  801aa8:	00802074 	movhi	r2,129
  801aac:	109dc504 	addi	r2,r2,30484
  801ab0:	f800283a 	ret
	case	FR_TIMEOUT:
		return	"Could not get a grant to access the volume within defined period";
  801ab4:	00802074 	movhi	r2,129
  801ab8:	109dd604 	addi	r2,r2,30552
  801abc:	f800283a 	ret
	case	FR_LOCKED:
		return	"The operation is rejected according to the file sharing policy";
  801ac0:	00802074 	movhi	r2,129
  801ac4:	109de604 	addi	r2,r2,30616
  801ac8:	f800283a 	ret
	case	FR_NOT_ENOUGH_CORE:
		return	"LFN working buffer could not be allocated";
  801acc:	00802074 	movhi	r2,129
  801ad0:	109df104 	addi	r2,r2,30660
	case	FR_INVALID_PARAMETER:
		return	"Given parameter is invalid";
	}

	return "";
}
  801ad4:	f800283a 	ret

00801ad8 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  801ad8:	deffff04 	addi	sp,sp,-4
  801adc:	dfc00015 	stw	ra,0(sp)
	if (!fs || !fs->fs_type || fs->id != id)
  801ae0:	20000e26 	beq	r4,zero,801b1c <validate+0x44>
  801ae4:	20800003 	ldbu	r2,0(r4)
  801ae8:	297fffcc 	andi	r5,r5,65535
  801aec:	10000b26 	beq	r2,zero,801b1c <validate+0x44>
  801af0:	2080018b 	ldhu	r2,6(r4)
  801af4:	1140091e 	bne	r2,r5,801b1c <validate+0x44>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  801af8:	21000043 	ldbu	r4,1(r4)
  801afc:	08013e40 	call	8013e4 <disk_status>
  801b00:	1080004c 	andi	r2,r2,1
  801b04:	1005003a 	cmpeq	r2,r2,zero
  801b08:	1000021e 	bne	r2,zero,801b14 <validate+0x3c>
  801b0c:	008000c4 	movi	r2,3
  801b10:	00000306 	br	801b20 <validate+0x48>
  801b14:	0005883a 	mov	r2,zero
  801b18:	00000106 	br	801b20 <validate+0x48>
  801b1c:	00800244 	movi	r2,9
		return FR_NOT_READY;

	return FR_OK;
}
  801b20:	dfc00017 	ldw	ra,0(sp)
  801b24:	dec00104 	addi	sp,sp,4
  801b28:	f800283a 	ret

00801b2c <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  801b2c:	defffe04 	addi	sp,sp,-8
  801b30:	dc000015 	stw	r16,0(sp)
  801b34:	dfc00115 	stw	ra,4(sp)
  801b38:	2005883a 	mov	r2,r4
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  801b3c:	21000043 	ldbu	r4,1(r4)
  801b40:	14000d04 	addi	r16,r2,52
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  801b44:	280d883a 	mov	r6,r5
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  801b48:	01c00044 	movi	r7,1
  801b4c:	800b883a 	mov	r5,r16
  801b50:	08016b00 	call	8016b0 <disk_read>
  801b54:	010000c4 	movi	r4,3
  801b58:	1000271e 	bne	r2,zero,801bf8 <check_fs+0xcc>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  801b5c:	80807fc3 	ldbu	r2,511(r16)
  801b60:	80c07f83 	ldbu	r3,510(r16)
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  801b64:	01c04034 	movhi	r7,256
  801b68:	39ffffc4 	addi	r7,r7,-1
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  801b6c:	1004923a 	slli	r2,r2,8
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  801b70:	01801534 	movhi	r6,84
  801b74:	31905184 	addi	r6,r6,16710
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  801b78:	01000084 	movi	r4,2
  801b7c:	10c4b03a 	or	r2,r2,r3
  801b80:	10bfffcc 	andi	r2,r2,65535
  801b84:	10a0001c 	xori	r2,r2,32768
  801b88:	10a00004 	addi	r2,r2,-32768
  801b8c:	00ea9544 	movi	r3,-21931
  801b90:	10c0191e 	bne	r2,r3,801bf8 <check_fs+0xcc>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  801b94:	80800e43 	ldbu	r2,57(r16)
  801b98:	81000e03 	ldbu	r4,56(r16)
  801b9c:	80c00dc3 	ldbu	r3,55(r16)
  801ba0:	1004963a 	slli	r2,r2,24
  801ba4:	2008943a 	slli	r4,r4,16
  801ba8:	81400d83 	ldbu	r5,54(r16)
  801bac:	1806923a 	slli	r3,r3,8
  801bb0:	1104b03a 	or	r2,r2,r4
  801bb4:	1144b03a 	or	r2,r2,r5
  801bb8:	1886b03a 	or	r3,r3,r2
  801bbc:	19c6703a 	and	r3,r3,r7
  801bc0:	0009883a 	mov	r4,zero
  801bc4:	19800c26 	beq	r3,r6,801bf8 <check_fs+0xcc>
  801bc8:	80801543 	ldbu	r2,85(r16)
  801bcc:	81001503 	ldbu	r4,84(r16)
  801bd0:	80c014c3 	ldbu	r3,83(r16)
  801bd4:	1004963a 	slli	r2,r2,24
  801bd8:	2008943a 	slli	r4,r4,16
  801bdc:	81401483 	ldbu	r5,82(r16)
  801be0:	1806923a 	slli	r3,r3,8
  801be4:	1104b03a 	or	r2,r2,r4
  801be8:	1144b03a 	or	r2,r2,r5
  801bec:	1886b03a 	or	r3,r3,r2
  801bf0:	19c6703a 	and	r3,r3,r7
  801bf4:	1988c03a 	cmpne	r4,r3,r6
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  801bf8:	2005883a 	mov	r2,r4
  801bfc:	dfc00117 	ldw	ra,4(sp)
  801c00:	dc000017 	ldw	r16,0(sp)
  801c04:	dec00204 	addi	sp,sp,8
  801c08:	f800283a 	ret

00801c0c <chk_mounted>:
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  801c0c:	21c00017 	ldw	r7,0(r4)
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  801c10:	defff804 	addi	sp,sp,-32
  801c14:	dc000015 	stw	r16,0(sp)
  801c18:	dfc00715 	stw	ra,28(sp)
  801c1c:	dd800615 	stw	r22,24(sp)
  801c20:	dd400515 	stw	r21,20(sp)
  801c24:	dd000415 	stw	r20,16(sp)
  801c28:	dcc00315 	stw	r19,12(sp)
  801c2c:	dc800215 	stw	r18,8(sp)
  801c30:	dc400115 	stw	r17,4(sp)
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  801c34:	38800007 	ldb	r2,0(r7)
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  801c38:	3021883a 	mov	r16,r6
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  801c3c:	11bff404 	addi	r6,r2,-48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  801c40:	00800244 	movi	r2,9
  801c44:	11800636 	bltu	r2,r6,801c60 <chk_mounted+0x54>
  801c48:	38c00047 	ldb	r3,1(r7)
  801c4c:	00800e84 	movi	r2,58
  801c50:	1880031e 	bne	r3,r2,801c60 <chk_mounted+0x54>
		p += 2; *path = p;				/* Return pointer to the path name */
  801c54:	38800084 	addi	r2,r7,2
  801c58:	20800015 	stw	r2,0(r4)
  801c5c:	00000106 	br	801c64 <chk_mounted+0x58>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
  801c60:	d1a6ea83 	ldbu	r6,-25686(gp)
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  801c64:	30000226 	beq	r6,zero,801c70 <chk_mounted+0x64>
  801c68:	00c002c4 	movi	r3,11
  801c6c:	00013206 	br	802138 <chk_mounted+0x52c>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  801c70:	d466e917 	ldw	r17,-25692(gp)
  801c74:	2c400015 	stw	r17,0(r5)
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  801c78:	8800021e 	bne	r17,zero,801c84 <chk_mounted+0x78>
  801c7c:	00c00304 	movi	r3,12
  801c80:	00012d06 	br	802138 <chk_mounted+0x52c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  801c84:	88800003 	ldbu	r2,0(r17)
  801c88:	10000a26 	beq	r2,zero,801cb4 <chk_mounted+0xa8>
		stat = disk_status(fs->drv);
  801c8c:	89000043 	ldbu	r4,1(r17)
  801c90:	08013e40 	call	8013e4 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  801c94:	10c03fcc 	andi	r3,r2,255
  801c98:	1880004c 	andi	r2,r3,1
  801c9c:	1000051e 	bne	r2,zero,801cb4 <chk_mounted+0xa8>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  801ca0:	80803fcc 	andi	r2,r16,255
  801ca4:	10011726 	beq	r2,zero,802104 <chk_mounted+0x4f8>
  801ca8:	1880010c 	andi	r2,r3,4
  801cac:	1001131e 	bne	r2,zero,8020fc <chk_mounted+0x4f0>
  801cb0:	00011406 	br	802104 <chk_mounted+0x4f8>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  801cb4:	88000005 	stb	zero,0(r17)
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  801cb8:	88000045 	stb	zero,1(r17)
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  801cbc:	0009883a 	mov	r4,zero
  801cc0:	080124c0 	call	80124c <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  801cc4:	10c03fcc 	andi	r3,r2,255
  801cc8:	1880004c 	andi	r2,r3,1
  801ccc:	1005003a 	cmpeq	r2,r2,zero
  801cd0:	1000021e 	bne	r2,zero,801cdc <chk_mounted+0xd0>
  801cd4:	00c000c4 	movi	r3,3
  801cd8:	00011706 	br	802138 <chk_mounted+0x52c>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  801cdc:	80803fcc 	andi	r2,r16,255
  801ce0:	10000226 	beq	r2,zero,801cec <chk_mounted+0xe0>
  801ce4:	1880010c 	andi	r2,r3,4
  801ce8:	1001041e 	bne	r2,zero,8020fc <chk_mounted+0x4f0>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  801cec:	8809883a 	mov	r4,r17
  801cf0:	000b883a 	mov	r5,zero
  801cf4:	0801b2c0 	call	801b2c <check_fs>
  801cf8:	1009883a 	mov	r4,r2
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  801cfc:	10c03fcc 	andi	r3,r2,255
  801d00:	00800044 	movi	r2,1
  801d04:	18800226 	beq	r3,r2,801d10 <chk_mounted+0x104>
  801d08:	002d883a 	mov	r22,zero
  801d0c:	00001106 	br	801d54 <chk_mounted+0x148>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
  801d10:	89407c84 	addi	r5,r17,498
		if (tbl[4]) {						/* Is the partition existing? */
  801d14:	28800103 	ldbu	r2,4(r5)
  801d18:	1000fc26 	beq	r2,zero,80210c <chk_mounted+0x500>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  801d1c:	288002c3 	ldbu	r2,11(r5)
  801d20:	28c00283 	ldbu	r3,10(r5)
  801d24:	29000243 	ldbu	r4,9(r5)
  801d28:	1004963a 	slli	r2,r2,24
  801d2c:	1806943a 	slli	r3,r3,16
  801d30:	29400203 	ldbu	r5,8(r5)
  801d34:	2008923a 	slli	r4,r4,8
  801d38:	10c4b03a 	or	r2,r2,r3
  801d3c:	1144b03a 	or	r2,r2,r5
  801d40:	20acb03a 	or	r22,r4,r2
			fmt = check_fs(fs, bsect);		/* Check the partition */
  801d44:	b00b883a 	mov	r5,r22
  801d48:	8809883a 	mov	r4,r17
  801d4c:	0801b2c0 	call	801b2c <check_fs>
  801d50:	1009883a 	mov	r4,r2
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  801d54:	20c03fcc 	andi	r3,r4,255
  801d58:	008000c4 	movi	r2,3
  801d5c:	1880021e 	bne	r3,r2,801d68 <chk_mounted+0x15c>
  801d60:	00c00044 	movi	r3,1
  801d64:	0000f406 	br	802138 <chk_mounted+0x52c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  801d68:	1800e81e 	bne	r3,zero,80210c <chk_mounted+0x500>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  801d6c:	8c000d04 	addi	r16,r17,52
  801d70:	80800303 	ldbu	r2,12(r16)
  801d74:	80c002c3 	ldbu	r3,11(r16)
  801d78:	1004923a 	slli	r2,r2,8
  801d7c:	10c4b03a 	or	r2,r2,r3
  801d80:	10bfffcc 	andi	r2,r2,65535
  801d84:	10a0001c 	xori	r2,r2,32768
  801d88:	10a00004 	addi	r2,r2,-32768
  801d8c:	00c08004 	movi	r3,512
  801d90:	10c0de1e 	bne	r2,r3,80210c <chk_mounted+0x500>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  801d94:	808005c3 	ldbu	r2,23(r16)
  801d98:	80c00583 	ldbu	r3,22(r16)
  801d9c:	1004923a 	slli	r2,r2,8
  801da0:	10c8b03a 	or	r4,r2,r3
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  801da4:	20bfffcc 	andi	r2,r4,65535
  801da8:	10a0001c 	xori	r2,r2,32768
  801dac:	10a00004 	addi	r2,r2,-32768
  801db0:	10000226 	beq	r2,zero,801dbc <chk_mounted+0x1b0>
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  801db4:	21ffffcc 	andi	r7,r4,65535
  801db8:	00000a06 	br	801de4 <chk_mounted+0x1d8>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  801dbc:	808009c3 	ldbu	r2,39(r16)
  801dc0:	80c00983 	ldbu	r3,38(r16)
  801dc4:	81000943 	ldbu	r4,37(r16)
  801dc8:	1004963a 	slli	r2,r2,24
  801dcc:	1806943a 	slli	r3,r3,16
  801dd0:	81400903 	ldbu	r5,36(r16)
  801dd4:	2008923a 	slli	r4,r4,8
  801dd8:	10c4b03a 	or	r2,r2,r3
  801ddc:	1144b03a 	or	r2,r2,r5
  801de0:	208eb03a 	or	r7,r4,r2
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  801de4:	89801103 	ldbu	r6,68(r17)
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  801de8:	00c00044 	movi	r3,1
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  801dec:	89c00815 	stw	r7,32(r17)

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  801df0:	30bfffc4 	addi	r2,r6,-1
  801df4:	10803fcc 	andi	r2,r2,255

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  801df8:	898000c5 	stb	r6,3(r17)
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  801dfc:	1880c336 	bltu	r3,r2,80210c <chk_mounted+0x500>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  801e00:	88801043 	ldbu	r2,65(r17)
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  801e04:	1007883a 	mov	r3,r2

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  801e08:	88800085 	stb	r2,2(r17)
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  801e0c:	1000bf26 	beq	r2,zero,80210c <chk_mounted+0x500>
  801e10:	10bfffc4 	addi	r2,r2,-1
  801e14:	1884703a 	and	r2,r3,r2
  801e18:	1000bc1e 	bne	r2,zero,80210c <chk_mounted+0x500>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  801e1c:	80800483 	ldbu	r2,18(r16)
  801e20:	80c00443 	ldbu	r3,17(r16)
  801e24:	1004923a 	slli	r2,r2,8
  801e28:	10c4b03a 	or	r2,r2,r3
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  801e2c:	10c003cc 	andi	r3,r2,15
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  801e30:	1029883a 	mov	r20,r2
  801e34:	8880020d 	sth	r2,8(r17)
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  801e38:	1800b41e 	bne	r3,zero,80210c <chk_mounted+0x500>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  801e3c:	80800503 	ldbu	r2,20(r16)
  801e40:	80c004c3 	ldbu	r3,19(r16)
  801e44:	1004923a 	slli	r2,r2,8
  801e48:	10c8b03a 	or	r4,r2,r3
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  801e4c:	20bfffcc 	andi	r2,r4,65535
  801e50:	10a0001c 	xori	r2,r2,32768
  801e54:	10a00004 	addi	r2,r2,-32768
  801e58:	10000226 	beq	r2,zero,801e64 <chk_mounted+0x258>
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  801e5c:	24ffffcc 	andi	r19,r4,65535
  801e60:	00000a06 	br	801e8c <chk_mounted+0x280>
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  801e64:	808008c3 	ldbu	r2,35(r16)
  801e68:	80c00883 	ldbu	r3,34(r16)
  801e6c:	81000843 	ldbu	r4,33(r16)
  801e70:	1004963a 	slli	r2,r2,24
  801e74:	1806943a 	slli	r3,r3,16
  801e78:	81400803 	ldbu	r5,32(r16)
  801e7c:	2008923a 	slli	r4,r4,8
  801e80:	10c4b03a 	or	r2,r2,r3
  801e84:	1144b03a 	or	r2,r2,r5
  801e88:	20a6b03a 	or	r19,r4,r2

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  801e8c:	808003c3 	ldbu	r2,15(r16)
  801e90:	80c00383 	ldbu	r3,14(r16)
  801e94:	1004923a 	slli	r2,r2,8
  801e98:	10e4b03a 	or	r18,r2,r3
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  801e9c:	90bfffcc 	andi	r2,r18,65535
  801ea0:	10a0001c 	xori	r2,r2,32768
  801ea4:	10a00004 	addi	r2,r2,-32768
  801ea8:	10009826 	beq	r2,zero,80210c <chk_mounted+0x500>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  801eac:	3809883a 	mov	r4,r7
  801eb0:	31403fcc 	andi	r5,r6,255
  801eb4:	08064840 	call	806484 <__mulsi3>
  801eb8:	102b883a 	mov	r21,r2

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  801ebc:	a0bfffcc 	andi	r2,r20,65535
  801ec0:	1004d13a 	srli	r2,r2,4
  801ec4:	953fffcc 	andi	r20,r18,65535
  801ec8:	a085883a 	add	r2,r20,r2
  801ecc:	a8a5883a 	add	r18,r21,r2
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  801ed0:	9c808e36 	bltu	r19,r18,80210c <chk_mounted+0x500>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  801ed4:	89400083 	ldbu	r5,2(r17)
  801ed8:	9c89c83a 	sub	r4,r19,r18
  801edc:	08064740 	call	806474 <__udivsi3>
  801ee0:	1009883a 	mov	r4,r2
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  801ee4:	10008926 	beq	r2,zero,80210c <chk_mounted+0x500>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  801ee8:	0083fd44 	movi	r2,4085
  801eec:	11000236 	bltu	r2,r4,801ef8 <chk_mounted+0x2ec>
  801ef0:	04c00044 	movi	r19,1
  801ef4:	00000306 	br	801f04 <chk_mounted+0x2f8>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  801ef8:	00bffd54 	movui	r2,65525
  801efc:	11008536 	bltu	r2,r4,802114 <chk_mounted+0x508>
  801f00:	04c00084 	movi	r19,2
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  801f04:	88c0020b 	ldhu	r3,8(r17)
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  801f08:	21400084 	addi	r5,r4,2
	fs->database = bsect + sysect;						/* Data start sector */
  801f0c:	b485883a 	add	r2,r22,r18
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  801f10:	b509883a 	add	r4,r22,r20
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
  801f14:	88800b15 	stw	r2,44(r17)
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  801f18:	89400715 	stw	r5,28(r17)
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  801f1c:	89000915 	stw	r4,36(r17)
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  801f20:	1800111e 	bne	r3,zero,801f68 <chk_mounted+0x35c>
  801f24:	00007906 	br	80210c <chk_mounted+0x500>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  801f28:	80800bc3 	ldbu	r2,47(r16)
  801f2c:	81000b83 	ldbu	r4,46(r16)
  801f30:	81400b43 	ldbu	r5,45(r16)
  801f34:	1004963a 	slli	r2,r2,24
  801f38:	2008943a 	slli	r4,r4,16
  801f3c:	81800b03 	ldbu	r6,44(r16)
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  801f40:	88c00717 	ldw	r3,28(r17)
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  801f44:	280a923a 	slli	r5,r5,8
  801f48:	1104b03a 	or	r2,r2,r4
  801f4c:	1184b03a 	or	r2,r2,r6
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  801f50:	18c7883a 	add	r3,r3,r3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  801f54:	288ab03a 	or	r5,r5,r2
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  801f58:	04c000c4 	movi	r19,3
  801f5c:	18c5883a 	add	r2,r3,r3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  801f60:	89400a15 	stw	r5,40(r17)
  801f64:	00000c06 	br	801f98 <chk_mounted+0x38c>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  801f68:	2545883a 	add	r2,r4,r21
  801f6c:	88800a15 	stw	r2,40(r17)
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
  801f70:	98c03fcc 	andi	r3,r19,255
  801f74:	00800084 	movi	r2,2
  801f78:	1880021e 	bne	r3,r2,801f84 <chk_mounted+0x378>
  801f7c:	2945883a 	add	r2,r5,r5
  801f80:	00000506 	br	801f98 <chk_mounted+0x38c>
  801f84:	2945883a 	add	r2,r5,r5
  801f88:	1145883a 	add	r2,r2,r5
  801f8c:	1004d07a 	srli	r2,r2,1
  801f90:	28c0004c 	andi	r3,r5,1
  801f94:	10c5883a 	add	r2,r2,r3
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  801f98:	10807fc4 	addi	r2,r2,511
  801f9c:	1004d27a 	srli	r2,r2,9
  801fa0:	88c00817 	ldw	r3,32(r17)
  801fa4:	18805936 	bltu	r3,r2,80210c <chk_mounted+0x500>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  801fa8:	00ffffc4 	movi	r3,-1
  801fac:	88c00415 	stw	r3,16(r17)
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  801fb0:	98803fcc 	andi	r2,r19,255
  801fb4:	00c000c4 	movi	r3,3
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;
  801fb8:	88000315 	stw	zero,12(r17)

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  801fbc:	10c0451e 	bne	r2,r3,8020d4 <chk_mounted+0x4c8>
	 	fs->fsi_flag = 0;
  801fc0:	88000145 	stb	zero,5(r17)
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  801fc4:	81800c43 	ldbu	r6,49(r16)
  801fc8:	80800c03 	ldbu	r2,48(r16)
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  801fcc:	89000043 	ldbu	r4,1(r17)
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  801fd0:	300c923a 	slli	r6,r6,8
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  801fd4:	800b883a 	mov	r5,r16
  801fd8:	01c00044 	movi	r7,1
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  801fdc:	308cb03a 	or	r6,r6,r2
  801fe0:	b18d883a 	add	r6,r22,r6
  801fe4:	89800515 	stw	r6,20(r17)
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  801fe8:	08016b00 	call	8016b0 <disk_read>
  801fec:	1000391e 	bne	r2,zero,8020d4 <chk_mounted+0x4c8>
  801ff0:	80807fc3 	ldbu	r2,511(r16)
  801ff4:	80c07f83 	ldbu	r3,510(r16)
  801ff8:	1004923a 	slli	r2,r2,8
  801ffc:	10c4b03a 	or	r2,r2,r3
  802000:	10bfffcc 	andi	r2,r2,65535
  802004:	10a0001c 	xori	r2,r2,32768
  802008:	10a00004 	addi	r2,r2,-32768
  80200c:	00ea9544 	movi	r3,-21931
  802010:	10c0301e 	bne	r2,r3,8020d4 <chk_mounted+0x4c8>
  802014:	808000c3 	ldbu	r2,3(r16)
  802018:	80c00083 	ldbu	r3,2(r16)
  80201c:	81000043 	ldbu	r4,1(r16)
  802020:	1004963a 	slli	r2,r2,24
  802024:	1806943a 	slli	r3,r3,16
  802028:	89400d03 	ldbu	r5,52(r17)
  80202c:	2008923a 	slli	r4,r4,8
  802030:	10c4b03a 	or	r2,r2,r3
  802034:	1144b03a 	or	r2,r2,r5
  802038:	2088b03a 	or	r4,r4,r2
  80203c:	00905874 	movhi	r2,16737
  802040:	10949484 	addi	r2,r2,21074
  802044:	2080231e 	bne	r4,r2,8020d4 <chk_mounted+0x4c8>
  802048:	808079c3 	ldbu	r2,487(r16)
  80204c:	80c07983 	ldbu	r3,486(r16)
  802050:	81007943 	ldbu	r4,485(r16)
  802054:	1004963a 	slli	r2,r2,24
  802058:	1806943a 	slli	r3,r3,16
  80205c:	81407903 	ldbu	r5,484(r16)
  802060:	2008923a 	slli	r4,r4,8
  802064:	10c4b03a 	or	r2,r2,r3
  802068:	1144b03a 	or	r2,r2,r5
  80206c:	2088b03a 	or	r4,r4,r2
  802070:	00985074 	movhi	r2,24897
  802074:	109c9c84 	addi	r2,r2,29298
  802078:	2080161e 	bne	r4,r2,8020d4 <chk_mounted+0x4c8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  80207c:	80807bc3 	ldbu	r2,495(r16)
  802080:	81007b83 	ldbu	r4,494(r16)
  802084:	80c07b43 	ldbu	r3,493(r16)
  802088:	1004963a 	slli	r2,r2,24
  80208c:	2008943a 	slli	r4,r4,16
  802090:	81407b03 	ldbu	r5,492(r16)
  802094:	1806923a 	slli	r3,r3,8
  802098:	1104b03a 	or	r2,r2,r4
  80209c:	1144b03a 	or	r2,r2,r5
  8020a0:	1886b03a 	or	r3,r3,r2
  8020a4:	88c00315 	stw	r3,12(r17)
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  8020a8:	80807ac3 	ldbu	r2,491(r16)
  8020ac:	81007a83 	ldbu	r4,490(r16)
  8020b0:	80c07a43 	ldbu	r3,489(r16)
  8020b4:	1004963a 	slli	r2,r2,24
  8020b8:	2008943a 	slli	r4,r4,16
  8020bc:	81407a03 	ldbu	r5,488(r16)
  8020c0:	1806923a 	slli	r3,r3,8
  8020c4:	1104b03a 	or	r2,r2,r4
  8020c8:	1144b03a 	or	r2,r2,r5
  8020cc:	1886b03a 	or	r3,r3,r2
  8020d0:	88c00415 	stw	r3,16(r17)
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  8020d4:	8cc00005 	stb	r19,0(r17)
	fs->id = ++Fsid;		/* File system mount ID */
  8020d8:	d0a6ea0b 	ldhu	r2,-25688(gp)
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
  8020dc:	0007883a 	mov	r3,zero
  8020e0:	88000615 	stw	zero,24(r17)
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  8020e4:	10800044 	addi	r2,r2,1
  8020e8:	d0a6ea0d 	sth	r2,-25688(gp)
  8020ec:	8880018d 	sth	r2,6(r17)
	fs->winsect = 0;		/* Invalidate sector cache */
  8020f0:	88000c15 	stw	zero,48(r17)
	fs->wflag = 0;
  8020f4:	88000105 	stb	zero,4(r17)
  8020f8:	00000f06 	br	802138 <chk_mounted+0x52c>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  8020fc:	00c00284 	movi	r3,10
  802100:	00000d06 	br	802138 <chk_mounted+0x52c>
  802104:	0007883a 	mov	r3,zero
  802108:	00000b06 	br	802138 <chk_mounted+0x52c>
  80210c:	00c00344 	movi	r3,13
  802110:	00000906 	br	802138 <chk_mounted+0x52c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  802114:	8940020b 	ldhu	r5,8(r17)
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  802118:	20800084 	addi	r2,r4,2
	fs->database = bsect + sysect;						/* Data start sector */
  80211c:	b487883a 	add	r3,r22,r18
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  802120:	b509883a 	add	r4,r22,r20
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  802124:	88800715 	stw	r2,28(r17)
	fs->database = bsect + sysect;						/* Data start sector */
  802128:	88c00b15 	stw	r3,44(r17)
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  80212c:	89000915 	stw	r4,36(r17)
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  802130:	283ff61e 	bne	r5,zero,80210c <chk_mounted+0x500>
  802134:	003f7c06 	br	801f28 <chk_mounted+0x31c>
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
  802138:	1805883a 	mov	r2,r3
  80213c:	dfc00717 	ldw	ra,28(sp)
  802140:	dd800617 	ldw	r22,24(sp)
  802144:	dd400517 	ldw	r21,20(sp)
  802148:	dd000417 	ldw	r20,16(sp)
  80214c:	dcc00317 	ldw	r19,12(sp)
  802150:	dc800217 	ldw	r18,8(sp)
  802154:	dc400117 	ldw	r17,4(sp)
  802158:	dc000017 	ldw	r16,0(sp)
  80215c:	dec00804 	addi	sp,sp,32
  802160:	f800283a 	ret

00802164 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  802164:	defffa04 	addi	sp,sp,-24
  802168:	dc800215 	stw	r18,8(sp)
	DWORD wsect;


	wsect = fs->winsect;
  80216c:	24800c17 	ldw	r18,48(r4)
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  802170:	dcc00315 	stw	r19,12(sp)
  802174:	dc000015 	stw	r16,0(sp)
  802178:	dfc00515 	stw	ra,20(sp)
  80217c:	dd000415 	stw	r20,16(sp)
  802180:	dc400115 	stw	r17,4(sp)
  802184:	2021883a 	mov	r16,r4
  802188:	2827883a 	mov	r19,r5
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  80218c:	91402626 	beq	r18,r5,802228 <move_window+0xc4>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  802190:	20800103 	ldbu	r2,4(r4)
  802194:	10001926 	beq	r2,zero,8021fc <move_window+0x98>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  802198:	21000043 	ldbu	r4,1(r4)
  80219c:	85000d04 	addi	r20,r16,52
  8021a0:	a00b883a 	mov	r5,r20
  8021a4:	900d883a 	mov	r6,r18
  8021a8:	01c00044 	movi	r7,1
  8021ac:	08015a40 	call	8015a4 <disk_write>
  8021b0:	10001b1e 	bne	r2,zero,802220 <move_window+0xbc>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  8021b4:	80800917 	ldw	r2,36(r16)
  8021b8:	80c00817 	ldw	r3,32(r16)
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  8021bc:	80000105 	stb	zero,4(r16)
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  8021c0:	10c5883a 	add	r2,r2,r3
  8021c4:	90800d2e 	bgeu	r18,r2,8021fc <move_window+0x98>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  8021c8:	844000c3 	ldbu	r17,3(r16)
  8021cc:	00000506 	br	8021e4 <move_window+0x80>
					wsect += fs->fsize;
  8021d0:	80800817 	ldw	r2,32(r16)
					disk_write(fs->drv, fs->win, wsect, 1);
  8021d4:	81000043 	ldbu	r4,1(r16)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
  8021d8:	90a5883a 	add	r18,r18,r2
					disk_write(fs->drv, fs->win, wsect, 1);
  8021dc:	900d883a 	mov	r6,r18
  8021e0:	08015a40 	call	8015a4 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  8021e4:	88c03fcc 	andi	r3,r17,255
  8021e8:	00800044 	movi	r2,1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  8021ec:	a00b883a 	mov	r5,r20
  8021f0:	100f883a 	mov	r7,r2
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  8021f4:	8c7fffc4 	addi	r17,r17,-1
  8021f8:	10fff536 	bltu	r2,r3,8021d0 <move_window+0x6c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  8021fc:	98000a26 	beq	r19,zero,802228 <move_window+0xc4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  802200:	81000043 	ldbu	r4,1(r16)
  802204:	81400d04 	addi	r5,r16,52
  802208:	980d883a 	mov	r6,r19
  80220c:	01c00044 	movi	r7,1
  802210:	08016b00 	call	8016b0 <disk_read>
  802214:	1000021e 	bne	r2,zero,802220 <move_window+0xbc>
				return FR_DISK_ERR;
			fs->winsect = sector;
  802218:	84c00c15 	stw	r19,48(r16)
  80221c:	00000306 	br	80222c <move_window+0xc8>
  802220:	00800044 	movi	r2,1
  802224:	00000106 	br	80222c <move_window+0xc8>
  802228:	0005883a 	mov	r2,zero
		}
	}

	return FR_OK;
}
  80222c:	dfc00517 	ldw	ra,20(sp)
  802230:	dd000417 	ldw	r20,16(sp)
  802234:	dcc00317 	ldw	r19,12(sp)
  802238:	dc800217 	ldw	r18,8(sp)
  80223c:	dc400117 	ldw	r17,4(sp)
  802240:	dc000017 	ldw	r16,0(sp)
  802244:	dec00604 	addi	sp,sp,24
  802248:	f800283a 	ret

0080224c <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
  80224c:	defff904 	addi	sp,sp,-28
  802250:	dc000015 	stw	r16,0(sp)
  802254:	2821883a 	mov	r16,r5
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  802258:	01400044 	movi	r5,1
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
  80225c:	dd000415 	stw	r20,16(sp)
  802260:	dc800215 	stw	r18,8(sp)
  802264:	dfc00615 	stw	ra,24(sp)
  802268:	dd400515 	stw	r21,20(sp)
  80226c:	dcc00315 	stw	r19,12(sp)
  802270:	dc400115 	stw	r17,4(sp)
  802274:	3029883a 	mov	r20,r6
  802278:	2025883a 	mov	r18,r4
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  80227c:	2c005e2e 	bgeu	r5,r16,8023f8 <put_fat+0x1ac>
  802280:	20800717 	ldw	r2,28(r4)
  802284:	80805c2e 	bgeu	r16,r2,8023f8 <put_fat+0x1ac>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  802288:	24400003 	ldbu	r17,0(r4)
  80228c:	00c00084 	movi	r3,2
  802290:	88c03126 	beq	r17,r3,802358 <put_fat+0x10c>
  802294:	008000c4 	movi	r2,3
  802298:	88803d26 	beq	r17,r2,802390 <put_fat+0x144>
  80229c:	89400226 	beq	r17,r5,8022a8 <put_fat+0x5c>
  8022a0:	1811883a 	mov	r8,r3
  8022a4:	00005106 	br	8023ec <put_fat+0x1a0>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  8022a8:	8004d07a 	srli	r2,r16,1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  8022ac:	20c00917 	ldw	r3,36(r4)
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  8022b0:	80a7883a 	add	r19,r16,r2
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  8022b4:	980ad27a 	srli	r5,r19,9
  8022b8:	28cb883a 	add	r5,r5,r3
  8022bc:	08021640 	call	802164 <move_window>
  8022c0:	1011883a 	mov	r8,r2
			if (res != FR_OK) break;
  8022c4:	1000491e 	bne	r2,zero,8023ec <put_fat+0x1a0>
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  8022c8:	846a703a 	and	r21,r16,r17
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
  8022cc:	98807fcc 	andi	r2,r19,511
  8022d0:	94400d04 	addi	r17,r18,52
  8022d4:	8889883a 	add	r4,r17,r2
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  8022d8:	a8000626 	beq	r21,zero,8022f4 <put_fat+0xa8>
  8022dc:	20c00003 	ldbu	r3,0(r4)
  8022e0:	a0803fcc 	andi	r2,r20,255
  8022e4:	1004913a 	slli	r2,r2,4
  8022e8:	18c003cc 	andi	r3,r3,15
  8022ec:	1886b03a 	or	r3,r3,r2
  8022f0:	00000106 	br	8022f8 <put_fat+0xac>
  8022f4:	a007883a 	mov	r3,r20
  8022f8:	20c00005 	stb	r3,0(r4)
			bc++;
  8022fc:	9c000044 	addi	r16,r19,1
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  802300:	90c00917 	ldw	r3,36(r18)
  802304:	800ad27a 	srli	r5,r16,9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  802308:	00800044 	movi	r2,1
  80230c:	90800105 	stb	r2,4(r18)
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  802310:	28cb883a 	add	r5,r5,r3
  802314:	9009883a 	mov	r4,r18
  802318:	08021640 	call	802164 <move_window>
  80231c:	1011883a 	mov	r8,r2
			if (res != FR_OK) break;
  802320:	1000321e 	bne	r2,zero,8023ec <put_fat+0x1a0>
			p = &fs->win[bc % SS(fs)];
  802324:	80807fcc 	andi	r2,r16,511
  802328:	888b883a 	add	r5,r17,r2
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  80232c:	a8000226 	beq	r21,zero,802338 <put_fat+0xec>
  802330:	a006d13a 	srli	r3,r20,4
  802334:	00000606 	br	802350 <put_fat+0x104>
  802338:	a004d23a 	srli	r2,r20,8
  80233c:	28c00003 	ldbu	r3,0(r5)
  802340:	013ffc04 	movi	r4,-16
  802344:	108003cc 	andi	r2,r2,15
  802348:	1906703a 	and	r3,r3,r4
  80234c:	1886b03a 	or	r3,r3,r2
  802350:	28c00005 	stb	r3,0(r5)
  802354:	00002506 	br	8023ec <put_fat+0x1a0>
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  802358:	20800917 	ldw	r2,36(r4)
  80235c:	800ad23a 	srli	r5,r16,8
  802360:	288b883a 	add	r5,r5,r2
  802364:	08021640 	call	802164 <move_window>
  802368:	1011883a 	mov	r8,r2
			if (res != FR_OK) break;
  80236c:	10001f1e 	bne	r2,zero,8023ec <put_fat+0x1a0>
			p = &fs->win[clst * 2 % SS(fs)];
  802370:	8405883a 	add	r2,r16,r16
			ST_WORD(p, (WORD)val);
  802374:	a008d23a 	srli	r4,r20,8
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
  802378:	10807fcc 	andi	r2,r2,511
  80237c:	90c00d04 	addi	r3,r18,52
  802380:	1887883a 	add	r3,r3,r2
			ST_WORD(p, (WORD)val);
  802384:	19000045 	stb	r4,1(r3)
  802388:	1d000005 	stb	r20,0(r3)
  80238c:	00001706 	br	8023ec <put_fat+0x1a0>
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  802390:	20800917 	ldw	r2,36(r4)
  802394:	800ad1fa 	srli	r5,r16,7
  802398:	288b883a 	add	r5,r5,r2
  80239c:	08021640 	call	802164 <move_window>
  8023a0:	1011883a 	mov	r8,r2
			if (res != FR_OK) break;
  8023a4:	1000111e 	bne	r2,zero,8023ec <put_fat+0x1a0>
			p = &fs->win[clst * 4 % SS(fs)];
  8023a8:	8405883a 	add	r2,r16,r16
  8023ac:	1085883a 	add	r2,r2,r2
  8023b0:	10807fcc 	andi	r2,r2,511
  8023b4:	90c00d04 	addi	r3,r18,52
  8023b8:	1887883a 	add	r3,r3,r2
			val |= LD_DWORD(p) & 0xF0000000;
  8023bc:	1c4f883a 	add	r7,r3,r17
  8023c0:	38800003 	ldbu	r2,0(r7)
  8023c4:	1004963a 	slli	r2,r2,24
  8023c8:	10bc002c 	andhi	r2,r2,61440
  8023cc:	a084b03a 	or	r2,r20,r2
			ST_DWORD(p, val);
  8023d0:	1008d23a 	srli	r4,r2,8
  8023d4:	100ad43a 	srli	r5,r2,16
  8023d8:	100cd63a 	srli	r6,r2,24
  8023dc:	19000045 	stb	r4,1(r3)
  8023e0:	19400085 	stb	r5,2(r3)
  8023e4:	18800005 	stb	r2,0(r3)
  8023e8:	39800005 	stb	r6,0(r7)
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  8023ec:	00800044 	movi	r2,1
  8023f0:	90800105 	stb	r2,4(r18)
  8023f4:	00000106 	br	8023fc <put_fat+0x1b0>
  8023f8:	02000084 	movi	r8,2
	}

	return res;
}
  8023fc:	4005883a 	mov	r2,r8
  802400:	dfc00617 	ldw	ra,24(sp)
  802404:	dd400517 	ldw	r21,20(sp)
  802408:	dd000417 	ldw	r20,16(sp)
  80240c:	dcc00317 	ldw	r19,12(sp)
  802410:	dc800217 	ldw	r18,8(sp)
  802414:	dc400117 	ldw	r17,4(sp)
  802418:	dc000017 	ldw	r16,0(sp)
  80241c:	dec00704 	addi	sp,sp,28
  802420:	f800283a 	ret

00802424 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
  802424:	defffa04 	addi	sp,sp,-24
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  802428:	00c00044 	movi	r3,1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
  80242c:	dc800215 	stw	r18,8(sp)
  802430:	dc400115 	stw	r17,4(sp)
  802434:	dfc00515 	stw	ra,20(sp)
  802438:	dd000415 	stw	r20,16(sp)
  80243c:	dcc00315 	stw	r19,12(sp)
  802440:	dc000015 	stw	r16,0(sp)
  802444:	2825883a 	mov	r18,r5
  802448:	2023883a 	mov	r17,r4
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  80244c:	19404b2e 	bgeu	r3,r5,80257c <get_fat+0x158>
  802450:	20800717 	ldw	r2,28(r4)
  802454:	2880492e 	bgeu	r5,r2,80257c <get_fat+0x158>
		return 1;

	switch (fs->fs_type) {
  802458:	24c00003 	ldbu	r19,0(r4)
  80245c:	00800084 	movi	r2,2
  802460:	98802026 	beq	r19,r2,8024e4 <get_fat+0xc0>
  802464:	008000c4 	movi	r2,3
  802468:	98802c26 	beq	r19,r2,80251c <get_fat+0xf8>
  80246c:	98c0451e 	bne	r19,r3,802584 <get_fat+0x160>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  802470:	28c4d83a 	srl	r2,r5,r3
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  802474:	20c00917 	ldw	r3,36(r4)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  802478:	28a1883a 	add	r16,r5,r2
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  80247c:	800ad27a 	srli	r5,r16,9
  802480:	28cb883a 	add	r5,r5,r3
  802484:	08021640 	call	802164 <move_window>
  802488:	10003e1e 	bne	r2,zero,802584 <get_fat+0x160>
		wc = fs->win[bc % SS(fs)]; bc++;
  80248c:	84e9883a 	add	r20,r16,r19
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  802490:	a006d27a 	srli	r3,r20,9
  802494:	89400917 	ldw	r5,36(r17)

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  802498:	80807fcc 	andi	r2,r16,511
  80249c:	1445883a 	add	r2,r2,r17
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  8024a0:	194b883a 	add	r5,r3,r5
  8024a4:	8809883a 	mov	r4,r17

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  8024a8:	14000d03 	ldbu	r16,52(r2)
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  8024ac:	08021640 	call	802164 <move_window>
  8024b0:	1000341e 	bne	r2,zero,802584 <get_fat+0x160>
		wc |= fs->win[bc % SS(fs)] << 8;
  8024b4:	a0807fcc 	andi	r2,r20,511
  8024b8:	1445883a 	add	r2,r2,r17
  8024bc:	10800d03 	ldbu	r2,52(r2)

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  8024c0:	80c03fcc 	andi	r3,r16,255
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  8024c4:	94c8703a 	and	r4,r18,r19
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
  8024c8:	1004923a 	slli	r2,r2,8
  8024cc:	1884b03a 	or	r2,r3,r2
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  8024d0:	20000226 	beq	r4,zero,8024dc <get_fat+0xb8>
  8024d4:	1004d13a 	srli	r2,r2,4
  8024d8:	00002b06 	br	802588 <get_fat+0x164>
  8024dc:	1083ffcc 	andi	r2,r2,4095
  8024e0:	00002906 	br	802588 <get_fat+0x164>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  8024e4:	2804d23a 	srli	r2,r5,8
  8024e8:	21400917 	ldw	r5,36(r4)
  8024ec:	114b883a 	add	r5,r2,r5
  8024f0:	08021640 	call	802164 <move_window>
  8024f4:	1000231e 	bne	r2,zero,802584 <get_fat+0x160>
		p = &fs->win[clst * 2 % SS(fs)];
  8024f8:	9485883a 	add	r2,r18,r18
  8024fc:	10807fcc 	andi	r2,r2,511
  802500:	88c00d04 	addi	r3,r17,52
  802504:	1887883a 	add	r3,r3,r2
		return LD_WORD(p);
  802508:	18800043 	ldbu	r2,1(r3)
  80250c:	18c00003 	ldbu	r3,0(r3)
  802510:	1004923a 	slli	r2,r2,8
  802514:	10c4b03a 	or	r2,r2,r3
  802518:	00001b06 	br	802588 <get_fat+0x164>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  80251c:	2804d1fa 	srli	r2,r5,7
  802520:	21400917 	ldw	r5,36(r4)
  802524:	114b883a 	add	r5,r2,r5
  802528:	08021640 	call	802164 <move_window>
  80252c:	1000151e 	bne	r2,zero,802584 <get_fat+0x160>
		p = &fs->win[clst * 4 % SS(fs)];
  802530:	9485883a 	add	r2,r18,r18
  802534:	1085883a 	add	r2,r2,r2
  802538:	10807fcc 	andi	r2,r2,511
  80253c:	88c00d04 	addi	r3,r17,52
  802540:	1887883a 	add	r3,r3,r2
		return LD_DWORD(p) & 0x0FFFFFFF;
  802544:	188000c3 	ldbu	r2,3(r3)
  802548:	19000083 	ldbu	r4,2(r3)
  80254c:	19400043 	ldbu	r5,1(r3)
  802550:	1004963a 	slli	r2,r2,24
  802554:	2008943a 	slli	r4,r4,16
  802558:	18c00003 	ldbu	r3,0(r3)
  80255c:	280a923a 	slli	r5,r5,8
  802560:	1104b03a 	or	r2,r2,r4
  802564:	10c4b03a 	or	r2,r2,r3
  802568:	288ab03a 	or	r5,r5,r2
  80256c:	00840034 	movhi	r2,4096
  802570:	10bfffc4 	addi	r2,r2,-1
  802574:	2884703a 	and	r2,r5,r2
  802578:	00000306 	br	802588 <get_fat+0x164>
  80257c:	00800044 	movi	r2,1
  802580:	00000106 	br	802588 <get_fat+0x164>
  802584:	00bfffc4 	movi	r2,-1
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
  802588:	dfc00517 	ldw	ra,20(sp)
  80258c:	dd000417 	ldw	r20,16(sp)
  802590:	dcc00317 	ldw	r19,12(sp)
  802594:	dc800217 	ldw	r18,8(sp)
  802598:	dc400117 	ldw	r17,4(sp)
  80259c:	dc000017 	ldw	r16,0(sp)
  8025a0:	dec00604 	addi	sp,sp,24
  8025a4:	f800283a 	ret

008025a8 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
  8025a8:	defff704 	addi	sp,sp,-36
  8025ac:	dd800715 	stw	r22,28(sp)
  8025b0:	dc000115 	stw	r16,4(sp)
  8025b4:	d9000015 	stw	r4,0(sp)
  8025b8:	3021883a 	mov	r16,r6
  8025bc:	282d883a 	mov	r22,r5
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
  8025c0:	d809883a 	mov	r4,sp
  8025c4:	300b883a 	mov	r5,r6
  8025c8:	000d883a 	mov	r6,zero
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
  8025cc:	dd000515 	stw	r20,20(sp)
  8025d0:	dfc00815 	stw	ra,32(sp)
  8025d4:	dd400615 	stw	r21,24(sp)
  8025d8:	dcc00415 	stw	r19,16(sp)
  8025dc:	dc800315 	stw	r18,12(sp)
  8025e0:	dc400215 	stw	r17,8(sp)
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
  8025e4:	0801c0c0 	call	801c0c <chk_mounted>
  8025e8:	1029883a 	mov	r20,r2
	if (res == FR_OK) {
  8025ec:	10005a1e 	bne	r2,zero,802758 <f_getfree+0x1b0>
		/* If free_clust is valid, return it without full cluster scan */
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
  8025f0:	81400017 	ldw	r5,0(r16)
  8025f4:	2c400717 	ldw	r17,28(r5)
  8025f8:	28c00417 	ldw	r3,16(r5)
  8025fc:	88bfff84 	addi	r2,r17,-2
  802600:	10c00236 	bltu	r2,r3,80260c <f_getfree+0x64>
			*nclst = (*fatfs)->free_clust;
  802604:	b0c00015 	stw	r3,0(r22)
  802608:	00005306 	br	802758 <f_getfree+0x1b0>
		} else {
			/* Get number of free clusters */
			fat = (*fatfs)->fs_type;
  80260c:	2d400003 	ldbu	r21,0(r5)
			n = 0;
			if (fat == FS_FAT12) {
  802610:	00800044 	movi	r2,1
  802614:	a8c03fcc 	andi	r3,r21,255
  802618:	1880111e 	bne	r3,r2,802660 <f_getfree+0xb8>
  80261c:	0025883a 	mov	r18,zero
  802620:	04400084 	movi	r17,2
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
  802624:	81000017 	ldw	r4,0(r16)
  802628:	880b883a 	mov	r5,r17
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < (*fatfs)->n_fatent);
  80262c:	8c400044 	addi	r17,r17,1
			fat = (*fatfs)->fs_type;
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
  802630:	08024240 	call	802424 <get_fat>
  802634:	1007883a 	mov	r3,r2
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  802638:	00bfffc4 	movi	r2,-1
  80263c:	18804226 	beq	r3,r2,802748 <f_getfree+0x1a0>
					if (stat == 1) { res = FR_INT_ERR; break; }
  802640:	00800044 	movi	r2,1
  802644:	18803e26 	beq	r3,r2,802740 <f_getfree+0x198>
					if (stat == 0) n++;
  802648:	1800011e 	bne	r3,zero,802650 <f_getfree+0xa8>
  80264c:	90a5883a 	add	r18,r18,r2
				} while (++clst < (*fatfs)->n_fatent);
  802650:	80800017 	ldw	r2,0(r16)
  802654:	10800717 	ldw	r2,28(r2)
  802658:	88803c2e 	bgeu	r17,r2,80274c <f_getfree+0x1a4>
  80265c:	003ff106 	br	802624 <f_getfree+0x7c>
			} else {
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
  802660:	2cc00917 	ldw	r19,36(r5)
  802664:	0025883a 	mov	r18,zero
  802668:	000f883a 	mov	r7,zero
  80266c:	000d883a 	mov	r6,zero
				i = 0; p = 0;
				do {
					if (!i) {
  802670:	3800091e 	bne	r7,zero,802698 <f_getfree+0xf0>
						res = move_window(*fatfs, sect++);
  802674:	81000017 	ldw	r4,0(r16)
  802678:	980b883a 	mov	r5,r19
  80267c:	08021640 	call	802164 <move_window>
  802680:	1029883a 	mov	r20,r2
						if (res != FR_OK) break;
  802684:	1000251e 	bne	r2,zero,80271c <f_getfree+0x174>
						p = (*fatfs)->win;
  802688:	80800017 	ldw	r2,0(r16)
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
  80268c:	9cc00044 	addi	r19,r19,1
						if (res != FR_OK) break;
						p = (*fatfs)->win;
  802690:	01c08004 	movi	r7,512
  802694:	11800d04 	addi	r6,r2,52
						i = SS(*fatfs);
					}
					if (fat == FS_FAT16) {
  802698:	a9003fcc 	andi	r4,r21,255
  80269c:	00800084 	movi	r2,2
  8026a0:	30c00043 	ldbu	r3,1(r6)
  8026a4:	20800b1e 	bne	r4,r2,8026d4 <f_getfree+0x12c>
						if (LD_WORD(p) == 0) n++;
  8026a8:	1804923a 	slli	r2,r3,8
  8026ac:	30c00003 	ldbu	r3,0(r6)
  8026b0:	10c4b03a 	or	r2,r2,r3
  8026b4:	10bfffcc 	andi	r2,r2,65535
  8026b8:	10a0001c 	xori	r2,r2,32768
  8026bc:	10a00004 	addi	r2,r2,-32768
  8026c0:	1000011e 	bne	r2,zero,8026c8 <f_getfree+0x120>
  8026c4:	94800044 	addi	r18,r18,1
						p += 2; i -= 2;
  8026c8:	390fc83a 	sub	r7,r7,r4
  8026cc:	310d883a 	add	r6,r6,r4
  8026d0:	00001006 	br	802714 <f_getfree+0x16c>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
  8026d4:	308000c3 	ldbu	r2,3(r6)
  8026d8:	31000083 	ldbu	r4,2(r6)
  8026dc:	31400003 	ldbu	r5,0(r6)
  8026e0:	1004963a 	slli	r2,r2,24
  8026e4:	2008943a 	slli	r4,r4,16
  8026e8:	1806923a 	slli	r3,r3,8
  8026ec:	1104b03a 	or	r2,r2,r4
  8026f0:	1144b03a 	or	r2,r2,r5
  8026f4:	1886b03a 	or	r3,r3,r2
  8026f8:	00840034 	movhi	r2,4096
  8026fc:	10bfffc4 	addi	r2,r2,-1
  802700:	1886703a 	and	r3,r3,r2
  802704:	1800011e 	bne	r3,zero,80270c <f_getfree+0x164>
  802708:	94800044 	addi	r18,r18,1
						p += 4; i -= 4;
  80270c:	31800104 	addi	r6,r6,4
  802710:	39ffff04 	addi	r7,r7,-4
					}
				} while (--clst);
  802714:	8c7fffc4 	addi	r17,r17,-1
  802718:	883fd51e 	bne	r17,zero,802670 <f_getfree+0xc8>
			}
			(*fatfs)->free_clust = n;
  80271c:	81000017 	ldw	r4,0(r16)
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  802720:	a8c03fcc 	andi	r3,r21,255
  802724:	008000c4 	movi	r2,3
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
  802728:	24800415 	stw	r18,16(r4)
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  80272c:	1880021e 	bne	r3,r2,802738 <f_getfree+0x190>
  802730:	00800044 	movi	r2,1
  802734:	20800145 	stb	r2,5(r4)
			*nclst = n;
  802738:	b4800015 	stw	r18,0(r22)
  80273c:	00000606 	br	802758 <f_getfree+0x1b0>
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
					if (stat == 1) { res = FR_INT_ERR; break; }
  802740:	05000084 	movi	r20,2
  802744:	00000106 	br	80274c <f_getfree+0x1a4>
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
			*nclst = n;
  802748:	05000044 	movi	r20,1
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
  80274c:	80800017 	ldw	r2,0(r16)
  802750:	14800415 	stw	r18,16(r2)
  802754:	003ff806 	br	802738 <f_getfree+0x190>
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
			*nclst = n;
		}
	}
	LEAVE_FF(*fatfs, res);
}
  802758:	a005883a 	mov	r2,r20
  80275c:	dfc00817 	ldw	ra,32(sp)
  802760:	dd800717 	ldw	r22,28(sp)
  802764:	dd400617 	ldw	r21,24(sp)
  802768:	dd000517 	ldw	r20,20(sp)
  80276c:	dcc00417 	ldw	r19,16(sp)
  802770:	dc800317 	ldw	r18,12(sp)
  802774:	dc400217 	ldw	r17,8(sp)
  802778:	dc000117 	ldw	r16,4(sp)
  80277c:	dec00904 	addi	sp,sp,36
  802780:	f800283a 	ret

00802784 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  802784:	defff704 	addi	sp,sp,-36
  802788:	dc000015 	stw	r16,0(sp)
  80278c:	2021883a 	mov	r16,r4
  802790:	dc800215 	stw	r18,8(sp)
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  802794:	21000017 	ldw	r4,0(r4)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  802798:	2825883a 	mov	r18,r5
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  80279c:	8140010b 	ldhu	r5,4(r16)
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  8027a0:	38000015 	stw	zero,0(r7)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  8027a4:	ddc00715 	stw	r23,28(sp)
  8027a8:	dd400515 	stw	r21,20(sp)
  8027ac:	dc400115 	stw	r17,4(sp)
  8027b0:	dfc00815 	stw	ra,32(sp)
  8027b4:	dd800615 	stw	r22,24(sp)
  8027b8:	dd000415 	stw	r20,16(sp)
  8027bc:	dcc00315 	stw	r19,12(sp)
  8027c0:	382f883a 	mov	r23,r7
  8027c4:	3023883a 	mov	r17,r6
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  8027c8:	0801ad80 	call	801ad8 <validate>
  8027cc:	102b883a 	mov	r21,r2
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  8027d0:	1000701e 	bne	r2,zero,802994 <f_read+0x210>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  8027d4:	80c00183 	ldbu	r3,6(r16)
  8027d8:	18803fcc 	andi	r2,r3,255
  8027dc:	1080201c 	xori	r2,r2,128
  8027e0:	10bfe004 	addi	r2,r2,-128
  8027e4:	1000020e 	bge	r2,zero,8027f0 <f_read+0x6c>
  8027e8:	05400084 	movi	r21,2
  8027ec:	00006906 	br	802994 <f_read+0x210>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  8027f0:	1880004c 	andi	r2,r3,1
  8027f4:	10000e1e 	bne	r2,zero,802830 <f_read+0xac>
  8027f8:	054001c4 	movi	r21,7
  8027fc:	00006506 	br	802994 <f_read+0x210>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802800:	80800183 	ldbu	r2,6(r16)
  802804:	202b883a 	mov	r21,r4
  802808:	00ffe004 	movi	r3,-128
  80280c:	10c4b03a 	or	r2,r2,r3
  802810:	80800185 	stb	r2,6(r16)
  802814:	00005f06 	br	802994 <f_read+0x210>
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  802818:	80800183 	ldbu	r2,6(r16)
  80281c:	05400084 	movi	r21,2
  802820:	003ff906 	br	802808 <f_read+0x84>
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
  802824:	80800183 	ldbu	r2,6(r16)
  802828:	05400044 	movi	r21,1
  80282c:	003ff606 	br	802808 <f_read+0x84>
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
  802830:	80c00317 	ldw	r3,12(r16)
  802834:	80800217 	ldw	r2,8(r16)
  802838:	902d883a 	mov	r22,r18
  80283c:	18a9c83a 	sub	r20,r3,r2
  802840:	8d00532e 	bgeu	r17,r20,802990 <f_read+0x20c>
  802844:	8829883a 	mov	r20,r17
  802848:	00005106 	br	802990 <f_read+0x20c>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  80284c:	81400217 	ldw	r5,8(r16)
  802850:	28807fcc 	andi	r2,r5,511
  802854:	1000331e 	bne	r2,zero,802924 <f_read+0x1a0>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  802858:	81000017 	ldw	r4,0(r16)
  80285c:	2804d27a 	srli	r2,r5,9
  802860:	20c00083 	ldbu	r3,2(r4)
  802864:	18ffffc4 	addi	r3,r3,-1
  802868:	10e6703a 	and	r19,r2,r3
			if (!csect) {						/* On the cluster boundary? */
  80286c:	98803fcc 	andi	r2,r19,255
  802870:	10000b1e 	bne	r2,zero,8028a0 <f_read+0x11c>
				if (fp->fptr == 0) {			/* On the top of the file? */
  802874:	2800021e 	bne	r5,zero,802880 <f_read+0xfc>
					clst = fp->sclust;			/* Follow from the origin */
  802878:	80c00417 	ldw	r3,16(r16)
  80287c:	00000306 	br	80288c <f_read+0x108>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  802880:	81400517 	ldw	r5,20(r16)
  802884:	08024240 	call	802424 <get_fat>
  802888:	1007883a 	mov	r3,r2
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  80288c:	01000044 	movi	r4,1
  802890:	20ffe12e 	bgeu	r4,r3,802818 <f_read+0x94>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802894:	00bfffc4 	movi	r2,-1
  802898:	18bfd926 	beq	r3,r2,802800 <f_read+0x7c>
				fp->clust = clst;				/* Update current cluster */
  80289c:	80c00515 	stw	r3,20(r16)
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  8028a0:	84800017 	ldw	r18,0(r16)
  8028a4:	81400517 	ldw	r5,20(r16)
  8028a8:	9009883a 	mov	r4,r18
  8028ac:	08017d80 	call	8017d8 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  8028b0:	103fd926 	beq	r2,zero,802818 <f_read+0x94>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
  8028b4:	a022d27a 	srli	r17,r20,9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  8028b8:	98c03fcc 	andi	r3,r19,255
  8028bc:	10e7883a 	add	r19,r2,r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  8028c0:	88001726 	beq	r17,zero,802920 <f_read+0x19c>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  8028c4:	91000083 	ldbu	r4,2(r18)
  8028c8:	1c45883a 	add	r2,r3,r17
  8028cc:	2080012e 	bgeu	r4,r2,8028d4 <f_read+0x150>
					cc = fp->fs->csize - csect;
  8028d0:	20e3c83a 	sub	r17,r4,r3
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  8028d4:	91000043 	ldbu	r4,1(r18)
  8028d8:	b00b883a 	mov	r5,r22
  8028dc:	980d883a 	mov	r6,r19
  8028e0:	89c03fcc 	andi	r7,r17,255
  8028e4:	08016b00 	call	8016b0 <disk_read>
  8028e8:	103fce1e 	bne	r2,zero,802824 <f_read+0xa0>
					ABORT(fp->fs, FR_DISK_ERR);
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
  8028ec:	81400017 	ldw	r5,0(r16)
  8028f0:	28800103 	ldbu	r2,4(r5)
  8028f4:	10000826 	beq	r2,zero,802918 <f_read+0x194>
  8028f8:	28800c17 	ldw	r2,48(r5)
  8028fc:	14c5c83a 	sub	r2,r2,r19
  802900:	1440052e 	bgeu	r2,r17,802918 <f_read+0x194>
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
  802904:	1008927a 	slli	r4,r2,9
  802908:	29400d04 	addi	r5,r5,52
  80290c:	01808004 	movi	r6,512
  802910:	b109883a 	add	r4,r22,r4
  802914:	08017980 	call	801798 <mem_cpy>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  802918:	8822927a 	slli	r17,r17,9
  80291c:	00001406 	br	802970 <f_read+0x1ec>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  802920:	84c00615 	stw	r19,24(r16)
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
  802924:	81000017 	ldw	r4,0(r16)
  802928:	81400617 	ldw	r5,24(r16)
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  80292c:	84400217 	ldw	r17,8(r16)
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
  802930:	08021640 	call	802164 <move_window>
  802934:	103fbb1e 	bne	r2,zero,802824 <f_read+0xa0>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  802938:	88c07fcc 	andi	r3,r17,511
  80293c:	00808004 	movi	r2,512
  802940:	10c5c83a 	sub	r2,r2,r3
  802944:	a023883a 	mov	r17,r20
  802948:	1500012e 	bgeu	r2,r20,802950 <f_read+0x1cc>
  80294c:	1023883a 	mov	r17,r2
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  802950:	80800017 	ldw	r2,0(r16)
  802954:	81400217 	ldw	r5,8(r16)
  802958:	b009883a 	mov	r4,r22
  80295c:	10800d04 	addi	r2,r2,52
  802960:	29407fcc 	andi	r5,r5,511
  802964:	114b883a 	add	r5,r2,r5
  802968:	880d883a 	mov	r6,r17
  80296c:	08017980 	call	801798 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  802970:	80800217 	ldw	r2,8(r16)
  802974:	b8c00017 	ldw	r3,0(r23)
  802978:	a469c83a 	sub	r20,r20,r17
  80297c:	1445883a 	add	r2,r2,r17
  802980:	1c47883a 	add	r3,r3,r17
  802984:	80800215 	stw	r2,8(r16)
  802988:	b8c00015 	stw	r3,0(r23)
  80298c:	b46d883a 	add	r22,r22,r17
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  802990:	a03fae1e 	bne	r20,zero,80284c <f_read+0xc8>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  802994:	a805883a 	mov	r2,r21
  802998:	dfc00817 	ldw	ra,32(sp)
  80299c:	ddc00717 	ldw	r23,28(sp)
  8029a0:	dd800617 	ldw	r22,24(sp)
  8029a4:	dd400517 	ldw	r21,20(sp)
  8029a8:	dd000417 	ldw	r20,16(sp)
  8029ac:	dcc00317 	ldw	r19,12(sp)
  8029b0:	dc800217 	ldw	r18,8(sp)
  8029b4:	dc400117 	ldw	r17,4(sp)
  8029b8:	dc000017 	ldw	r16,0(sp)
  8029bc:	dec00904 	addi	sp,sp,36
  8029c0:	f800283a 	ret

008029c4 <dir_sdi>:
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  8029c4:	20c00217 	ldw	r3,8(r4)
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  8029c8:	defffb04 	addi	sp,sp,-20
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  8029cc:	00800044 	movi	r2,1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  8029d0:	dc800215 	stw	r18,8(sp)
  8029d4:	dc000015 	stw	r16,0(sp)
  8029d8:	dfc00415 	stw	ra,16(sp)
  8029dc:	dcc00315 	stw	r19,12(sp)
  8029e0:	dc400115 	stw	r17,4(sp)
  8029e4:	2021883a 	mov	r16,r4
	DWORD clst;
	WORD ic;


	dj->index = idx;
  8029e8:	2140018d 	sth	r5,6(r4)
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  8029ec:	2825883a 	mov	r18,r5
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  8029f0:	18803226 	beq	r3,r2,802abc <dir_sdi+0xf8>
  8029f4:	21000017 	ldw	r4,0(r4)
  8029f8:	20800717 	ldw	r2,28(r4)
  8029fc:	18802f2e 	bgeu	r3,r2,802abc <dir_sdi+0xf8>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  802a00:	18000c1e 	bne	r3,zero,802a34 <dir_sdi+0x70>
  802a04:	20c00003 	ldbu	r3,0(r4)
  802a08:	008000c4 	movi	r2,3
  802a0c:	1880021e 	bne	r3,r2,802a18 <dir_sdi+0x54>
		clst = dj->fs->dirbase;
  802a10:	20c00a17 	ldw	r3,40(r4)

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  802a14:	1800071e 	bne	r3,zero,802a34 <dir_sdi+0x70>
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  802a18:	2080020b 	ldhu	r2,8(r4)
  802a1c:	90ffffcc 	andi	r3,r18,65535
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  802a20:	80000315 	stw	zero,12(r16)
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  802a24:	1880252e 	bgeu	r3,r2,802abc <dir_sdi+0xf8>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  802a28:	20800a17 	ldw	r2,40(r4)
  802a2c:	1806d13a 	srli	r3,r3,4
  802a30:	00001606 	br	802a8c <dir_sdi+0xc8>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  802a34:	20800083 	ldbu	r2,2(r4)
  802a38:	1026913a 	slli	r19,r2,4
  802a3c:	00000b06 	br	802a6c <dir_sdi+0xa8>
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  802a40:	81000017 	ldw	r4,0(r16)
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
  802a44:	94e5c83a 	sub	r18,r18,r19
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  802a48:	08024240 	call	802424 <get_fat>
  802a4c:	1007883a 	mov	r3,r2
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  802a50:	00bfffc4 	movi	r2,-1
  802a54:	18801726 	beq	r3,r2,802ab4 <dir_sdi+0xf0>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  802a58:	00800044 	movi	r2,1
  802a5c:	10c0172e 	bgeu	r2,r3,802abc <dir_sdi+0xf8>
  802a60:	80800017 	ldw	r2,0(r16)
  802a64:	10800717 	ldw	r2,28(r2)
  802a68:	1880142e 	bgeu	r3,r2,802abc <dir_sdi+0xf8>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  802a6c:	947fffcc 	andi	r17,r18,65535
  802a70:	98bfffcc 	andi	r2,r19,65535
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  802a74:	180b883a 	mov	r5,r3
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  802a78:	88bff12e 	bgeu	r17,r2,802a40 <dir_sdi+0x7c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  802a7c:	81000017 	ldw	r4,0(r16)
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  802a80:	80c00315 	stw	r3,12(r16)
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  802a84:	08017d80 	call	8017d8 <clust2sect>
  802a88:	8806d13a 	srli	r3,r17,4
  802a8c:	10c5883a 	add	r2,r2,r3
  802a90:	80800415 	stw	r2,16(r16)
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  802a94:	90c003cc 	andi	r3,r18,15
  802a98:	80800017 	ldw	r2,0(r16)
  802a9c:	1806917a 	slli	r3,r3,5
  802aa0:	0009883a 	mov	r4,zero
  802aa4:	10800d04 	addi	r2,r2,52
  802aa8:	10c5883a 	add	r2,r2,r3
  802aac:	80800515 	stw	r2,20(r16)
  802ab0:	00000306 	br	802ac0 <dir_sdi+0xfc>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  802ab4:	01000044 	movi	r4,1
  802ab8:	00000106 	br	802ac0 <dir_sdi+0xfc>
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
  802abc:	01000084 	movi	r4,2
}
  802ac0:	2005883a 	mov	r2,r4
  802ac4:	dfc00417 	ldw	ra,16(sp)
  802ac8:	dcc00317 	ldw	r19,12(sp)
  802acc:	dc800217 	ldw	r18,8(sp)
  802ad0:	dc400117 	ldw	r17,4(sp)
  802ad4:	dc000017 	ldw	r16,0(sp)
  802ad8:	dec00504 	addi	sp,sp,20
  802adc:	f800283a 	ret

00802ae0 <dir_remove>:
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
  802ae0:	2140018b 	ldhu	r5,6(r4)
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
  802ae4:	defffe04 	addi	sp,sp,-8
  802ae8:	dc000015 	stw	r16,0(sp)
  802aec:	dfc00115 	stw	ra,4(sp)
  802af0:	2021883a 	mov	r16,r4
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
  802af4:	08029c40 	call	8029c4 <dir_sdi>
  802af8:	1009883a 	mov	r4,r2
	if (res == FR_OK) {
  802afc:	10000b1e 	bne	r2,zero,802b2c <dir_remove+0x4c>
		res = move_window(dj->fs, dj->sect);
  802b00:	81000017 	ldw	r4,0(r16)
  802b04:	81400417 	ldw	r5,16(r16)
  802b08:	08021640 	call	802164 <move_window>
  802b0c:	1009883a 	mov	r4,r2
		if (res == FR_OK) {
  802b10:	1000061e 	bne	r2,zero,802b2c <dir_remove+0x4c>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
  802b14:	80c00517 	ldw	r3,20(r16)
  802b18:	00bff944 	movi	r2,-27
  802b1c:	18800005 	stb	r2,0(r3)
			dj->fs->wflag = 1;
  802b20:	80c00017 	ldw	r3,0(r16)
  802b24:	00800044 	movi	r2,1
  802b28:	18800105 	stb	r2,4(r3)
		}
	}
#endif

	return res;
}
  802b2c:	2005883a 	mov	r2,r4
  802b30:	dfc00117 	ldw	ra,4(sp)
  802b34:	dc000017 	ldw	r16,0(sp)
  802b38:	dec00204 	addi	sp,sp,8
  802b3c:	f800283a 	ret

00802b40 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  802b40:	defffa04 	addi	sp,sp,-24
  802b44:	dcc00315 	stw	r19,12(sp)
  802b48:	dc800215 	stw	r18,8(sp)
  802b4c:	dfc00515 	stw	ra,20(sp)
  802b50:	dd000415 	stw	r20,16(sp)
  802b54:	dc400115 	stw	r17,4(sp)
  802b58:	dc000015 	stw	r16,0(sp)
  802b5c:	2827883a 	mov	r19,r5
  802b60:	2025883a 	mov	r18,r4
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  802b64:	2800051e 	bne	r5,zero,802b7c <create_chain+0x3c>
		scl = fs->last_clust;			/* Get suggested start point */
  802b68:	24400317 	ldw	r17,12(r4)
		if (!scl || scl >= fs->n_fatent) scl = 1;
  802b6c:	88000b26 	beq	r17,zero,802b9c <create_chain+0x5c>
  802b70:	20800717 	ldw	r2,28(r4)
  802b74:	8880092e 	bgeu	r17,r2,802b9c <create_chain+0x5c>
  802b78:	00000906 	br	802ba0 <create_chain+0x60>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
  802b7c:	08024240 	call	802424 <get_fat>
  802b80:	1007883a 	mov	r3,r2
		if (cs < 2) return 1;			/* It is an invalid cluster */
  802b84:	00800044 	movi	r2,1
  802b88:	10c0332e 	bgeu	r2,r3,802c58 <create_chain+0x118>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  802b8c:	90800717 	ldw	r2,28(r18)
  802b90:	18803436 	bltu	r3,r2,802c64 <create_chain+0x124>
  802b94:	9823883a 	mov	r17,r19
  802b98:	00000106 	br	802ba0 <create_chain+0x60>
  802b9c:	04400044 	movi	r17,1
  802ba0:	8821883a 	mov	r16,r17
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  802ba4:	90800717 	ldw	r2,28(r18)
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  802ba8:	84000044 	addi	r16,r16,1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
  802bac:	9009883a 	mov	r4,r18
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  802bb0:	05000044 	movi	r20,1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  802bb4:	80800236 	bltu	r16,r2,802bc0 <create_chain+0x80>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  802bb8:	a440292e 	bgeu	r20,r17,802c60 <create_chain+0x120>
  802bbc:	04000084 	movi	r16,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
  802bc0:	800b883a 	mov	r5,r16
  802bc4:	08024240 	call	802424 <get_fat>
  802bc8:	1007883a 	mov	r3,r2
		if (cs == 0) break;				/* Found a free cluster */
  802bcc:	10000526 	beq	r2,zero,802be4 <create_chain+0xa4>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  802bd0:	00bfffc4 	movi	r2,-1
  802bd4:	18802326 	beq	r3,r2,802c64 <create_chain+0x124>
  802bd8:	1d002226 	beq	r3,r20,802c64 <create_chain+0x124>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  802bdc:	84402026 	beq	r16,r17,802c60 <create_chain+0x120>
  802be0:	003ff006 	br	802ba4 <create_chain+0x64>
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
  802be4:	9009883a 	mov	r4,r18
  802be8:	800b883a 	mov	r5,r16
  802bec:	01840034 	movhi	r6,4096
  802bf0:	31bfffc4 	addi	r6,r6,-1
  802bf4:	080224c0 	call	80224c <put_fat>
  802bf8:	1007883a 	mov	r3,r2
	if (res == FR_OK && clst != 0) {
  802bfc:	1000121e 	bne	r2,zero,802c48 <create_chain+0x108>
  802c00:	98000626 	beq	r19,zero,802c1c <create_chain+0xdc>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
  802c04:	980b883a 	mov	r5,r19
  802c08:	9009883a 	mov	r4,r18
  802c0c:	800d883a 	mov	r6,r16
  802c10:	080224c0 	call	80224c <put_fat>
  802c14:	1007883a 	mov	r3,r2
	}
	if (res == FR_OK) {
  802c18:	10000b1e 	bne	r2,zero,802c48 <create_chain+0x108>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  802c1c:	90c00417 	ldw	r3,16(r18)
  802c20:	00bfffc4 	movi	r2,-1
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  802c24:	94000315 	stw	r16,12(r18)
		if (fs->free_clust != 0xFFFFFFFF) {
  802c28:	1880021e 	bne	r3,r2,802c34 <create_chain+0xf4>
  802c2c:	8007883a 	mov	r3,r16
  802c30:	00000c06 	br	802c64 <create_chain+0x124>
			fs->free_clust--;
  802c34:	18bfffc4 	addi	r2,r3,-1
			fs->fsi_flag = 1;
  802c38:	8007883a 	mov	r3,r16
  802c3c:	95000145 	stb	r20,5(r18)
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  802c40:	90800415 	stw	r2,16(r18)
  802c44:	00000706 	br	802c64 <create_chain+0x124>
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  802c48:	00800044 	movi	r2,1
  802c4c:	1880021e 	bne	r3,r2,802c58 <create_chain+0x118>
  802c50:	00ffffc4 	movi	r3,-1
  802c54:	00000306 	br	802c64 <create_chain+0x124>
  802c58:	00c00044 	movi	r3,1
  802c5c:	00000106 	br	802c64 <create_chain+0x124>
  802c60:	0007883a 	mov	r3,zero
	}

	return ncl;		/* Return new cluster number or error code */
}
  802c64:	1805883a 	mov	r2,r3
  802c68:	dfc00517 	ldw	ra,20(sp)
  802c6c:	dd000417 	ldw	r20,16(sp)
  802c70:	dcc00317 	ldw	r19,12(sp)
  802c74:	dc800217 	ldw	r18,8(sp)
  802c78:	dc400117 	ldw	r17,4(sp)
  802c7c:	dc000017 	ldw	r16,0(sp)
  802c80:	dec00604 	addi	sp,sp,24
  802c84:	f800283a 	ret

00802c88 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
  802c88:	defff804 	addi	sp,sp,-32
  802c8c:	dc400115 	stw	r17,4(sp)
  802c90:	2023883a 	mov	r17,r4
  802c94:	dc800215 	stw	r18,8(sp)
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  802c98:	21000017 	ldw	r4,0(r4)

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
  802c9c:	2825883a 	mov	r18,r5
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  802ca0:	8940010b 	ldhu	r5,4(r17)

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
  802ca4:	dd400515 	stw	r21,20(sp)
  802ca8:	dfc00715 	stw	ra,28(sp)
  802cac:	dd800615 	stw	r22,24(sp)
  802cb0:	dd000415 	stw	r20,16(sp)
  802cb4:	dcc00315 	stw	r19,12(sp)
  802cb8:	dc000015 	stw	r16,0(sp)
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  802cbc:	0801ad80 	call	801ad8 <validate>
  802cc0:	102b883a 	mov	r21,r2
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  802cc4:	1000711e 	bne	r2,zero,802e8c <f_lseek+0x204>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
  802cc8:	88c00183 	ldbu	r3,6(r17)
  802ccc:	18803fcc 	andi	r2,r3,255
  802cd0:	1080201c 	xori	r2,r2,128
  802cd4:	10bfe004 	addi	r2,r2,-128
  802cd8:	1000020e 	bge	r2,zero,802ce4 <f_lseek+0x5c>
  802cdc:	05400084 	movi	r21,2
  802ce0:	00006a06 	br	802e8c <f_lseek+0x204>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
  802ce4:	89400317 	ldw	r5,12(r17)
  802ce8:	2c80032e 	bgeu	r5,r18,802cf8 <f_lseek+0x70>
  802cec:	1880008c 	andi	r2,r3,2
  802cf0:	1000011e 	bne	r2,zero,802cf8 <f_lseek+0x70>
  802cf4:	2825883a 	mov	r18,r5
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
  802cf8:	89000217 	ldw	r4,8(r17)
		fp->fptr = nsect = 0;
  802cfc:	88000215 	stw	zero,8(r17)
		if (ofs) {
  802d00:	90006226 	beq	r18,zero,802e8c <f_lseek+0x204>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
  802d04:	8d800017 	ldw	r22,0(r17)
  802d08:	b0800083 	ldbu	r2,2(r22)
  802d0c:	1026927a 	slli	r19,r2,9
			if (ifptr > 0 &&
  802d10:	20000f26 	beq	r4,zero,802d50 <f_lseek+0xc8>
  802d14:	253fffc4 	addi	r20,r4,-1
  802d18:	980b883a 	mov	r5,r19
  802d1c:	913fffc4 	addi	r4,r18,-1
  802d20:	08064740 	call	806474 <__udivsi3>
  802d24:	a009883a 	mov	r4,r20
  802d28:	980b883a 	mov	r5,r19
  802d2c:	1021883a 	mov	r16,r2
  802d30:	08064740 	call	806474 <__udivsi3>
  802d34:	80800636 	bltu	r16,r2,802d50 <f_lseek+0xc8>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
  802d38:	04c5c83a 	sub	r2,zero,r19
				ofs -= fp->fptr;
				clst = fp->clust;
  802d3c:	89800517 	ldw	r6,20(r17)
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
  802d40:	a084703a 	and	r2,r20,r2
				ofs -= fp->fptr;
  802d44:	90a5c83a 	sub	r18,r18,r2
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
  802d48:	88800215 	stw	r2,8(r17)
  802d4c:	00000f06 	br	802d8c <f_lseek+0x104>
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
  802d50:	89800417 	ldw	r6,16(r17)
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
  802d54:	30000c1e 	bne	r6,zero,802d88 <f_lseek+0x100>
					clst = create_chain(fp->fs, 0);
  802d58:	b009883a 	mov	r4,r22
  802d5c:	000b883a 	mov	r5,zero
  802d60:	0802b400 	call	802b40 <create_chain>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  802d64:	00c00044 	movi	r3,1
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
  802d68:	100d883a 	mov	r6,r2
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  802d6c:	10c02e26 	beq	r2,r3,802e28 <f_lseek+0x1a0>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802d70:	00bfffc4 	movi	r2,-1
  802d74:	3080031e 	bne	r6,r2,802d84 <f_lseek+0xfc>
  802d78:	88800183 	ldbu	r2,6(r17)
  802d7c:	182b883a 	mov	r21,r3
  802d80:	00003106 	br	802e48 <f_lseek+0x1c0>
					fp->sclust = clst;
  802d84:	89800415 	stw	r6,16(r17)
				}
#endif
				fp->clust = clst;
  802d88:	89800515 	stw	r6,20(r17)
			}
			if (clst != 0) {
  802d8c:	30001a1e 	bne	r6,zero,802df8 <f_lseek+0x170>
  802d90:	00003006 	br	802e54 <f_lseek+0x1cc>
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  802d94:	88800183 	ldbu	r2,6(r17)
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
  802d98:	94e5c83a 	sub	r18,r18,r19
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  802d9c:	1080008c 	andi	r2,r2,2
  802da0:	10000626 	beq	r2,zero,802dbc <f_lseek+0x134>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
  802da4:	89000017 	ldw	r4,0(r17)
  802da8:	0802b400 	call	802b40 <create_chain>
  802dac:	100d883a 	mov	r6,r2
						if (clst == 0) {				/* When disk gets full, clip file size */
  802db0:	1000061e 	bne	r2,zero,802dcc <f_lseek+0x144>
  802db4:	9825883a 	mov	r18,r19
  802db8:	00001106 	br	802e00 <f_lseek+0x178>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
  802dbc:	89000017 	ldw	r4,0(r17)
  802dc0:	300b883a 	mov	r5,r6
  802dc4:	08024240 	call	802424 <get_fat>
  802dc8:	100d883a 	mov	r6,r2
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802dcc:	00bfffc4 	movi	r2,-1
  802dd0:	30801b26 	beq	r6,r2,802e40 <f_lseek+0x1b8>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
  802dd4:	00800044 	movi	r2,1
  802dd8:	1180132e 	bgeu	r2,r6,802e28 <f_lseek+0x1a0>
  802ddc:	88800017 	ldw	r2,0(r17)
  802de0:	10800717 	ldw	r2,28(r2)
  802de4:	3080102e 	bgeu	r6,r2,802e28 <f_lseek+0x1a0>
					fp->clust = clst;
					fp->fptr += bcs;
  802de8:	88800217 	ldw	r2,8(r17)
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
  802dec:	89800515 	stw	r6,20(r17)
					fp->fptr += bcs;
  802df0:	14c5883a 	add	r2,r2,r19
  802df4:	88800215 	stw	r2,8(r17)
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
  802df8:	300b883a 	mov	r5,r6
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
  802dfc:	9cbfe536 	bltu	r19,r18,802d94 <f_lseek+0x10c>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
  802e00:	88800217 	ldw	r2,8(r17)
				if (ofs % SS(fp->fs)) {
  802e04:	90c07fcc 	andi	r3,r18,511
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
  802e08:	1485883a 	add	r2,r2,r18
  802e0c:	88800215 	stw	r2,8(r17)
				if (ofs % SS(fp->fs)) {
  802e10:	18001026 	beq	r3,zero,802e54 <f_lseek+0x1cc>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
  802e14:	89000017 	ldw	r4,0(r17)
  802e18:	300b883a 	mov	r5,r6
  802e1c:	08017d80 	call	8017d8 <clust2sect>
  802e20:	1007883a 	mov	r3,r2
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
  802e24:	1000031e 	bne	r2,zero,802e34 <f_lseek+0x1ac>
  802e28:	88800183 	ldbu	r2,6(r17)
  802e2c:	05400084 	movi	r21,2
  802e30:	00000506 	br	802e48 <f_lseek+0x1c0>
					nsect += ofs / SS(fp->fs);
  802e34:	9004d27a 	srli	r2,r18,9
  802e38:	1887883a 	add	r3,r3,r2
  802e3c:	00000606 	br	802e58 <f_lseek+0x1d0>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802e40:	88800183 	ldbu	r2,6(r17)
  802e44:	05400044 	movi	r21,1
  802e48:	00ffe004 	movi	r3,-128
  802e4c:	10c4b03a 	or	r2,r2,r3
  802e50:	00000d06 	br	802e88 <f_lseek+0x200>
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
  802e54:	0007883a 	mov	r3,zero
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
  802e58:	88800217 	ldw	r2,8(r17)
  802e5c:	10807fcc 	andi	r2,r2,511
  802e60:	10000326 	beq	r2,zero,802e70 <f_lseek+0x1e8>
  802e64:	88800617 	ldw	r2,24(r17)
  802e68:	18800126 	beq	r3,r2,802e70 <f_lseek+0x1e8>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
  802e6c:	88c00615 	stw	r3,24(r17)
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
  802e70:	88c00217 	ldw	r3,8(r17)
  802e74:	88800317 	ldw	r2,12(r17)
  802e78:	10c0042e 	bgeu	r2,r3,802e8c <f_lseek+0x204>
			fp->fsize = fp->fptr;
			fp->flag |= FA__WRITTEN;
  802e7c:	88800183 	ldbu	r2,6(r17)
#endif
			fp->dsect = nsect;
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
			fp->fsize = fp->fptr;
  802e80:	88c00315 	stw	r3,12(r17)
			fp->flag |= FA__WRITTEN;
  802e84:	10800814 	ori	r2,r2,32
  802e88:	88800185 	stb	r2,6(r17)
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
  802e8c:	a805883a 	mov	r2,r21
  802e90:	dfc00717 	ldw	ra,28(sp)
  802e94:	dd800617 	ldw	r22,24(sp)
  802e98:	dd400517 	ldw	r21,20(sp)
  802e9c:	dd000417 	ldw	r20,16(sp)
  802ea0:	dcc00317 	ldw	r19,12(sp)
  802ea4:	dc800217 	ldw	r18,8(sp)
  802ea8:	dc400117 	ldw	r17,4(sp)
  802eac:	dc000017 	ldw	r16,0(sp)
  802eb0:	dec00804 	addi	sp,sp,32
  802eb4:	f800283a 	ret

00802eb8 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  802eb8:	defff704 	addi	sp,sp,-36
  802ebc:	dc000015 	stw	r16,0(sp)
  802ec0:	2021883a 	mov	r16,r4
  802ec4:	dc400115 	stw	r17,4(sp)
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
  802ec8:	21000017 	ldw	r4,0(r4)
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  802ecc:	2823883a 	mov	r17,r5
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
  802ed0:	8140010b 	ldhu	r5,4(r16)
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
  802ed4:	38000015 	stw	zero,0(r7)
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  802ed8:	ddc00715 	stw	r23,28(sp)
  802edc:	dd400515 	stw	r21,20(sp)
  802ee0:	dd000415 	stw	r20,16(sp)
  802ee4:	dfc00815 	stw	ra,32(sp)
  802ee8:	dd800615 	stw	r22,24(sp)
  802eec:	dcc00315 	stw	r19,12(sp)
  802ef0:	dc800215 	stw	r18,8(sp)
  802ef4:	382f883a 	mov	r23,r7
  802ef8:	302b883a 	mov	r21,r6
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
  802efc:	0801ad80 	call	801ad8 <validate>
  802f00:	1029883a 	mov	r20,r2
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  802f04:	10008d1e 	bne	r2,zero,80313c <f_write+0x284>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
  802f08:	80c00183 	ldbu	r3,6(r16)
  802f0c:	18803fcc 	andi	r2,r3,255
  802f10:	1080201c 	xori	r2,r2,128
  802f14:	10bfe004 	addi	r2,r2,-128
  802f18:	1000020e 	bge	r2,zero,802f24 <f_write+0x6c>
  802f1c:	05000084 	movi	r20,2
  802f20:	00008606 	br	80313c <f_write+0x284>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
  802f24:	1880008c 	andi	r2,r3,2
  802f28:	10000d1e 	bne	r2,zero,802f60 <f_write+0xa8>
  802f2c:	050001c4 	movi	r20,7
  802f30:	00008206 	br	80313c <f_write+0x284>
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802f34:	80800183 	ldbu	r2,6(r16)
  802f38:	2029883a 	mov	r20,r4
  802f3c:	00000506 	br	802f54 <f_write+0x9c>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  802f40:	80800183 	ldbu	r2,6(r16)
  802f44:	05000084 	movi	r20,2
  802f48:	00000206 	br	802f54 <f_write+0x9c>
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
  802f4c:	80800183 	ldbu	r2,6(r16)
  802f50:	05000044 	movi	r20,1
  802f54:	00ffe004 	movi	r3,-128
  802f58:	10c4b03a 	or	r2,r2,r3
  802f5c:	00007606 	br	803138 <f_write+0x280>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
  802f60:	80c00317 	ldw	r3,12(r16)
  802f64:	1d45883a 	add	r2,r3,r21
  802f68:	10c0012e 	bgeu	r2,r3,802f70 <f_write+0xb8>
  802f6c:	002b883a 	mov	r21,zero
)
{
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
  802f70:	882d883a 	mov	r22,r17
  802f74:	00006906 	br	80311c <f_write+0x264>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
  802f78:	81400217 	ldw	r5,8(r16)
  802f7c:	28807fcc 	andi	r2,r5,511
  802f80:	1000481e 	bne	r2,zero,8030a4 <f_write+0x1ec>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  802f84:	81000017 	ldw	r4,0(r16)
  802f88:	2804d27a 	srli	r2,r5,9
  802f8c:	20c00083 	ldbu	r3,2(r4)
  802f90:	18ffffc4 	addi	r3,r3,-1
  802f94:	10e6703a 	and	r19,r2,r3
			if (!csect) {					/* On the cluster boundary? */
  802f98:	98803fcc 	andi	r2,r19,255
  802f9c:	1000101e 	bne	r2,zero,802fe0 <f_write+0x128>
				if (fp->fptr == 0) {		/* On the top of the file? */
  802fa0:	2800061e 	bne	r5,zero,802fbc <f_write+0x104>
					clst = fp->sclust;		/* Follow from the origin */
  802fa4:	80c00417 	ldw	r3,16(r16)
					if (clst == 0)			/* When no cluster is allocated, */
  802fa8:	1800081e 	bne	r3,zero,802fcc <f_write+0x114>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
  802fac:	0802b400 	call	802b40 <create_chain>
  802fb0:	1007883a 	mov	r3,r2
  802fb4:	80800415 	stw	r2,16(r16)
  802fb8:	00000306 	br	802fc8 <f_write+0x110>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  802fbc:	81400517 	ldw	r5,20(r16)
  802fc0:	0802b400 	call	802b40 <create_chain>
  802fc4:	1007883a 	mov	r3,r2
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  802fc8:	18005526 	beq	r3,zero,803120 <f_write+0x268>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  802fcc:	01000044 	movi	r4,1
  802fd0:	193fdb26 	beq	r3,r4,802f40 <f_write+0x88>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  802fd4:	00bfffc4 	movi	r2,-1
  802fd8:	18bfd626 	beq	r3,r2,802f34 <f_write+0x7c>
				fp->clust = clst;			/* Update current cluster */
  802fdc:	80c00515 	stw	r3,20(r16)
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
  802fe0:	81000017 	ldw	r4,0(r16)
  802fe4:	80c00617 	ldw	r3,24(r16)
  802fe8:	20800c17 	ldw	r2,48(r4)
  802fec:	10c0031e 	bne	r2,r3,802ffc <f_write+0x144>
  802ff0:	000b883a 	mov	r5,zero
  802ff4:	08021640 	call	802164 <move_window>
  802ff8:	103fd41e 	bne	r2,zero,802f4c <f_write+0x94>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  802ffc:	84800017 	ldw	r18,0(r16)
  803000:	81400517 	ldw	r5,20(r16)
  803004:	9009883a 	mov	r4,r18
  803008:	08017d80 	call	8017d8 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  80300c:	103fcc26 	beq	r2,zero,802f40 <f_write+0x88>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
  803010:	a822d27a 	srli	r17,r21,9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  803014:	98c03fcc 	andi	r3,r19,255
  803018:	10e7883a 	add	r19,r2,r3
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
  80301c:	88001726 	beq	r17,zero,80307c <f_write+0x1c4>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  803020:	91000083 	ldbu	r4,2(r18)
  803024:	1c45883a 	add	r2,r3,r17
  803028:	2080012e 	bgeu	r4,r2,803030 <f_write+0x178>
					cc = fp->fs->csize - csect;
  80302c:	20e3c83a 	sub	r17,r4,r3
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
  803030:	91000043 	ldbu	r4,1(r18)
  803034:	b00b883a 	mov	r5,r22
  803038:	980d883a 	mov	r6,r19
  80303c:	89c03fcc 	andi	r7,r17,255
  803040:	08015a40 	call	8015a4 <disk_write>
  803044:	103fc11e 	bne	r2,zero,802f4c <f_write+0x94>
					ABORT(fp->fs, FR_DISK_ERR);
#if _FS_TINY
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
  803048:	81000017 	ldw	r4,0(r16)
  80304c:	20800c17 	ldw	r2,48(r4)
  803050:	14c5c83a 	sub	r2,r2,r19
  803054:	1440072e 	bgeu	r2,r17,803074 <f_write+0x1bc>
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
  803058:	100a927a 	slli	r5,r2,9
  80305c:	21000d04 	addi	r4,r4,52
  803060:	01808004 	movi	r6,512
  803064:	b14b883a 	add	r5,r22,r5
  803068:	08017980 	call	801798 <mem_cpy>
					fp->fs->wflag = 0;
  80306c:	80800017 	ldw	r2,0(r16)
  803070:	10000105 	stb	zero,4(r2)
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->flag &= ~FA__DIRTY;
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
  803074:	8822927a 	slli	r17,r17,9
  803078:	00002006 	br	8030fc <f_write+0x244>
				continue;
			}
#if _FS_TINY
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
  80307c:	80c00217 	ldw	r3,8(r16)
  803080:	80800317 	ldw	r2,12(r16)
  803084:	18800636 	bltu	r3,r2,8030a0 <f_write+0x1e8>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
  803088:	9009883a 	mov	r4,r18
  80308c:	000b883a 	mov	r5,zero
  803090:	08021640 	call	802164 <move_window>
  803094:	103fad1e 	bne	r2,zero,802f4c <f_write+0x94>
				fp->fs->winsect = sect;
  803098:	80800017 	ldw	r2,0(r16)
  80309c:	14c00c15 	stw	r19,48(r2)
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  8030a0:	84c00615 	stw	r19,24(r16)
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
  8030a4:	81000017 	ldw	r4,0(r16)
  8030a8:	81400617 	ldw	r5,24(r16)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
  8030ac:	84400217 	ldw	r17,8(r16)
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
  8030b0:	08021640 	call	802164 <move_window>
  8030b4:	103fa51e 	bne	r2,zero,802f4c <f_write+0x94>
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
  8030b8:	88c07fcc 	andi	r3,r17,511
  8030bc:	00808004 	movi	r2,512
  8030c0:	10c5c83a 	sub	r2,r2,r3
  8030c4:	a823883a 	mov	r17,r21
  8030c8:	1540012e 	bgeu	r2,r21,8030d0 <f_write+0x218>
  8030cc:	1023883a 	mov	r17,r2
		if (wcnt > btw) wcnt = btw;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
  8030d0:	80800017 	ldw	r2,0(r16)
  8030d4:	81000217 	ldw	r4,8(r16)
  8030d8:	b00b883a 	mov	r5,r22
  8030dc:	10800d04 	addi	r2,r2,52
  8030e0:	21007fcc 	andi	r4,r4,511
  8030e4:	1109883a 	add	r4,r2,r4
  8030e8:	880d883a 	mov	r6,r17
  8030ec:	08017980 	call	801798 <mem_cpy>
		fp->fs->wflag = 1;
  8030f0:	80c00017 	ldw	r3,0(r16)
  8030f4:	00800044 	movi	r2,1
  8030f8:	18800105 	stb	r2,4(r3)
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
  8030fc:	80800217 	ldw	r2,8(r16)
  803100:	b8c00017 	ldw	r3,0(r23)
  803104:	ac6bc83a 	sub	r21,r21,r17
  803108:	1445883a 	add	r2,r2,r17
  80310c:	1c47883a 	add	r3,r3,r17
  803110:	80800215 	stw	r2,8(r16)
  803114:	b8c00015 	stw	r3,0(r23)
  803118:	b46d883a 	add	r22,r22,r17
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
  80311c:	a83f961e 	bne	r21,zero,802f78 <f_write+0xc0>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
  803120:	80c00217 	ldw	r3,8(r16)
  803124:	80800317 	ldw	r2,12(r16)
  803128:	10c0012e 	bgeu	r2,r3,803130 <f_write+0x278>
  80312c:	80c00315 	stw	r3,12(r16)
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
  803130:	80800183 	ldbu	r2,6(r16)
  803134:	10800814 	ori	r2,r2,32
  803138:	80800185 	stb	r2,6(r16)

	LEAVE_FF(fp->fs, FR_OK);
}
  80313c:	a005883a 	mov	r2,r20
  803140:	dfc00817 	ldw	ra,32(sp)
  803144:	ddc00717 	ldw	r23,28(sp)
  803148:	dd800617 	ldw	r22,24(sp)
  80314c:	dd400517 	ldw	r21,20(sp)
  803150:	dd000417 	ldw	r20,16(sp)
  803154:	dcc00317 	ldw	r19,12(sp)
  803158:	dc800217 	ldw	r18,8(sp)
  80315c:	dc400117 	ldw	r17,4(sp)
  803160:	dc000017 	ldw	r16,0(sp)
  803164:	dec00904 	addi	sp,sp,36
  803168:	f800283a 	ret

0080316c <dir_next>:
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  80316c:	2080018b 	ldhu	r2,6(r4)
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  803170:	defff804 	addi	sp,sp,-32
  803174:	dd800615 	stw	r22,24(sp)
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  803178:	15800044 	addi	r22,r2,1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  80317c:	b0ffffcc 	andi	r3,r22,65535
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  803180:	dcc00315 	stw	r19,12(sp)
  803184:	dc400115 	stw	r17,4(sp)
  803188:	dfc00715 	stw	ra,28(sp)
  80318c:	dd400515 	stw	r21,20(sp)
  803190:	dd000415 	stw	r20,16(sp)
  803194:	dc800215 	stw	r18,8(sp)
  803198:	dc000015 	stw	r16,0(sp)
  80319c:	2023883a 	mov	r17,r4
  8031a0:	2827883a 	mov	r19,r5
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  8031a4:	18005226 	beq	r3,zero,8032f0 <dir_next+0x184>
  8031a8:	20800417 	ldw	r2,16(r4)
  8031ac:	10005026 	beq	r2,zero,8032f0 <dir_next+0x184>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  8031b0:	1d4003cc 	andi	r21,r3,15
  8031b4:	a800461e 	bne	r21,zero,8032d0 <dir_next+0x164>
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  8031b8:	21400317 	ldw	r5,12(r4)
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  8031bc:	10800044 	addi	r2,r2,1
  8031c0:	20800415 	stw	r2,16(r4)
  8031c4:	05000044 	movi	r20,1
  8031c8:	21000017 	ldw	r4,0(r4)

		if (dj->clust == 0) {	/* Static table */
  8031cc:	2800031e 	bne	r5,zero,8031dc <dir_next+0x70>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  8031d0:	2080020b 	ldhu	r2,8(r4)
  8031d4:	18803e36 	bltu	r3,r2,8032d0 <dir_next+0x164>
  8031d8:	00004506 	br	8032f0 <dir_next+0x184>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  8031dc:	20800083 	ldbu	r2,2(r4)
  8031e0:	1806d13a 	srli	r3,r3,4
  8031e4:	043fffc4 	movi	r16,-1
  8031e8:	1405883a 	add	r2,r2,r16
  8031ec:	1886703a 	and	r3,r3,r2
  8031f0:	1800371e 	bne	r3,zero,8032d0 <dir_next+0x164>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
  8031f4:	08024240 	call	802424 <get_fat>
  8031f8:	1025883a 	mov	r18,r2
				if (clst <= 1) return FR_INT_ERR;
  8031fc:	a0803e2e 	bgeu	r20,r2,8032f8 <dir_next+0x18c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  803200:	14003f26 	beq	r2,r16,803300 <dir_next+0x194>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  803204:	89000017 	ldw	r4,0(r17)
  803208:	20800717 	ldw	r2,28(r4)
  80320c:	90802b36 	bltu	r18,r2,8032bc <dir_next+0x150>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  803210:	98003726 	beq	r19,zero,8032f0 <dir_next+0x184>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  803214:	89400317 	ldw	r5,12(r17)
  803218:	0802b400 	call	802b40 <create_chain>
  80321c:	1025883a 	mov	r18,r2
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  803220:	1000021e 	bne	r2,zero,80322c <dir_next+0xc0>
  803224:	010001c4 	movi	r4,7
  803228:	00003606 	br	803304 <dir_next+0x198>
					if (clst == 1) return FR_INT_ERR;
  80322c:	15003226 	beq	r2,r20,8032f8 <dir_next+0x18c>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  803230:	14003326 	beq	r2,r16,803300 <dir_next+0x194>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  803234:	89000017 	ldw	r4,0(r17)
  803238:	000b883a 	mov	r5,zero
  80323c:	08021640 	call	802164 <move_window>
  803240:	10002f1e 	bne	r2,zero,803300 <dir_next+0x194>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  803244:	89000017 	ldw	r4,0(r17)
  803248:	000b883a 	mov	r5,zero
  80324c:	01808004 	movi	r6,512
  803250:	21000d04 	addi	r4,r4,52
  803254:	08017bc0 	call	8017bc <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  803258:	8c000017 	ldw	r16,0(r17)
  80325c:	900b883a 	mov	r5,r18
  803260:	0027883a 	mov	r19,zero
  803264:	8009883a 	mov	r4,r16
  803268:	08017d80 	call	8017d8 <clust2sect>
  80326c:	80800c15 	stw	r2,48(r16)
  803270:	00000906 	br	803298 <dir_next+0x12c>
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
  803274:	00800044 	movi	r2,1
  803278:	18800105 	stb	r2,4(r3)
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  80327c:	89000017 	ldw	r4,0(r17)
  803280:	08021640 	call	802164 <move_window>
  803284:	10001e1e 	bne	r2,zero,803300 <dir_next+0x194>
						dj->fs->winsect++;
  803288:	88c00017 	ldw	r3,0(r17)
  80328c:	18800c17 	ldw	r2,48(r3)
  803290:	10800044 	addi	r2,r2,1
  803294:	18800c15 	stw	r2,48(r3)
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  803298:	88c00017 	ldw	r3,0(r17)
  80329c:	99003fcc 	andi	r4,r19,255
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  8032a0:	000b883a 	mov	r5,zero
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  8032a4:	18800083 	ldbu	r2,2(r3)
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  8032a8:	9cc00044 	addi	r19,r19,1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  8032ac:	20bff136 	bltu	r4,r2,803274 <dir_next+0x108>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  8032b0:	18800c17 	ldw	r2,48(r3)
  8032b4:	1105c83a 	sub	r2,r2,r4
  8032b8:	18800c15 	stw	r2,48(r3)
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  8032bc:	89000017 	ldw	r4,0(r17)
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  8032c0:	8c800315 	stw	r18,12(r17)
				dj->sect = clust2sect(dj->fs, clst);
  8032c4:	900b883a 	mov	r5,r18
  8032c8:	08017d80 	call	8017d8 <clust2sect>
  8032cc:	88800415 	stw	r2,16(r17)
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  8032d0:	88800017 	ldw	r2,0(r17)
  8032d4:	a806917a 	slli	r3,r21,5
  8032d8:	0009883a 	mov	r4,zero
  8032dc:	10800d04 	addi	r2,r2,52
  8032e0:	10c5883a 	add	r2,r2,r3
  8032e4:	88800515 	stw	r2,20(r17)
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  8032e8:	8d80018d 	sth	r22,6(r17)
  8032ec:	00000506 	br	803304 <dir_next+0x198>
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  8032f0:	01000104 	movi	r4,4
  8032f4:	00000306 	br	803304 <dir_next+0x198>
  8032f8:	01000084 	movi	r4,2
  8032fc:	00000106 	br	803304 <dir_next+0x198>
  803300:	01000044 	movi	r4,1
}
  803304:	2005883a 	mov	r2,r4
  803308:	dfc00717 	ldw	ra,28(sp)
  80330c:	dd800617 	ldw	r22,24(sp)
  803310:	dd400517 	ldw	r21,20(sp)
  803314:	dd000417 	ldw	r20,16(sp)
  803318:	dcc00317 	ldw	r19,12(sp)
  80331c:	dc800217 	ldw	r18,8(sp)
  803320:	dc400117 	ldw	r17,4(sp)
  803324:	dc000017 	ldw	r16,0(sp)
  803328:	dec00804 	addi	sp,sp,32
  80332c:	f800283a 	ret

00803330 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  803330:	defffc04 	addi	sp,sp,-16
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
  803334:	000b883a 	mov	r5,zero
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  803338:	dc800215 	stw	r18,8(sp)
  80333c:	dfc00315 	stw	ra,12(sp)
  803340:	dc400115 	stw	r17,4(sp)
  803344:	dc000015 	stw	r16,0(sp)
  803348:	2025883a 	mov	r18,r4
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
  80334c:	08029c40 	call	8029c4 <dir_sdi>
  803350:	1023883a 	mov	r17,r2
	if (res == FR_OK) {
  803354:	1000201e 	bne	r2,zero,8033d8 <dir_register+0xa8>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
  803358:	91000017 	ldw	r4,0(r18)
  80335c:	91400417 	ldw	r5,16(r18)
  803360:	08021640 	call	802164 <move_window>
  803364:	1023883a 	mov	r17,r2
			if (res != FR_OK) break;
			c = *dj->dir;
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
			res = dir_next(dj, 1);			/* Next entry with table stretch */
  803368:	9009883a 	mov	r4,r18
  80336c:	01400044 	movi	r5,1
#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
	if (res == FR_OK) {
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
  803370:	1000191e 	bne	r2,zero,8033d8 <dir_register+0xa8>
			c = *dj->dir;
  803374:	90800517 	ldw	r2,20(r18)
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
  803378:	10c00003 	ldbu	r3,0(r2)
  80337c:	00803944 	movi	r2,229
  803380:	18801026 	beq	r3,r2,8033c4 <dir_register+0x94>
  803384:	18000f26 	beq	r3,zero,8033c4 <dir_register+0x94>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
  803388:	080316c0 	call	80316c <dir_next>
  80338c:	003ff006 	br	803350 <dir_register+0x20>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
  803390:	94000517 	ldw	r16,20(r18)
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
  803394:	000b883a 	mov	r5,zero
  803398:	01800804 	movi	r6,32
  80339c:	8009883a 	mov	r4,r16
  8033a0:	08017bc0 	call	8017bc <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  8033a4:	91400617 	ldw	r5,24(r18)
  8033a8:	8009883a 	mov	r4,r16
  8033ac:	018002c4 	movi	r6,11
  8033b0:	08017980 	call	801798 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
  8033b4:	90c00017 	ldw	r3,0(r18)
  8033b8:	00800044 	movi	r2,1
  8033bc:	18800105 	stb	r2,4(r3)
  8033c0:	00000506 	br	8033d8 <dir_register+0xa8>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  8033c4:	91000017 	ldw	r4,0(r18)
  8033c8:	91400417 	ldw	r5,16(r18)
  8033cc:	08021640 	call	802164 <move_window>
  8033d0:	1023883a 	mov	r17,r2
		if (res == FR_OK) {
  8033d4:	103fee26 	beq	r2,zero,803390 <dir_register+0x60>
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  8033d8:	8805883a 	mov	r2,r17
  8033dc:	dfc00317 	ldw	ra,12(sp)
  8033e0:	dc800217 	ldw	r18,8(sp)
  8033e4:	dc400117 	ldw	r17,4(sp)
  8033e8:	dc000017 	ldw	r16,0(sp)
  8033ec:	dec00404 	addi	sp,sp,16
  8033f0:	f800283a 	ret

008033f4 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
  8033f4:	defffe04 	addi	sp,sp,-8
  8033f8:	dc000015 	stw	r16,0(sp)
  8033fc:	01c00104 	movi	r7,4
  803400:	2021883a 	mov	r16,r4
  803404:	dfc00115 	stw	ra,4(sp)
  803408:	00001106 	br	803450 <dir_read+0x5c>
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  80340c:	81000017 	ldw	r4,0(r16)
  803410:	08021640 	call	802164 <move_window>
  803414:	100f883a 	mov	r7,r2
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
  803418:	8009883a 	mov	r4,r16
  80341c:	000b883a 	mov	r5,zero
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  803420:	10000f1e 	bne	r2,zero,803460 <dir_read+0x6c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  803424:	81800517 	ldw	r6,20(r16)
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  803428:	30c00003 	ldbu	r3,0(r6)
  80342c:	18000e26 	beq	r3,zero,803468 <dir_read+0x74>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
  803430:	00803944 	movi	r2,229
  803434:	18800326 	beq	r3,r2,803444 <dir_read+0x50>
  803438:	308002c3 	ldbu	r2,11(r6)
  80343c:	1080020c 	andi	r2,r2,8
  803440:	10000b26 	beq	r2,zero,803470 <dir_read+0x7c>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
  803444:	080316c0 	call	80316c <dir_next>
  803448:	100f883a 	mov	r7,r2
		if (res != FR_OK) break;
  80344c:	1000041e 	bne	r2,zero,803460 <dir_read+0x6c>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  803450:	80800417 	ldw	r2,16(r16)
		res = move_window(dj->fs, dj->sect);
  803454:	100b883a 	mov	r5,r2
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  803458:	103fec1e 	bne	r2,zero,80340c <dir_read+0x18>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  80345c:	38000426 	beq	r7,zero,803470 <dir_read+0x7c>
  803460:	80000415 	stw	zero,16(r16)
  803464:	00000206 	br	803470 <dir_read+0x7c>
  803468:	01c00104 	movi	r7,4
  80346c:	003ffc06 	br	803460 <dir_read+0x6c>

	return res;
}
  803470:	3805883a 	mov	r2,r7
  803474:	dfc00117 	ldw	ra,4(sp)
  803478:	dc000017 	ldw	r16,0(sp)
  80347c:	dec00204 	addi	sp,sp,8
  803480:	f800283a 	ret

00803484 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  803484:	defff904 	addi	sp,sp,-28
  803488:	dc000315 	stw	r16,12(sp)
  80348c:	2021883a 	mov	r16,r4
  803490:	dc800515 	stw	r18,20(sp)
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  803494:	21000017 	ldw	r4,0(r4)

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  803498:	2825883a 	mov	r18,r5
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  80349c:	8140010b 	ldhu	r5,4(r16)

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  8034a0:	dc400415 	stw	r17,16(sp)
  8034a4:	dfc00615 	stw	ra,24(sp)
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  8034a8:	0801ad80 	call	801ad8 <validate>
  8034ac:	1023883a 	mov	r17,r2
	if (res == FR_OK) {
  8034b0:	10001b1e 	bne	r2,zero,803520 <f_readdir+0x9c>
		if (!fno) {
  8034b4:	9000051e 	bne	r18,zero,8034cc <f_readdir+0x48>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
  8034b8:	8009883a 	mov	r4,r16
  8034bc:	000b883a 	mov	r5,zero
  8034c0:	08029c40 	call	8029c4 <dir_sdi>
  8034c4:	1023883a 	mov	r17,r2
  8034c8:	00001506 	br	803520 <f_readdir+0x9c>
		} else {
			INIT_BUF(*dj);
  8034cc:	86c00615 	stw	sp,24(r16)
			res = dir_read(dj);				/* Read an directory item */
  8034d0:	8009883a 	mov	r4,r16
  8034d4:	08033f40 	call	8033f4 <dir_read>
  8034d8:	1007883a 	mov	r3,r2
			if (res == FR_NO_FILE) {		/* Reached end of dir */
  8034dc:	00800104 	movi	r2,4
  8034e0:	1880021e 	bne	r3,r2,8034ec <f_readdir+0x68>
				dj->sect = 0;
  8034e4:	80000415 	stw	zero,16(r16)
  8034e8:	00000106 	br	8034f0 <f_readdir+0x6c>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
  8034ec:	1800091e 	bne	r3,zero,803514 <f_readdir+0x90>
				get_fileinfo(dj, fno);		/* Get the object information */
  8034f0:	900b883a 	mov	r5,r18
  8034f4:	8009883a 	mov	r4,r16
  8034f8:	08018240 	call	801824 <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
  8034fc:	8009883a 	mov	r4,r16
  803500:	000b883a 	mov	r5,zero
  803504:	080316c0 	call	80316c <dir_next>
  803508:	1007883a 	mov	r3,r2
				if (res == FR_NO_FILE) {
  80350c:	00800104 	movi	r2,4
  803510:	18800226 	beq	r3,r2,80351c <f_readdir+0x98>
  803514:	1823883a 	mov	r17,r3
  803518:	00000106 	br	803520 <f_readdir+0x9c>
					dj->sect = 0;
  80351c:	80000415 	stw	zero,16(r16)
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
  803520:	8805883a 	mov	r2,r17
  803524:	dfc00617 	ldw	ra,24(sp)
  803528:	dc800517 	ldw	r18,20(sp)
  80352c:	dc400417 	ldw	r17,16(sp)
  803530:	dc000317 	ldw	r16,12(sp)
  803534:	dec00704 	addi	sp,sp,28
  803538:	f800283a 	ret

0080353c <f_getcwd>:
#if _FS_RPATH >= 2
FRESULT f_getcwd (
	TCHAR *path,	/* Pointer to the directory path */
	UINT sz_path	/* Size of path */
)
{
  80353c:	deffe904 	addi	sp,sp,-92
  803540:	dcc01415 	stw	r19,80(sp)
  803544:	dc801315 	stw	r18,76(sp)
  803548:	d9001015 	stw	r4,64(sp)
  80354c:	dfc01615 	stw	ra,88(sp)
  803550:	dd001515 	stw	r20,84(sp)
  803554:	dc401215 	stw	r17,72(sp)
  803558:	dc001115 	stw	r16,68(sp)
	TCHAR *tp;
	FILINFO fno;
	DEF_NAMEBUF;


	*path = 0;
  80355c:	20000005 	stb	zero,0(r4)
#if _FS_RPATH >= 2
FRESULT f_getcwd (
	TCHAR *path,	/* Pointer to the directory path */
	UINT sz_path	/* Size of path */
)
{
  803560:	2827883a 	mov	r19,r5
	FILINFO fno;
	DEF_NAMEBUF;


	*path = 0;
	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
  803564:	d9001004 	addi	r4,sp,64
  803568:	d9400904 	addi	r5,sp,36
  80356c:	000d883a 	mov	r6,zero
  803570:	0801c0c0 	call	801c0c <chk_mounted>
  803574:	1025883a 	mov	r18,r2
	if (res == FR_OK) {
  803578:	1000771e 	bne	r2,zero,803758 <f_getcwd+0x21c>
		INIT_BUF(dj);
		i = sz_path;		/* Bottom of buffer (dir stack base) */
		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
  80357c:	d8800917 	ldw	r2,36(sp)
  803580:	9823883a 	mov	r17,r19


	*path = 0;
	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
	if (res == FR_OK) {
		INIT_BUF(dj);
  803584:	dec00f15 	stw	sp,60(sp)
		i = sz_path;		/* Bottom of buffer (dir stack base) */
		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
  803588:	10800617 	ldw	r2,24(r2)
  80358c:	d8800b15 	stw	r2,44(sp)
  803590:	00005106 	br	8036d8 <f_getcwd+0x19c>
		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
			res = dir_sdi(&dj, 1);			/* Get parent dir */
  803594:	dc000904 	addi	r16,sp,36
  803598:	8009883a 	mov	r4,r16
  80359c:	01400044 	movi	r5,1
  8035a0:	08029c40 	call	8029c4 <dir_sdi>
  8035a4:	1007883a 	mov	r3,r2
			if (res != FR_OK) break;
  8035a8:	10005f1e 	bne	r2,zero,803728 <f_getcwd+0x1ec>
			res = dir_read(&dj);
  8035ac:	8009883a 	mov	r4,r16
  8035b0:	08033f40 	call	8033f4 <dir_read>
  8035b4:	1007883a 	mov	r3,r2
			if (res != FR_OK) break;
  8035b8:	10005b1e 	bne	r2,zero,803728 <f_getcwd+0x1ec>
			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
  8035bc:	d9800e17 	ldw	r6,56(sp)
			res = dir_sdi(&dj, 0);
  8035c0:	8009883a 	mov	r4,r16
  8035c4:	000b883a 	mov	r5,zero
		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
			res = dir_sdi(&dj, 1);			/* Get parent dir */
			if (res != FR_OK) break;
			res = dir_read(&dj);
			if (res != FR_OK) break;
			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
  8035c8:	30800543 	ldbu	r2,21(r6)
  8035cc:	31c00503 	ldbu	r7,20(r6)
  8035d0:	30c006c3 	ldbu	r3,27(r6)
  8035d4:	1004923a 	slli	r2,r2,8
  8035d8:	31800683 	ldbu	r6,26(r6)
  8035dc:	1806923a 	slli	r3,r3,8
  8035e0:	11c4b03a 	or	r2,r2,r7
  8035e4:	1004943a 	slli	r2,r2,16
  8035e8:	1986b03a 	or	r3,r3,r6
  8035ec:	10c4b03a 	or	r2,r2,r3
  8035f0:	d8800b15 	stw	r2,44(sp)
			res = dir_sdi(&dj, 0);
  8035f4:	08029c40 	call	8029c4 <dir_sdi>
  8035f8:	1007883a 	mov	r3,r2
			if (res != FR_OK) break;
  8035fc:	10004a1e 	bne	r2,zero,803728 <f_getcwd+0x1ec>
			do {							/* Find the entry links to the child dir */
				res = dir_read(&dj);
  803600:	dc000904 	addi	r16,sp,36
  803604:	8009883a 	mov	r4,r16
  803608:	08033f40 	call	8033f4 <dir_read>
  80360c:	1007883a 	mov	r3,r2
				if (res != FR_OK) break;
				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
				res = dir_next(&dj, 0);	
  803610:	8009883a 	mov	r4,r16
  803614:	000b883a 	mov	r5,zero
			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
			res = dir_sdi(&dj, 0);
			if (res != FR_OK) break;
			do {							/* Find the entry links to the child dir */
				res = dir_read(&dj);
				if (res != FR_OK) break;
  803618:	10000f1e 	bne	r2,zero,803658 <f_getcwd+0x11c>
				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
  80361c:	d8c00e17 	ldw	r3,56(sp)
  803620:	18800543 	ldbu	r2,21(r3)
  803624:	19c00503 	ldbu	r7,20(r3)
  803628:	198006c3 	ldbu	r6,27(r3)
  80362c:	1004923a 	slli	r2,r2,8
  803630:	18c00683 	ldbu	r3,26(r3)
  803634:	300c923a 	slli	r6,r6,8
  803638:	11c4b03a 	or	r2,r2,r7
  80363c:	1004943a 	slli	r2,r2,16
  803640:	30ccb03a 	or	r6,r6,r3
  803644:	1184b03a 	or	r2,r2,r6
  803648:	a0800626 	beq	r20,r2,803664 <f_getcwd+0x128>
				res = dir_next(&dj, 0);	
  80364c:	080316c0 	call	80316c <dir_next>
  803650:	1007883a 	mov	r3,r2
			} while (res == FR_OK);
  803654:	103fea26 	beq	r2,zero,803600 <f_getcwd+0xc4>
			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
  803658:	00800104 	movi	r2,4
  80365c:	18802e26 	beq	r3,r2,803718 <f_getcwd+0x1dc>
			if (res != FR_OK) break;
  803660:	1800311e 	bne	r3,zero,803728 <f_getcwd+0x1ec>
#if _USE_LFN
			fno.lfname = path;
			fno.lfsize = i;
#endif
			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
  803664:	dc000304 	addi	r16,sp,12
  803668:	d9000904 	addi	r4,sp,36
  80366c:	800b883a 	mov	r5,r16
  803670:	08018240 	call	801824 <get_fileinfo>
  803674:	00000106 	br	80367c <f_getcwd+0x140>
			tp = fno.fname;
			if (_USE_LFN && *path) tp = path;
			for (n = 0; tp[n]; n++) ;
  803678:	84000044 	addi	r16,r16,1
  80367c:	80800247 	ldb	r2,9(r16)
  803680:	103ffd1e 	bne	r2,zero,803678 <f_getcwd+0x13c>
#if _FS_RPATH >= 2
FRESULT f_getcwd (
	TCHAR *path,	/* Pointer to the directory path */
	UINT sz_path	/* Size of path */
)
{
  803684:	d8c00304 	addi	r3,sp,12
  803688:	80e1c83a 	sub	r16,r16,r3
#endif
			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
			tp = fno.fname;
			if (_USE_LFN && *path) tp = path;
			for (n = 0; tp[n]; n++) ;
			if (i < n + 3) {
  80368c:	808000c4 	addi	r2,r16,3
  803690:	88802436 	bltu	r17,r2,803724 <f_getcwd+0x1e8>
  803694:	180d883a 	mov	r6,r3
  803698:	880b883a 	mov	r5,r17
  80369c:	8009883a 	mov	r4,r16
  8036a0:	00000506 	br	8036b8 <f_getcwd+0x17c>
				res = FR_NOT_ENOUGH_CORE; break;
			}
			while (n) path[--i] = tp[--n];
  8036a4:	213fffc4 	addi	r4,r4,-1
  8036a8:	1945883a 	add	r2,r3,r5
  8036ac:	3107883a 	add	r3,r6,r4
  8036b0:	18c00243 	ldbu	r3,9(r3)
  8036b4:	10c00005 	stb	r3,0(r2)
  8036b8:	297fffc4 	addi	r5,r5,-1
  8036bc:	d8c01017 	ldw	r3,64(sp)
  8036c0:	203ff81e 	bne	r4,zero,8036a4 <f_getcwd+0x168>
  8036c4:	8c05c83a 	sub	r2,r17,r16
			path[--i] = '/';
  8036c8:	147fffc4 	addi	r17,r2,-1
  8036cc:	1c47883a 	add	r3,r3,r17
  8036d0:	00800bc4 	movi	r2,47
  8036d4:	18800005 	stb	r2,0(r3)
	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
	if (res == FR_OK) {
		INIT_BUF(dj);
		i = sz_path;		/* Bottom of buffer (dir stack base) */
		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
  8036d8:	dd000b17 	ldw	r20,44(sp)
  8036dc:	a03fad1e 	bne	r20,zero,803594 <f_getcwd+0x58>
  8036e0:	00001406 	br	803734 <f_getcwd+0x1f8>
		tp = path;
		if (res == FR_OK) {
			*tp++ = '0' + CurrVol;			/* Put drive number */
			*tp++ = ':';
			if (i == sz_path) {				/* Root-dir */
				*tp++ = '/';
  8036e4:	00800bc4 	movi	r2,47
  8036e8:	20800005 	stb	r2,0(r4)
  8036ec:	21000044 	addi	r4,r4,1
  8036f0:	00000706 	br	803710 <f_getcwd+0x1d4>
			} else {						/* Sub-dir */
				do		/* Add stacked path str */
					*tp++ = path[i++];
  8036f4:	d8801017 	ldw	r2,64(sp)
  8036f8:	1445883a 	add	r2,r2,r17
  8036fc:	10800003 	ldbu	r2,0(r2)
  803700:	8c400044 	addi	r17,r17,1
  803704:	20800005 	stb	r2,0(r4)
  803708:	21000044 	addi	r4,r4,1
				while (i < sz_path);
  80370c:	8cfff936 	bltu	r17,r19,8036f4 <f_getcwd+0x1b8>
			}
		}
		*tp = 0;
  803710:	20000005 	stb	zero,0(r4)
  803714:	00001006 	br	803758 <f_getcwd+0x21c>
				res = FR_NOT_ENOUGH_CORE; break;
			}
			while (n) path[--i] = tp[--n];
			path[--i] = '/';
		}
		tp = path;
  803718:	d9001017 	ldw	r4,64(sp)
  80371c:	04800084 	movi	r18,2
  803720:	003ffb06 	br	803710 <f_getcwd+0x1d4>
  803724:	00c00444 	movi	r3,17
  803728:	d9001017 	ldw	r4,64(sp)
  80372c:	1825883a 	mov	r18,r3
  803730:	003ff706 	br	803710 <f_getcwd+0x1d4>
		if (res == FR_OK) {
			*tp++ = '0' + CurrVol;			/* Put drive number */
  803734:	d0e6ea83 	ldbu	r3,-25686(gp)
				res = FR_NOT_ENOUGH_CORE; break;
			}
			while (n) path[--i] = tp[--n];
			path[--i] = '/';
		}
		tp = path;
  803738:	d8801017 	ldw	r2,64(sp)
		if (res == FR_OK) {
			*tp++ = '0' + CurrVol;			/* Put drive number */
  80373c:	18c00c04 	addi	r3,r3,48
  803740:	10c00005 	stb	r3,0(r2)
			*tp++ = ':';
  803744:	00c00e84 	movi	r3,58
  803748:	10c00045 	stb	r3,1(r2)
  80374c:	11000084 	addi	r4,r2,2
			if (i == sz_path) {				/* Root-dir */
  803750:	8cffe81e 	bne	r17,r19,8036f4 <f_getcwd+0x1b8>
  803754:	003fe306 	br	8036e4 <f_getcwd+0x1a8>
		*tp = 0;
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  803758:	9005883a 	mov	r2,r18
  80375c:	dfc01617 	ldw	ra,88(sp)
  803760:	dd001517 	ldw	r20,84(sp)
  803764:	dcc01417 	ldw	r19,80(sp)
  803768:	dc801317 	ldw	r18,76(sp)
  80376c:	dc401217 	ldw	r17,72(sp)
  803770:	dc001117 	ldw	r16,68(sp)
  803774:	dec01704 	addi	sp,sp,92
  803778:	f800283a 	ret

0080377c <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  80377c:	defffc04 	addi	sp,sp,-16
  803780:	dc400115 	stw	r17,4(sp)
  803784:	dc000015 	stw	r16,0(sp)
  803788:	dfc00315 	stw	ra,12(sp)
  80378c:	dc800215 	stw	r18,8(sp)
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
  803790:	28c00007 	ldb	r3,0(r5)
  803794:	00800bc4 	movi	r2,47
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  803798:	2821883a 	mov	r16,r5
  80379c:	2023883a 	mov	r17,r4
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
  8037a0:	18800226 	beq	r3,r2,8037ac <follow_path+0x30>
  8037a4:	00801704 	movi	r2,92
  8037a8:	1880031e 	bne	r3,r2,8037b8 <follow_path+0x3c>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
  8037ac:	84000044 	addi	r16,r16,1
  8037b0:	88000215 	stw	zero,8(r17)
  8037b4:	00000306 	br	8037c4 <follow_path+0x48>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
  8037b8:	20800017 	ldw	r2,0(r4)
  8037bc:	10800617 	ldw	r2,24(r2)
  8037c0:	20800215 	stw	r2,8(r4)
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  8037c4:	80c00003 	ldbu	r3,0(r16)
  8037c8:	008007c4 	movi	r2,31
  8037cc:	10c00736 	bltu	r2,r3,8037ec <follow_path+0x70>
		res = dir_sdi(dj, 0);
  8037d0:	000b883a 	mov	r5,zero
  8037d4:	8809883a 	mov	r4,r17
  8037d8:	08029c40 	call	8029c4 <dir_sdi>
  8037dc:	100b883a 	mov	r5,r2
		dj->dir = 0;
  8037e0:	88000515 	stw	zero,20(r17)
  8037e4:	0000ed06 	br	803b9c <follow_path+0x420>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  8037e8:	84000044 	addi	r16,r16,1
  8037ec:	80c00007 	ldb	r3,0(r16)
  8037f0:	00800bc4 	movi	r2,47
  8037f4:	18bffc26 	beq	r3,r2,8037e8 <follow_path+0x6c>
  8037f8:	00801704 	movi	r2,92
  8037fc:	18bffa26 	beq	r3,r2,8037e8 <follow_path+0x6c>
	sfn = dj->fn;
  803800:	8c800617 	ldw	r18,24(r17)
	mem_set(sfn, ' ', 11);
  803804:	01400804 	movi	r5,32
  803808:	018002c4 	movi	r6,11
  80380c:	9009883a 	mov	r4,r18
  803810:	08017bc0 	call	8017bc <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
  803814:	81400007 	ldb	r5,0(r16)
  803818:	00800b84 	movi	r2,46
  80381c:	28800526 	beq	r5,r2,803834 <follow_path+0xb8>
  803820:	000f883a 	mov	r7,zero
  803824:	02400204 	movi	r9,8
  803828:	0011883a 	mov	r8,zero
  80382c:	000d883a 	mov	r6,zero
  803830:	00002606 	br	8038cc <follow_path+0x150>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
  803834:	91400005 	stb	r5,0(r18)
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
  803838:	80c00043 	ldbu	r3,1(r16)
			if (c != '.' || si >= 3) break;
  80383c:	19003fcc 	andi	r4,r3,255
  803840:	2100201c 	xori	r4,r4,128
  803844:	213fe004 	addi	r4,r4,-128
  803848:	21400226 	beq	r4,r5,803854 <follow_path+0xd8>
  80384c:	01400084 	movi	r5,2
  803850:	00000906 	br	803878 <follow_path+0xfc>
			sfn[i++] = c;
  803854:	91000045 	stb	r4,1(r18)
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
  803858:	80c00083 	ldbu	r3,2(r16)
			if (c != '.' || si >= 3) break;
  80385c:	18803fcc 	andi	r2,r3,255
  803860:	1080201c 	xori	r2,r2,128
  803864:	10bfe004 	addi	r2,r2,-128
  803868:	1100021e 	bne	r2,r4,803874 <follow_path+0xf8>
  80386c:	014000c4 	movi	r5,3
  803870:	00000806 	br	803894 <follow_path+0x118>
  803874:	014000c4 	movi	r5,3
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
  803878:	19003fcc 	andi	r4,r3,255
  80387c:	2100201c 	xori	r4,r4,128
  803880:	213fe004 	addi	r4,r4,-128
  803884:	00800bc4 	movi	r2,47
  803888:	20800626 	beq	r4,r2,8038a4 <follow_path+0x128>
  80388c:	00801704 	movi	r2,92
  803890:	20800426 	beq	r4,r2,8038a4 <follow_path+0x128>
  803894:	18c03fcc 	andi	r3,r3,255
  803898:	00800804 	movi	r2,32
  80389c:	10c0b02e 	bgeu	r2,r3,803b60 <follow_path+0x3e4>
  8038a0:	0000ab06 	br	803b50 <follow_path+0x3d4>
		*path = &p[si];									/* Return pointer to the next segment */
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
  8038a4:	18803fcc 	andi	r2,r3,255
  8038a8:	01000804 	movi	r4,32
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
  8038ac:	8161883a 	add	r16,r16,r5
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
  8038b0:	90c002c4 	addi	r3,r18,11
  8038b4:	2080022e 	bgeu	r4,r2,8038c0 <follow_path+0x144>
  8038b8:	2005883a 	mov	r2,r4
  8038bc:	00000106 	br	8038c4 <follow_path+0x148>
  8038c0:	00800904 	movi	r2,36
  8038c4:	18800005 	stb	r2,0(r3)
  8038c8:	0000ab06 	br	803b78 <follow_path+0x3fc>
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
  8038cc:	8205883a 	add	r2,r16,r8
  8038d0:	11000003 	ldbu	r4,0(r2)
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
  8038d4:	00800804 	movi	r2,32
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
  8038d8:	42000044 	addi	r8,r8,1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
  8038dc:	21403fcc 	andi	r5,r4,255
  8038e0:	1140462e 	bgeu	r2,r5,8039fc <follow_path+0x280>
  8038e4:	20c03fcc 	andi	r3,r4,255
  8038e8:	18c0201c 	xori	r3,r3,128
  8038ec:	18ffe004 	addi	r3,r3,-128
  8038f0:	00800bc4 	movi	r2,47
  8038f4:	18809d26 	beq	r3,r2,803b6c <follow_path+0x3f0>
  8038f8:	00801704 	movi	r2,92
  8038fc:	18809b26 	beq	r3,r2,803b6c <follow_path+0x3f0>
		if (c == '.' || i >= ni) {
  803900:	00800b84 	movi	r2,46
  803904:	18800126 	beq	r3,r2,80390c <follow_path+0x190>
  803908:	32400836 	bltu	r6,r9,80392c <follow_path+0x1b0>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
  80390c:	01000204 	movi	r4,8
  803910:	49008f1e 	bne	r9,r4,803b50 <follow_path+0x3d4>
  803914:	18808e1e 	bne	r3,r2,803b50 <follow_path+0x3d4>
			i = 8; ni = 11;
			b <<= 2; continue;
  803918:	39c5883a 	add	r2,r7,r7
  80391c:	108f883a 	add	r7,r2,r2
  803920:	200d883a 	mov	r6,r4
  803924:	024002c4 	movi	r9,11
  803928:	003fe806 	br	8038cc <follow_path+0x150>
		}
		if (c >= 0x80) {				/* Extended char? */
  80392c:	1800010e 	bge	r3,zero,803934 <follow_path+0x1b8>
			b |= 3;						/* Eliminate NT flag */
  803930:	39c000d4 	ori	r7,r7,3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
  803934:	20801fc4 	addi	r2,r4,127
  803938:	10803fcc 	andi	r2,r2,255
  80393c:	00c00784 	movi	r3,30
  803940:	1880042e 	bgeu	r3,r2,803954 <follow_path+0x1d8>
  803944:	20800804 	addi	r2,r4,32
  803948:	10803fcc 	andi	r2,r2,255
  80394c:	00c00704 	movi	r3,28
  803950:	18801436 	bltu	r3,r2,8039a4 <follow_path+0x228>
			d = (BYTE)p[si++];			/* Get 2nd byte */
  803954:	8205883a 	add	r2,r16,r8
  803958:	11400003 	ldbu	r5,0(r2)
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
  80395c:	00c00f84 	movi	r3,62
  803960:	28bff004 	addi	r2,r5,-64
  803964:	10803fcc 	andi	r2,r2,255
  803968:	1880042e 	bgeu	r3,r2,80397c <follow_path+0x200>
  80396c:	28bfe004 	addi	r2,r5,-128
  803970:	10803fcc 	andi	r2,r2,255
  803974:	00c01f04 	movi	r3,124
  803978:	18807536 	bltu	r3,r2,803b50 <follow_path+0x3d4>
  80397c:	48bfffc4 	addi	r2,r9,-1
  803980:	3080732e 	bgeu	r6,r2,803b50 <follow_path+0x3d4>
				return FR_INVALID_NAME;
			sfn[i++] = c;
  803984:	9187883a 	add	r3,r18,r6
  803988:	30800044 	addi	r2,r6,1
  80398c:	19000005 	stb	r4,0(r3)
			sfn[i++] = d;
  803990:	9085883a 	add	r2,r18,r2
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
  803994:	42000044 	addi	r8,r8,1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
  803998:	31800084 	addi	r6,r6,2
  80399c:	11400005 	stb	r5,0(r2)
  8039a0:	003fca06 	br	8038cc <follow_path+0x150>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
  8039a4:	00c02074 	movhi	r3,129
  8039a8:	18de0104 	addi	r3,r3,30724
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  8039ac:	18800007 	ldb	r2,0(r3)
  8039b0:	18c00044 	addi	r3,r3,1
  8039b4:	10000226 	beq	r2,zero,8039c0 <follow_path+0x244>
  8039b8:	117ffc1e 	bne	r2,r5,8039ac <follow_path+0x230>
  8039bc:	00006406 	br	803b50 <follow_path+0x3d4>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
  8039c0:	20bfefc4 	addi	r2,r4,-65
  8039c4:	10803fcc 	andi	r2,r2,255
  8039c8:	00c00644 	movi	r3,25
  8039cc:	18800236 	bltu	r3,r2,8039d8 <follow_path+0x25c>
				b |= 2;
  8039d0:	39c00094 	ori	r7,r7,2
  8039d4:	00000506 	br	8039ec <follow_path+0x270>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
  8039d8:	20bfe7c4 	addi	r2,r4,-97
  8039dc:	10803fcc 	andi	r2,r2,255
  8039e0:	18800236 	bltu	r3,r2,8039ec <follow_path+0x270>
					b |= 1; c -= 0x20;
  8039e4:	39c00054 	ori	r7,r7,1
  8039e8:	213ff804 	addi	r4,r4,-32
				}
			}
			sfn[i++] = c;
  8039ec:	9185883a 	add	r2,r18,r6
  8039f0:	31800044 	addi	r6,r6,1
  8039f4:	11000005 	stb	r4,0(r2)
  8039f8:	003fb406 	br	8038cc <follow_path+0x150>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
  8039fc:	8221883a 	add	r16,r16,r8
  803a00:	01400104 	movi	r5,4
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
  803a04:	30005226 	beq	r6,zero,803b50 <follow_path+0x3d4>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
  803a08:	90c00003 	ldbu	r3,0(r18)
  803a0c:	00803944 	movi	r2,229
  803a10:	1880021e 	bne	r3,r2,803a1c <follow_path+0x2a0>
  803a14:	00800144 	movi	r2,5
  803a18:	90800005 	stb	r2,0(r18)

	if (ni == 8) b <<= 2;
  803a1c:	00800204 	movi	r2,8
  803a20:	4880021e 	bne	r9,r2,803a2c <follow_path+0x2b0>
  803a24:	39c5883a 	add	r2,r7,r7
  803a28:	108f883a 	add	r7,r2,r2
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
  803a2c:	39003fcc 	andi	r4,r7,255
  803a30:	20c000cc 	andi	r3,r4,3
  803a34:	00800044 	movi	r2,1
  803a38:	1880011e 	bne	r3,r2,803a40 <follow_path+0x2c4>
  803a3c:	29400414 	ori	r5,r5,16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
  803a40:	20c0030c 	andi	r3,r4,12
  803a44:	00800104 	movi	r2,4
  803a48:	1880011e 	bne	r3,r2,803a50 <follow_path+0x2d4>
  803a4c:	29400214 	ori	r5,r5,8

	sfn[NS] = c;		/* Store NT flag, File name is created */
  803a50:	914002c5 	stb	r5,11(r18)
  803a54:	00004806 	br	803b78 <follow_path+0x3fc>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  803a58:	89400417 	ldw	r5,16(r17)
  803a5c:	89000017 	ldw	r4,0(r17)
  803a60:	08021640 	call	802164 <move_window>
  803a64:	100b883a 	mov	r5,r2
		if (res != FR_OK) break;
  803a68:	10001a1e 	bne	r2,zero,803ad4 <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  803a6c:	89800517 	ldw	r6,20(r17)
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  803a70:	30800003 	ldbu	r2,0(r6)
  803a74:	10004626 	beq	r2,zero,803b90 <follow_path+0x414>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
  803a78:	308002c3 	ldbu	r2,11(r6)
  803a7c:	1080020c 	andi	r2,r2,8
  803a80:	1000101e 	bne	r2,zero,803ac4 <follow_path+0x348>
  803a84:	8a000617 	ldw	r8,24(r17)
  803a88:	000f883a 	mov	r7,zero
  803a8c:	024002c4 	movi	r9,11
  803a90:	00000106 	br	803a98 <follow_path+0x31c>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  803a94:	3a400726 	beq	r7,r9,803ab4 <follow_path+0x338>
  803a98:	31c5883a 	add	r2,r6,r7
  803a9c:	41c7883a 	add	r3,r8,r7
  803aa0:	11000003 	ldbu	r4,0(r2)
  803aa4:	18800003 	ldbu	r2,0(r3)
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
  803aa8:	39c00044 	addi	r7,r7,1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  803aac:	20bff926 	beq	r4,r2,803a94 <follow_path+0x318>
  803ab0:	00000406 	br	803ac4 <follow_path+0x348>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  803ab4:	408002c3 	ldbu	r2,11(r8)
  803ab8:	1080010c 	andi	r2,r2,4
  803abc:	10001526 	beq	r2,zero,803b14 <follow_path+0x398>
  803ac0:	00003606 	br	803b9c <follow_path+0x420>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  803ac4:	8809883a 	mov	r4,r17
  803ac8:	000b883a 	mov	r5,zero
  803acc:	080316c0 	call	80316c <dir_next>
  803ad0:	00002c06 	br	803b84 <follow_path+0x408>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  803ad4:	88800617 	ldw	r2,24(r17)
  803ad8:	10c002c3 	ldbu	r3,11(r2)
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  803adc:	00800104 	movi	r2,4
  803ae0:	28802e1e 	bne	r5,r2,803b9c <follow_path+0x420>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
  803ae4:	18803fcc 	andi	r2,r3,255
  803ae8:	10c0080c 	andi	r3,r2,32
  803aec:	1080010c 	andi	r2,r2,4
  803af0:	18000526 	beq	r3,zero,803b08 <follow_path+0x38c>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
  803af4:	88000215 	stw	zero,8(r17)
  803af8:	88000515 	stw	zero,20(r17)
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
  803afc:	103f3b26 	beq	r2,zero,8037ec <follow_path+0x70>
  803b00:	000b883a 	mov	r5,zero
  803b04:	00002506 	br	803b9c <follow_path+0x420>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  803b08:	10001326 	beq	r2,zero,803b58 <follow_path+0x3dc>
  803b0c:	01400104 	movi	r5,4
  803b10:	00002206 	br	803b9c <follow_path+0x420>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  803b14:	308002c3 	ldbu	r2,11(r6)
  803b18:	1080040c 	andi	r2,r2,16
  803b1c:	10000e26 	beq	r2,zero,803b58 <follow_path+0x3dc>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  803b20:	30800543 	ldbu	r2,21(r6)
  803b24:	31400503 	ldbu	r5,20(r6)
  803b28:	30c006c3 	ldbu	r3,27(r6)
  803b2c:	1004923a 	slli	r2,r2,8
  803b30:	31000683 	ldbu	r4,26(r6)
  803b34:	1806923a 	slli	r3,r3,8
  803b38:	1144b03a 	or	r2,r2,r5
  803b3c:	1004943a 	slli	r2,r2,16
  803b40:	1906b03a 	or	r3,r3,r4
  803b44:	10c4b03a 	or	r2,r2,r3
  803b48:	88800215 	stw	r2,8(r17)
  803b4c:	003f2706 	br	8037ec <follow_path+0x70>
  803b50:	01400184 	movi	r5,6
  803b54:	00001106 	br	803b9c <follow_path+0x420>
  803b58:	01400144 	movi	r5,5
  803b5c:	00000f06 	br	803b9c <follow_path+0x420>
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
  803b60:	8161883a 	add	r16,r16,r5
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
  803b64:	90c002c4 	addi	r3,r18,11
  803b68:	003f5506 	br	8038c0 <follow_path+0x144>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
  803b6c:	8221883a 	add	r16,r16,r8
  803b70:	000b883a 	mov	r5,zero
  803b74:	003fa306 	br	803a04 <follow_path+0x288>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  803b78:	8809883a 	mov	r4,r17
  803b7c:	000b883a 	mov	r5,zero
  803b80:	08029c40 	call	8029c4 <dir_sdi>
  803b84:	100b883a 	mov	r5,r2
	if (res != FR_OK) return res;
  803b88:	103fd21e 	bne	r2,zero,803ad4 <follow_path+0x358>
  803b8c:	003fb206 	br	803a58 <follow_path+0x2dc>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  803b90:	88800617 	ldw	r2,24(r17)
  803b94:	10c002c3 	ldbu	r3,11(r2)
  803b98:	003fd206 	br	803ae4 <follow_path+0x368>
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  803b9c:	2805883a 	mov	r2,r5
  803ba0:	dfc00317 	ldw	ra,12(sp)
  803ba4:	dc800217 	ldw	r18,8(sp)
  803ba8:	dc400117 	ldw	r17,4(sp)
  803bac:	dc000017 	ldw	r16,0(sp)
  803bb0:	dec00404 	addi	sp,sp,16
  803bb4:	f800283a 	ret

00803bb8 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  803bb8:	defff104 	addi	sp,sp,-60
  803bbc:	dc400c15 	stw	r17,48(sp)
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803bc0:	dc400304 	addi	r17,sp,12

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  803bc4:	dc800d15 	stw	r18,52(sp)
  803bc8:	d9000a15 	stw	r4,40(sp)
  803bcc:	2825883a 	mov	r18,r5
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803bd0:	d9000a04 	addi	r4,sp,40
  803bd4:	000d883a 	mov	r6,zero
  803bd8:	880b883a 	mov	r5,r17

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  803bdc:	dc000b15 	stw	r16,44(sp)
  803be0:	dfc00e15 	stw	ra,56(sp)
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803be4:	0801c0c0 	call	801c0c <chk_mounted>
  803be8:	1021883a 	mov	r16,r2
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
  803bec:	8809883a 	mov	r4,r17
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
  803bf0:	10000c1e 	bne	r2,zero,803c24 <f_stat+0x6c>
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
  803bf4:	d9400a17 	ldw	r5,40(sp)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
  803bf8:	dec00915 	stw	sp,36(sp)
		res = follow_path(&dj, path);	/* Follow the file path */
  803bfc:	080377c0 	call	80377c <follow_path>
  803c00:	1021883a 	mov	r16,r2
		if (res == FR_OK) {				/* Follow completed */
  803c04:	1000071e 	bne	r2,zero,803c24 <f_stat+0x6c>
			if (dj.dir)		/* Found an object */
  803c08:	d8800817 	ldw	r2,32(sp)
				get_fileinfo(&dj, fno);
  803c0c:	8809883a 	mov	r4,r17
  803c10:	900b883a 	mov	r5,r18
	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		if (res == FR_OK) {				/* Follow completed */
			if (dj.dir)		/* Found an object */
  803c14:	1000021e 	bne	r2,zero,803c20 <f_stat+0x68>
  803c18:	04000184 	movi	r16,6
  803c1c:	00000106 	br	803c24 <f_stat+0x6c>
				get_fileinfo(&dj, fno);
  803c20:	08018240 	call	801824 <get_fileinfo>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  803c24:	8005883a 	mov	r2,r16
  803c28:	dfc00e17 	ldw	ra,56(sp)
  803c2c:	dc800d17 	ldw	r18,52(sp)
  803c30:	dc400c17 	ldw	r17,48(sp)
  803c34:	dc000b17 	ldw	r16,44(sp)
  803c38:	dec00f04 	addi	sp,sp,60
  803c3c:	f800283a 	ret

00803c40 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
  803c40:	defffa04 	addi	sp,sp,-24
  803c44:	dc000415 	stw	r16,16(sp)
  803c48:	2021883a 	mov	r16,r4
  803c4c:	d9400315 	stw	r5,12(sp)
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
  803c50:	d9000304 	addi	r4,sp,12
  803c54:	000d883a 	mov	r6,zero
  803c58:	800b883a 	mov	r5,r16

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
  803c5c:	dfc00515 	stw	ra,20(sp)
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
  803c60:	0801c0c0 	call	801c0c <chk_mounted>
  803c64:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
		INIT_BUF(*dj);
		res = follow_path(dj, path);			/* Follow the path to the directory */
  803c68:	8009883a 	mov	r4,r16
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
  803c6c:	1000201e 	bne	r2,zero,803cf0 <f_opendir+0xb0>
		INIT_BUF(*dj);
		res = follow_path(dj, path);			/* Follow the path to the directory */
  803c70:	d9400317 	ldw	r5,12(sp)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
		INIT_BUF(*dj);
  803c74:	86c00615 	stw	sp,24(r16)
		res = follow_path(dj, path);			/* Follow the path to the directory */
  803c78:	080377c0 	call	80377c <follow_path>
  803c7c:	1007883a 	mov	r3,r2
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
  803c80:	1000181e 	bne	r2,zero,803ce4 <f_opendir+0xa4>
			if (dj->dir) {						/* It is not the root dir */
  803c84:	81800517 	ldw	r6,20(r16)
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
  803c88:	8009883a 	mov	r4,r16
  803c8c:	000b883a 	mov	r5,zero
	if (res == FR_OK) {
		INIT_BUF(*dj);
		res = follow_path(dj, path);			/* Follow the path to the directory */
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
  803c90:	30000f26 	beq	r6,zero,803cd0 <f_opendir+0x90>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
  803c94:	308002c3 	ldbu	r2,11(r6)
  803c98:	00c00144 	movi	r3,5
  803c9c:	1080040c 	andi	r2,r2,16
  803ca0:	10001326 	beq	r2,zero,803cf0 <f_opendir+0xb0>
					dj->sclust = LD_CLUST(dj->dir);
  803ca4:	30800543 	ldbu	r2,21(r6)
  803ca8:	31c00503 	ldbu	r7,20(r6)
  803cac:	30c006c3 	ldbu	r3,27(r6)
  803cb0:	1004923a 	slli	r2,r2,8
  803cb4:	31800683 	ldbu	r6,26(r6)
  803cb8:	1806923a 	slli	r3,r3,8
  803cbc:	11c4b03a 	or	r2,r2,r7
  803cc0:	1004943a 	slli	r2,r2,16
  803cc4:	1986b03a 	or	r3,r3,r6
  803cc8:	10c4b03a 	or	r2,r2,r3
  803ccc:	80800215 	stw	r2,8(r16)
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
  803cd0:	80800017 	ldw	r2,0(r16)
  803cd4:	1080018b 	ldhu	r2,6(r2)
  803cd8:	8080010d 	sth	r2,4(r16)
				res = dir_sdi(dj, 0);			/* Rewind dir */
  803cdc:	08029c40 	call	8029c4 <dir_sdi>
  803ce0:	1007883a 	mov	r3,r2
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
  803ce4:	00800104 	movi	r2,4
  803ce8:	1880011e 	bne	r3,r2,803cf0 <f_opendir+0xb0>
  803cec:	00c00144 	movi	r3,5
	}

	LEAVE_FF(dj->fs, res);
}
  803cf0:	1805883a 	mov	r2,r3
  803cf4:	dfc00517 	ldw	ra,20(sp)
  803cf8:	dc000417 	ldw	r16,16(sp)
  803cfc:	dec00604 	addi	sp,sp,24
  803d00:	f800283a 	ret

00803d04 <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
  803d04:	defff304 	addi	sp,sp,-52
  803d08:	dc000b15 	stw	r16,44(sp)
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803d0c:	dc000304 	addi	r16,sp,12


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
  803d10:	d9000a15 	stw	r4,40(sp)
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803d14:	000d883a 	mov	r6,zero
  803d18:	d9000a04 	addi	r4,sp,40
  803d1c:	800b883a 	mov	r5,r16


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
  803d20:	dfc00c15 	stw	ra,48(sp)
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  803d24:	0801c0c0 	call	801c0c <chk_mounted>
  803d28:	100d883a 	mov	r6,r2
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);		/* Follow the path */
  803d2c:	8009883a 	mov	r4,r16
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
  803d30:	10001e1e 	bne	r2,zero,803dac <f_chdir+0xa8>
		INIT_BUF(dj);
		res = follow_path(&dj, path);		/* Follow the path */
  803d34:	d9400a17 	ldw	r5,40(sp)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
  803d38:	dec00915 	stw	sp,36(sp)
		res = follow_path(&dj, path);		/* Follow the path */
  803d3c:	080377c0 	call	80377c <follow_path>
  803d40:	100d883a 	mov	r6,r2
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
  803d44:	1000161e 	bne	r2,zero,803da0 <f_chdir+0x9c>
			if (!dj.dir) {
  803d48:	d9000817 	ldw	r4,32(sp)
  803d4c:	2000041e 	bne	r4,zero,803d60 <f_chdir+0x5c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
  803d50:	d8c00517 	ldw	r3,20(sp)
  803d54:	d8800317 	ldw	r2,12(sp)
  803d58:	10c00615 	stw	r3,24(r2)
  803d5c:	00001306 	br	803dac <f_chdir+0xa8>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
  803d60:	208002c3 	ldbu	r2,11(r4)
  803d64:	1080040c 	andi	r2,r2,16
  803d68:	10000f26 	beq	r2,zero,803da8 <f_chdir+0xa4>
					dj.fs->cdir = LD_CLUST(dj.dir);
  803d6c:	20800543 	ldbu	r2,21(r4)
  803d70:	21400503 	ldbu	r5,20(r4)
  803d74:	20c006c3 	ldbu	r3,27(r4)
  803d78:	1004923a 	slli	r2,r2,8
  803d7c:	21000683 	ldbu	r4,26(r4)
  803d80:	1806923a 	slli	r3,r3,8
  803d84:	1144b03a 	or	r2,r2,r5
  803d88:	1004943a 	slli	r2,r2,16
  803d8c:	1906b03a 	or	r3,r3,r4
  803d90:	10c4b03a 	or	r2,r2,r3
  803d94:	d8c00317 	ldw	r3,12(sp)
  803d98:	18800615 	stw	r2,24(r3)
  803d9c:	00000306 	br	803dac <f_chdir+0xa8>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
  803da0:	00800104 	movi	r2,4
  803da4:	3080011e 	bne	r6,r2,803dac <f_chdir+0xa8>
  803da8:	01800144 	movi	r6,5
	}

	LEAVE_FF(dj.fs, res);
}
  803dac:	3005883a 	mov	r2,r6
  803db0:	dfc00c17 	ldw	ra,48(sp)
  803db4:	dc000b17 	ldw	r16,44(sp)
  803db8:	dec00d04 	addi	sp,sp,52
  803dbc:	f800283a 	ret

00803dc0 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
  803dc0:	defffa04 	addi	sp,sp,-24
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  803dc4:	00800044 	movi	r2,1
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
  803dc8:	dc400115 	stw	r17,4(sp)
  803dcc:	dc000015 	stw	r16,0(sp)
  803dd0:	dfc00515 	stw	ra,20(sp)
  803dd4:	dd000415 	stw	r20,16(sp)
  803dd8:	dcc00315 	stw	r19,12(sp)
  803ddc:	dc800215 	stw	r18,8(sp)
  803de0:	2823883a 	mov	r17,r5
  803de4:	2021883a 	mov	r16,r4
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  803de8:	11401e2e 	bgeu	r2,r5,803e64 <remove_chain+0xa4>
  803dec:	20800717 	ldw	r2,28(r4)
  803df0:	28801c2e 	bgeu	r5,r2,803e64 <remove_chain+0xa4>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
  803df4:	8009883a 	mov	r4,r16
  803df8:	880b883a 	mov	r5,r17
  803dfc:	08024240 	call	802424 <get_fat>
  803e00:	1025883a 	mov	r18,r2
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
  803e04:	880b883a 	mov	r5,r17
  803e08:	8009883a 	mov	r4,r16
  803e0c:	000d883a 	mov	r6,zero
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  803e10:	04c00044 	movi	r19,1
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  803e14:	053fffc4 	movi	r20,-1

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  803e18:	10000e26 	beq	r2,zero,803e54 <remove_chain+0x94>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  803e1c:	14c01126 	beq	r2,r19,803e64 <remove_chain+0xa4>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  803e20:	15000e26 	beq	r2,r20,803e5c <remove_chain+0x9c>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
  803e24:	080224c0 	call	80224c <put_fat>
  803e28:	1007883a 	mov	r3,r2
			if (res != FR_OK) break;
  803e2c:	10000e1e 	bne	r2,zero,803e68 <remove_chain+0xa8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  803e30:	80800417 	ldw	r2,16(r16)
				fs->free_clust++;
				fs->fsi_flag = 1;
  803e34:	9023883a 	mov	r17,r18
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
  803e38:	14c9883a 	add	r4,r2,r19
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  803e3c:	15000226 	beq	r2,r20,803e48 <remove_chain+0x88>
				fs->free_clust++;
  803e40:	81000415 	stw	r4,16(r16)
				fs->fsi_flag = 1;
  803e44:	84c00145 	stb	r19,5(r16)
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  803e48:	80800717 	ldw	r2,28(r16)
  803e4c:	9080062e 	bgeu	r18,r2,803e68 <remove_chain+0xa8>
  803e50:	003fe806 	br	803df4 <remove_chain+0x34>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  803e54:	0007883a 	mov	r3,zero
  803e58:	00000306 	br	803e68 <remove_chain+0xa8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  803e5c:	9807883a 	mov	r3,r19
  803e60:	00000106 	br	803e68 <remove_chain+0xa8>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  803e64:	00c00084 	movi	r3,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  803e68:	1805883a 	mov	r2,r3
  803e6c:	dfc00517 	ldw	ra,20(sp)
  803e70:	dd000417 	ldw	r20,16(sp)
  803e74:	dcc00317 	ldw	r19,12(sp)
  803e78:	dc800217 	ldw	r18,8(sp)
  803e7c:	dc400117 	ldw	r17,4(sp)
  803e80:	dc000017 	ldw	r16,0(sp)
  803e84:	dec00604 	addi	sp,sp,24
  803e88:	f800283a 	ret

00803e8c <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
  803e8c:	defffc04 	addi	sp,sp,-16
  803e90:	dc000015 	stw	r16,0(sp)
  803e94:	2021883a 	mov	r16,r4
	FRESULT res;
	DWORD ncl;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  803e98:	8140010b 	ldhu	r5,4(r16)
  803e9c:	21000017 	ldw	r4,0(r4)
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
  803ea0:	dc400115 	stw	r17,4(sp)
  803ea4:	dfc00315 	stw	ra,12(sp)
  803ea8:	dc800215 	stw	r18,8(sp)
	FRESULT res;
	DWORD ncl;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  803eac:	0801ad80 	call	801ad8 <validate>
  803eb0:	1023883a 	mov	r17,r2
	if (res == FR_OK) {
  803eb4:	1000381e 	bne	r2,zero,803f98 <f_truncate+0x10c>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
  803eb8:	81000183 	ldbu	r4,6(r16)
  803ebc:	20803fcc 	andi	r2,r4,255
  803ec0:	1080201c 	xori	r2,r2,128
  803ec4:	10bfe004 	addi	r2,r2,-128
  803ec8:	1000020e 	bge	r2,zero,803ed4 <f_truncate+0x48>
  803ecc:	04400084 	movi	r17,2
  803ed0:	00003106 	br	803f98 <f_truncate+0x10c>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
  803ed4:	2080008c 	andi	r2,r4,2
  803ed8:	1000261e 	bne	r2,zero,803f74 <f_truncate+0xe8>
  803edc:	044001c4 	movi	r17,7
  803ee0:	00002d06 	br	803f98 <f_truncate+0x10c>
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
			fp->flag |= FA__WRITTEN;
  803ee4:	20800814 	ori	r2,r4,32
  803ee8:	80800185 	stb	r2,6(r16)
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
  803eec:	80c00315 	stw	r3,12(r16)
			fp->flag |= FA__WRITTEN;
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
  803ef0:	1800061e 	bne	r3,zero,803f0c <f_truncate+0x80>
				res = remove_chain(fp->fs, fp->sclust);
  803ef4:	81000017 	ldw	r4,0(r16)
  803ef8:	81400417 	ldw	r5,16(r16)
  803efc:	0803dc00 	call	803dc0 <remove_chain>
  803f00:	1023883a 	mov	r17,r2
				fp->sclust = 0;
  803f04:	80000415 	stw	zero,16(r16)
  803f08:	00001406 	br	803f5c <f_truncate+0xd0>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
  803f0c:	81000017 	ldw	r4,0(r16)
  803f10:	81400517 	ldw	r5,20(r16)
  803f14:	08024240 	call	802424 <get_fat>
  803f18:	1025883a 	mov	r18,r2
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
  803f1c:	00bfffc4 	movi	r2,-1
  803f20:	90801826 	beq	r18,r2,803f84 <f_truncate+0xf8>
				if (ncl == 1) res = FR_INT_ERR;
  803f24:	00800044 	movi	r2,1
  803f28:	9080181e 	bne	r18,r2,803f8c <f_truncate+0x100>
  803f2c:	04400084 	movi	r17,2
  803f30:	00000b06 	br	803f60 <f_truncate+0xd4>
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
  803f34:	81400517 	ldw	r5,20(r16)
  803f38:	01840034 	movhi	r6,4096
  803f3c:	31bfffc4 	addi	r6,r6,-1
  803f40:	080224c0 	call	80224c <put_fat>
  803f44:	1023883a 	mov	r17,r2
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
  803f48:	1000051e 	bne	r2,zero,803f60 <f_truncate+0xd4>
  803f4c:	81000017 	ldw	r4,0(r16)
  803f50:	900b883a 	mov	r5,r18
  803f54:	0803dc00 	call	803dc0 <remove_chain>
  803f58:	1023883a 	mov	r17,r2
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
  803f5c:	88000e26 	beq	r17,zero,803f98 <f_truncate+0x10c>
  803f60:	80800183 	ldbu	r2,6(r16)
  803f64:	00ffe004 	movi	r3,-128
  803f68:	10c4b03a 	or	r2,r2,r3
  803f6c:	80800185 	stb	r2,6(r16)
  803f70:	00000906 	br	803f98 <f_truncate+0x10c>
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
  803f74:	80c00217 	ldw	r3,8(r16)
  803f78:	80800317 	ldw	r2,12(r16)
  803f7c:	18bfd936 	bltu	r3,r2,803ee4 <f_truncate+0x58>
  803f80:	00000506 	br	803f98 <f_truncate+0x10c>
  803f84:	04400044 	movi	r17,1
  803f88:	003ff506 	br	803f60 <f_truncate+0xd4>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
  803f8c:	81000017 	ldw	r4,0(r16)
  803f90:	20800717 	ldw	r2,28(r4)
  803f94:	90bfe736 	bltu	r18,r2,803f34 <f_truncate+0xa8>
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
  803f98:	8805883a 	mov	r2,r17
  803f9c:	dfc00317 	ldw	ra,12(sp)
  803fa0:	dc800217 	ldw	r18,8(sp)
  803fa4:	dc400117 	ldw	r17,4(sp)
  803fa8:	dc000017 	ldw	r16,0(sp)
  803fac:	dec00404 	addi	sp,sp,16
  803fb0:	f800283a 	ret

00803fb4 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  803fb4:	defffd04 	addi	sp,sp,-12
	FRESULT res;


	res = move_window(fs, 0);
  803fb8:	000b883a 	mov	r5,zero
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  803fbc:	dc400115 	stw	r17,4(sp)
  803fc0:	dfc00215 	stw	ra,8(sp)
  803fc4:	dc000015 	stw	r16,0(sp)
  803fc8:	2023883a 	mov	r17,r4
	FRESULT res;


	res = move_window(fs, 0);
  803fcc:	08021640 	call	802164 <move_window>
	if (res == FR_OK) {
  803fd0:	1000381e 	bne	r2,zero,8040b4 <sync+0x100>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  803fd4:	88c00003 	ldbu	r3,0(r17)
  803fd8:	008000c4 	movi	r2,3
  803fdc:	1880301e 	bne	r3,r2,8040a0 <sync+0xec>
  803fe0:	88800143 	ldbu	r2,5(r17)
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  803fe4:	8c000d04 	addi	r16,r17,52
  803fe8:	8009883a 	mov	r4,r16
  803fec:	000b883a 	mov	r5,zero
  803ff0:	01808004 	movi	r6,512


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  803ff4:	10002a26 	beq	r2,zero,8040a0 <sync+0xec>
			fs->winsect = 0;
  803ff8:	88000c15 	stw	zero,48(r17)
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  803ffc:	08017bc0 	call	8017bc <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  804000:	00801544 	movi	r2,85
  804004:	80807f85 	stb	r2,510(r16)
  804008:	00bfea84 	movi	r2,-86
  80400c:	80807fc5 	stb	r2,511(r16)
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  804010:	00801484 	movi	r2,82
  804014:	88800d05 	stb	r2,52(r17)
  804018:	00c01844 	movi	r3,97
  80401c:	01001044 	movi	r4,65
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  804020:	01401c84 	movi	r5,114
  804024:	81407945 	stb	r5,485(r16)
  804028:	81407905 	stb	r5,484(r16)
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  80402c:	80800045 	stb	r2,1(r16)
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  804030:	81007985 	stb	r4,486(r16)
  804034:	80c079c5 	stb	r3,487(r16)
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  804038:	80c00085 	stb	r3,2(r16)
  80403c:	810000c5 	stb	r4,3(r16)
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  804040:	88800417 	ldw	r2,16(r17)
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  804044:	01c00044 	movi	r7,1
  804048:	800b883a 	mov	r5,r16
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  80404c:	80807a05 	stb	r2,488(r16)
  804050:	8880040b 	ldhu	r2,16(r17)
  804054:	1004d23a 	srli	r2,r2,8
  804058:	80807a45 	stb	r2,489(r16)
  80405c:	8880048b 	ldhu	r2,18(r17)
  804060:	80807a85 	stb	r2,490(r16)
  804064:	888004c3 	ldbu	r2,19(r17)
  804068:	80807ac5 	stb	r2,491(r16)
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  80406c:	88800317 	ldw	r2,12(r17)
  804070:	80807b05 	stb	r2,492(r16)
  804074:	8880030b 	ldhu	r2,12(r17)
  804078:	1004d23a 	srli	r2,r2,8
  80407c:	80807b45 	stb	r2,493(r16)
  804080:	8880038b 	ldhu	r2,14(r17)
  804084:	80807b85 	stb	r2,494(r16)
  804088:	888003c3 	ldbu	r2,15(r17)
  80408c:	80807bc5 	stb	r2,495(r16)
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  804090:	89000043 	ldbu	r4,1(r17)
  804094:	89800517 	ldw	r6,20(r17)
  804098:	08015a40 	call	8015a4 <disk_write>
			fs->fsi_flag = 0;
  80409c:	88000145 	stb	zero,5(r17)
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  8040a0:	89000043 	ldbu	r4,1(r17)
  8040a4:	000b883a 	mov	r5,zero
  8040a8:	000d883a 	mov	r6,zero
  8040ac:	08014480 	call	801448 <disk_ioctl>
  8040b0:	1004c03a 	cmpne	r2,r2,zero
			res = FR_DISK_ERR;
	}

	return res;
}
  8040b4:	dfc00217 	ldw	ra,8(sp)
  8040b8:	dc400117 	ldw	r17,4(sp)
  8040bc:	dc000017 	ldw	r16,0(sp)
  8040c0:	dec00304 	addi	sp,sp,12
  8040c4:	f800283a 	ret

008040c8 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
  8040c8:	deffe304 	addi	sp,sp,-116
  8040cc:	dcc01b15 	stw	r19,108(sp)
  8040d0:	dc401915 	stw	r17,100(sp)
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
  8040d4:	04c00044 	movi	r19,1
  8040d8:	dc401004 	addi	r17,sp,64

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
  8040dc:	dc801a15 	stw	r18,104(sp)
  8040e0:	d9001715 	stw	r4,92(sp)
  8040e4:	2825883a 	mov	r18,r5
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
  8040e8:	d9001704 	addi	r4,sp,92
  8040ec:	880b883a 	mov	r5,r17
  8040f0:	980d883a 	mov	r6,r19

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
  8040f4:	dfc01c15 	stw	ra,112(sp)
  8040f8:	dc001815 	stw	r16,96(sp)
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
  8040fc:	0801c0c0 	call	801c0c <chk_mounted>
  804100:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
  804104:	10006c1e 	bne	r2,zero,8042b8 <f_rename+0x1f0>
		djn.fs = djo.fs;
  804108:	d8801017 	ldw	r2,64(sp)
		INIT_BUF(djo);
		res = follow_path(&djo, path_old);		/* Check old object */
  80410c:	d9401717 	ldw	r5,92(sp)
  804110:	8809883a 	mov	r4,r17
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
	if (res == FR_OK) {
		djn.fs = djo.fs;
  804114:	d8800915 	stw	r2,36(sp)
		INIT_BUF(djo);
  804118:	dec01615 	stw	sp,88(sp)
		res = follow_path(&djo, path_old);		/* Check old object */
  80411c:	080377c0 	call	80377c <follow_path>
  804120:	1007883a 	mov	r3,r2
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
  804124:	1000641e 	bne	r2,zero,8042b8 <f_rename+0x1f0>
  804128:	d8801617 	ldw	r2,88(sp)
  80412c:	108002c3 	ldbu	r2,11(r2)
  804130:	1080080c 	andi	r2,r2,32
  804134:	10005b26 	beq	r2,zero,8042a4 <f_rename+0x1dc>
  804138:	00c00184 	movi	r3,6
  80413c:	00005e06 	br	8042b8 <f_rename+0x1f0>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
  804140:	294002c4 	addi	r5,r5,11
  804144:	d9000304 	addi	r4,sp,12
  804148:	01800544 	movi	r6,21
				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
  80414c:	dc000904 	addi	r16,sp,36
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
  804150:	08017980 	call	801798 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
  804154:	880b883a 	mov	r5,r17
  804158:	01800704 	movi	r6,28
  80415c:	8009883a 	mov	r4,r16
  804160:	08017980 	call	801798 <mem_cpy>
				res = follow_path(&djn, path_new);
  804164:	8009883a 	mov	r4,r16
  804168:	900b883a 	mov	r5,r18
  80416c:	080377c0 	call	80377c <follow_path>
  804170:	1007883a 	mov	r3,r2
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
  804174:	1000021e 	bne	r2,zero,804180 <f_rename+0xb8>
  804178:	00c00204 	movi	r3,8
  80417c:	00004e06 	br	8042b8 <f_rename+0x1f0>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
  804180:	00800104 	movi	r2,4
  804184:	18804c1e 	bne	r3,r2,8042b8 <f_rename+0x1f0>
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
  804188:	8009883a 	mov	r4,r16
  80418c:	08033300 	call	803330 <dir_register>
  804190:	1007883a 	mov	r3,r2
					if (res == FR_OK) {
  804194:	1000481e 	bne	r2,zero,8042b8 <f_rename+0x1f0>
						dir = djn.dir;					/* Copy object information except for name */
  804198:	dc000e17 	ldw	r16,56(sp)
						mem_cpy(dir+13, buf+2, 19);
  80419c:	d9400384 	addi	r5,sp,14
  8041a0:	018004c4 	movi	r6,19
  8041a4:	81000344 	addi	r4,r16,13
  8041a8:	08017980 	call	801798 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
  8041ac:	d8800303 	ldbu	r2,12(sp)
  8041b0:	10800814 	ori	r2,r2,32
  8041b4:	808002c5 	stb	r2,11(r16)
						djo.fs->wflag = 1;
  8041b8:	d8801017 	ldw	r2,64(sp)
  8041bc:	14c00105 	stb	r19,4(r2)
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
  8041c0:	d8c01217 	ldw	r3,72(sp)
  8041c4:	d8800b17 	ldw	r2,44(sp)
  8041c8:	18802e26 	beq	r3,r2,804284 <f_rename+0x1bc>
  8041cc:	808002c3 	ldbu	r2,11(r16)
  8041d0:	1080040c 	andi	r2,r2,16
  8041d4:	10002b26 	beq	r2,zero,804284 <f_rename+0x1bc>
							dw = clust2sect(djn.fs, LD_CLUST(dir));
  8041d8:	81400543 	ldbu	r5,21(r16)
  8041dc:	80c00503 	ldbu	r3,20(r16)
  8041e0:	808006c3 	ldbu	r2,27(r16)
  8041e4:	280a923a 	slli	r5,r5,8
  8041e8:	81000683 	ldbu	r4,26(r16)
  8041ec:	1004923a 	slli	r2,r2,8
  8041f0:	28cab03a 	or	r5,r5,r3
  8041f4:	280a943a 	slli	r5,r5,16
  8041f8:	dc000917 	ldw	r16,36(sp)
  8041fc:	1104b03a 	or	r2,r2,r4
  804200:	288ab03a 	or	r5,r5,r2
  804204:	8009883a 	mov	r4,r16
  804208:	08017d80 	call	8017d8 <clust2sect>
  80420c:	100b883a 	mov	r5,r2
							if (!dw) {
  804210:	10002826 	beq	r2,zero,8042b4 <f_rename+0x1ec>
								res = FR_INT_ERR;
							} else {
								res = move_window(djn.fs, dw);
  804214:	8009883a 	mov	r4,r16
  804218:	08021640 	call	802164 <move_window>
  80421c:	1007883a 	mov	r3,r2
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
  804220:	d9000917 	ldw	r4,36(sp)
								if (res == FR_OK && dir[1] == '.') {
  804224:	1000241e 	bne	r2,zero,8042b8 <f_rename+0x1f0>
							dw = clust2sect(djn.fs, LD_CLUST(dir));
							if (!dw) {
								res = FR_INT_ERR;
							} else {
								res = move_window(djn.fs, dw);
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
  804228:	21401504 	addi	r5,r4,84
								if (res == FR_OK && dir[1] == '.') {
  80422c:	28c00043 	ldbu	r3,1(r5)
  804230:	00800b84 	movi	r2,46
  804234:	1880131e 	bne	r3,r2,804284 <f_rename+0x1bc>
									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
  804238:	20c00003 	ldbu	r3,0(r4)
  80423c:	008000c4 	movi	r2,3
  804240:	1880051e 	bne	r3,r2,804258 <f_rename+0x190>
  804244:	20c00a17 	ldw	r3,40(r4)
  804248:	d8800b17 	ldw	r2,44(sp)
  80424c:	10c0021e 	bne	r2,r3,804258 <f_rename+0x190>
  804250:	0007883a 	mov	r3,zero
  804254:	00000106 	br	80425c <f_rename+0x194>
  804258:	d8c00b17 	ldw	r3,44(sp)
									ST_CLUST(dir, dw);
  80425c:	1808d43a 	srli	r4,r3,16
  804260:	1804d23a 	srli	r2,r3,8
  804264:	28c00685 	stb	r3,26(r5)
  804268:	2006d23a 	srli	r3,r4,8
  80426c:	288006c5 	stb	r2,27(r5)
  804270:	29000505 	stb	r4,20(r5)
  804274:	28c00545 	stb	r3,21(r5)
									djn.fs->wflag = 1;
  804278:	d8800917 	ldw	r2,36(sp)
  80427c:	00c00044 	movi	r3,1
  804280:	10c00105 	stb	r3,4(r2)
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
  804284:	d9001004 	addi	r4,sp,64
  804288:	0802ae00 	call	802ae0 <dir_remove>
  80428c:	1007883a 	mov	r3,r2
							if (res == FR_OK)
  804290:	1000091e 	bne	r2,zero,8042b8 <f_rename+0x1f0>
								res = sync(djo.fs);
  804294:	d9001017 	ldw	r4,64(sp)
  804298:	0803fb40 	call	803fb4 <sync>
  80429c:	1007883a 	mov	r3,r2
  8042a0:	00000506 	br	8042b8 <f_rename+0x1f0>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
  8042a4:	d9401517 	ldw	r5,84(sp)
  8042a8:	283fa51e 	bne	r5,zero,804140 <f_rename+0x78>
  8042ac:	00c00104 	movi	r3,4
  8042b0:	00000106 	br	8042b8 <f_rename+0x1f0>
  8042b4:	00c00084 	movi	r3,2
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
  8042b8:	1805883a 	mov	r2,r3
  8042bc:	dfc01c17 	ldw	ra,112(sp)
  8042c0:	dcc01b17 	ldw	r19,108(sp)
  8042c4:	dc801a17 	ldw	r18,104(sp)
  8042c8:	dc401917 	ldw	r17,100(sp)
  8042cc:	dc001817 	ldw	r16,96(sp)
  8042d0:	dec01d04 	addi	sp,sp,116
  8042d4:	f800283a 	ret

008042d8 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
  8042d8:	defff104 	addi	sp,sp,-60
  8042dc:	dc800d15 	stw	r18,52(sp)
  8042e0:	dc000b15 	stw	r16,44(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8042e4:	04800044 	movi	r18,1
  8042e8:	dc000304 	addi	r16,sp,12

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
  8042ec:	dc400c15 	stw	r17,48(sp)
  8042f0:	d9000a15 	stw	r4,40(sp)
  8042f4:	2823883a 	mov	r17,r5
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8042f8:	d9000a04 	addi	r4,sp,40
  8042fc:	900d883a 	mov	r6,r18
  804300:	800b883a 	mov	r5,r16

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
  804304:	dfc00e15 	stw	ra,56(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  804308:	0801c0c0 	call	801c0c <chk_mounted>
  80430c:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
  804310:	8009883a 	mov	r4,r16
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
  804314:	10001e1e 	bne	r2,zero,804390 <f_utime+0xb8>
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
  804318:	d9400a17 	ldw	r5,40(sp)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  80431c:	dec00915 	stw	sp,36(sp)
		res = follow_path(&dj, path);	/* Follow the file path */
  804320:	080377c0 	call	80377c <follow_path>
  804324:	1007883a 	mov	r3,r2
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
  804328:	1000191e 	bne	r2,zero,804390 <f_utime+0xb8>
  80432c:	d8800917 	ldw	r2,36(sp)
  804330:	00c00184 	movi	r3,6
  804334:	108002c3 	ldbu	r2,11(r2)
  804338:	1080080c 	andi	r2,r2,32
  80433c:	10001126 	beq	r2,zero,804384 <f_utime+0xac>
  804340:	00001306 	br	804390 <f_utime+0xb8>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
  804344:	8880018b 	ldhu	r2,6(r17)
  804348:	20800585 	stb	r2,22(r4)
  80434c:	8880018b 	ldhu	r2,6(r17)
  804350:	1004d23a 	srli	r2,r2,8
  804354:	208005c5 	stb	r2,23(r4)
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
  804358:	8880010b 	ldhu	r2,4(r17)
  80435c:	20800605 	stb	r2,24(r4)
  804360:	8880010b 	ldhu	r2,4(r17)
  804364:	1004d23a 	srli	r2,r2,8
  804368:	20800645 	stb	r2,25(r4)
				dj.fs->wflag = 1;
  80436c:	d8800317 	ldw	r2,12(sp)
  804370:	14800105 	stb	r18,4(r2)
				res = sync(dj.fs);
  804374:	d9000317 	ldw	r4,12(sp)
  804378:	0803fb40 	call	803fb4 <sync>
  80437c:	1007883a 	mov	r3,r2
  804380:	00000306 	br	804390 <f_utime+0xb8>
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
  804384:	d9000817 	ldw	r4,32(sp)
			if (!dir) {					/* Root directory */
  804388:	00c00184 	movi	r3,6
  80438c:	203fed1e 	bne	r4,zero,804344 <f_utime+0x6c>
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
  804390:	1805883a 	mov	r2,r3
  804394:	dfc00e17 	ldw	ra,56(sp)
  804398:	dc800d17 	ldw	r18,52(sp)
  80439c:	dc400c17 	ldw	r17,48(sp)
  8043a0:	dc000b17 	ldw	r16,44(sp)
  8043a4:	dec00f04 	addi	sp,sp,60
  8043a8:	f800283a 	ret

008043ac <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
  8043ac:	defff004 	addi	sp,sp,-64
  8043b0:	dcc00e15 	stw	r19,56(sp)
  8043b4:	dc000b15 	stw	r16,44(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8043b8:	04c00044 	movi	r19,1
  8043bc:	dc000304 	addi	r16,sp,12
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
  8043c0:	dc800d15 	stw	r18,52(sp)
  8043c4:	dc400c15 	stw	r17,48(sp)
  8043c8:	d9000a15 	stw	r4,40(sp)
  8043cc:	2825883a 	mov	r18,r5
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8043d0:	d9000a04 	addi	r4,sp,40
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
  8043d4:	3023883a 	mov	r17,r6
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8043d8:	800b883a 	mov	r5,r16
  8043dc:	980d883a 	mov	r6,r19
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
  8043e0:	dfc00f15 	stw	ra,60(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8043e4:	0801c0c0 	call	801c0c <chk_mounted>
  8043e8:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);		/* Follow the file path */
  8043ec:	8009883a 	mov	r4,r16
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
  8043f0:	10001b1e 	bne	r2,zero,804460 <f_chmod+0xb4>
		INIT_BUF(dj);
		res = follow_path(&dj, path);		/* Follow the file path */
  8043f4:	d9400a17 	ldw	r5,40(sp)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  8043f8:	dec00915 	stw	sp,36(sp)
		res = follow_path(&dj, path);		/* Follow the file path */
  8043fc:	080377c0 	call	80377c <follow_path>
  804400:	1007883a 	mov	r3,r2
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
  804404:	1000161e 	bne	r2,zero,804460 <f_chmod+0xb4>
  804408:	d8800917 	ldw	r2,36(sp)
  80440c:	00c00184 	movi	r3,6
  804410:	108002c3 	ldbu	r2,11(r2)
  804414:	1080080c 	andi	r2,r2,32
  804418:	10000b26 	beq	r2,zero,804448 <f_chmod+0x9c>
  80441c:	00001006 	br	804460 <f_chmod+0xb4>
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
  804420:	208002c3 	ldbu	r2,11(r4)
  804424:	3084703a 	and	r2,r6,r2
  804428:	2884b03a 	or	r2,r5,r2
  80442c:	208002c5 	stb	r2,11(r4)
				dj.fs->wflag = 1;
  804430:	d8800317 	ldw	r2,12(sp)
  804434:	14c00105 	stb	r19,4(r2)
				res = sync(dj.fs);
  804438:	d9000317 	ldw	r4,12(sp)
  80443c:	0803fb40 	call	803fb4 <sync>
  804440:	1007883a 	mov	r3,r2
  804444:	00000606 	br	804460 <f_chmod+0xb4>
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
  804448:	d9000817 	ldw	r4,32(sp)
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
  80444c:	888009cc 	andi	r2,r17,39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
  804450:	008c303a 	nor	r6,zero,r2
  804454:	908a703a 	and	r5,r18,r2
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
  804458:	00c00184 	movi	r3,6
  80445c:	203ff01e 	bne	r4,zero,804420 <f_chmod+0x74>
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
  804460:	1805883a 	mov	r2,r3
  804464:	dfc00f17 	ldw	ra,60(sp)
  804468:	dcc00e17 	ldw	r19,56(sp)
  80446c:	dc800d17 	ldw	r18,52(sp)
  804470:	dc400c17 	ldw	r17,48(sp)
  804474:	dc000b17 	ldw	r16,44(sp)
  804478:	dec01004 	addi	sp,sp,64
  80447c:	f800283a 	ret

00804480 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  804480:	deffea04 	addi	sp,sp,-88
  804484:	dc801415 	stw	r18,80(sp)
  804488:	dc401315 	stw	r17,76(sp)
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  80448c:	dc800a04 	addi	r18,sp,40
  804490:	04400044 	movi	r17,1
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  804494:	d9001115 	stw	r4,68(sp)
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  804498:	900b883a 	mov	r5,r18
  80449c:	d9001104 	addi	r4,sp,68
  8044a0:	880d883a 	mov	r6,r17
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  8044a4:	dfc01515 	stw	ra,84(sp)
  8044a8:	dc001215 	stw	r16,72(sp)
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8044ac:	0801c0c0 	call	801c0c <chk_mounted>
  8044b0:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
  8044b4:	10004a1e 	bne	r2,zero,8045e0 <f_unlink+0x160>
		INIT_BUF(dj);
		res = follow_path(&dj, path);		/* Follow the file path */
  8044b8:	d9401117 	ldw	r5,68(sp)
  8044bc:	9009883a 	mov	r4,r18
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  8044c0:	dec01015 	stw	sp,64(sp)
		res = follow_path(&dj, path);		/* Follow the file path */
  8044c4:	080377c0 	call	80377c <follow_path>
  8044c8:	1007883a 	mov	r3,r2
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
  8044cc:	1000441e 	bne	r2,zero,8045e0 <f_unlink+0x160>
  8044d0:	d8801017 	ldw	r2,64(sp)
  8044d4:	108002c3 	ldbu	r2,11(r2)
  8044d8:	1080080c 	andi	r2,r2,32
  8044dc:	10002826 	beq	r2,zero,804580 <f_unlink+0x100>
  8044e0:	00002906 	br	804588 <f_unlink+0x108>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
  8044e4:	218002c3 	ldbu	r6,11(r4)
  8044e8:	3080004c 	andi	r2,r6,1
  8044ec:	1005003a 	cmpeq	r2,r2,zero
  8044f0:	10002e1e 	bne	r2,zero,8045ac <f_unlink+0x12c>
  8044f4:	00001606 	br	804550 <f_unlink+0xd0>
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = LD_CLUST(dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
  8044f8:	8c00252e 	bgeu	r17,r16,804590 <f_unlink+0x110>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
  8044fc:	dc400304 	addi	r17,sp,12
  804500:	900b883a 	mov	r5,r18
  804504:	8809883a 	mov	r4,r17
  804508:	01800704 	movi	r6,28
  80450c:	08017980 	call	801798 <mem_cpy>
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  804510:	8809883a 	mov	r4,r17
  804514:	01400084 	movi	r5,2
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
  804518:	dc000515 	stw	r16,20(sp)
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  80451c:	08029c40 	call	8029c4 <dir_sdi>
  804520:	1007883a 	mov	r3,r2
					if (res == FR_OK) {
  804524:	10002e1e 	bne	r2,zero,8045e0 <f_unlink+0x160>
						res = dir_read(&sdj);
  804528:	8809883a 	mov	r4,r17
  80452c:	08033f40 	call	8033f4 <dir_read>
  804530:	1007883a 	mov	r3,r2
						if (res == FR_OK			/* Not empty dir */
  804534:	10000626 	beq	r2,zero,804550 <f_unlink+0xd0>
  804538:	d8800317 	ldw	r2,12(sp)
  80453c:	10800617 	ldw	r2,24(r2)
  804540:	80800326 	beq	r16,r2,804550 <f_unlink+0xd0>
#if _FS_RPATH
						|| dclst == sdj.fs->cdir	/* Current dir */
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
  804544:	00800104 	movi	r2,4
  804548:	1880251e 	bne	r3,r2,8045e0 <f_unlink+0x160>
  80454c:	00001206 	br	804598 <f_unlink+0x118>
  804550:	00c001c4 	movi	r3,7
  804554:	00002206 	br	8045e0 <f_unlink+0x160>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
  804558:	80000526 	beq	r16,zero,804570 <f_unlink+0xf0>
						res = remove_chain(dj.fs, dclst);
  80455c:	d9000a17 	ldw	r4,40(sp)
  804560:	800b883a 	mov	r5,r16
  804564:	0803dc00 	call	803dc0 <remove_chain>
  804568:	1007883a 	mov	r3,r2
					if (res == FR_OK) res = sync(dj.fs);
  80456c:	10001c1e 	bne	r2,zero,8045e0 <f_unlink+0x160>
  804570:	d9000a17 	ldw	r4,40(sp)
  804574:	0803fb40 	call	803fb4 <sync>
  804578:	1007883a 	mov	r3,r2
  80457c:	00001806 	br	8045e0 <f_unlink+0x160>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
  804580:	d9000f17 	ldw	r4,60(sp)
			if (!dir) {
  804584:	203fd71e 	bne	r4,zero,8044e4 <f_unlink+0x64>
  804588:	00c00184 	movi	r3,6
  80458c:	00001406 	br	8045e0 <f_unlink+0x160>
  804590:	00c00084 	movi	r3,2
  804594:	00001206 	br	8045e0 <f_unlink+0x160>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
  804598:	d9000a04 	addi	r4,sp,40
  80459c:	0802ae00 	call	802ae0 <dir_remove>
  8045a0:	1007883a 	mov	r3,r2
				if (res == FR_OK) {
  8045a4:	103fec26 	beq	r2,zero,804558 <f_unlink+0xd8>
  8045a8:	00000d06 	br	8045e0 <f_unlink+0x160>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = LD_CLUST(dir);
  8045ac:	20800543 	ldbu	r2,21(r4)
  8045b0:	21400503 	ldbu	r5,20(r4)
  8045b4:	20c006c3 	ldbu	r3,27(r4)
  8045b8:	1004923a 	slli	r2,r2,8
  8045bc:	21000683 	ldbu	r4,26(r4)
  8045c0:	1806923a 	slli	r3,r3,8
  8045c4:	1144b03a 	or	r2,r2,r5
  8045c8:	1004943a 	slli	r2,r2,16
  8045cc:	1906b03a 	or	r3,r3,r4
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
  8045d0:	3100040c 	andi	r4,r6,16
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = LD_CLUST(dir);
  8045d4:	10e0b03a 	or	r16,r2,r3
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
  8045d8:	203fc71e 	bne	r4,zero,8044f8 <f_unlink+0x78>
  8045dc:	003fee06 	br	804598 <f_unlink+0x118>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
  8045e0:	1805883a 	mov	r2,r3
  8045e4:	dfc01517 	ldw	ra,84(sp)
  8045e8:	dc801417 	ldw	r18,80(sp)
  8045ec:	dc401317 	ldw	r17,76(sp)
  8045f0:	dc001217 	ldw	r16,72(sp)
  8045f4:	dec01604 	addi	sp,sp,88
  8045f8:	f800283a 	ret

008045fc <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  8045fc:	defffe04 	addi	sp,sp,-8
  804600:	dc000015 	stw	r16,0(sp)
  804604:	2021883a 	mov	r16,r4
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  804608:	8140010b 	ldhu	r5,4(r16)
  80460c:	21000017 	ldw	r4,0(r4)
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  804610:	dfc00115 	stw	ra,4(sp)
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  804614:	0801ad80 	call	801ad8 <validate>
  804618:	1007883a 	mov	r3,r2
	if (res == FR_OK) {
  80461c:	1000301e 	bne	r2,zero,8046e0 <f_sync+0xe4>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  804620:	80800183 	ldbu	r2,6(r16)
  804624:	1080080c 	andi	r2,r2,32
  804628:	10002d26 	beq	r2,zero,8046e0 <f_sync+0xe4>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  80462c:	81000017 	ldw	r4,0(r16)
  804630:	81400717 	ldw	r5,28(r16)
  804634:	08021640 	call	802164 <move_window>
  804638:	1007883a 	mov	r3,r2
			if (res == FR_OK) {
  80463c:	1000281e 	bne	r2,zero,8046e0 <f_sync+0xe4>
				dir = fp->dir_ptr;
  804640:	80c00817 	ldw	r3,32(r16)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  804644:	188002c3 	ldbu	r2,11(r3)
  804648:	10800814 	ori	r2,r2,32
  80464c:	188002c5 	stb	r2,11(r3)
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  804650:	80800317 	ldw	r2,12(r16)
  804654:	18800705 	stb	r2,28(r3)
  804658:	8080030b 	ldhu	r2,12(r16)
  80465c:	1004d23a 	srli	r2,r2,8
  804660:	18800745 	stb	r2,29(r3)
  804664:	8080038b 	ldhu	r2,14(r16)
  804668:	18800785 	stb	r2,30(r3)
  80466c:	808003c3 	ldbu	r2,15(r16)
  804670:	188007c5 	stb	r2,31(r3)
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  804674:	80800417 	ldw	r2,16(r16)
  804678:	18800685 	stb	r2,26(r3)
  80467c:	8080040b 	ldhu	r2,16(r16)
  804680:	1004d23a 	srli	r2,r2,8
  804684:	188006c5 	stb	r2,27(r3)
  804688:	8080048b 	ldhu	r2,18(r16)
  80468c:	18800505 	stb	r2,20(r3)
  804690:	8100048b 	ldhu	r4,18(r16)
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
  804694:	00801004 	movi	r2,64
  804698:	18800645 	stb	r2,25(r3)
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  80469c:	2008d23a 	srli	r4,r4,8
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
  8046a0:	00800844 	movi	r2,33
  8046a4:	18800605 	stb	r2,24(r3)
  8046a8:	18000585 	stb	zero,22(r3)
  8046ac:	180005c5 	stb	zero,23(r3)
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  8046b0:	19000545 	stb	r4,21(r3)
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  8046b4:	80800183 	ldbu	r2,6(r16)
				fp->fs->wflag = 1;
  8046b8:	80c00017 	ldw	r3,0(r16)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  8046bc:	108037cc 	andi	r2,r2,223
  8046c0:	80800185 	stb	r2,6(r16)
				fp->fs->wflag = 1;
  8046c4:	00800044 	movi	r2,1
  8046c8:	18800105 	stb	r2,4(r3)
				res = sync(fp->fs);
  8046cc:	81000017 	ldw	r4,0(r16)
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  8046d0:	dfc00117 	ldw	ra,4(sp)
  8046d4:	dc000017 	ldw	r16,0(sp)
  8046d8:	dec00204 	addi	sp,sp,8
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
				res = sync(fp->fs);
  8046dc:	0803fb41 	jmpi	803fb4 <sync>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  8046e0:	1805883a 	mov	r2,r3
  8046e4:	dfc00117 	ldw	ra,4(sp)
  8046e8:	dc000017 	ldw	r16,0(sp)
  8046ec:	dec00204 	addi	sp,sp,8
  8046f0:	f800283a 	ret

008046f4 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  8046f4:	defffe04 	addi	sp,sp,-8
  8046f8:	dc000015 	stw	r16,0(sp)
  8046fc:	dfc00115 	stw	ra,4(sp)
  804700:	2021883a 	mov	r16,r4
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  804704:	08045fc0 	call	8045fc <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  804708:	1000011e 	bne	r2,zero,804710 <f_close+0x1c>
  80470c:	80000015 	stw	zero,0(r16)
	return res;
#endif
}
  804710:	dfc00117 	ldw	ra,4(sp)
  804714:	dc000017 	ldw	r16,0(sp)
  804718:	dec00204 	addi	sp,sp,8
  80471c:	f800283a 	ret

00804720 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  804720:	deffef04 	addi	sp,sp,-68
  804724:	dc800d15 	stw	r18,52(sp)


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  804728:	348007cc 	andi	r18,r6,31
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  80472c:	dc400c15 	stw	r17,48(sp)
  804730:	dc000b15 	stw	r16,44(sp)

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  804734:	94403fcc 	andi	r17,r18,255
  804738:	dc000304 	addi	r16,sp,12
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  80473c:	dd000f15 	stw	r20,60(sp)
  804740:	d9400a15 	stw	r5,40(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  804744:	20000015 	stw	zero,0(r4)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  804748:	2029883a 	mov	r20,r4

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  80474c:	800b883a 	mov	r5,r16
  804750:	d9000a04 	addi	r4,sp,40
  804754:	8980078c 	andi	r6,r17,30
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  804758:	dfc01015 	stw	ra,64(sp)
  80475c:	dcc00e15 	stw	r19,56(sp)

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  804760:	0801c0c0 	call	801c0c <chk_mounted>
  804764:	1011883a 	mov	r8,r2
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  804768:	dec00915 	stw	sp,36(sp)
	if (res == FR_OK)
  80476c:	1000761e 	bne	r2,zero,804948 <f_open+0x228>
		res = follow_path(&dj, path);	/* Follow the file path */
  804770:	d9400a17 	ldw	r5,40(sp)
  804774:	8009883a 	mov	r4,r16
  804778:	080377c0 	call	80377c <follow_path>
  80477c:	1011883a 	mov	r8,r2
	dir = dj.dir;
  804780:	dc000817 	ldw	r16,32(sp)

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  804784:	1000021e 	bne	r2,zero,804790 <f_open+0x70>
		if (!dir)	/* Current dir itself */
  804788:	8000011e 	bne	r16,zero,804790 <f_open+0x70>
  80478c:	02000184 	movi	r8,6
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  804790:	8880070c 	andi	r2,r17,28
  804794:	10003626 	beq	r2,zero,804870 <f_open+0x150>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  804798:	40000926 	beq	r8,zero,8047c0 <f_open+0xa0>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  80479c:	00800104 	movi	r2,4
  8047a0:	4080701e 	bne	r8,r2,804964 <f_open+0x244>
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
				res = dir_register(&dj);
  8047a4:	d9000304 	addi	r4,sp,12
  8047a8:	08033300 	call	803330 <dir_register>
  8047ac:	1011883a 	mov	r8,r2
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
  8047b0:	dc000817 	ldw	r16,32(sp)
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  8047b4:	10006b1e 	bne	r2,zero,804964 <f_open+0x244>
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  8047b8:	94800214 	ori	r18,r18,8
  8047bc:	00000506 	br	8047d4 <f_open+0xb4>
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  8047c0:	808002c3 	ldbu	r2,11(r16)
  8047c4:	1080044c 	andi	r2,r2,17
  8047c8:	1000321e 	bne	r2,zero,804894 <f_open+0x174>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  8047cc:	8880010c 	andi	r2,r17,4
  8047d0:	10005f1e 	bne	r2,zero,804950 <f_open+0x230>
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  8047d4:	9080020c 	andi	r2,r18,8
  8047d8:	10005f26 	beq	r2,zero,804958 <f_open+0x238>
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  8047dc:	80c00543 	ldbu	r3,21(r16)
  8047e0:	80800503 	ldbu	r2,20(r16)
  8047e4:	810006c3 	ldbu	r4,27(r16)
  8047e8:	1806923a 	slli	r3,r3,8
  8047ec:	81400683 	ldbu	r5,26(r16)
  8047f0:	2008923a 	slli	r4,r4,8
  8047f4:	1886b03a 	or	r3,r3,r2
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  8047f8:	00800844 	movi	r2,33
  8047fc:	80800405 	stb	r2,16(r16)
  804800:	00801004 	movi	r2,64
  804804:	80800445 	stb	r2,17(r16)
  804808:	80000385 	stb	zero,14(r16)
  80480c:	800003c5 	stb	zero,15(r16)
			dir[DIR_Attr] = 0;					/* Reset attribute */
  804810:	800002c5 	stb	zero,11(r16)
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  804814:	80000705 	stb	zero,28(r16)
  804818:	80000745 	stb	zero,29(r16)
  80481c:	80000785 	stb	zero,30(r16)
  804820:	800007c5 	stb	zero,31(r16)
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  804824:	80000685 	stb	zero,26(r16)
  804828:	800006c5 	stb	zero,27(r16)
  80482c:	80000505 	stb	zero,20(r16)
  804830:	80000545 	stb	zero,21(r16)
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  804834:	1806943a 	slli	r3,r3,16
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  804838:	d8800317 	ldw	r2,12(sp)
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  80483c:	2148b03a 	or	r4,r4,r5
  804840:	1922b03a 	or	r17,r3,r4
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  804844:	00c00044 	movi	r3,1
  804848:	10c00105 	stb	r3,4(r2)
			if (cl) {							/* Remove the cluster chain if exist */
  80484c:	88004226 	beq	r17,zero,804958 <f_open+0x238>
				dw = dj.fs->winsect;
  804850:	d8800317 	ldw	r2,12(sp)
				res = remove_chain(dj.fs, cl);
  804854:	880b883a 	mov	r5,r17
  804858:	1009883a 	mov	r4,r2
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  80485c:	14c00c17 	ldw	r19,48(r2)
				res = remove_chain(dj.fs, cl);
  804860:	0803dc00 	call	803dc0 <remove_chain>
  804864:	1011883a 	mov	r8,r2
				if (res == FR_OK) {
  804868:	10003e1e 	bne	r2,zero,804964 <f_open+0x244>
  80486c:	00000b06 	br	80489c <f_open+0x17c>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  804870:	40003c1e 	bne	r8,zero,804964 <f_open+0x244>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  804874:	80c002c3 	ldbu	r3,11(r16)
  804878:	1880040c 	andi	r2,r3,16
  80487c:	1000381e 	bne	r2,zero,804960 <f_open+0x240>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  804880:	8880008c 	andi	r2,r17,2
  804884:	10003426 	beq	r2,zero,804958 <f_open+0x238>
  804888:	1880004c 	andi	r2,r3,1
  80488c:	1005003a 	cmpeq	r2,r2,zero
  804890:	1000311e 	bne	r2,zero,804958 <f_open+0x238>
  804894:	020001c4 	movi	r8,7
  804898:	00003206 	br	804964 <f_open+0x244>
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  80489c:	d9000317 	ldw	r4,12(sp)
  8048a0:	88bfffc4 	addi	r2,r17,-1
					res = move_window(dj.fs, dw);
  8048a4:	980b883a 	mov	r5,r19
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  8048a8:	20800315 	stw	r2,12(r4)
					res = move_window(dj.fs, dw);
  8048ac:	08021640 	call	802164 <move_window>
  8048b0:	1011883a 	mov	r8,r2
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  8048b4:	10002b1e 	bne	r2,zero,804964 <f_open+0x244>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  8048b8:	9080020c 	andi	r2,r18,8
  8048bc:	10000126 	beq	r2,zero,8048c4 <f_open+0x1a4>
			mode |= FA__WRITTEN;
  8048c0:	94800814 	ori	r18,r18,32
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  8048c4:	d9800317 	ldw	r6,12(sp)
		fp->dir_ptr = dir;
  8048c8:	a4000815 	stw	r16,32(r20)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  8048cc:	30800c17 	ldw	r2,48(r6)
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  8048d0:	a4800185 	stb	r18,6(r20)
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  8048d4:	31c0018b 	ldhu	r7,6(r6)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  8048d8:	a0800715 	stw	r2,28(r20)
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  8048dc:	80800543 	ldbu	r2,21(r16)
  8048e0:	81400503 	ldbu	r5,20(r16)
  8048e4:	80c006c3 	ldbu	r3,27(r16)
  8048e8:	1004923a 	slli	r2,r2,8
  8048ec:	81000683 	ldbu	r4,26(r16)
  8048f0:	1806923a 	slli	r3,r3,8
  8048f4:	1144b03a 	or	r2,r2,r5
  8048f8:	1004943a 	slli	r2,r2,16
  8048fc:	1906b03a 	or	r3,r3,r4
  804900:	10c4b03a 	or	r2,r2,r3
  804904:	a0800415 	stw	r2,16(r20)
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  804908:	808007c3 	ldbu	r2,31(r16)
  80490c:	80c00783 	ldbu	r3,30(r16)
  804910:	81000743 	ldbu	r4,29(r16)
  804914:	1004963a 	slli	r2,r2,24
  804918:	1806943a 	slli	r3,r3,16
  80491c:	81400703 	ldbu	r5,28(r16)
  804920:	2008923a 	slli	r4,r4,8
  804924:	10c4b03a 	or	r2,r2,r3
  804928:	1144b03a 	or	r2,r2,r5
  80492c:	2088b03a 	or	r4,r4,r2
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  804930:	a1c0010d 	sth	r7,4(r20)
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  804934:	a1000315 	stw	r4,12(r20)
		fp->fptr = 0;						/* File pointer */
  804938:	a0000215 	stw	zero,8(r20)
		fp->dsect = 0;
  80493c:	a0000615 	stw	zero,24(r20)
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  804940:	a1800015 	stw	r6,0(r20)
  804944:	00000706 	br	804964 <f_open+0x244>
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
  804948:	dc000817 	ldw	r16,32(sp)
  80494c:	003f9006 	br	804790 <f_open+0x70>
  804950:	02000204 	movi	r8,8
  804954:	00000306 	br	804964 <f_open+0x244>
  804958:	0011883a 	mov	r8,zero
  80495c:	003fd606 	br	8048b8 <f_open+0x198>
  804960:	02000104 	movi	r8,4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  804964:	4005883a 	mov	r2,r8
  804968:	dfc01017 	ldw	ra,64(sp)
  80496c:	dd000f17 	ldw	r20,60(sp)
  804970:	dcc00e17 	ldw	r19,56(sp)
  804974:	dc800d17 	ldw	r18,52(sp)
  804978:	dc400c17 	ldw	r17,48(sp)
  80497c:	dc000b17 	ldw	r16,44(sp)
  804980:	dec01104 	addi	sp,sp,68
  804984:	f800283a 	ret

00804988 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
  804988:	deffef04 	addi	sp,sp,-68
  80498c:	dc400c15 	stw	r17,48(sp)
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  804990:	dc400304 	addi	r17,sp,12
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
  804994:	d9000a15 	stw	r4,40(sp)
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  804998:	880b883a 	mov	r5,r17
  80499c:	d9000a04 	addi	r4,sp,40
  8049a0:	01800044 	movi	r6,1
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
  8049a4:	dc000b15 	stw	r16,44(sp)
  8049a8:	dfc01015 	stw	ra,64(sp)
  8049ac:	dd000f15 	stw	r20,60(sp)
  8049b0:	dcc00e15 	stw	r19,56(sp)
  8049b4:	dc800d15 	stw	r18,52(sp)
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  8049b8:	0801c0c0 	call	801c0c <chk_mounted>
  8049bc:	1021883a 	mov	r16,r2
	if (res == FR_OK) {
  8049c0:	10008d1e 	bne	r2,zero,804bf8 <f_mkdir+0x270>
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
  8049c4:	d9400a17 	ldw	r5,40(sp)
  8049c8:	8809883a 	mov	r4,r17
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  8049cc:	dec00915 	stw	sp,36(sp)
		res = follow_path(&dj, path);			/* Follow the file path */
  8049d0:	080377c0 	call	80377c <follow_path>
  8049d4:	1021883a 	mov	r16,r2
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
  8049d8:	1000021e 	bne	r2,zero,8049e4 <f_mkdir+0x5c>
  8049dc:	04000204 	movi	r16,8
  8049e0:	00008506 	br	804bf8 <f_mkdir+0x270>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
  8049e4:	00800104 	movi	r2,4
  8049e8:	8080831e 	bne	r16,r2,804bf8 <f_mkdir+0x270>
  8049ec:	d8800917 	ldw	r2,36(sp)
  8049f0:	108002c3 	ldbu	r2,11(r2)
  8049f4:	1080080c 	andi	r2,r2,32
  8049f8:	10006e1e 	bne	r2,zero,804bb4 <f_mkdir+0x22c>
  8049fc:	00006f06 	br	804bbc <f_mkdir+0x234>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
  804a00:	00800044 	movi	r2,1
  804a04:	9880021e 	bne	r19,r2,804a10 <f_mkdir+0x88>
  804a08:	04000084 	movi	r16,2
  804a0c:	00004e06 	br	804b48 <f_mkdir+0x1c0>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
  804a10:	00bfffc4 	movi	r2,-1
  804a14:	9880721e 	bne	r19,r2,804be0 <f_mkdir+0x258>
  804a18:	00006f06 	br	804bd8 <f_mkdir+0x250>
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
  804a1c:	dc000317 	ldw	r16,12(sp)
  804a20:	980b883a 	mov	r5,r19
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
  804a24:	04400b84 	movi	r17,46
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
  804a28:	8009883a 	mov	r4,r16
				dir = dj.fs->win;
  804a2c:	84800d04 	addi	r18,r16,52
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
  804a30:	08017d80 	call	8017d8 <clust2sect>
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
  804a34:	01808004 	movi	r6,512
  804a38:	000b883a 	mov	r5,zero
  804a3c:	9009883a 	mov	r4,r18
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
  804a40:	1029883a 	mov	r20,r2
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
  804a44:	08017bc0 	call	8017bc <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
  804a48:	9009883a 	mov	r4,r18
  804a4c:	01400804 	movi	r5,32
  804a50:	018002c4 	movi	r6,11
  804a54:	08017bc0 	call	8017bc <mem_set>
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
  804a58:	980ad43a 	srli	r5,r19,16
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
  804a5c:	84400d05 	stb	r17,52(r16)
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
  804a60:	9808d23a 	srli	r4,r19,8
  804a64:	2806d23a 	srli	r3,r5,8
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
  804a68:	00800404 	movi	r2,16
  804a6c:	908002c5 	stb	r2,11(r18)
				ST_DWORD(dir+DIR_WrtTime, tim);
  804a70:	00800844 	movi	r2,33
  804a74:	90800605 	stb	r2,24(r18)
  804a78:	00801004 	movi	r2,64
  804a7c:	90800645 	stb	r2,25(r18)
				ST_CLUST(dir, dcl);
  804a80:	910006c5 	stb	r4,27(r18)
  804a84:	90c00545 	stb	r3,21(r18)
  804a88:	91400505 	stb	r5,20(r18)
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
  804a8c:	81001504 	addi	r4,r16,84
  804a90:	900b883a 	mov	r5,r18
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  804a94:	90000585 	stb	zero,22(r18)
  804a98:	900005c5 	stb	zero,23(r18)
				ST_CLUST(dir, dcl);
  804a9c:	94c00685 	stb	r19,26(r18)
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
  804aa0:	01800804 	movi	r6,32
  804aa4:	08017980 	call	801798 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
  804aa8:	94400845 	stb	r17,33(r18)
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  804aac:	d9000317 	ldw	r4,12(sp)
  804ab0:	008000c4 	movi	r2,3
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
  804ab4:	d9400517 	ldw	r5,20(sp)
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  804ab8:	20c00003 	ldbu	r3,0(r4)
  804abc:	1880031e 	bne	r3,r2,804acc <f_mkdir+0x144>
  804ac0:	20800a17 	ldw	r2,40(r4)
  804ac4:	2880011e 	bne	r5,r2,804acc <f_mkdir+0x144>
  804ac8:	000b883a 	mov	r5,zero
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
  804acc:	2808d43a 	srli	r4,r5,16
  804ad0:	2804d23a 	srli	r2,r5,8
  804ad4:	91400e85 	stb	r5,58(r18)
  804ad8:	2006d23a 	srli	r3,r4,8
  804adc:	90800ec5 	stb	r2,59(r18)
  804ae0:	91000d05 	stb	r4,52(r18)
  804ae4:	90c00d45 	stb	r3,53(r18)
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  804ae8:	d8800317 	ldw	r2,12(sp)
  804aec:	14400083 	ldbu	r17,2(r2)
  804af0:	00000d06 	br	804b28 <f_mkdir+0x1a0>
					dj.fs->winsect = dsc++;
  804af4:	d8c00317 	ldw	r3,12(sp)
					dj.fs->wflag = 1;
  804af8:	00800044 	movi	r2,1
  804afc:	18800105 	stb	r2,4(r3)
					res = move_window(dj.fs, 0);
  804b00:	d9000317 	ldw	r4,12(sp)
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
  804b04:	1d000c15 	stw	r20,48(r3)
  804b08:	a5000044 	addi	r20,r20,1
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
  804b0c:	08021640 	call	802164 <move_window>
  804b10:	1021883a 	mov	r16,r2
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
  804b14:	9009883a 	mov	r4,r18
  804b18:	000b883a 	mov	r5,zero
  804b1c:	01808004 	movi	r6,512
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
  804b20:	1000081e 	bne	r2,zero,804b44 <f_mkdir+0x1bc>
					mem_set(dir, 0, SS(dj.fs));
  804b24:	08017bc0 	call	8017bc <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  804b28:	88803fcc 	andi	r2,r17,255
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
  804b2c:	000b883a 	mov	r5,zero
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  804b30:	8c7fffc4 	addi	r17,r17,-1
  804b34:	103fef1e 	bne	r2,zero,804af4 <f_mkdir+0x16c>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
  804b38:	d9000304 	addi	r4,sp,12
  804b3c:	08033300 	call	803330 <dir_register>
  804b40:	1021883a 	mov	r16,r2
			if (res != FR_OK) {
  804b44:	80000426 	beq	r16,zero,804b58 <f_mkdir+0x1d0>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
  804b48:	d9000317 	ldw	r4,12(sp)
  804b4c:	980b883a 	mov	r5,r19
  804b50:	0803dc00 	call	803dc0 <remove_chain>
  804b54:	00002806 	br	804bf8 <f_mkdir+0x270>
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
  804b58:	980ad43a 	srli	r5,r19,16
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
  804b5c:	d8800817 	ldw	r2,32(sp)
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
  804b60:	9808d23a 	srli	r4,r19,8
  804b64:	2806d23a 	srli	r3,r5,8
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
  804b68:	10000585 	stb	zero,22(r2)
				ST_CLUST(dir, dcl);					/* Table start cluster */
  804b6c:	110006c5 	stb	r4,27(r2)
  804b70:	10c00545 	stb	r3,21(r2)
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
  804b74:	00c00404 	movi	r3,16
  804b78:	10c002c5 	stb	r3,11(r2)
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
  804b7c:	00c00844 	movi	r3,33
  804b80:	10c00605 	stb	r3,24(r2)
  804b84:	00c01004 	movi	r3,64
  804b88:	10c00645 	stb	r3,25(r2)
  804b8c:	100005c5 	stb	zero,23(r2)
				ST_CLUST(dir, dcl);					/* Table start cluster */
  804b90:	14c00685 	stb	r19,26(r2)
  804b94:	11400505 	stb	r5,20(r2)
				dj.fs->wflag = 1;
  804b98:	d8800317 	ldw	r2,12(sp)
  804b9c:	00c00044 	movi	r3,1
  804ba0:	10c00105 	stb	r3,4(r2)
				res = sync(dj.fs);
  804ba4:	d9000317 	ldw	r4,12(sp)
  804ba8:	0803fb40 	call	803fb4 <sync>
  804bac:	1021883a 	mov	r16,r2
  804bb0:	00001106 	br	804bf8 <f_mkdir+0x270>
  804bb4:	04000184 	movi	r16,6
  804bb8:	00000f06 	br	804bf8 <f_mkdir+0x270>
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
  804bbc:	d9000317 	ldw	r4,12(sp)
  804bc0:	000b883a 	mov	r5,zero
  804bc4:	0802b400 	call	802b40 <create_chain>
  804bc8:	1027883a 	mov	r19,r2
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
  804bcc:	103f8c1e 	bne	r2,zero,804a00 <f_mkdir+0x78>
  804bd0:	040001c4 	movi	r16,7
  804bd4:	003fdc06 	br	804b48 <f_mkdir+0x1c0>
  804bd8:	04000044 	movi	r16,1
  804bdc:	003fda06 	br	804b48 <f_mkdir+0x1c0>
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
  804be0:	d9000317 	ldw	r4,12(sp)
  804be4:	000b883a 	mov	r5,zero
  804be8:	08021640 	call	802164 <move_window>
  804bec:	1021883a 	mov	r16,r2
			if (res == FR_OK) {					/* Initialize the new directory table */
  804bf0:	103fd41e 	bne	r2,zero,804b44 <f_mkdir+0x1bc>
  804bf4:	003f8906 	br	804a1c <f_mkdir+0x94>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  804bf8:	8005883a 	mov	r2,r16
  804bfc:	dfc01017 	ldw	ra,64(sp)
  804c00:	dd000f17 	ldw	r20,60(sp)
  804c04:	dcc00e17 	ldw	r19,56(sp)
  804c08:	dc800d17 	ldw	r18,52(sp)
  804c0c:	dc400c17 	ldw	r17,48(sp)
  804c10:	dc000b17 	ldw	r16,44(sp)
  804c14:	dec01104 	addi	sp,sp,68
  804c18:	f800283a 	ret

00804c1c <read_fft_cache>:
 *  Created on: Dec 11, 2012
 *      Author: Gregory
 */
#include "fft_cache.h"

void read_fft_cache(alt_u32 * lfft_bffr, alt_u32 * rfft_bffr, alt_u8 num){
  804c1c:	2015883a 	mov	r10,r4
  804c20:	31803fcc 	andi	r6,r6,255
  804c24:	0013883a 	mov	r9,zero
  804c28:	02c04434 	movhi	r11,272
  804c2c:	00000a06 	br	804c58 <read_fft_cache+0x3c>
	alt_u8 i;

	for(i=0; i<num; i++){	//num should  be < 128
		rfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_RCACHE_BASE)<<4);
  804c30:	19000037 	ldwio	r4,0(r3)
		lfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_LCACHE_BASE)<<4);
  804c34:	38802004 	addi	r2,r7,128
  804c38:	1004913a 	slli	r2,r2,4

void read_fft_cache(alt_u32 * lfft_bffr, alt_u32 * rfft_bffr, alt_u8 num){
	alt_u8 i;

	for(i=0; i<num; i++){	//num should  be < 128
		rfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_RCACHE_BASE)<<4);
  804c3c:	2a07883a 	add	r3,r5,r8
  804c40:	19000015 	stw	r4,0(r3)
		lfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_LCACHE_BASE)<<4);
  804c44:	12c5883a 	add	r2,r2,r11
  804c48:	10c00037 	ldwio	r3,0(r2)
  804c4c:	5205883a 	add	r2,r10,r8
  804c50:	10c00015 	stw	r3,0(r2)
#include "fft_cache.h"

void read_fft_cache(alt_u32 * lfft_bffr, alt_u32 * rfft_bffr, alt_u8 num){
	alt_u8 i;

	for(i=0; i<num; i++){	//num should  be < 128
  804c54:	4a400044 	addi	r9,r9,1
  804c58:	49c03fcc 	andi	r7,r9,255
		rfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_RCACHE_BASE)<<4);
  804c5c:	3806913a 	slli	r3,r7,4
  804c60:	39c5883a 	add	r2,r7,r7
  804c64:	1091883a 	add	r8,r2,r2
  804c68:	1ac7883a 	add	r3,r3,r11
#include "fft_cache.h"

void read_fft_cache(alt_u32 * lfft_bffr, alt_u32 * rfft_bffr, alt_u8 num){
	alt_u8 i;

	for(i=0; i<num; i++){	//num should  be < 128
  804c6c:	39bff01e 	bne	r7,r6,804c30 <read_fft_cache+0x14>
		rfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_RCACHE_BASE)<<4);
		lfft_bffr[i]	=	IORD_32DIRECT(FFT_CACHE_MM_SL_BASE, (i + FFT_LCACHE_BASE)<<4);
	}
}
  804c70:	f800283a 	ret

00804c74 <update_aud_bytes_read>:
	return;
}


void update_aud_bytes_read(void *p){
	aud_bytes_read	+=	*((alt_u32 *)p);
  804c74:	20c00017 	ldw	r3,0(r4)
  804c78:	d0a6eb17 	ldw	r2,-25684(gp)
  804c7c:	10c5883a 	add	r2,r2,r3
  804c80:	d0a6eb15 	stw	r2,-25684(gp)
}
  804c84:	f800283a 	ret

00804c88 <byte_swap16>:

void byte_swap16(alt_u16 *data){
	*data	=	(((*data) & 0xff00) >> 8) + (((*data) & 0xff) << 8);
  804c88:	2080000b 	ldhu	r2,0(r4)
  804c8c:	10c03fcc 	andi	r3,r2,255
  804c90:	10bfc00c 	andi	r2,r2,65280
  804c94:	1005d23a 	srai	r2,r2,8
  804c98:	1806923a 	slli	r3,r3,8
  804c9c:	10c5883a 	add	r2,r2,r3
  804ca0:	2080000d 	sth	r2,0(r4)
	return;
}
  804ca4:	f800283a 	ret

00804ca8 <byte_swap32>:

void byte_swap32(alt_u32 *data){
	*data	=	(((*data) & 0xff000000) >> 24) + (((*data) & 0xff0000) >> 8) + (((*data) & 0xff00) << 8) + (((*data) & 0xff) << 24);
  804ca8:	20800017 	ldw	r2,0(r4)
  804cac:	11bfc00c 	andi	r6,r2,65280
  804cb0:	11403fec 	andhi	r5,r2,255
  804cb4:	1006d63a 	srli	r3,r2,24
  804cb8:	280ad23a 	srli	r5,r5,8
  804cbc:	300c923a 	slli	r6,r6,8
  804cc0:	1004963a 	slli	r2,r2,24
  804cc4:	1947883a 	add	r3,r3,r5
  804cc8:	1185883a 	add	r2,r2,r6
  804ccc:	1887883a 	add	r3,r3,r2
  804cd0:	20c00015 	stw	r3,0(r4)
}
  804cd4:	f800283a 	ret

00804cd8 <chk_wav_hdr>:

alt_u32 chk_wav_hdr(WavHdrType *hdr){
	alt_u32	error =0;

	if(hdr->ChunkID		!= 0x52494646)	error = 1;
	if(hdr->Format		!= 0x57415645)	error = 1;
  804cd8:	20c00217 	ldw	r3,8(r4)
  804cdc:	0095d074 	movhi	r2,22337
  804ce0:	10959144 	addi	r2,r2,22085
}

alt_u32 chk_wav_hdr(WavHdrType *hdr){
	alt_u32	error =0;

	if(hdr->ChunkID		!= 0x52494646)	error = 1;
  804ce4:	21400017 	ldw	r5,0(r4)
	if(hdr->Format		!= 0x57415645)	error = 1;
  804ce8:	18800226 	beq	r3,r2,804cf4 <chk_wav_hdr+0x1c>
  804cec:	01800044 	movi	r6,1
  804cf0:	00000306 	br	804d00 <chk_wav_hdr+0x28>
  804cf4:	00949274 	movhi	r2,21065
  804cf8:	10919184 	addi	r2,r2,17990
  804cfc:	288cc03a 	cmpne	r6,r5,r2
	if(hdr->Subchunk1ID	!= 0x666d7420)	error = 1;
  804d00:	20c00317 	ldw	r3,12(r4)
  804d04:	00999b74 	movhi	r2,26221
  804d08:	109d0804 	addi	r2,r2,29728
  804d0c:	18800126 	beq	r3,r2,804d14 <chk_wav_hdr+0x3c>
  804d10:	01800044 	movi	r6,1
	if((hdr->Subchunk1Size != 16) && (hdr->Subchunk1Size != 18))	error = 1;
  804d14:	20c00417 	ldw	r3,16(r4)
  804d18:	00800404 	movi	r2,16
  804d1c:	18800326 	beq	r3,r2,804d2c <chk_wav_hdr+0x54>
  804d20:	00800484 	movi	r2,18
  804d24:	18800126 	beq	r3,r2,804d2c <chk_wav_hdr+0x54>
  804d28:	01800044 	movi	r6,1
	if(hdr->AudioFormat	!= 0x1)			error = 1;
  804d2c:	2080050b 	ldhu	r2,20(r4)
  804d30:	01400044 	movi	r5,1
  804d34:	11400126 	beq	r2,r5,804d3c <chk_wav_hdr+0x64>
  804d38:	280d883a 	mov	r6,r5
	if((hdr->NumChannels   != 1)  && (hdr->NumChannels != 2))		error = 1;
  804d3c:	2080058b 	ldhu	r2,22(r4)
  804d40:	10bfffc4 	addi	r2,r2,-1
  804d44:	10bfffcc 	andi	r2,r2,65535
  804d48:	2880012e 	bgeu	r5,r2,804d50 <chk_wav_hdr+0x78>
  804d4c:	280d883a 	mov	r6,r5
	if((hdr->BitsPerSample != 16) && (hdr->BitsPerSample != 32))	error = 1;
  804d50:	20c0088b 	ldhu	r3,34(r4)
  804d54:	00800404 	movi	r2,16
  804d58:	18800326 	beq	r3,r2,804d68 <chk_wav_hdr+0x90>
  804d5c:	00800804 	movi	r2,32
  804d60:	18800126 	beq	r3,r2,804d68 <chk_wav_hdr+0x90>
  804d64:	280d883a 	mov	r6,r5
	if(hdr->Subchunk2ID	!= 0x64617461)	error = 1;
  804d68:	20c00a17 	ldw	r3,40(r4)
  804d6c:	00991874 	movhi	r2,25697
  804d70:	109d1844 	addi	r2,r2,29793
  804d74:	18800126 	beq	r3,r2,804d7c <chk_wav_hdr+0xa4>
  804d78:	01800044 	movi	r6,1

	return error;
}
  804d7c:	3005883a 	mov	r2,r6
  804d80:	f800283a 	ret

00804d84 <prep_cortex>:
}



/*	Function to configure acortex & fgyrus blocks based on parsed wavheader	*/
I2C_RES prep_cortex(WavHdrType * hdr){
  804d84:	defffe04 	addi	sp,sp,-8
  804d88:	dc000015 	stw	r16,0(sp)
  804d8c:	dfc00115 	stw	ra,4(sp)
  804d90:	2021883a 	mov	r16,r4
	alt_u8 sr_val;

	if(codec_dsp_if_inactivate())	return I2C_NACK_DETECTED;
  804d94:	08004040 	call	800404 <codec_dsp_if_inactivate>
  804d98:	10003d1e 	bne	r2,zero,804e90 <prep_cortex+0x10c>
	if(codec_dac_inactivate())		return I2C_NACK_DETECTED;
  804d9c:	080033c0 	call	80033c <codec_dac_inactivate>
  804da0:	10003b1e 	bne	r2,zero,804e90 <prep_cortex+0x10c>

	if(hdr->BitsPerSample == 16){
  804da4:	80c0088b 	ldhu	r3,34(r16)
  804da8:	00800404 	movi	r2,16
  804dac:	1880021e 	bne	r3,r2,804db8 <prep_cortex+0x34>
		if(codec_iwl_update(IWL_16))	return	I2C_NACK_DETECTED;
  804db0:	0009883a 	mov	r4,zero
  804db4:	00000106 	br	804dbc <prep_cortex+0x38>
	}
	else{	//32b
		if(codec_iwl_update(IWL_32))	return	I2C_NACK_DETECTED;
  804db8:	010000c4 	movi	r4,3
  804dbc:	08002b00 	call	8002b0 <codec_iwl_update>
  804dc0:	1000331e 	bne	r2,zero,804e90 <prep_cortex+0x10c>
	}

	//BOSR is always zero !

	//Select SR
	if(hdr->SampleRate	==	8000)		sr_val	=	FS_8KHZ;
  804dc4:	80c00617 	ldw	r3,24(r16)
  804dc8:	0087d004 	movi	r2,8000
  804dcc:	1880021e 	bne	r3,r2,804dd8 <prep_cortex+0x54>
  804dd0:	0005883a 	mov	r2,zero
  804dd4:	00001006 	br	804e18 <prep_cortex+0x94>
	else if(hdr->SampleRate	==	32000)	sr_val	=	FS_32KHZ;
  804dd8:	009f4004 	movi	r2,32000
  804ddc:	1880021e 	bne	r3,r2,804de8 <prep_cortex+0x64>
  804de0:	00800044 	movi	r2,1
  804de4:	00000c06 	br	804e18 <prep_cortex+0x94>
	else if(hdr->SampleRate	==	44100)	sr_val	=	FS_44KHZ;
  804de8:	00ab1114 	movui	r2,44100
  804dec:	1880021e 	bne	r3,r2,804df8 <prep_cortex+0x74>
  804df0:	00800084 	movi	r2,2
  804df4:	00000806 	br	804e18 <prep_cortex+0x94>
	else if(hdr->SampleRate	==	48000)	sr_val	=	FS_48KHZ;
  804df8:	00aee014 	movui	r2,48000
  804dfc:	1880021e 	bne	r3,r2,804e08 <prep_cortex+0x84>
  804e00:	008000c4 	movi	r2,3
  804e04:	00000406 	br	804e18 <prep_cortex+0x94>
	else if(hdr->SampleRate	==	88200)	sr_val	=	FS_88KHZ;
  804e08:	00800074 	movhi	r2,1
  804e0c:	10962204 	addi	r2,r2,22664
  804e10:	1884c03a 	cmpne	r2,r3,r2
  804e14:	10800104 	addi	r2,r2,4
	else 								sr_val	=	FS_96KHZ;	//default is 96KHz

	if(codec_config_reg(CODEC_SR_IDX, CODEC_SR_OFFST, CODEC_SR_MSK, sr_val))	return	I2C_NACK_DETECTED;
  804e18:	11c03fcc 	andi	r7,r2,255
  804e1c:	01000204 	movi	r4,8
  804e20:	01400084 	movi	r5,2
  804e24:	018003c4 	movi	r6,15
  804e28:	08002600 	call	800260 <codec_config_reg>
  804e2c:	1000181e 	bne	r2,zero,804e90 <prep_cortex+0x10c>

	//Update MCLK
	if((hdr->SampleRate == 44100) || (hdr->SampleRate == 88200)){
  804e30:	80c00617 	ldw	r3,24(r16)
  804e34:	00ab1114 	movui	r2,44100
  804e38:	18800326 	beq	r3,r2,804e48 <prep_cortex+0xc4>
  804e3c:	00800074 	movhi	r2,1
  804e40:	10962204 	addi	r2,r2,22664
  804e44:	1880031e 	bne	r3,r2,804e54 <prep_cortex+0xd0>
		update_mclk(CORTEX_MM_SL_BASE, CLK_11MHZ);
  804e48:	01004034 	movhi	r4,256
  804e4c:	014000c4 	movi	r5,3
  804e50:	00000206 	br	804e5c <prep_cortex+0xd8>
	}
	else{
		update_mclk(CORTEX_MM_SL_BASE, CLK_12MHZ);
  804e54:	01004034 	movhi	r4,256
  804e58:	01400084 	movi	r5,2
  804e5c:	08008840 	call	800884 <update_mclk>
	}

	enable_fgyrus(CORTEX_MM_SL_BASE,(FGYRUS_TYPE)0);	//by default
  804e60:	000b883a 	mov	r5,zero
  804e64:	01004034 	movhi	r4,256
  804e68:	0800d340 	call	800d34 <enable_fgyrus>
	if(hdr->NumChannels > 1)	enable_fgyrus(CORTEX_MM_SL_BASE,(FGYRUS_TYPE)1);
  804e6c:	8080058b 	ldhu	r2,22(r16)
  804e70:	01400044 	movi	r5,1
  804e74:	2880022e 	bgeu	r5,r2,804e80 <prep_cortex+0xfc>
  804e78:	01004034 	movhi	r4,256
  804e7c:	0800d340 	call	800d34 <enable_fgyrus>

	enable_dac_drvr(CORTEX_MM_SL_BASE);
  804e80:	01004034 	movhi	r4,256
  804e84:	08009500 	call	800950 <enable_dac_drvr>
  804e88:	0005883a 	mov	r2,zero
  804e8c:	00000106 	br	804e94 <prep_cortex+0x110>




	return I2C_OK;
  804e90:	00800044 	movi	r2,1
}
  804e94:	dfc00117 	ldw	ra,4(sp)
  804e98:	dc000017 	ldw	r16,0(sp)
  804e9c:	dec00204 	addi	sp,sp,8
  804ea0:	f800283a 	ret

00804ea4 <printf_wave_hdr>:

void byte_swap32(alt_u32 *data){
	*data	=	(((*data) & 0xff000000) >> 24) + (((*data) & 0xff0000) >> 8) + (((*data) & 0xff00) << 8) + (((*data) & 0xff) << 24);
}

void printf_wave_hdr(WavHdrType *hdr){
  804ea4:	defffe04 	addi	sp,sp,-8
  804ea8:	dc000015 	stw	r16,0(sp)
	alt_printf("ChunkID\t-\t%s\r\n",         (char *)&(hdr->ChunkID));
  804eac:	200b883a 	mov	r5,r4

void byte_swap32(alt_u32 *data){
	*data	=	(((*data) & 0xff000000) >> 24) + (((*data) & 0xff0000) >> 8) + (((*data) & 0xff00) << 8) + (((*data) & 0xff) << 24);
}

void printf_wave_hdr(WavHdrType *hdr){
  804eb0:	2021883a 	mov	r16,r4
	alt_printf("ChunkID\t-\t%s\r\n",         (char *)&(hdr->ChunkID));
  804eb4:	01002074 	movhi	r4,129
  804eb8:	211e0504 	addi	r4,r4,30740

void byte_swap32(alt_u32 *data){
	*data	=	(((*data) & 0xff000000) >> 24) + (((*data) & 0xff0000) >> 8) + (((*data) & 0xff00) << 8) + (((*data) & 0xff) << 24);
}

void printf_wave_hdr(WavHdrType *hdr){
  804ebc:	dfc00115 	stw	ra,4(sp)
	alt_printf("ChunkID\t-\t%s\r\n",         (char *)&(hdr->ChunkID));
  804ec0:	08136300 	call	813630 <alt_printf>
	alt_printf("ChunkSize\t-\t%s\r\n",       (char *)&(hdr->ChunkSize));
  804ec4:	81400104 	addi	r5,r16,4
  804ec8:	01002074 	movhi	r4,129
  804ecc:	211e0904 	addi	r4,r4,30756
  804ed0:	08136300 	call	813630 <alt_printf>
	alt_printf("Format\t-\t%s\r\n",          (char *)&(hdr->Format));
  804ed4:	81400204 	addi	r5,r16,8
  804ed8:	01002074 	movhi	r4,129
  804edc:	211e0e04 	addi	r4,r4,30776
  804ee0:	08136300 	call	813630 <alt_printf>
	alt_printf("Subchunk1ID\t-\t%s\r\n",     (char *)&(hdr->Subchunk1ID));
  804ee4:	81400304 	addi	r5,r16,12
  804ee8:	01002074 	movhi	r4,129
  804eec:	211e1204 	addi	r4,r4,30792
  804ef0:	08136300 	call	813630 <alt_printf>
	alt_printf("Subchunk1Size\t-\t%s\r\n",   (char *)&(hdr->Subchunk1Size));
  804ef4:	81400404 	addi	r5,r16,16
  804ef8:	01002074 	movhi	r4,129
  804efc:	211e1704 	addi	r4,r4,30812
  804f00:	08136300 	call	813630 <alt_printf>
	alt_printf("AudioFormat\t-\t%s\r\n",     (char *)&(hdr->AudioFormat));
  804f04:	81400504 	addi	r5,r16,20
  804f08:	01002074 	movhi	r4,129
  804f0c:	211e1d04 	addi	r4,r4,30836
  804f10:	08136300 	call	813630 <alt_printf>
	alt_printf("NumChannels\t-\t%s\r\n",     (char *)&(hdr->NumChannels));
  804f14:	81400584 	addi	r5,r16,22
  804f18:	01002074 	movhi	r4,129
  804f1c:	211e2204 	addi	r4,r4,30856
  804f20:	08136300 	call	813630 <alt_printf>
	alt_printf("SampleRate\t-\t%s\r\n",      (char *)&(hdr->SampleRate));
  804f24:	81400604 	addi	r5,r16,24
  804f28:	01002074 	movhi	r4,129
  804f2c:	211e2704 	addi	r4,r4,30876
  804f30:	08136300 	call	813630 <alt_printf>
	alt_printf("ByteRate\t-\t%s\r\n",        (char *)&(hdr->ByteRate));
  804f34:	81400704 	addi	r5,r16,28
  804f38:	01002074 	movhi	r4,129
  804f3c:	211e2c04 	addi	r4,r4,30896
  804f40:	08136300 	call	813630 <alt_printf>
	alt_printf("BlockAlign\t-\t%s\r\n",      (char *)&(hdr->BlockAlign));
  804f44:	81400804 	addi	r5,r16,32
  804f48:	01002074 	movhi	r4,129
  804f4c:	211e3004 	addi	r4,r4,30912
  804f50:	08136300 	call	813630 <alt_printf>
	alt_printf("BitsPerSample\t-\t%s\r\n",   (char *)&(hdr->BitsPerSample));
  804f54:	81400884 	addi	r5,r16,34
  804f58:	01002074 	movhi	r4,129
  804f5c:	211e3504 	addi	r4,r4,30932
  804f60:	08136300 	call	813630 <alt_printf>
	alt_printf("Extra\t-\t%s\r\n",           (char *)&(hdr->Extra));
  804f64:	81400904 	addi	r5,r16,36
  804f68:	01002074 	movhi	r4,129
  804f6c:	211e3b04 	addi	r4,r4,30956
  804f70:	08136300 	call	813630 <alt_printf>
	alt_printf("Subchunk2ID\t-\t%s\r\n",     (char *)&(hdr->Subchunk2ID));
  804f74:	81400a04 	addi	r5,r16,40
  804f78:	01002074 	movhi	r4,129
  804f7c:	211e3f04 	addi	r4,r4,30972
  804f80:	08136300 	call	813630 <alt_printf>
	alt_printf("Subchunk2Size\t-\t%s\r\n",   (char *)&(hdr->Subchunk2Size));
  804f84:	81400b04 	addi	r5,r16,44
  804f88:	01002074 	movhi	r4,129
  804f8c:	211e4404 	addi	r4,r4,30992
	return;
}
  804f90:	dfc00117 	ldw	ra,4(sp)
  804f94:	dc000017 	ldw	r16,0(sp)
  804f98:	dec00204 	addi	sp,sp,8
	alt_printf("ByteRate\t-\t%s\r\n",        (char *)&(hdr->ByteRate));
	alt_printf("BlockAlign\t-\t%s\r\n",      (char *)&(hdr->BlockAlign));
	alt_printf("BitsPerSample\t-\t%s\r\n",   (char *)&(hdr->BitsPerSample));
	alt_printf("Extra\t-\t%s\r\n",           (char *)&(hdr->Extra));
	alt_printf("Subchunk2ID\t-\t%s\r\n",     (char *)&(hdr->Subchunk2ID));
	alt_printf("Subchunk2Size\t-\t%s\r\n",   (char *)&(hdr->Subchunk2Size));
  804f9c:	08136301 	jmpi	813630 <alt_printf>

00804fa0 <wave_parse>:
	if(hdr->Subchunk2ID	!= 0x64617461)	error = 1;

	return error;
}

alt_u32 wave_parse(WavHdrType * hdr){
  804fa0:	defffe04 	addi	sp,sp,-8

	get_wav_hdr_frm_prsr(CORTEX_MM_SL_BASE, (alt_u16 *)hdr);
  804fa4:	200b883a 	mov	r5,r4
	if(hdr->Subchunk2ID	!= 0x64617461)	error = 1;

	return error;
}

alt_u32 wave_parse(WavHdrType * hdr){
  804fa8:	dc000015 	stw	r16,0(sp)
  804fac:	2021883a 	mov	r16,r4

	get_wav_hdr_frm_prsr(CORTEX_MM_SL_BASE, (alt_u16 *)hdr);
  804fb0:	01004034 	movhi	r4,256
	if(hdr->Subchunk2ID	!= 0x64617461)	error = 1;

	return error;
}

alt_u32 wave_parse(WavHdrType * hdr){
  804fb4:	dfc00115 	stw	ra,4(sp)

	get_wav_hdr_frm_prsr(CORTEX_MM_SL_BASE, (alt_u16 *)hdr);
  804fb8:	0800b140 	call	800b14 <get_wav_hdr_frm_prsr>

	//correct endianess
	byte_swap32(&(hdr->ChunkSize));
  804fbc:	81000104 	addi	r4,r16,4
  804fc0:	0804ca80 	call	804ca8 <byte_swap32>
	byte_swap32(&(hdr->Subchunk1Size));
  804fc4:	81000404 	addi	r4,r16,16
  804fc8:	0804ca80 	call	804ca8 <byte_swap32>
	byte_swap16(&(hdr->AudioFormat));
  804fcc:	81000504 	addi	r4,r16,20
  804fd0:	0804c880 	call	804c88 <byte_swap16>
	byte_swap16(&(hdr->NumChannels));
  804fd4:	81000584 	addi	r4,r16,22
  804fd8:	0804c880 	call	804c88 <byte_swap16>
	byte_swap32(&(hdr->SampleRate));
  804fdc:	81000604 	addi	r4,r16,24
  804fe0:	0804ca80 	call	804ca8 <byte_swap32>
	byte_swap32(&(hdr->ByteRate));
  804fe4:	81000704 	addi	r4,r16,28
  804fe8:	0804ca80 	call	804ca8 <byte_swap32>
	byte_swap16(&(hdr->BlockAlign));
  804fec:	81000804 	addi	r4,r16,32
  804ff0:	0804c880 	call	804c88 <byte_swap16>
	byte_swap16(&(hdr->BitsPerSample));
  804ff4:	81000884 	addi	r4,r16,34
  804ff8:	0804c880 	call	804c88 <byte_swap16>

	if(hdr->Subchunk2Size	==	0x10){ //re align
  804ffc:	80c00b17 	ldw	r3,44(r16)
  805000:	00800404 	movi	r2,16
		hdr->Subchunk2Size	=	((hdr->Subchunk2Size & 0xffff0000) >> 16) + ((hdr->Subchunk2ID & 0xffff) << 16);
		hdr->Subchunk2ID	=	((hdr->Subchunk2ID & 0xffff0000) >> 16) + ((hdr->Extra & 0xffff) << 16);
	}

	byte_swap32(&(hdr->Subchunk2Size));
  805004:	81000b04 	addi	r4,r16,44
	byte_swap32(&(hdr->SampleRate));
	byte_swap32(&(hdr->ByteRate));
	byte_swap16(&(hdr->BlockAlign));
	byte_swap16(&(hdr->BitsPerSample));

	if(hdr->Subchunk2Size	==	0x10){ //re align
  805008:	1880081e 	bne	r3,r2,80502c <wave_parse+0x8c>
		hdr->Subchunk2Size	=	((hdr->Subchunk2Size & 0xffff0000) >> 16) + ((hdr->Subchunk2ID & 0xffff) << 16);
  80500c:	80800a17 	ldw	r2,40(r16)
		hdr->Subchunk2ID	=	((hdr->Subchunk2ID & 0xffff0000) >> 16) + ((hdr->Extra & 0xffff) << 16);
  805010:	80c0090b 	ldhu	r3,36(r16)
  805014:	100ad43a 	srli	r5,r2,16
  805018:	1806943a 	slli	r3,r3,16
	byte_swap32(&(hdr->ByteRate));
	byte_swap16(&(hdr->BlockAlign));
	byte_swap16(&(hdr->BitsPerSample));

	if(hdr->Subchunk2Size	==	0x10){ //re align
		hdr->Subchunk2Size	=	((hdr->Subchunk2Size & 0xffff0000) >> 16) + ((hdr->Subchunk2ID & 0xffff) << 16);
  80501c:	1004943a 	slli	r2,r2,16
		hdr->Subchunk2ID	=	((hdr->Subchunk2ID & 0xffff0000) >> 16) + ((hdr->Extra & 0xffff) << 16);
  805020:	28cb883a 	add	r5,r5,r3
	byte_swap32(&(hdr->ByteRate));
	byte_swap16(&(hdr->BlockAlign));
	byte_swap16(&(hdr->BitsPerSample));

	if(hdr->Subchunk2Size	==	0x10){ //re align
		hdr->Subchunk2Size	=	((hdr->Subchunk2Size & 0xffff0000) >> 16) + ((hdr->Subchunk2ID & 0xffff) << 16);
  805024:	80800b15 	stw	r2,44(r16)
		hdr->Subchunk2ID	=	((hdr->Subchunk2ID & 0xffff0000) >> 16) + ((hdr->Extra & 0xffff) << 16);
  805028:	81400a15 	stw	r5,40(r16)
	}

	byte_swap32(&(hdr->Subchunk2Size));
  80502c:	0804ca80 	call	804ca8 <byte_swap32>

	printf_wave_hdr(hdr);
  805030:	8009883a 	mov	r4,r16
  805034:	0804ea40 	call	804ea4 <printf_wave_hdr>

	return chk_wav_hdr(hdr);
  805038:	8009883a 	mov	r4,r16
}
  80503c:	dfc00117 	ldw	ra,4(sp)
  805040:	dc000017 	ldw	r16,0(sp)
  805044:	dec00204 	addi	sp,sp,8

	byte_swap32(&(hdr->Subchunk2Size));

	printf_wave_hdr(hdr);

	return chk_wav_hdr(hdr);
  805048:	0804cd81 	jmpi	804cd8 <chk_wav_hdr>

0080504c <splash_ledos>:
static WORKING_AREA(ShellStack, SHELL_WA_SIZE);

EventListener shell_tel;


void splash_ledos(void){
  80504c:	defffe04 	addi	sp,sp,-8
  805050:	dc000015 	stw	r16,0(sp)
	alt_printf("\r\n");
  805054:	04002074 	movhi	r16,129
  805058:	841f5b04 	addi	r16,r16,32108
  80505c:	8009883a 	mov	r4,r16
static WORKING_AREA(ShellStack, SHELL_WA_SIZE);

EventListener shell_tel;


void splash_ledos(void){
  805060:	dfc00115 	stw	ra,4(sp)
	alt_printf("\r\n");
  805064:	08136300 	call	813630 <alt_printf>
	alt_printf("\r\n");
  805068:	8009883a 	mov	r4,r16
  80506c:	08136300 	call	813630 <alt_printf>
	alt_printf("            .,ad88888888baa,\r\n");
  805070:	01002074 	movhi	r4,129
  805074:	211e4a04 	addi	r4,r4,31016
  805078:	08136300 	call	813630 <alt_printf>
	alt_printf("        ,d8P\"\"\"        \"\"9888ba.\r\n");
  80507c:	01002074 	movhi	r4,129
  805080:	211e5204 	addi	r4,r4,31048
  805084:	08136300 	call	813630 <alt_printf>
	alt_printf("     .a8\"          ,ad88888888888a\r\n");
  805088:	01002074 	movhi	r4,129
  80508c:	211e5b04 	addi	r4,r4,31084
  805090:	08136300 	call	813630 <alt_printf>
	alt_printf("    aP'          ,88888888888888888a\r\n");
  805094:	01002074 	movhi	r4,129
  805098:	211e6504 	addi	r4,r4,31124
  80509c:	08136300 	call	813630 <alt_printf>
	alt_printf("  ,8\"           ,88888888888888888888,\r\n");
  8050a0:	01002074 	movhi	r4,129
  8050a4:	211e6f04 	addi	r4,r4,31164
  8050a8:	08136300 	call	813630 <alt_printf>
	alt_printf(" ,8'            (888888888( )888888888,\r\n");
  8050ac:	01002074 	movhi	r4,129
  8050b0:	211e7a04 	addi	r4,r4,31208
  8050b4:	08136300 	call	813630 <alt_printf>
	alt_printf(",8'             `8888888888888888888888\r\n");
  8050b8:	01002074 	movhi	r4,129
  8050bc:	211e8504 	addi	r4,r4,31252
  8050c0:	08136300 	call	813630 <alt_printf>
	alt_printf("8)               `888888888888888888888,\r\n");
  8050c4:	01002074 	movhi	r4,129
  8050c8:	211e9004 	addi	r4,r4,31296
  8050cc:	08136300 	call	813630 <alt_printf>
	alt_printf("8                  \"8888888888888888888)\r\n");
  8050d0:	01002074 	movhi	r4,129
  8050d4:	211e9b04 	addi	r4,r4,31340
  8050d8:	08136300 	call	813630 <alt_printf>
	alt_printf("8                   `888888888888888888)\r\n");
  8050dc:	01002074 	movhi	r4,129
  8050e0:	211ea604 	addi	r4,r4,31384
  8050e4:	08136300 	call	813630 <alt_printf>
	alt_printf("8)                    \"8888888888888888\r\n");
  8050e8:	01002074 	movhi	r4,129
  8050ec:	211eb104 	addi	r4,r4,31428
  8050f0:	08136300 	call	813630 <alt_printf>
	alt_printf("(b                     \"88888888888888'\r\n");
  8050f4:	01002074 	movhi	r4,129
  8050f8:	211ebc04 	addi	r4,r4,31472
  8050fc:	08136300 	call	813630 <alt_printf>
	alt_printf("`8,        (8)          8888888888888)\r\n");
  805100:	01002074 	movhi	r4,129
  805104:	211ec704 	addi	r4,r4,31516
  805108:	08136300 	call	813630 <alt_printf>
	alt_printf(" \"8a                   ,888888888888)\r\n");
  80510c:	01002074 	movhi	r4,129
  805110:	211ed204 	addi	r4,r4,31560
  805114:	08136300 	call	813630 <alt_printf>
	alt_printf("   V8,                 d88888888888\"\r\n");
  805118:	01002074 	movhi	r4,129
  80511c:	211edc04 	addi	r4,r4,31600
  805120:	08136300 	call	813630 <alt_printf>
	alt_printf("    `8b,             ,d8888888888P'\r\n");
  805124:	01002074 	movhi	r4,129
  805128:	211ee604 	addi	r4,r4,31640
  80512c:	08136300 	call	813630 <alt_printf>
	alt_printf("      `V8a,       ,ad8888888888P'\r\n");
  805130:	01002074 	movhi	r4,129
  805134:	211ef004 	addi	r4,r4,31680
  805138:	08136300 	call	813630 <alt_printf>
	alt_printf("         \"\"88888888888888888P\"    Synesthesia by mammenx\r\n");
  80513c:	01002074 	movhi	r4,129
  805140:	211ef904 	addi	r4,r4,31716
  805144:	08136300 	call	813630 <alt_printf>
	alt_printf("              \"\"\"\"\"\"\"\"\"\"\"\"\r\n");
  805148:	01002074 	movhi	r4,129
  80514c:	211f0804 	addi	r4,r4,31776
  805150:	08136300 	call	813630 <alt_printf>
	alt_printf("\r\n");
  805154:	8009883a 	mov	r4,r16


}
  805158:	dfc00117 	ldw	ra,4(sp)
  80515c:	dc000017 	ldw	r16,0(sp)
  805160:	dec00204 	addi	sp,sp,8
	alt_printf("   V8,                 d88888888888\"\r\n");
	alt_printf("    `8b,             ,d8888888888P'\r\n");
	alt_printf("      `V8a,       ,ad8888888888P'\r\n");
	alt_printf("         \"\"88888888888888888P\"    Synesthesia by mammenx\r\n");
	alt_printf("              \"\"\"\"\"\"\"\"\"\"\"\"\r\n");
	alt_printf("\r\n");
  805164:	08136301 	jmpi	813630 <alt_printf>

00805168 <init_ledos>:


}

void init_ledos(FS_T fs, BPS_T bps){
  805168:	defffd04 	addi	sp,sp,-12
  80516c:	dc400115 	stw	r17,4(sp)
  805170:	2023883a 	mov	r17,r4

	//HW Init
	cortex_init(CORTEX_MM_SL_BASE, fs, bps);
  805174:	280d883a 	mov	r6,r5
	alt_printf("\r\n");


}

void init_ledos(FS_T fs, BPS_T bps){
  805178:	dc000015 	stw	r16,0(sp)

	//HW Init
	cortex_init(CORTEX_MM_SL_BASE, fs, bps);
  80517c:	01004034 	movhi	r4,256
	alt_printf("\r\n");


}

void init_ledos(FS_T fs, BPS_T bps){
  805180:	2821883a 	mov	r16,r5

	//HW Init
	cortex_init(CORTEX_MM_SL_BASE, fs, bps);
  805184:	880b883a 	mov	r5,r17
	alt_printf("\r\n");


}

void init_ledos(FS_T fs, BPS_T bps){
  805188:	dfc00215 	stw	ra,8(sp)

	//HW Init
	cortex_init(CORTEX_MM_SL_BASE, fs, bps);
  80518c:	0800c640 	call	800c64 <cortex_init>

	codec_init(bps, fs);
  805190:	8009883a 	mov	r4,r16
  805194:	880b883a 	mov	r5,r17
  805198:	080049c0 	call	80049c <codec_init>

	init_bash();
  80519c:	08052780 	call	805278 <init_bash>

	/*
	 * Shell manager initialization.
	*/
	shellInit();
  8051a0:	0805d780 	call	805d78 <shellInit>

	chEvtRegister(&shell_terminated, &shell_tel, 0);
  8051a4:	01800044 	movi	r6,1
  8051a8:	014020f4 	movhi	r5,131
  8051ac:	2979f604 	addi	r5,r5,-6184
  8051b0:	010020b4 	movhi	r4,130
  8051b4:	21301d04 	addi	r4,r4,-16268
  8051b8:	08101740 	call	810174 <chEvtRegisterMask>


	/*	SW Stuff	*/
	alt_printf("Updating default acid to <sunshine>\r\n");
  8051bc:	01002074 	movhi	r4,129
  8051c0:	211f1004 	addi	r4,r4,31808
  8051c4:	08136300 	call	813630 <alt_printf>

	update_acid(get_acid_box(), "sunshine");	//set default acid/plugin
  8051c8:	08052640 	call	805264 <get_acid_box>
  8051cc:	01402074 	movhi	r5,129
  8051d0:	295f1a04 	addi	r5,r5,31848
  8051d4:	1009883a 	mov	r4,r2
  8051d8:	08052c00 	call	8052c0 <update_acid>

	/*	Start Acid Thread	*/
	alt_printf("Starting acid_thread\r\n");
  8051dc:	01002074 	movhi	r4,129
  8051e0:	211f1d04 	addi	r4,r4,31860
  8051e4:	08136300 	call	813630 <alt_printf>
	acidThreadCreateStatic(AcidStack, sizeof(AcidStack), TASK_ACID_PRIORITY);
  8051e8:	01415004 	movi	r5,1344
  8051ec:	018010c4 	movi	r6,67
  8051f0:	010020b4 	movhi	r4,130
  8051f4:	21303304 	addi	r4,r4,-16180
  8051f8:	0805cb80 	call	805cb8 <acidThreadCreateStatic>

	//Welcome logo
	splash_ledos();
  8051fc:	080504c0 	call	80504c <splash_ledos>

	/*
	 * Start Shell Thread
	*/
	alt_printf("Starting Shell\r\n");
  805200:	01002074 	movhi	r4,129
  805204:	211f2304 	addi	r4,r4,31884
  805208:	08136300 	call	813630 <alt_printf>
	shellCreateStatic(get_usr_bash_config(), ShellStack,sizeof(ShellStack), SHELL_PRIORITY);
  80520c:	08052700 	call	805270 <get_usr_bash_config>
  805210:	1009883a 	mov	r4,r2
  805214:	014020b4 	movhi	r5,130
  805218:	29718304 	addi	r5,r5,-14836
  80521c:	01800074 	movhi	r6,1
  805220:	31885004 	addi	r6,r6,8512
  805224:	01c01044 	movi	r7,65


	return;
}
  805228:	dfc00217 	ldw	ra,8(sp)
  80522c:	dc400117 	ldw	r17,4(sp)
  805230:	dc000017 	ldw	r16,0(sp)
  805234:	dec00304 	addi	sp,sp,12

	/*
	 * Start Shell Thread
	*/
	alt_printf("Starting Shell\r\n");
	shellCreateStatic(get_usr_bash_config(), ShellStack,sizeof(ShellStack), SHELL_PRIORITY);
  805238:	0805ec41 	jmpi	805ec4 <shellCreateStatic>

0080523c <acid_sunshine>:

#include "lsd.h"
#include <stdio.h>
#include "../cortex/cortex.h"

static void acid_sunshine(int argc, alt_u32 *lfft_bffr, alt_u32 *rfft_bffr, alt_u16 *pwm_bffr){
  80523c:	0009883a 	mov	r4,zero
  805240:	01800804 	movi	r6,32

	for(i=0; i<VCORTEX_PWM_CHNNLS; i++){
		//pwm_bffr[i]	=	(alt_u16)(lfft_bffr[i]	>>	16);
		//pwm_bffr[i]	=	pwm_bffr[i]	<<	12;

		pwm_bffr[i]	=	(alt_u16)(lfft_bffr[i]	<<	14);
  805244:	28800017 	ldw	r2,0(r5)
  805248:	3907883a 	add	r3,r7,r4
  80524c:	21000084 	addi	r4,r4,2
  805250:	100493ba 	slli	r2,r2,14
  805254:	29400104 	addi	r5,r5,4
  805258:	1880000d 	sth	r2,0(r3)
#include "../cortex/cortex.h"

static void acid_sunshine(int argc, alt_u32 *lfft_bffr, alt_u32 *rfft_bffr, alt_u16 *pwm_bffr){
	alt_u8	i;

	for(i=0; i<VCORTEX_PWM_CHNNLS; i++){
  80525c:	21bff91e 	bne	r4,r6,805244 <acid_sunshine+0x8>

		pwm_bffr[i]	=	(alt_u16)(lfft_bffr[i]	<<	14);
	}

	return;
}
  805260:	f800283a 	ret

00805264 <get_acid_box>:
		{NULL, NULL}
};

Acid * get_acid_box(void){
	return (Acid *)(acid_box);
}
  805264:	00802074 	movhi	r2,129
  805268:	109f2804 	addi	r2,r2,31904
  80526c:	f800283a 	ret

00805270 <get_usr_bash_config>:
};


ShellConfig * get_usr_bash_config(void){
	return (ShellConfig  *)(&shell_cfg1);
}
  805270:	d0a00304 	addi	r2,gp,-32756
  805274:	f800283a 	ret

00805278 <init_bash>:


void init_bash(void){
  805278:	deffff04 	addi	sp,sp,-4
	f_mount(0, &bash_Fatfs);		/* Register volume work area (never fails) */
  80527c:	01402134 	movhi	r5,132
  805280:	297a0f04 	addi	r5,r5,-6084
  805284:	0009883a 	mov	r4,zero
ShellConfig * get_usr_bash_config(void){
	return (ShellConfig  *)(&shell_cfg1);
}


void init_bash(void){
  805288:	dfc00015 	stw	ra,0(sp)
	f_mount(0, &bash_Fatfs);		/* Register volume work area (never fails) */
  80528c:	080191c0 	call	80191c <f_mount>
	alt_printf("Registered Bash-FATFs - fmount() done\r\n");
  805290:	01002074 	movhi	r4,129
  805294:	211f2c04 	addi	r4,r4,31920
  805298:	08136300 	call	813630 <alt_printf>

	PERF_RESET(PERF_CNTR_BASE);
  80529c:	01404434 	movhi	r5,272
  8052a0:	29480004 	addi	r5,r5,8192
  8052a4:	00800044 	movi	r2,1
  8052a8:	28800035 	stwio	r2,0(r5)
	alt_printf("Reset Performance Counter [0x%x]\r\n",PERF_CNTR_BASE);
  8052ac:	01002074 	movhi	r4,129
  8052b0:	211f3604 	addi	r4,r4,31960

	return;
}
  8052b4:	dfc00017 	ldw	ra,0(sp)
  8052b8:	dec00104 	addi	sp,sp,4
void init_bash(void){
	f_mount(0, &bash_Fatfs);		/* Register volume work area (never fails) */
	alt_printf("Registered Bash-FATFs - fmount() done\r\n");

	PERF_RESET(PERF_CNTR_BASE);
	alt_printf("Reset Performance Counter [0x%x]\r\n",PERF_CNTR_BASE);
  8052bc:	08136301 	jmpi	813630 <alt_printf>

008052c0 <update_acid>:

	return;
}


bool_t	update_acid(const Acid *ad, char *name){
  8052c0:	defffc04 	addi	sp,sp,-16
  8052c4:	dc800215 	stw	r18,8(sp)
  8052c8:	dc400115 	stw	r17,4(sp)
  8052cc:	2825883a 	mov	r18,r5
  8052d0:	2023883a 	mov	r17,r4
  8052d4:	dfc00315 	stw	ra,12(sp)
  8052d8:	dc000015 	stw	r16,0(sp)
  8052dc:	00000806 	br	805300 <update_acid+0x40>
	while (ad->acid_name != NULL) {
		if (strcasecmp(ad->acid_name, name) == 0) {
  8052e0:	08065340 	call	806534 <strcasecmp>
  8052e4:	1000051e 	bne	r2,zero,8052fc <update_acid+0x3c>
		  current_acid		=	ad->acid_function;
  8052e8:	88800117 	ldw	r2,4(r17)
		  current_acid_str	=	ad->acid_name;
  8052ec:	0007883a 	mov	r3,zero
  8052f0:	d426ef15 	stw	r16,-25668(gp)


bool_t	update_acid(const Acid *ad, char *name){
	while (ad->acid_name != NULL) {
		if (strcasecmp(ad->acid_name, name) == 0) {
		  current_acid		=	ad->acid_function;
  8052f4:	d0a6ee15 	stw	r2,-25672(gp)
  8052f8:	00000606 	br	805314 <update_acid+0x54>
		  current_acid_str	=	ad->acid_name;
		  return FALSE;
		}
		ad++;
  8052fc:	8c400204 	addi	r17,r17,8
	return;
}


bool_t	update_acid(const Acid *ad, char *name){
	while (ad->acid_name != NULL) {
  805300:	8c000017 	ldw	r16,0(r17)
		if (strcasecmp(ad->acid_name, name) == 0) {
  805304:	900b883a 	mov	r5,r18
  805308:	8009883a 	mov	r4,r16
	return;
}


bool_t	update_acid(const Acid *ad, char *name){
	while (ad->acid_name != NULL) {
  80530c:	803ff41e 	bne	r16,zero,8052e0 <update_acid+0x20>
  805310:	00c00044 	movi	r3,1
		}
		ad++;
	}

	return TRUE;
}
  805314:	1805883a 	mov	r2,r3
  805318:	dfc00317 	ldw	ra,12(sp)
  80531c:	dc800217 	ldw	r18,8(sp)
  805320:	dc400117 	ldw	r17,4(sp)
  805324:	dc000017 	ldw	r16,0(sp)
  805328:	dec00404 	addi	sp,sp,16
  80532c:	f800283a 	ret

00805330 <cmd_drop_acid>:
static void cmd_drop_acid(int argc, char *argv[]) {
	short c;

	(void)argv;

	bash_tp	=	chThdSelf();	//make a copy of this thread
  805330:	00802134 	movhi	r2,132
  805334:	10ba9c04 	addi	r2,r2,-5520
  805338:	10800717 	ldw	r2,28(r2)
// 		-	Starts the visualization thread with the
//			selected plugin.
//		-	If no plugin name is specified, the present
//			value of plugin is used.
/*---------------------------------------------------------*/
static void cmd_drop_acid(int argc, char *argv[]) {
  80533c:	defffd04 	addi	sp,sp,-12
  805340:	dc400115 	stw	r17,4(sp)
	short c;

	(void)argv;

	bash_tp	=	chThdSelf();	//make a copy of this thread
  805344:	d0a6ec15 	stw	r2,-25680(gp)


	if ((argc > 1) || (strcasecmp(argv[0],"--help") == 0)) {
  805348:	00800044 	movi	r2,1
// 		-	Starts the visualization thread with the
//			selected plugin.
//		-	If no plugin name is specified, the present
//			value of plugin is used.
/*---------------------------------------------------------*/
static void cmd_drop_acid(int argc, char *argv[]) {
  80534c:	dc000015 	stw	r16,0(sp)
  805350:	dfc00215 	stw	ra,8(sp)
  805354:	2023883a 	mov	r17,r4
  805358:	2821883a 	mov	r16,r5
	(void)argv;

	bash_tp	=	chThdSelf();	//make a copy of this thread


	if ((argc > 1) || (strcasecmp(argv[0],"--help") == 0)) {
  80535c:	11000516 	blt	r2,r4,805374 <cmd_drop_acid+0x44>
  805360:	29000017 	ldw	r4,0(r5)
  805364:	01402074 	movhi	r5,129
  805368:	295f3f04 	addi	r5,r5,31996
  80536c:	08065340 	call	806534 <strcasecmp>
  805370:	1000031e 	bne	r2,zero,805380 <cmd_drop_acid+0x50>
		alt_printf("Usage: drop_acid <plugin_name>\r\n");
  805374:	01002074 	movhi	r4,129
  805378:	211f4104 	addi	r4,r4,32004
  80537c:	00001d06 	br	8053f4 <cmd_drop_acid+0xc4>
		return;
	}

	if(argc){
  805380:	88000d26 	beq	r17,zero,8053b8 <cmd_drop_acid+0x88>
		if(update_acid(get_acid_box(), argv[0])){
  805384:	08052640 	call	805264 <get_acid_box>
  805388:	81400017 	ldw	r5,0(r16)
  80538c:	1009883a 	mov	r4,r2
  805390:	08052c00 	call	8052c0 <update_acid>
  805394:	10000826 	beq	r2,zero,8053b8 <cmd_drop_acid+0x88>
			printf("Plugin <%s> not found ... Bummer man :-(\r\n",argv[0]);
  805398:	81400017 	ldw	r5,0(r16)
  80539c:	01002074 	movhi	r4,129
  8053a0:	211f4a04 	addi	r4,r4,32040


	alt_printf("End of Trip ...\r\n");

	return;
}
  8053a4:	dfc00217 	ldw	ra,8(sp)
  8053a8:	dc400117 	ldw	r17,4(sp)
  8053ac:	dc000017 	ldw	r16,0(sp)
  8053b0:	dec00304 	addi	sp,sp,12
		return;
	}

	if(argc){
		if(update_acid(get_acid_box(), argv[0])){
			printf("Plugin <%s> not found ... Bummer man :-(\r\n",argv[0]);
  8053b4:	08064bc1 	jmpi	8064bc <printf>
			return;
		}
	}


	alt_printf("Starting Cortex engines \r\n");
  8053b8:	01002074 	movhi	r4,129
  8053bc:	211f5504 	addi	r4,r4,32084
  8053c0:	08136300 	call	813630 <alt_printf>

	enable_fgyrus(CORTEX_MM_SL_BASE, LCHNL);
  8053c4:	000b883a 	mov	r5,zero
  8053c8:	01004034 	movhi	r4,256
  8053cc:	0800d340 	call	800d34 <enable_fgyrus>
	enable_fgyrus(CORTEX_MM_SL_BASE, RCHNL);
  8053d0:	01004034 	movhi	r4,256
  8053d4:	01400044 	movi	r5,1
  8053d8:	0800d340 	call	800d34 <enable_fgyrus>
	enable_adc_drvr(CORTEX_MM_SL_BASE);
  8053dc:	01004034 	movhi	r4,256
  8053e0:	08009140 	call	800914 <enable_adc_drvr>


	if(acid_tp == NULL){
  8053e4:	d0a6ed17 	ldw	r2,-25676(gp)
  8053e8:	1000071e 	bne	r2,zero,805408 <cmd_drop_acid+0xd8>
		alt_printf("acid_thread not started\r\nExiting ...\r\n");
  8053ec:	01002074 	movhi	r4,129
  8053f0:	211f5c04 	addi	r4,r4,32112


	alt_printf("End of Trip ...\r\n");

	return;
}
  8053f4:	dfc00217 	ldw	ra,8(sp)
  8053f8:	dc400117 	ldw	r17,4(sp)
  8053fc:	dc000017 	ldw	r16,0(sp)
  805400:	dec00304 	addi	sp,sp,12
	enable_fgyrus(CORTEX_MM_SL_BASE, RCHNL);
	enable_adc_drvr(CORTEX_MM_SL_BASE);


	if(acid_tp == NULL){
		alt_printf("acid_thread not started\r\nExiting ...\r\n");
  805404:	08136301 	jmpi	813630 <alt_printf>
		return;
	}


	printf("Starting plugin : %s\r\nPress 'q' to stop ...\r\n",current_acid_str);
  805408:	d166ef17 	ldw	r5,-25668(gp)
  80540c:	01002074 	movhi	r4,129
  805410:	211f6604 	addi	r4,r4,32152
  805414:	08064bc0 	call	8064bc <printf>

	chMsgSend(acid_tp, (msg_t)1);	//Send dummy message to acid_thread to start it.
  805418:	d126ed17 	ldw	r4,-25676(gp)
  80541c:	01400044 	movi	r5,1
  805420:	08114380 	call	811438 <chMsgSend>
									//This thread is stopped until chMsgWait() is executed
									//from acid_thread.

	while(1){
		c = (short)alt_getchar();	//read single character
  805424:	08131cc0 	call	8131cc <alt_getchar>

		if(c == 'q'){
  805428:	10bfffcc 	andi	r2,r2,65535
  80542c:	10a0001c 	xori	r2,r2,32768
  805430:	10a00004 	addi	r2,r2,-32768
  805434:	00c01c44 	movi	r3,113
			break;
		}
		else{
			chThdSleepMilliseconds(100);
  805438:	01001904 	movi	r4,100
									//from acid_thread.

	while(1){
		c = (short)alt_getchar();	//read single character

		if(c == 'q'){
  80543c:	10c00226 	beq	r2,r3,805448 <cmd_drop_acid+0x118>
			break;
		}
		else{
			chThdSleepMilliseconds(100);
  805440:	08128680 	call	812868 <chThdSleep>
  805444:	003ff706 	br	805424 <cmd_drop_acid+0xf4>
		}
	}

	alt_printf("Stopping plugin ...\r\n");
  805448:	01002074 	movhi	r4,129
  80544c:	211f7204 	addi	r4,r4,32200
  805450:	08136300 	call	813630 <alt_printf>

	chMsgSend(acid_tp, (msg_t)1);	//Send dummy message to acid_thread to stop it.
  805454:	d126ed17 	ldw	r4,-25676(gp)
  805458:	01400044 	movi	r5,1
  80545c:	08114380 	call	811438 <chMsgSend>
									//This thread is stopped until chMsgWait() is executed
									//from acid_thread.

	alt_printf("Shutting down Cortex engines\r\n");
  805460:	01002074 	movhi	r4,129
  805464:	211f7804 	addi	r4,r4,32224
  805468:	08136300 	call	813630 <alt_printf>

	disable_fgyrus(CORTEX_MM_SL_BASE, LCHNL);
  80546c:	000b883a 	mov	r5,zero
  805470:	01004034 	movhi	r4,256
  805474:	0800d200 	call	800d20 <disable_fgyrus>
	disable_fgyrus(CORTEX_MM_SL_BASE, RCHNL);
  805478:	01004034 	movhi	r4,256
  80547c:	01400044 	movi	r5,1
  805480:	0800d200 	call	800d20 <disable_fgyrus>
	disable_adc_drvr(CORTEX_MM_SL_BASE);
  805484:	01004034 	movhi	r4,256
  805488:	08009300 	call	800930 <disable_adc_drvr>


	alt_printf("End of Trip ...\r\n");
  80548c:	01002074 	movhi	r4,129
  805490:	211f8004 	addi	r4,r4,32256
  805494:	003fd706 	br	8053f4 <cmd_drop_acid+0xc4>

00805498 <cmd_cath>:

/*---------------------------------------------------------*/
// User Function	:	cmd_cath
// 		-	Display file contents in hex form
/*---------------------------------------------------------*/
static void cmd_cath(int argc, char *argv[]) {
  805498:	defffc04 	addi	sp,sp,-16
	UINT br,i;

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  80549c:	00800044 	movi	r2,1

/*---------------------------------------------------------*/
// User Function	:	cmd_cath
// 		-	Display file contents in hex form
/*---------------------------------------------------------*/
static void cmd_cath(int argc, char *argv[]) {
  8054a0:	dc400215 	stw	r17,8(sp)
  8054a4:	dfc00315 	stw	ra,12(sp)
  8054a8:	dc000115 	stw	r16,4(sp)
  8054ac:	2023883a 	mov	r17,r4
	UINT br,i;

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  8054b0:	2080061e 	bne	r4,r2,8054cc <cmd_cath+0x34>
  8054b4:	2c000017 	ldw	r16,0(r5)
  8054b8:	01402074 	movhi	r5,129
  8054bc:	295f3f04 	addi	r5,r5,31996
  8054c0:	8009883a 	mov	r4,r16
  8054c4:	08065340 	call	806534 <strcasecmp>
  8054c8:	1000041e 	bne	r2,zero,8054dc <cmd_cath+0x44>
	  alt_printf("Usage: cath <filename>\r\n");
  8054cc:	01002074 	movhi	r4,129
  8054d0:	211f8504 	addi	r4,r4,32276
  8054d4:	08136300 	call	813630 <alt_printf>
  8054d8:	00003f06 	br	8055d8 <cmd_cath+0x140>
    return;
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_READ);
  8054dc:	01002134 	movhi	r4,132
  8054e0:	213a0604 	addi	r4,r4,-6120
  8054e4:	800b883a 	mov	r5,r16
  8054e8:	880d883a 	mov	r6,r17
  8054ec:	08047200 	call	804720 <f_open>
  8054f0:	1009883a 	mov	r4,r2
  8054f4:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  8054f8:	10000526 	beq	r2,zero,805510 <cmd_cath+0x78>
  8054fc:	08019680 	call	801968 <decode_fres>
  805500:	100b883a 	mov	r5,r2
  805504:	01002074 	movhi	r4,129
  805508:	211e3d04 	addi	r4,r4,30964
  80550c:	08136300 	call	813630 <alt_printf>

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
  805510:	01002134 	movhi	r4,132
  805514:	213a0604 	addi	r4,r4,-6120
  805518:	014020f4 	movhi	r5,131
  80551c:	2979f904 	addi	r5,r5,-6172
  805520:	01800074 	movhi	r6,1
  805524:	d80f883a 	mov	r7,sp
  805528:	08027840 	call	802784 <f_read>
  80552c:	d0a6f015 	stw	r2,-25664(gp)
	if (bash_rc || !br) break;			// Error or end of file
  805530:	1000141e 	bne	r2,zero,805584 <cmd_cath+0xec>
  805534:	d8800017 	ldw	r2,0(sp)
  805538:	10001226 	beq	r2,zero,805584 <cmd_cath+0xec>
  80553c:	044020f4 	movhi	r17,131
  805540:	8c79f904 	addi	r17,r17,-6172
  805544:	0021883a 	mov	r16,zero
  805548:	00000806 	br	80556c <cmd_cath+0xd4>
  80554c:	84000044 	addi	r16,r16,1
	for (i = 0; i < br; i++){		// Type the data
		if((i%16) == 0){
  805550:	1800011e 	bne	r3,zero,805558 <cmd_cath+0xc0>
			alt_printf("\r\n");
  805554:	08136300 	call	813630 <alt_printf>
		}
		alt_printf("%x ",bash_Buff[i]);
  805558:	89400003 	ldbu	r5,0(r17)
  80555c:	01002074 	movhi	r4,129
  805560:	211f8c04 	addi	r4,r4,32304
  805564:	8c400044 	addi	r17,r17,1
  805568:	08136300 	call	813630 <alt_printf>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
	if (bash_rc || !br) break;			// Error or end of file
	for (i = 0; i < br; i++){		// Type the data
  80556c:	d8800017 	ldw	r2,0(sp)
		if((i%16) == 0){
  805570:	80c003cc 	andi	r3,r16,15
			alt_printf("\r\n");
  805574:	01002074 	movhi	r4,129
  805578:	211f5b04 	addi	r4,r4,32108
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
	if (bash_rc || !br) break;			// Error or end of file
	for (i = 0; i < br; i++){		// Type the data
  80557c:	80bff336 	bltu	r16,r2,80554c <cmd_cath+0xb4>
  805580:	003fe306 	br	805510 <cmd_cath+0x78>
		}
		alt_printf("%x ",bash_Buff[i]);
	}
  }

  alt_printf("\r\n");
  805584:	01002074 	movhi	r4,129
  805588:	211f5b04 	addi	r4,r4,32108
  80558c:	08136300 	call	813630 <alt_printf>

  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805590:	d126f017 	ldw	r4,-25664(gp)
  805594:	20000526 	beq	r4,zero,8055ac <cmd_cath+0x114>
  805598:	08019680 	call	801968 <decode_fres>
  80559c:	100b883a 	mov	r5,r2
  8055a0:	01002074 	movhi	r4,129
  8055a4:	211e3d04 	addi	r4,r4,30964
  8055a8:	08136300 	call	813630 <alt_printf>

  bash_rc = f_close(&bash_Fil);
  8055ac:	01002134 	movhi	r4,132
  8055b0:	213a0604 	addi	r4,r4,-6120
  8055b4:	08046f40 	call	8046f4 <f_close>
  8055b8:	1009883a 	mov	r4,r2
  8055bc:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  8055c0:	10000526 	beq	r2,zero,8055d8 <cmd_cath+0x140>
  8055c4:	08019680 	call	801968 <decode_fres>
  8055c8:	100b883a 	mov	r5,r2
  8055cc:	01002074 	movhi	r4,129
  8055d0:	211e3d04 	addi	r4,r4,30964
  8055d4:	08136300 	call	813630 <alt_printf>

  return;
}
  8055d8:	dfc00317 	ldw	ra,12(sp)
  8055dc:	dc400217 	ldw	r17,8(sp)
  8055e0:	dc000117 	ldw	r16,4(sp)
  8055e4:	dec00404 	addi	sp,sp,16
  8055e8:	f800283a 	ret

008055ec <cmd_touch>:

/*---------------------------------------------------------*/
// User Function	:	cmd_touch
// 		-	Create empty file in current directory
/*---------------------------------------------------------*/
static void cmd_touch(int argc, char *argv[]) {
  8055ec:	defffe04 	addi	sp,sp,-8

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  8055f0:	00800044 	movi	r2,1

/*---------------------------------------------------------*/
// User Function	:	cmd_touch
// 		-	Create empty file in current directory
/*---------------------------------------------------------*/
static void cmd_touch(int argc, char *argv[]) {
  8055f4:	2807883a 	mov	r3,r5
  8055f8:	dfc00115 	stw	ra,4(sp)
  8055fc:	dc000015 	stw	r16,0(sp)

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805600:	01402074 	movhi	r5,129
  805604:	295f3f04 	addi	r5,r5,31996
  805608:	2080081e 	bne	r4,r2,80562c <cmd_touch+0x40>
  80560c:	1c000017 	ldw	r16,0(r3)
  805610:	8009883a 	mov	r4,r16
  805614:	08065340 	call	806534 <strcasecmp>
	  alt_printf("Usage: touch <filename>\r\n");
    return;
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_CREATE_NEW);
  805618:	01800104 	movi	r6,4
  80561c:	800b883a 	mov	r5,r16
  805620:	01002134 	movhi	r4,132
  805624:	213a0604 	addi	r4,r4,-6120
// 		-	Create empty file in current directory
/*---------------------------------------------------------*/
static void cmd_touch(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805628:	1000061e 	bne	r2,zero,805644 <cmd_touch+0x58>
	  alt_printf("Usage: touch <filename>\r\n");
  80562c:	01002074 	movhi	r4,129
  805630:	211f8d04 	addi	r4,r4,32308

  bash_rc = f_close(&bash_Fil);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  return;
}
  805634:	dfc00117 	ldw	ra,4(sp)
  805638:	dc000017 	ldw	r16,0(sp)
  80563c:	dec00204 	addi	sp,sp,8
/*---------------------------------------------------------*/
static void cmd_touch(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: touch <filename>\r\n");
  805640:	08136301 	jmpi	813630 <alt_printf>
    return;
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_CREATE_NEW);
  805644:	08047200 	call	804720 <f_open>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805648:	1009883a 	mov	r4,r2
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: touch <filename>\r\n");
    return;
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_CREATE_NEW);
  80564c:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805650:	10000526 	beq	r2,zero,805668 <cmd_touch+0x7c>
  805654:	08019680 	call	801968 <decode_fres>
  805658:	100b883a 	mov	r5,r2
  80565c:	01002074 	movhi	r4,129
  805660:	211e3d04 	addi	r4,r4,30964
  805664:	08136300 	call	813630 <alt_printf>

  bash_rc = f_close(&bash_Fil);
  805668:	01002134 	movhi	r4,132
  80566c:	213a0604 	addi	r4,r4,-6120
  805670:	08046f40 	call	8046f4 <f_close>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805674:	1009883a 	mov	r4,r2
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_CREATE_NEW);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  bash_rc = f_close(&bash_Fil);
  805678:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  80567c:	10000826 	beq	r2,zero,8056a0 <cmd_touch+0xb4>
  805680:	08019680 	call	801968 <decode_fres>
  805684:	100b883a 	mov	r5,r2
  805688:	01002074 	movhi	r4,129
  80568c:	211e3d04 	addi	r4,r4,30964

  return;
}
  805690:	dfc00117 	ldw	ra,4(sp)
  805694:	dc000017 	ldw	r16,0(sp)
  805698:	dec00204 	addi	sp,sp,8

  bash_rc = f_open(&bash_Fil, argv[0], FA_CREATE_NEW);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  bash_rc = f_close(&bash_Fil);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  80569c:	08136301 	jmpi	813630 <alt_printf>

  return;
}
  8056a0:	dfc00117 	ldw	ra,4(sp)
  8056a4:	dc000017 	ldw	r16,0(sp)
  8056a8:	dec00204 	addi	sp,sp,8
  8056ac:	f800283a 	ret

008056b0 <cmd_perf>:
// User Function	:	cmd_perf
// 		-	Runs the performance test for reading given file
//			from SDCARD
//		-	Input file must be at least 4KB in size
/*---------------------------------------------------------*/
static void cmd_perf(int argc, char *argv[]) {
  8056b0:	defff804 	addi	sp,sp,-32
	UINT br,i,size;

	(void)argv;

	if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  8056b4:	00800044 	movi	r2,1
// User Function	:	cmd_perf
// 		-	Runs the performance test for reading given file
//			from SDCARD
//		-	Input file must be at least 4KB in size
/*---------------------------------------------------------*/
static void cmd_perf(int argc, char *argv[]) {
  8056b8:	dcc00615 	stw	r19,24(sp)
  8056bc:	dc000315 	stw	r16,12(sp)
  8056c0:	dfc00715 	stw	ra,28(sp)
  8056c4:	dc800515 	stw	r18,20(sp)
  8056c8:	dc400415 	stw	r17,16(sp)
  8056cc:	2021883a 	mov	r16,r4
  8056d0:	2827883a 	mov	r19,r5
	UINT br,i,size;

	(void)argv;

	if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  8056d4:	2080051e 	bne	r4,r2,8056ec <cmd_perf+0x3c>
  8056d8:	29000017 	ldw	r4,0(r5)
  8056dc:	01402074 	movhi	r5,129
  8056e0:	295f3f04 	addi	r5,r5,31996
  8056e4:	08065340 	call	806534 <strcasecmp>
  8056e8:	1000041e 	bne	r2,zero,8056fc <cmd_perf+0x4c>
		alt_printf("Usage: perf <filename>\r\n");
  8056ec:	01002074 	movhi	r4,129
  8056f0:	211f9404 	addi	r4,r4,32336
  8056f4:	08136300 	call	813630 <alt_printf>
  8056f8:	00005706 	br	805858 <cmd_perf+0x1a8>
		return;
	}

	alt_printf("Reseting Performance Counter ...\r\n");
  8056fc:	01002074 	movhi	r4,129
  805700:	211f9b04 	addi	r4,r4,32364
  805704:	08136300 	call	813630 <alt_printf>
	PERF_RESET(PERF_CNTR_BASE);
  805708:	00804434 	movhi	r2,272
  80570c:	10880004 	addi	r2,r2,8192
  805710:	14000035 	stwio	r16,0(r2)

    chThdSleepMilliseconds(3000);
  805714:	0102ee04 	movi	r4,3000
  805718:	08128680 	call	812868 <chThdSleep>

	alt_printf("Starting Performance Counter ...\r\n");
  80571c:	01002074 	movhi	r4,129
  805720:	211fa404 	addi	r4,r4,32400
  805724:	08136300 	call	813630 <alt_printf>
	PERF_START_MEASURING(PERF_CNTR_BASE);
  805728:	00804434 	movhi	r2,272
  80572c:	10880104 	addi	r2,r2,8196
  805730:	10000035 	stwio	zero,0(r2)
  805734:	8025883a 	mov	r18,r16
  805738:	04404434 	movhi	r17,272
  80573c:	8c480504 	addi	r17,r17,8212
  805740:	04100004 	movi	r16,16384

	for(i=1,size=sizeof(bash_Buff)>>2;i<=3;i++,size=size<<1){
	      chThdSleepMilliseconds(1000);
  805744:	0100fa04 	movi	r4,1000
  805748:	08128680 	call	812868 <chThdSleep>

		  printf("Starting Test[%d] - Read %dB from SDCARD\r\n",i,size);
  80574c:	900b883a 	mov	r5,r18
  805750:	800d883a 	mov	r6,r16
  805754:	01002074 	movhi	r4,129
  805758:	211fad04 	addi	r4,r4,32436
  80575c:	08064bc0 	call	8064bc <printf>

		  bash_rc = f_open(&bash_Fil, argv[0], FA_READ);
  805760:	99400017 	ldw	r5,0(r19)
  805764:	01002134 	movhi	r4,132
  805768:	213a0604 	addi	r4,r4,-6120
  80576c:	01800044 	movi	r6,1
  805770:	08047200 	call	804720 <f_open>
  805774:	d0a6f015 	stw	r2,-25664(gp)
		  if(bash_rc)	break;
  805778:	1000181e 	bne	r2,zero,8057dc <cmd_perf+0x12c>

		  PERF_BEGIN(PERF_CNTR_BASE,i);
  80577c:	88000035 	stwio	zero,0(r17)
		  bash_rc = f_read(&bash_Fil, bash_Buff, size, &br);	// Read a chunk of file
  805780:	01002134 	movhi	r4,132
  805784:	213a0604 	addi	r4,r4,-6120
  805788:	014020f4 	movhi	r5,131
  80578c:	2979f904 	addi	r5,r5,-6172
  805790:	800d883a 	mov	r6,r16
  805794:	d9c00204 	addi	r7,sp,8
  805798:	08027840 	call	802784 <f_read>
  80579c:	d0a6f015 	stw	r2,-25664(gp)
		  PERF_END(PERF_CNTR_BASE,i);
  8057a0:	883fff35 	stwio	zero,-4(r17)

		  if(bash_rc || !br) break;			// Error or end of file
  8057a4:	d0a6f017 	ldw	r2,-25664(gp)
    chThdSleepMilliseconds(3000);

	alt_printf("Starting Performance Counter ...\r\n");
	PERF_START_MEASURING(PERF_CNTR_BASE);

	for(i=1,size=sizeof(bash_Buff)>>2;i<=3;i++,size=size<<1){
  8057a8:	8421883a 	add	r16,r16,r16
		  bash_rc = f_read(&bash_Fil, bash_Buff, size, &br);	// Read a chunk of file
		  PERF_END(PERF_CNTR_BASE,i);

		  if(bash_rc || !br) break;			// Error or end of file

		  bash_rc = f_close(&bash_Fil);
  8057ac:	01002134 	movhi	r4,132
  8057b0:	213a0604 	addi	r4,r4,-6120
    chThdSleepMilliseconds(3000);

	alt_printf("Starting Performance Counter ...\r\n");
	PERF_START_MEASURING(PERF_CNTR_BASE);

	for(i=1,size=sizeof(bash_Buff)>>2;i<=3;i++,size=size<<1){
  8057b4:	94800044 	addi	r18,r18,1

		  PERF_BEGIN(PERF_CNTR_BASE,i);
		  bash_rc = f_read(&bash_Fil, bash_Buff, size, &br);	// Read a chunk of file
		  PERF_END(PERF_CNTR_BASE,i);

		  if(bash_rc || !br) break;			// Error or end of file
  8057b8:	1000081e 	bne	r2,zero,8057dc <cmd_perf+0x12c>
  8057bc:	d8800217 	ldw	r2,8(sp)
    chThdSleepMilliseconds(3000);

	alt_printf("Starting Performance Counter ...\r\n");
	PERF_START_MEASURING(PERF_CNTR_BASE);

	for(i=1,size=sizeof(bash_Buff)>>2;i<=3;i++,size=size<<1){
  8057c0:	8c400404 	addi	r17,r17,16

		  PERF_BEGIN(PERF_CNTR_BASE,i);
		  bash_rc = f_read(&bash_Fil, bash_Buff, size, &br);	// Read a chunk of file
		  PERF_END(PERF_CNTR_BASE,i);

		  if(bash_rc || !br) break;			// Error or end of file
  8057c4:	10000526 	beq	r2,zero,8057dc <cmd_perf+0x12c>

		  bash_rc = f_close(&bash_Fil);
  8057c8:	08046f40 	call	8046f4 <f_close>
  8057cc:	d0a6f015 	stw	r2,-25664(gp)

		  if(bash_rc) break;			// Error or end of file
  8057d0:	1000021e 	bne	r2,zero,8057dc <cmd_perf+0x12c>
    chThdSleepMilliseconds(3000);

	alt_printf("Starting Performance Counter ...\r\n");
	PERF_START_MEASURING(PERF_CNTR_BASE);

	for(i=1,size=sizeof(bash_Buff)>>2;i<=3;i++,size=size<<1){
  8057d4:	00800104 	movi	r2,4
  8057d8:	90bfda1e 	bne	r18,r2,805744 <cmd_perf+0x94>
		  bash_rc = f_close(&bash_Fil);

		  if(bash_rc) break;			// Error or end of file
	}

    chThdSleepMilliseconds(1000);
  8057dc:	0100fa04 	movi	r4,1000
  8057e0:	08128680 	call	812868 <chThdSleep>

	alt_printf("Stopping Performance Counter ...\r\n");
  8057e4:	01002074 	movhi	r4,129
  8057e8:	211fb804 	addi	r4,r4,32480
  8057ec:	08136300 	call	813630 <alt_printf>
	PERF_STOP_MEASURING(PERF_CNTR_BASE);
  8057f0:	04004434 	movhi	r16,272
  8057f4:	84080004 	addi	r16,r16,8192
  8057f8:	80000035 	stwio	zero,0(r16)

    chThdSleepMilliseconds(3000);
  8057fc:	0102ee04 	movi	r4,3000
  805800:	08128680 	call	812868 <chThdSleep>

	if(bash_rc){
  805804:	d126f017 	ldw	r4,-25664(gp)
  805808:	20000626 	beq	r4,zero,805824 <cmd_perf+0x174>
		alt_printf("%s\r\n",decode_fres(bash_rc));
  80580c:	08019680 	call	801968 <decode_fres>
  805810:	100b883a 	mov	r5,r2
  805814:	01002074 	movhi	r4,129
  805818:	211e3d04 	addi	r4,r4,30964
  80581c:	08136300 	call	813630 <alt_printf>
  805820:	00000d06 	br	805858 <cmd_perf+0x1a8>
	}
	else{
		perf_print_formatted_report(PERF_CNTR_BASE,
  805824:	0814a0c0 	call	814a0c <alt_get_cpu_freq>
  805828:	100b883a 	mov	r5,r2
  80582c:	00802074 	movhi	r2,129
  805830:	109fc404 	addi	r2,r2,32528
  805834:	d8800015 	stw	r2,0(sp)
  805838:	8009883a 	mov	r4,r16
  80583c:	00802074 	movhi	r2,129
  805840:	109fc704 	addi	r2,r2,32540
  805844:	018000c4 	movi	r6,3
  805848:	01c02074 	movhi	r7,129
  80584c:	39dfc104 	addi	r7,r7,32516
  805850:	d8800115 	stw	r2,4(sp)
  805854:	08154e00 	call	8154e0 <perf_print_formatted_report>
									"64KB_read"
									);
	}

	return;
}
  805858:	dfc00717 	ldw	ra,28(sp)
  80585c:	dcc00617 	ldw	r19,24(sp)
  805860:	dc800517 	ldw	r18,20(sp)
  805864:	dc400417 	ldw	r17,16(sp)
  805868:	dc000317 	ldw	r16,12(sp)
  80586c:	dec00804 	addi	sp,sp,32
  805870:	f800283a 	ret

00805874 <cmd_cat>:

/*---------------------------------------------------------*/
// User Function	:	cmd_cat
// 		-	Display file contents (preferably text files)
/*---------------------------------------------------------*/
static void cmd_cat(int argc, char *argv[]) {
  805874:	defffc04 	addi	sp,sp,-16
	UINT br,i;

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805878:	00800044 	movi	r2,1

/*---------------------------------------------------------*/
// User Function	:	cmd_cat
// 		-	Display file contents (preferably text files)
/*---------------------------------------------------------*/
static void cmd_cat(int argc, char *argv[]) {
  80587c:	dc400215 	stw	r17,8(sp)
  805880:	dfc00315 	stw	ra,12(sp)
  805884:	dc000115 	stw	r16,4(sp)
  805888:	2023883a 	mov	r17,r4
	UINT br,i;

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  80588c:	2080061e 	bne	r4,r2,8058a8 <cmd_cat+0x34>
  805890:	2c000017 	ldw	r16,0(r5)
  805894:	01402074 	movhi	r5,129
  805898:	295f3f04 	addi	r5,r5,31996
  80589c:	8009883a 	mov	r4,r16
  8058a0:	08065340 	call	806534 <strcasecmp>
  8058a4:	1000041e 	bne	r2,zero,8058b8 <cmd_cat+0x44>
	  alt_printf("Usage: cat <filename>\r\n");
  8058a8:	01002074 	movhi	r4,129
  8058ac:	211fca04 	addi	r4,r4,32552
  8058b0:	08136300 	call	813630 <alt_printf>
  8058b4:	00003506 	br	80598c <cmd_cat+0x118>
    return;
  }

  bash_rc = f_open(&bash_Fil, argv[0], FA_READ);
  8058b8:	01002134 	movhi	r4,132
  8058bc:	213a0604 	addi	r4,r4,-6120
  8058c0:	800b883a 	mov	r5,r16
  8058c4:	880d883a 	mov	r6,r17
  8058c8:	08047200 	call	804720 <f_open>
  8058cc:	1009883a 	mov	r4,r2
  8058d0:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  8058d4:	10000526 	beq	r2,zero,8058ec <cmd_cat+0x78>
  8058d8:	08019680 	call	801968 <decode_fres>
  8058dc:	100b883a 	mov	r5,r2
  8058e0:	01002074 	movhi	r4,129
  8058e4:	211e3d04 	addi	r4,r4,30964
  8058e8:	08136300 	call	813630 <alt_printf>

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
  8058ec:	01002134 	movhi	r4,132
  8058f0:	213a0604 	addi	r4,r4,-6120
  8058f4:	014020f4 	movhi	r5,131
  8058f8:	2979f904 	addi	r5,r5,-6172
  8058fc:	01800074 	movhi	r6,1
  805900:	d80f883a 	mov	r7,sp
  805904:	08027840 	call	802784 <f_read>
  805908:	1009883a 	mov	r4,r2
  80590c:	d0a6f015 	stw	r2,-25664(gp)
	if (bash_rc || !br) break;			// Error or end of file
  805910:	10000e1e 	bne	r2,zero,80594c <cmd_cat+0xd8>
  805914:	d8800017 	ldw	r2,0(sp)
  805918:	10001126 	beq	r2,zero,805960 <cmd_cat+0xec>
  80591c:	044020f4 	movhi	r17,131
  805920:	8c79f904 	addi	r17,r17,-6172
  805924:	0021883a 	mov	r16,zero
  805928:	00000206 	br	805934 <cmd_cat+0xc0>
	for (i = 0; i < br; i++)		// Type the data
		alt_putchar(bash_Buff[i]);
  80592c:	893fffc3 	ldbu	r4,-1(r17)
  805930:	08138880 	call	813888 <alt_putchar>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
	if (bash_rc || !br) break;			// Error or end of file
	for (i = 0; i < br; i++)		// Type the data
  805934:	d8800017 	ldw	r2,0(sp)

/*---------------------------------------------------------*/
// User Function	:	cmd_cat
// 		-	Display file contents (preferably text files)
/*---------------------------------------------------------*/
static void cmd_cat(int argc, char *argv[]) {
  805938:	8007883a 	mov	r3,r16
  80593c:	8c400044 	addi	r17,r17,1
  805940:	84000044 	addi	r16,r16,1
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  for (;;) {
	  bash_rc = f_read(&bash_Fil, bash_Buff, sizeof(bash_Buff), &br);	// Read a chunk of file
	if (bash_rc || !br) break;			// Error or end of file
	for (i = 0; i < br; i++)		// Type the data
  805944:	18bff936 	bltu	r3,r2,80592c <cmd_cat+0xb8>
  805948:	003fe806 	br	8058ec <cmd_cat+0x78>
		alt_putchar(bash_Buff[i]);
  }
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  80594c:	08019680 	call	801968 <decode_fres>
  805950:	100b883a 	mov	r5,r2
  805954:	01002074 	movhi	r4,129
  805958:	211e3d04 	addi	r4,r4,30964
  80595c:	08136300 	call	813630 <alt_printf>

  bash_rc = f_close(&bash_Fil);
  805960:	01002134 	movhi	r4,132
  805964:	213a0604 	addi	r4,r4,-6120
  805968:	08046f40 	call	8046f4 <f_close>
  80596c:	1009883a 	mov	r4,r2
  805970:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805974:	10000526 	beq	r2,zero,80598c <cmd_cat+0x118>
  805978:	08019680 	call	801968 <decode_fres>
  80597c:	100b883a 	mov	r5,r2
  805980:	01002074 	movhi	r4,129
  805984:	211e3d04 	addi	r4,r4,30964
  805988:	08136300 	call	813630 <alt_printf>

  return;
}
  80598c:	dfc00317 	ldw	ra,12(sp)
  805990:	dc400217 	ldw	r17,8(sp)
  805994:	dc000117 	ldw	r16,4(sp)
  805998:	dec00404 	addi	sp,sp,16
  80599c:	f800283a 	ret

008059a0 <cmd_pwd>:

/*---------------------------------------------------------*/
// User Function	:	cmd_pwd
// 		-	Get Present Working Directory
/*---------------------------------------------------------*/
static void cmd_pwd(int argc, char *argv[]) {
  8059a0:	deffff04 	addi	sp,sp,-4
  8059a4:	dfc00015 	stw	ra,0(sp)
  if (argc > 0) {
	  alt_printf("Usage: pwd\r\n");
    return;
  }

  bash_rc = f_getcwd((TCHAR*)bash_Buff,sizeof(bash_Buff));
  8059a8:	01400074 	movhi	r5,1
// 		-	Get Present Working Directory
/*---------------------------------------------------------*/
static void cmd_pwd(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  8059ac:	0100050e 	bge	zero,r4,8059c4 <cmd_pwd+0x24>
	  alt_printf("Usage: pwd\r\n");
  8059b0:	01002074 	movhi	r4,129
  8059b4:	211fd004 	addi	r4,r4,32576
  else{
	  alt_printf("%s\r\n",bash_Buff);
  }

  return;
}
  8059b8:	dfc00017 	ldw	ra,0(sp)
  8059bc:	dec00104 	addi	sp,sp,4
/*---------------------------------------------------------*/
static void cmd_pwd(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
	  alt_printf("Usage: pwd\r\n");
  8059c0:	08136301 	jmpi	813630 <alt_printf>
    return;
  }

  bash_rc = f_getcwd((TCHAR*)bash_Buff,sizeof(bash_Buff));
  8059c4:	010020f4 	movhi	r4,131
  8059c8:	2139f904 	addi	r4,r4,-6172
  8059cc:	080353c0 	call	80353c <f_getcwd>
  if(bash_rc){
	  alt_printf("%s\r\n",decode_fres(bash_rc));
  8059d0:	1009883a 	mov	r4,r2
  }
  else{
	  alt_printf("%s\r\n",bash_Buff);
  8059d4:	014020f4 	movhi	r5,131
  8059d8:	2979f904 	addi	r5,r5,-6172
  if (argc > 0) {
	  alt_printf("Usage: pwd\r\n");
    return;
  }

  bash_rc = f_getcwd((TCHAR*)bash_Buff,sizeof(bash_Buff));
  8059dc:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc){
  8059e0:	10000226 	beq	r2,zero,8059ec <cmd_pwd+0x4c>
	  alt_printf("%s\r\n",decode_fres(bash_rc));
  8059e4:	08019680 	call	801968 <decode_fres>
  8059e8:	100b883a 	mov	r5,r2
  }
  else{
	  alt_printf("%s\r\n",bash_Buff);
  8059ec:	01002074 	movhi	r4,129
  8059f0:	211e3d04 	addi	r4,r4,30964
  }

  return;
}
  8059f4:	dfc00017 	ldw	ra,0(sp)
  8059f8:	dec00104 	addi	sp,sp,4
  bash_rc = f_getcwd((TCHAR*)bash_Buff,sizeof(bash_Buff));
  if(bash_rc){
	  alt_printf("%s\r\n",decode_fres(bash_rc));
  }
  else{
	  alt_printf("%s\r\n",bash_Buff);
  8059fc:	08136301 	jmpi	813630 <alt_printf>

00805a00 <cmd_ll>:

/*---------------------------------------------------------*/
// User Function	:	cmd_ll
// 		-	List folder entries under pwd
/*---------------------------------------------------------*/
static void cmd_ll(int argc, char *argv[]) {
  805a00:	defffe04 	addi	sp,sp,-8
  805a04:	dfc00115 	stw	ra,4(sp)
  805a08:	dc000015 	stw	r16,0(sp)

  (void)argv;
  if (argc > 0) {
  805a0c:	0100060e 	bge	zero,r4,805a28 <cmd_ll+0x28>
	  alt_printf("Usage: ll\r\n");
  805a10:	01002074 	movhi	r4,129
  805a14:	211fd404 	addi	r4,r4,32592
		printf("%8lu  %s\r\n", bash_fno.fsize, bash_fno.fname);
  }
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  return;
}
  805a18:	dfc00117 	ldw	ra,4(sp)
  805a1c:	dc000017 	ldw	r16,0(sp)
  805a20:	dec00204 	addi	sp,sp,8
/*---------------------------------------------------------*/
static void cmd_ll(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
	  alt_printf("Usage: ll\r\n");
  805a24:	08136301 	jmpi	813630 <alt_printf>
    return;
  }

  bash_rc = f_getcwd((TCHAR*)bash_Buff,sizeof(bash_Buff)); //read pwd into buffer
  805a28:	010020f4 	movhi	r4,131
  805a2c:	2139f904 	addi	r4,r4,-6172
  805a30:	01400074 	movhi	r5,1
  805a34:	080353c0 	call	80353c <f_getcwd>
  805a38:	1009883a 	mov	r4,r2
  805a3c:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc){
  805a40:	10000526 	beq	r2,zero,805a58 <cmd_ll+0x58>
	  alt_printf("Could not get pwd - %s\r\n",decode_fres(bash_rc));
  805a44:	08019680 	call	801968 <decode_fres>
  805a48:	100b883a 	mov	r5,r2
  805a4c:	01002074 	movhi	r4,129
  805a50:	211fd704 	addi	r4,r4,32604
  805a54:	00002806 	br	805af8 <cmd_ll+0xf8>
	  return;
  }

  bash_rc = f_opendir(&bash_dir, (TCHAR*)bash_Buff);
  805a58:	01002134 	movhi	r4,132
  805a5c:	2139f904 	addi	r4,r4,-6172
  805a60:	014020f4 	movhi	r5,131
  805a64:	2979f904 	addi	r5,r5,-6172
  805a68:	0803c400 	call	803c40 <f_opendir>
  805a6c:	1009883a 	mov	r4,r2
  805a70:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("Could not open pwd - %s\r\n",decode_fres(bash_rc));
  805a74:	10000526 	beq	r2,zero,805a8c <cmd_ll+0x8c>
  805a78:	08019680 	call	801968 <decode_fres>
  805a7c:	100b883a 	mov	r5,r2
  805a80:	01002074 	movhi	r4,129
  805a84:	211fde04 	addi	r4,r4,32632
  805a88:	08136300 	call	813630 <alt_printf>

  for (;;) {
	  bash_rc = f_readdir(&bash_dir, &bash_fno);		// Read a directory item
  805a8c:	04002134 	movhi	r16,132
  805a90:	843a0004 	addi	r16,r16,-6144
  805a94:	800b883a 	mov	r5,r16
  805a98:	01002134 	movhi	r4,132
  805a9c:	2139f904 	addi	r4,r4,-6172
  805aa0:	08034840 	call	803484 <f_readdir>
	if (bash_rc || !bash_fno.fname[0]) break;	// Error or end of dir
	if (bash_fno.fattrib & AM_DIR)
		alt_printf("   <dir>  %s\r\n", bash_fno.fname);
  805aa4:	81400244 	addi	r5,r16,9
	else
		printf("%8lu  %s\r\n", bash_fno.fsize, bash_fno.fname);
  805aa8:	280d883a 	mov	r6,r5

  for (;;) {
	  bash_rc = f_readdir(&bash_dir, &bash_fno);		// Read a directory item
	if (bash_rc || !bash_fno.fname[0]) break;	// Error or end of dir
	if (bash_fno.fattrib & AM_DIR)
		alt_printf("   <dir>  %s\r\n", bash_fno.fname);
  805aac:	01002074 	movhi	r4,129
  805ab0:	211fe504 	addi	r4,r4,32660

  bash_rc = f_opendir(&bash_dir, (TCHAR*)bash_Buff);
  if(bash_rc)	alt_printf("Could not open pwd - %s\r\n",decode_fres(bash_rc));

  for (;;) {
	  bash_rc = f_readdir(&bash_dir, &bash_fno);		// Read a directory item
  805ab4:	d0a6f015 	stw	r2,-25664(gp)
	if (bash_rc || !bash_fno.fname[0]) break;	// Error or end of dir
  805ab8:	10000a1e 	bne	r2,zero,805ae4 <cmd_ll+0xe4>
  805abc:	80800247 	ldb	r2,9(r16)
  805ac0:	10001126 	beq	r2,zero,805b08 <cmd_ll+0x108>
	if (bash_fno.fattrib & AM_DIR)
  805ac4:	80800203 	ldbu	r2,8(r16)
  805ac8:	1080040c 	andi	r2,r2,16
  805acc:	103fee1e 	bne	r2,zero,805a88 <cmd_ll+0x88>
		alt_printf("   <dir>  %s\r\n", bash_fno.fname);
	else
		printf("%8lu  %s\r\n", bash_fno.fsize, bash_fno.fname);
  805ad0:	81400017 	ldw	r5,0(r16)
  805ad4:	01002074 	movhi	r4,129
  805ad8:	211fe904 	addi	r4,r4,32676
  805adc:	08064bc0 	call	8064bc <printf>
  805ae0:	003fea06 	br	805a8c <cmd_ll+0x8c>
  }
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805ae4:	1009883a 	mov	r4,r2
  805ae8:	08019680 	call	801968 <decode_fres>
  805aec:	100b883a 	mov	r5,r2
  805af0:	01002074 	movhi	r4,129
  805af4:	211e3d04 	addi	r4,r4,30964

  return;
}
  805af8:	dfc00117 	ldw	ra,4(sp)
  805afc:	dc000017 	ldw	r16,0(sp)
  805b00:	dec00204 	addi	sp,sp,8
	if (bash_fno.fattrib & AM_DIR)
		alt_printf("   <dir>  %s\r\n", bash_fno.fname);
	else
		printf("%8lu  %s\r\n", bash_fno.fsize, bash_fno.fname);
  }
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805b04:	08136301 	jmpi	813630 <alt_printf>

  return;
}
  805b08:	dfc00117 	ldw	ra,4(sp)
  805b0c:	dc000017 	ldw	r16,0(sp)
  805b10:	dec00204 	addi	sp,sp,8
  805b14:	f800283a 	ret

00805b18 <cmd_cd>:

/*---------------------------------------------------------*/
// User Function	:	cmd_cd
// 		-	Change Directory
/*---------------------------------------------------------*/
static void cmd_cd(int argc, char *argv[]) {
  805b18:	defffe04 	addi	sp,sp,-8

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805b1c:	00800044 	movi	r2,1

/*---------------------------------------------------------*/
// User Function	:	cmd_cd
// 		-	Change Directory
/*---------------------------------------------------------*/
static void cmd_cd(int argc, char *argv[]) {
  805b20:	2807883a 	mov	r3,r5
  805b24:	dfc00115 	stw	ra,4(sp)
  805b28:	dc000015 	stw	r16,0(sp)

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805b2c:	01402074 	movhi	r5,129
  805b30:	295f3f04 	addi	r5,r5,31996
  805b34:	2080051e 	bne	r4,r2,805b4c <cmd_cd+0x34>
  805b38:	1c000017 	ldw	r16,0(r3)
  805b3c:	8009883a 	mov	r4,r16
  805b40:	08065340 	call	806534 <strcasecmp>
	  alt_printf("Usage: cd <destination_dir>\r\n");
    return;
  }

  bash_rc = f_chdir(argv[0]);
  805b44:	8009883a 	mov	r4,r16
// 		-	Change Directory
/*---------------------------------------------------------*/
static void cmd_cd(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805b48:	1000061e 	bne	r2,zero,805b64 <cmd_cd+0x4c>
	  alt_printf("Usage: cd <destination_dir>\r\n");
  805b4c:	01002074 	movhi	r4,129
  805b50:	211fec04 	addi	r4,r4,32688

  bash_rc = f_chdir(argv[0]);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  return;
}
  805b54:	dfc00117 	ldw	ra,4(sp)
  805b58:	dc000017 	ldw	r16,0(sp)
  805b5c:	dec00204 	addi	sp,sp,8
/*---------------------------------------------------------*/
static void cmd_cd(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: cd <destination_dir>\r\n");
  805b60:	08136301 	jmpi	813630 <alt_printf>
    return;
  }

  bash_rc = f_chdir(argv[0]);
  805b64:	0803d040 	call	803d04 <f_chdir>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805b68:	1009883a 	mov	r4,r2
  if ((argc != 1)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: cd <destination_dir>\r\n");
    return;
  }

  bash_rc = f_chdir(argv[0]);
  805b6c:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805b70:	10000826 	beq	r2,zero,805b94 <cmd_cd+0x7c>
  805b74:	08019680 	call	801968 <decode_fres>
  805b78:	100b883a 	mov	r5,r2
  805b7c:	01002074 	movhi	r4,129
  805b80:	211e3d04 	addi	r4,r4,30964

  return;
}
  805b84:	dfc00117 	ldw	ra,4(sp)
  805b88:	dc000017 	ldw	r16,0(sp)
  805b8c:	dec00204 	addi	sp,sp,8
	  alt_printf("Usage: cd <destination_dir>\r\n");
    return;
  }

  bash_rc = f_chdir(argv[0]);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805b90:	08136301 	jmpi	813630 <alt_printf>

  return;
}
  805b94:	dfc00117 	ldw	ra,4(sp)
  805b98:	dc000017 	ldw	r16,0(sp)
  805b9c:	dec00204 	addi	sp,sp,8
  805ba0:	f800283a 	ret

00805ba4 <cmd_mv>:

/*---------------------------------------------------------*/
// User Function	:	cmd_mv
// 		-	Rename file
/*---------------------------------------------------------*/
static void cmd_mv(int argc, char *argv[]) {
  805ba4:	defffd04 	addi	sp,sp,-12

  (void)argv;
  if ((argc != 2)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805ba8:	00800084 	movi	r2,2

/*---------------------------------------------------------*/
// User Function	:	cmd_mv
// 		-	Rename file
/*---------------------------------------------------------*/
static void cmd_mv(int argc, char *argv[]) {
  805bac:	dc400115 	stw	r17,4(sp)
  805bb0:	dfc00215 	stw	ra,8(sp)
  805bb4:	2823883a 	mov	r17,r5
  805bb8:	dc000015 	stw	r16,0(sp)

  (void)argv;
  if ((argc != 2)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805bbc:	01402074 	movhi	r5,129
  805bc0:	295f3f04 	addi	r5,r5,31996
  805bc4:	2080051e 	bne	r4,r2,805bdc <cmd_mv+0x38>
  805bc8:	8c000017 	ldw	r16,0(r17)
  805bcc:	8009883a 	mov	r4,r16
  805bd0:	08065340 	call	806534 <strcasecmp>
	  alt_printf("Usage: mv <existing_filename> <new_filename>\r\n");
    return;
  }

  bash_rc = f_rename(argv[0], argv[1]);
  805bd4:	8009883a 	mov	r4,r16
// 		-	Rename file
/*---------------------------------------------------------*/
static void cmd_mv(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 2)	||	(strcasecmp(argv[0],"--help") == 0)) {
  805bd8:	1000071e 	bne	r2,zero,805bf8 <cmd_mv+0x54>
	  alt_printf("Usage: mv <existing_filename> <new_filename>\r\n");
  805bdc:	01002074 	movhi	r4,129
  805be0:	211ff404 	addi	r4,r4,32720

  bash_rc = f_rename(argv[0], argv[1]);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));

  return;
}
  805be4:	dfc00217 	ldw	ra,8(sp)
  805be8:	dc400117 	ldw	r17,4(sp)
  805bec:	dc000017 	ldw	r16,0(sp)
  805bf0:	dec00304 	addi	sp,sp,12
/*---------------------------------------------------------*/
static void cmd_mv(int argc, char *argv[]) {

  (void)argv;
  if ((argc != 2)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: mv <existing_filename> <new_filename>\r\n");
  805bf4:	08136301 	jmpi	813630 <alt_printf>
    return;
  }

  bash_rc = f_rename(argv[0], argv[1]);
  805bf8:	89400117 	ldw	r5,4(r17)
  805bfc:	08040c80 	call	8040c8 <f_rename>
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805c00:	1009883a 	mov	r4,r2
  if ((argc != 2)	||	(strcasecmp(argv[0],"--help") == 0)) {
	  alt_printf("Usage: mv <existing_filename> <new_filename>\r\n");
    return;
  }

  bash_rc = f_rename(argv[0], argv[1]);
  805c04:	d0a6f015 	stw	r2,-25664(gp)
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805c08:	10000926 	beq	r2,zero,805c30 <cmd_mv+0x8c>
  805c0c:	08019680 	call	801968 <decode_fres>
  805c10:	100b883a 	mov	r5,r2
  805c14:	01002074 	movhi	r4,129
  805c18:	211e3d04 	addi	r4,r4,30964

  return;
}
  805c1c:	dfc00217 	ldw	ra,8(sp)
  805c20:	dc400117 	ldw	r17,4(sp)
  805c24:	dc000017 	ldw	r16,0(sp)
  805c28:	dec00304 	addi	sp,sp,12
	  alt_printf("Usage: mv <existing_filename> <new_filename>\r\n");
    return;
  }

  bash_rc = f_rename(argv[0], argv[1]);
  if(bash_rc)	alt_printf("%s\r\n",decode_fres(bash_rc));
  805c2c:	08136301 	jmpi	813630 <alt_printf>

  return;
}
  805c30:	dfc00217 	ldw	ra,8(sp)
  805c34:	dc400117 	ldw	r17,4(sp)
  805c38:	dc000017 	ldw	r16,0(sp)
  805c3c:	dec00304 	addi	sp,sp,12
  805c40:	f800283a 	ret

00805c44 <cmd_mem>:

/*---------------------------------------------------------*/
// User Function	:	cmd_mem
// 		-	Display Memory Utilisation
/*---------------------------------------------------------*/
static void cmd_mem(int argc, char *argv[]) {
  805c44:	defffd04 	addi	sp,sp,-12
  805c48:	dfc00215 	stw	ra,8(sp)
  805c4c:	dc000115 	stw	r16,4(sp)
  if (argc > 0) {
	  alt_printf("Usage: mem\r\n");
    return;
  }

  n = chHeapStatus(NULL, &size);
  805c50:	d80b883a 	mov	r5,sp
/*---------------------------------------------------------*/
static void cmd_mem(int argc, char *argv[]) {
  size_t n, size;

  (void)argv;
  if (argc > 0) {
  805c54:	0100040e 	bge	zero,r4,805c68 <cmd_mem+0x24>
	  alt_printf("Usage: mem\r\n");
  805c58:	010020b4 	movhi	r4,130
  805c5c:	21200004 	addi	r4,r4,-32768
  805c60:	08136300 	call	813630 <alt_printf>
  805c64:	00001006 	br	805ca8 <cmd_mem+0x64>
    return;
  }

  n = chHeapStatus(NULL, &size);
  805c68:	0009883a 	mov	r4,zero
  805c6c:	08110180 	call	811018 <chHeapStatus>
  805c70:	1021883a 	mov	r16,r2

  printf("core free memory : %u bytes\r\n", chCoreStatus());
  805c74:	08112080 	call	811208 <chCoreStatus>
  805c78:	100b883a 	mov	r5,r2
  805c7c:	010020b4 	movhi	r4,130
  805c80:	21200404 	addi	r4,r4,-32752
  805c84:	08064bc0 	call	8064bc <printf>
  printf("heap fragments   : %u\r\n", n);
  805c88:	800b883a 	mov	r5,r16
  805c8c:	010020b4 	movhi	r4,130
  805c90:	21200c04 	addi	r4,r4,-32720
  805c94:	08064bc0 	call	8064bc <printf>
  printf("heap free total  : %u bytes\r\n", size);
  805c98:	d9400017 	ldw	r5,0(sp)
  805c9c:	010020b4 	movhi	r4,130
  805ca0:	21201204 	addi	r4,r4,-32696
  805ca4:	08064bc0 	call	8064bc <printf>
}
  805ca8:	dfc00217 	ldw	ra,8(sp)
  805cac:	dc000117 	ldw	r16,4(sp)
  805cb0:	dec00304 	addi	sp,sp,12
  805cb4:	f800283a 	ret

00805cb8 <acidThreadCreateStatic>:
	alt_printf("End of Trip ...\r\n");

	return;
}

Thread *acidThreadCreateStatic(void *wsp, size_t size, tprio_t prio) {
  805cb8:	defffe04 	addi	sp,sp,-8

  return chThdCreateStatic(wsp, size, prio, acid_thread, NULL);
  805cbc:	01c02034 	movhi	r7,128
  805cc0:	39d73704 	addi	r7,r7,23772
	alt_printf("End of Trip ...\r\n");

	return;
}

Thread *acidThreadCreateStatic(void *wsp, size_t size, tprio_t prio) {
  805cc4:	dfc00115 	stw	ra,4(sp)

  return chThdCreateStatic(wsp, size, prio, acid_thread, NULL);
  805cc8:	d8000015 	stw	zero,0(sp)
  805ccc:	081264c0 	call	81264c <chThdCreateStatic>
}
  805cd0:	dfc00117 	ldw	ra,4(sp)
  805cd4:	dec00204 	addi	sp,sp,8
  805cd8:	f800283a 	ret

00805cdc <acid_thread>:

void acid_thread(void *p){
	alt_u16 pwm_bffr[VCORTEX_PWM_CHNNLS];
	alt_u32	lfft_bffr[FFT_NUM_SAMPLES],rfft_bffr[FFT_NUM_SAMPLES];

	acid_tp	=	chThdSelf();	//make a copy of this thread
  805cdc:	00802134 	movhi	r2,132
  805ce0:	10ba9c04 	addi	r2,r2,-5520
  805ce4:	10800717 	ldw	r2,28(r2)
	}

	return TRUE;
}

void acid_thread(void *p){
  805ce8:	defef504 	addi	sp,sp,-1068
  805cec:	dfc10a15 	stw	ra,1064(sp)
  805cf0:	dc410915 	stw	r17,1060(sp)
  805cf4:	dc010815 	stw	r16,1056(sp)
	alt_u16 pwm_bffr[VCORTEX_PWM_CHNNLS];
	alt_u32	lfft_bffr[FFT_NUM_SAMPLES],rfft_bffr[FFT_NUM_SAMPLES];

	acid_tp	=	chThdSelf();	//make a copy of this thread
  805cf8:	d0a6ed15 	stw	r2,-25676(gp)

	while(1){
		chMsgWait();	//Suspend this thread & wait for go signal
  805cfc:	081155c0 	call	81155c <chMsgWait>
						//This thread starts in suspended state

		chMsgRelease(bash_tp, (msg_t)0);	//Send dummy response/ack to bash
  805d00:	d126ec17 	ldw	r4,-25680(gp)
  805d04:	000b883a 	mov	r5,zero
  805d08:	081164c0 	call	81164c <chMsgRelease>
  805d0c:	00000c06 	br	805d40 <acid_thread+0x64>

		while(!chMsgIsPendingI(acid_tp)){	//As long as there is no msg/signal from bash
			read_fft_cache(lfft_bffr, rfft_bffr, FFT_NUM_SAMPLES);	//read from FFT cache
  805d10:	0804c1c0 	call	804c1c <read_fft_cache>

			current_acid(0,lfft_bffr,rfft_bffr,pwm_bffr);
  805d14:	d0a6ee17 	ldw	r2,-25672(gp)
  805d18:	800b883a 	mov	r5,r16
  805d1c:	880d883a 	mov	r6,r17
  805d20:	0009883a 	mov	r4,zero
  805d24:	d80f883a 	mov	r7,sp
  805d28:	103ee83a 	callr	r2

			pwm_paint(CORTEX_MM_SL_BASE, pwm_bffr);
  805d2c:	01004034 	movhi	r4,256
  805d30:	d80b883a 	mov	r5,sp
  805d34:	0800d6c0 	call	800d6c <pwm_paint>
			chThdSleepMilliseconds(1);
  805d38:	01000044 	movi	r4,1
  805d3c:	08128680 	call	812868 <chThdSleep>
		chMsgWait();	//Suspend this thread & wait for go signal
						//This thread starts in suspended state

		chMsgRelease(bash_tp, (msg_t)0);	//Send dummy response/ack to bash

		while(!chMsgIsPendingI(acid_tp)){	//As long as there is no msg/signal from bash
  805d40:	d0a6ed17 	ldw	r2,-25676(gp)
			read_fft_cache(lfft_bffr, rfft_bffr, FFT_NUM_SAMPLES);	//read from FFT cache
  805d44:	dc008804 	addi	r16,sp,544
  805d48:	dc400804 	addi	r17,sp,32
		chMsgWait();	//Suspend this thread & wait for go signal
						//This thread starts in suspended state

		chMsgRelease(bash_tp, (msg_t)0);	//Send dummy response/ack to bash

		while(!chMsgIsPendingI(acid_tp)){	//As long as there is no msg/signal from bash
  805d4c:	10c00b17 	ldw	r3,44(r2)
  805d50:	10800b04 	addi	r2,r2,44
			read_fft_cache(lfft_bffr, rfft_bffr, FFT_NUM_SAMPLES);	//read from FFT cache
  805d54:	8009883a 	mov	r4,r16
  805d58:	880b883a 	mov	r5,r17
  805d5c:	01802004 	movi	r6,128
		chMsgWait();	//Suspend this thread & wait for go signal
						//This thread starts in suspended state

		chMsgRelease(bash_tp, (msg_t)0);	//Send dummy response/ack to bash

		while(!chMsgIsPendingI(acid_tp)){	//As long as there is no msg/signal from bash
  805d60:	18bfeb26 	beq	r3,r2,805d10 <acid_thread+0x34>

			pwm_paint(CORTEX_MM_SL_BASE, pwm_bffr);
			chThdSleepMilliseconds(1);
		}

		chMsgWait();						//Suspend this thread & pop dummy message from its fifo
  805d64:	081155c0 	call	81155c <chMsgWait>
		chMsgRelease(bash_tp, (msg_t)0);	//Send dummy response/ack to bash
  805d68:	d126ec17 	ldw	r4,-25680(gp)
  805d6c:	000b883a 	mov	r5,zero
  805d70:	081164c0 	call	81164c <chMsgRelease>
  805d74:	003fe106 	br	805cfc <acid_thread+0x20>

00805d78 <shellInit>:
/**
 * @brief   Shell manager initialization.
 */
void shellInit(void) {

  chEvtInit(&shell_terminated);
  805d78:	d0a6f104 	addi	r2,gp,-25660
  805d7c:	d0a6f115 	stw	r2,-25660(gp)
}
  805d80:	f800283a 	ret

00805d84 <list_commands>:
static void usage(char *p) {

	alt_printf("Usage: %s\r\n", p);
}

static void list_commands(const ShellCommand *scp) {
  805d84:	defffe04 	addi	sp,sp,-8
  805d88:	dc000015 	stw	r16,0(sp)
  805d8c:	2021883a 	mov	r16,r4
  805d90:	dfc00115 	stw	ra,4(sp)
  805d94:	00000106 	br	805d9c <list_commands+0x18>

  while (scp->sc_name != NULL) {
	  alt_printf("\t%s\r\n", scp->sc_name);
  805d98:	08136300 	call	813630 <alt_printf>
	alt_printf("Usage: %s\r\n", p);
}

static void list_commands(const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
  805d9c:	80800017 	ldw	r2,0(r16)
	  alt_printf("\t%s\r\n", scp->sc_name);
  805da0:	01002074 	movhi	r4,129
  805da4:	211e2a04 	addi	r4,r4,30888
    scp++;
  805da8:	84000204 	addi	r16,r16,8
}

static void list_commands(const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
	  alt_printf("\t%s\r\n", scp->sc_name);
  805dac:	100b883a 	mov	r5,r2
	alt_printf("Usage: %s\r\n", p);
}

static void list_commands(const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
  805db0:	103ff91e 	bne	r2,zero,805d98 <list_commands+0x14>
	  alt_printf("\t%s\r\n", scp->sc_name);
    scp++;
  }
}
  805db4:	dfc00117 	ldw	ra,4(sp)
  805db8:	dc000017 	ldw	r16,0(sp)
  805dbc:	dec00204 	addi	sp,sp,8
  805dc0:	f800283a 	ret

00805dc4 <usage>:
    *(*saveptr)++ = '\0';

  return *token ? token : NULL;
}

static void usage(char *p) {
  805dc4:	200b883a 	mov	r5,r4

	alt_printf("Usage: %s\r\n", p);
  805dc8:	010020b4 	movhi	r4,130
  805dcc:	21205f04 	addi	r4,r4,-32388
  805dd0:	08136301 	jmpi	813630 <alt_printf>

00805dd4 <shellGetLine>:
 * @param[in] size      buffer maximum length
 * @return              The operation status.
 * @retval TRUE         the channel was reset or CTRL-D pressed.
 * @retval FALSE        operation successful.
 */
bool_t shellGetLine(char *line, unsigned size) {
  805dd4:	defffa04 	addi	sp,sp,-24
  805dd8:	dd000415 	stw	r20,16(sp)
  805ddc:	dcc00315 	stw	r19,12(sp)
  805de0:	dc400115 	stw	r17,4(sp)
  805de4:	dfc00515 	stw	ra,20(sp)
  805de8:	dc800215 	stw	r18,8(sp)
  805dec:	dc000015 	stw	r16,0(sp)
  805df0:	2027883a 	mov	r19,r4
  805df4:	2829883a 	mov	r20,r5
  805df8:	2023883a 	mov	r17,r4
  char *p = line;

  while (TRUE) {
    short c = (short)alt_getchar();	//read single character
  805dfc:	08131cc0 	call	8131cc <alt_getchar>

    if (c < 0)
  805e00:	143fffcc 	andi	r16,r2,65535
  805e04:	8420001c 	xori	r16,r16,32768
  805e08:	84200004 	addi	r16,r16,-32768
 */
bool_t shellGetLine(char *line, unsigned size) {
  char *p = line;

  while (TRUE) {
    short c = (short)alt_getchar();	//read single character
  805e0c:	1025883a 	mov	r18,r2

    if (c < 0)
  805e10:	80002316 	blt	r16,zero,805ea0 <shellGetLine+0xcc>
      return TRUE;
    if (c == 4) {
  805e14:	00800104 	movi	r2,4
  805e18:	8080041e 	bne	r16,r2,805e2c <shellGetLine+0x58>
    	alt_printf("^D");
  805e1c:	010020b4 	movhi	r4,130
  805e20:	21206204 	addi	r4,r4,-32376
  805e24:	08136300 	call	813630 <alt_printf>
  805e28:	00001d06 	br	805ea0 <shellGetLine+0xcc>
      return TRUE;
    }
    if (c == 8) {
  805e2c:	00800204 	movi	r2,8
  805e30:	8080091e 	bne	r16,r2,805e58 <shellGetLine+0x84>
      if (p != line) {
    	  alt_putchar((uint8_t)c);
  805e34:	8009883a 	mov	r4,r16
    if (c == 4) {
    	alt_printf("^D");
      return TRUE;
    }
    if (c == 8) {
      if (p != line) {
  805e38:	8cfff026 	beq	r17,r19,805dfc <shellGetLine+0x28>
    	  alt_putchar((uint8_t)c);
  805e3c:	08138880 	call	813888 <alt_putchar>
    	  alt_putchar(0x20);
  805e40:	01000804 	movi	r4,32
  805e44:	08138880 	call	813888 <alt_putchar>
    	  alt_putchar((uint8_t)c);
  805e48:	8009883a 	mov	r4,r16
  805e4c:	08138880 	call	813888 <alt_putchar>
    	  p--;
  805e50:	8c7fffc4 	addi	r17,r17,-1
  805e54:	003fe906 	br	805dfc <shellGetLine+0x28>
    	*p = 0;
    	return FALSE;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
  805e58:	9d05883a 	add	r2,r19,r20
  805e5c:	10ffffc4 	addi	r3,r2,-1
    	  alt_putchar((uint8_t)c);
    	  p--;
      }
      continue;
    }
    if (c == '\r') {
  805e60:	00800344 	movi	r2,13
  805e64:	8080061e 	bne	r16,r2,805e80 <shellGetLine+0xac>
    	alt_printf("\r\n");
  805e68:	01002074 	movhi	r4,129
  805e6c:	211f5b04 	addi	r4,r4,32108
  805e70:	08136300 	call	813630 <alt_printf>
    	*p = 0;
  805e74:	0005883a 	mov	r2,zero
  805e78:	88000005 	stb	zero,0(r17)
  805e7c:	00000906 	br	805ea4 <shellGetLine+0xd0>
    	return FALSE;
    }
    if (c < 0x20)
  805e80:	008007c4 	movi	r2,31
  805e84:	143fdd0e 	bge	r2,r16,805dfc <shellGetLine+0x28>
      continue;
    if (p < line + size - 1) {
    	alt_putchar((uint8_t)c);
  805e88:	91003fcc 	andi	r4,r18,255
    	*p = 0;
    	return FALSE;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
  805e8c:	88ffdb2e 	bgeu	r17,r3,805dfc <shellGetLine+0x28>
    	alt_putchar((uint8_t)c);
  805e90:	08138880 	call	813888 <alt_putchar>
    	*p++ = (char)c;
  805e94:	8c800005 	stb	r18,0(r17)
  805e98:	8c400044 	addi	r17,r17,1
  805e9c:	003fd706 	br	805dfc <shellGetLine+0x28>
  805ea0:	00800044 	movi	r2,1
    }
  }
}
  805ea4:	dfc00517 	ldw	ra,20(sp)
  805ea8:	dd000417 	ldw	r20,16(sp)
  805eac:	dcc00317 	ldw	r19,12(sp)
  805eb0:	dc800217 	ldw	r18,8(sp)
  805eb4:	dc400117 	ldw	r17,4(sp)
  805eb8:	dc000017 	ldw	r16,0(sp)
  805ebc:	dec00604 	addi	sp,sp,24
  805ec0:	f800283a 	ret

00805ec4 <shellCreateStatic>:
 * @param[in] size      size of the shell working area
 * @param[in] prio      priority level for the new shell
 * @return              A pointer to the shell thread.
 */
Thread *shellCreateStatic(const ShellConfig *scp, void *wsp,
                          size_t size, tprio_t prio) {
  805ec4:	defffe04 	addi	sp,sp,-8

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
  805ec8:	d9000015 	stw	r4,0(sp)
  805ecc:	2809883a 	mov	r4,r5
  805ed0:	300b883a 	mov	r5,r6
  805ed4:	380d883a 	mov	r6,r7
  805ed8:	01c02034 	movhi	r7,128
  805edc:	39d84504 	addi	r7,r7,24852
 * @param[in] size      size of the shell working area
 * @param[in] prio      priority level for the new shell
 * @return              A pointer to the shell thread.
 */
Thread *shellCreateStatic(const ShellConfig *scp, void *wsp,
                          size_t size, tprio_t prio) {
  805ee0:	dfc00115 	stw	ra,4(sp)

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
  805ee4:	081264c0 	call	81264c <chThdCreateStatic>
}
  805ee8:	dfc00117 	ldw	ra,4(sp)
  805eec:	dec00204 	addi	sp,sp,8
  805ef0:	f800283a 	ret

00805ef4 <cmdexec>:
  {"info", cmd_info},
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool_t cmdexec(const ShellCommand *scp, char *name, int argc, char *argv[]) {
  805ef4:	defffb04 	addi	sp,sp,-20
  805ef8:	dcc00315 	stw	r19,12(sp)
  805efc:	dc800215 	stw	r18,8(sp)
  805f00:	dc400115 	stw	r17,4(sp)
  805f04:	dc000015 	stw	r16,0(sp)
  805f08:	2823883a 	mov	r17,r5
  805f0c:	2021883a 	mov	r16,r4
  805f10:	3025883a 	mov	r18,r6
  805f14:	3827883a 	mov	r19,r7
  805f18:	dfc00415 	stw	ra,16(sp)
  805f1c:	00000906 	br	805f44 <cmdexec+0x50>

  while (scp->sc_name != NULL) {
    if (strcasecmp(scp->sc_name, name) == 0) {
  805f20:	08065340 	call	806534 <strcasecmp>
  805f24:	1000061e 	bne	r2,zero,805f40 <cmdexec+0x4c>
      scp->sc_function(argc, argv);
  805f28:	80800117 	ldw	r2,4(r16)
  805f2c:	9009883a 	mov	r4,r18
  805f30:	980b883a 	mov	r5,r19
  805f34:	103ee83a 	callr	r2
  805f38:	0005883a 	mov	r2,zero
  805f3c:	00000606 	br	805f58 <cmdexec+0x64>
      return FALSE;
    }
    scp++;
  805f40:	84000204 	addi	r16,r16,8
  {NULL, NULL}
};

static bool_t cmdexec(const ShellCommand *scp, char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
  805f44:	80800017 	ldw	r2,0(r16)
    if (strcasecmp(scp->sc_name, name) == 0) {
  805f48:	880b883a 	mov	r5,r17
  805f4c:	1009883a 	mov	r4,r2
  {NULL, NULL}
};

static bool_t cmdexec(const ShellCommand *scp, char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
  805f50:	103ff31e 	bne	r2,zero,805f20 <cmdexec+0x2c>
  805f54:	00800044 	movi	r2,1
      return FALSE;
    }
    scp++;
  }
  return TRUE;
}
  805f58:	dfc00417 	ldw	ra,16(sp)
  805f5c:	dcc00317 	ldw	r19,12(sp)
  805f60:	dc800217 	ldw	r18,8(sp)
  805f64:	dc400117 	ldw	r17,4(sp)
  805f68:	dc000017 	ldw	r16,0(sp)
  805f6c:	dec00504 	addi	sp,sp,20
  805f70:	f800283a 	ret

00805f74 <cmd_systime>:
}

static void cmd_systime(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  805f74:	0100030e 	bge	zero,r4,805f84 <cmd_systime+0x10>
    usage("systime");
  805f78:	010020b4 	movhi	r4,130
  805f7c:	21206304 	addi	r4,r4,-32372
  805f80:	0805dc41 	jmpi	805dc4 <usage>
    return;
  }
  printf("%lu\r\n", (unsigned long)chTimeNow());
  805f84:	00802134 	movhi	r2,132
  805f88:	10baa404 	addi	r2,r2,-5488
  805f8c:	11400317 	ldw	r5,12(r2)
  805f90:	010020b4 	movhi	r4,130
  805f94:	21206504 	addi	r4,r4,-32364
  805f98:	08064bc1 	jmpi	8064bc <printf>

00805f9c <cmd_info>:
	  alt_printf("\t%s\r\n", scp->sc_name);
    scp++;
  }
}

static void cmd_info(int argc, char *argv[]) {
  805f9c:	deffff04 	addi	sp,sp,-4
  805fa0:	dfc00015 	stw	ra,0(sp)
  if (argc > 0) {
    usage("info");
    return;
  }

  alt_printf("Kernel:       %s\r\n", CH_KERNEL_VERSION);
  805fa4:	014020b4 	movhi	r5,130
  805fa8:	29606e04 	addi	r5,r5,-32328
}

static void cmd_info(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  805fac:	0100050e 	bge	zero,r4,805fc4 <cmd_info+0x28>
    usage("info");
  805fb0:	010020b4 	movhi	r4,130
  805fb4:	21206704 	addi	r4,r4,-32356
  alt_printf("Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
#endif
#endif
  printf("CPU Clock:    %uHz\r\n", alt_get_cpu_freq());

}
  805fb8:	dfc00017 	ldw	ra,0(sp)
  805fbc:	dec00104 	addi	sp,sp,4

static void cmd_info(int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
    usage("info");
  805fc0:	0805dc41 	jmpi	805dc4 <usage>
    return;
  }

  alt_printf("Kernel:       %s\r\n", CH_KERNEL_VERSION);
  805fc4:	010020b4 	movhi	r4,130
  805fc8:	21206904 	addi	r4,r4,-32348
  805fcc:	08136300 	call	813630 <alt_printf>
#ifdef CH_COMPILER_NAME
  alt_printf("Compiler:     %s\r\n", CH_COMPILER_NAME);
  805fd0:	010020b4 	movhi	r4,130
  805fd4:	21207004 	addi	r4,r4,-32320
  805fd8:	014020b4 	movhi	r5,130
  805fdc:	29607504 	addi	r5,r5,-32300
  805fe0:	08136300 	call	813630 <alt_printf>
#endif
  alt_printf("Architecture: %s\r\n", CH_ARCHITECTURE_NAME);
  805fe4:	010020b4 	movhi	r4,130
  805fe8:	21207604 	addi	r4,r4,-32296
  805fec:	014020b4 	movhi	r5,130
  805ff0:	29607b04 	addi	r5,r5,-32276
  805ff4:	08136300 	call	813630 <alt_printf>
#ifdef CH_CORE_VARIANT_NAME
  alt_printf("Core Variant: %s\r\n", CH_CORE_VARIANT_NAME);
  805ff8:	010020b4 	movhi	r4,130
  805ffc:	21207d04 	addi	r4,r4,-32268
  806000:	014020b4 	movhi	r5,130
  806004:	29608204 	addi	r5,r5,-32248
  806008:	08136300 	call	813630 <alt_printf>
#endif
#ifdef CH_PORT_INFO
  alt_printf("Port Info:    %s\r\n", CH_PORT_INFO);
  80600c:	010020b4 	movhi	r4,130
  806010:	21208404 	addi	r4,r4,-32240
  806014:	01402074 	movhi	r5,129
  806018:	295f0f04 	addi	r5,r5,31804
  80601c:	08136300 	call	813630 <alt_printf>
#endif
#ifdef PLATFORM_NAME
  alt_printf("Platform:     %s\r\n", PLATFORM_NAME);
  806020:	010020b4 	movhi	r4,130
  806024:	21203f04 	addi	r4,r4,-32516
  806028:	014020b4 	movhi	r5,130
  80602c:	29607b04 	addi	r5,r5,-32276
  806030:	08136300 	call	813630 <alt_printf>
#endif
#ifdef BOARD_NAME
  alt_printf("Board:        %s\r\n", BOARD_NAME);
  806034:	010020b4 	movhi	r4,130
  806038:	21204404 	addi	r4,r4,-32496
  80603c:	014020b4 	movhi	r5,130
  806040:	29604904 	addi	r5,r5,-32476
  806044:	08136300 	call	813630 <alt_printf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  alt_printf("Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
  806048:	018020b4 	movhi	r6,130
  80604c:	31a05504 	addi	r6,r6,-32428
  806050:	010020b4 	movhi	r4,130
  806054:	21204c04 	addi	r4,r4,-32464
  806058:	014020b4 	movhi	r5,130
  80605c:	29605204 	addi	r5,r5,-32440
  806060:	01c020b4 	movhi	r7,130
  806064:	39e05604 	addi	r7,r7,-32424
  806068:	08136300 	call	813630 <alt_printf>
#endif
#endif
  printf("CPU Clock:    %uHz\r\n", alt_get_cpu_freq());
  80606c:	0814a0c0 	call	814a0c <alt_get_cpu_freq>
  806070:	100b883a 	mov	r5,r2
  806074:	010020b4 	movhi	r4,130
  806078:	21205904 	addi	r4,r4,-32412

}
  80607c:	dfc00017 	ldw	ra,0(sp)
  806080:	dec00104 	addi	sp,sp,4
#ifdef __DATE__
#ifdef __TIME__
  alt_printf("Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
#endif
#endif
  printf("CPU Clock:    %uHz\r\n", alt_get_cpu_freq());
  806084:	08064bc1 	jmpi	8064bc <printf>

00806088 <_strtok>:
/**
 * @brief   Shell termination event source.
 */
EventSource shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
  806088:	defffc04 	addi	sp,sp,-16
  80608c:	dc800215 	stw	r18,8(sp)
  806090:	dc400115 	stw	r17,4(sp)
  806094:	dc000015 	stw	r16,0(sp)
  806098:	dfc00315 	stw	ra,12(sp)
  char *token;
  if (str)
    *saveptr = str;
  80609c:	2021883a 	mov	r16,r4
/**
 * @brief   Shell termination event source.
 */
EventSource shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
  8060a0:	3023883a 	mov	r17,r6
  8060a4:	2825883a 	mov	r18,r5
  char *token;
  if (str)
  8060a8:	20000226 	beq	r4,zero,8060b4 <_strtok+0x2c>
    *saveptr = str;
  8060ac:	31000015 	stw	r4,0(r6)
  8060b0:	00000206 	br	8060bc <_strtok+0x34>
  token = *saveptr;
  8060b4:	34000017 	ldw	r16,0(r6)

  if (!token)
  8060b8:	80000f26 	beq	r16,zero,8060f8 <_strtok+0x70>
    return NULL;

  token += strspn(token, delim);
  8060bc:	8009883a 	mov	r4,r16
  8060c0:	900b883a 	mov	r5,r18
  8060c4:	08066340 	call	806634 <strspn>
  8060c8:	80a1883a 	add	r16,r16,r2
  *saveptr = strpbrk(token, delim);
  8060cc:	900b883a 	mov	r5,r18
  8060d0:	8009883a 	mov	r4,r16
  8060d4:	08065e40 	call	8065e4 <strpbrk>
  if (*saveptr)
    *(*saveptr)++ = '\0';
  8060d8:	10c00044 	addi	r3,r2,1

  if (!token)
    return NULL;

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
  8060dc:	88800015 	stw	r2,0(r17)
  if (*saveptr)
  8060e0:	10000226 	beq	r2,zero,8060ec <_strtok+0x64>
    *(*saveptr)++ = '\0';
  8060e4:	10000005 	stb	zero,0(r2)
  8060e8:	88c00015 	stw	r3,0(r17)

  return *token ? token : NULL;
  8060ec:	80800007 	ldb	r2,0(r16)
  8060f0:	1000011e 	bne	r2,zero,8060f8 <_strtok+0x70>
  8060f4:	0021883a 	mov	r16,zero
}
  8060f8:	8005883a 	mov	r2,r16
  8060fc:	dfc00317 	ldw	ra,12(sp)
  806100:	dc800217 	ldw	r18,8(sp)
  806104:	dc400117 	ldw	r17,4(sp)
  806108:	dc000017 	ldw	r16,0(sp)
  80610c:	dec00404 	addi	sp,sp,16
  806110:	f800283a 	ret

00806114 <shell_thread>:
  msg_t msg = RDY_OK;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("LEDOS Shell");
  806114:	00802134 	movhi	r2,132
  806118:	10ba9c04 	addi	r2,r2,-5520
  80611c:	10c00717 	ldw	r3,28(r2)
 *
 * @return              Termination reason.
 * @retval RDY_OK       terminated by command.
 * @retval RDY_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  806120:	deffe504 	addi	sp,sp,-108
  msg_t msg = RDY_OK;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("LEDOS Shell");
  806124:	008020b4 	movhi	r2,130
  806128:	10a08904 	addi	r2,r2,-32220
 *
 * @return              Termination reason.
 * @retval RDY_OK       terminated by command.
 * @retval RDY_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  80612c:	dcc01915 	stw	r19,100(sp)
  msg_t msg = RDY_OK;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("LEDOS Shell");
  806130:	18800615 	stw	r2,24(r3)
 * @retval RDY_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  int n;
  msg_t msg = RDY_OK;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  806134:	24c00017 	ldw	r19,0(r4)
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("LEDOS Shell");
  alt_printf("\r\nChibiOS/RT - LEDOS Shell\r\n");
  806138:	010020b4 	movhi	r4,130
  80613c:	21208c04 	addi	r4,r4,-32208
 *
 * @return              Termination reason.
 * @retval RDY_OK       terminated by command.
 * @retval RDY_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  806140:	dfc01a15 	stw	ra,104(sp)
  806144:	dc801815 	stw	r18,96(sp)
  806148:	dc401715 	stw	r17,92(sp)
  80614c:	dc001615 	stw	r16,88(sp)
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("LEDOS Shell");
  alt_printf("\r\nChibiOS/RT - LEDOS Shell\r\n");
  806150:	08136300 	call	813630 <alt_printf>

  while (TRUE) {
	  alt_printf(SHELL_PROMPT);
  806154:	010020b4 	movhi	r4,130
  806158:	21209404 	addi	r4,r4,-32176
  80615c:	08136300 	call	813630 <alt_printf>

	  if (shellGetLine(line, sizeof(line))) {	//read complete line
  806160:	dc000604 	addi	r16,sp,24
  806164:	8009883a 	mov	r4,r16
  806168:	01401004 	movi	r5,64
  80616c:	0805dd40 	call	805dd4 <shellGetLine>
  806170:	10000326 	beq	r2,zero,806180 <shell_thread+0x6c>
		  alt_printf("\r\nlogout");
  806174:	010020b4 	movhi	r4,130
  806178:	21209804 	addi	r4,r4,-32160
  80617c:	08136300 	call	813630 <alt_printf>
	  }

	  lp = _strtok(line, " \009", &tokp);
  806180:	8009883a 	mov	r4,r16
  806184:	014020b4 	movhi	r5,130
  806188:	2960af04 	addi	r5,r5,-32068
  80618c:	d80d883a 	mov	r6,sp
  806190:	08060880 	call	806088 <_strtok>
  806194:	1023883a 	mov	r17,r2
  806198:	0021883a 	mov	r16,zero
  80619c:	dc800104 	addi	r18,sp,4
  8061a0:	00000506 	br	8061b8 <shell_thread+0xa4>
	  cmd = lp;
	  n = 0;

	  while ((lp = _strtok(NULL, " \009", &tokp)) != NULL) {
		  if (n >= SHELL_MAX_ARGUMENTS) {
  8061a4:	00800104 	movi	r2,4

	  lp = _strtok(line, " \009", &tokp);
	  cmd = lp;
	  n = 0;

	  while ((lp = _strtok(NULL, " \009", &tokp)) != NULL) {
  8061a8:	94800104 	addi	r18,r18,4
		  if (n >= SHELL_MAX_ARGUMENTS) {
  8061ac:	80802d26 	beq	r16,r2,806264 <shell_thread+0x150>
			  alt_printf("Too many arguments\r\n");
			  cmd = NULL;
			  break;
		  }
		  args[n++] = lp;
  8061b0:	90ffff15 	stw	r3,-4(r18)
  8061b4:	84000044 	addi	r16,r16,1

	  lp = _strtok(line, " \009", &tokp);
	  cmd = lp;
	  n = 0;

	  while ((lp = _strtok(NULL, " \009", &tokp)) != NULL) {
  8061b8:	0009883a 	mov	r4,zero
  8061bc:	014020b4 	movhi	r5,130
  8061c0:	2960af04 	addi	r5,r5,-32068
  8061c4:	d80d883a 	mov	r6,sp
  8061c8:	08060880 	call	806088 <_strtok>
  8061cc:	1007883a 	mov	r3,r2
  8061d0:	103ff41e 	bne	r2,zero,8061a4 <shell_thread+0x90>
			  break;
		  }
		  args[n++] = lp;
	  }

	  args[n] = NULL;
  8061d4:	8405883a 	add	r2,r16,r16
  8061d8:	1085883a 	add	r2,r2,r2
  8061dc:	16c5883a 	add	r2,r2,sp
  8061e0:	10000115 	stw	zero,4(r2)

	  if (cmd != NULL) {
  8061e4:	88003c26 	beq	r17,zero,8062d8 <shell_thread+0x1c4>
		  if (strcasecmp(cmd, "exit") == 0) {
  8061e8:	8809883a 	mov	r4,r17
  8061ec:	014020b4 	movhi	r5,130
  8061f0:	2960a104 	addi	r5,r5,-32124
  8061f4:	08065340 	call	806534 <strcasecmp>
  8061f8:	1000041e 	bne	r2,zero,80620c <shell_thread+0xf8>
			  if (n > 0) {
  8061fc:	0400360e 	bge	zero,r16,8062d8 <shell_thread+0x1c4>
				  usage("exit");
  806200:	010020b4 	movhi	r4,130
  806204:	2120a104 	addi	r4,r4,-32124
  806208:	00000806 	br	80622c <shell_thread+0x118>
				  continue;
			  }
			  //break;
		  }
		  else if (strcasecmp(cmd, "help") == 0) {
  80620c:	8809883a 	mov	r4,r17
  806210:	014020b4 	movhi	r5,130
  806214:	2960a304 	addi	r5,r5,-32116
  806218:	08065340 	call	806534 <strcasecmp>
  80621c:	1000181e 	bne	r2,zero,806280 <shell_thread+0x16c>
			  if (n > 0) {
  806220:	0400040e 	bge	zero,r16,806234 <shell_thread+0x120>
				  usage("help");
  806224:	010020b4 	movhi	r4,130
  806228:	2120a304 	addi	r4,r4,-32116
  80622c:	0805dc40 	call	805dc4 <usage>
  806230:	003fc806 	br	806154 <shell_thread+0x40>
				  continue;
			  }

			  alt_printf("Commands:\r\n\thelp\r\n\texit\r\n");
  806234:	010020b4 	movhi	r4,130
  806238:	2120a504 	addi	r4,r4,-32108
  80623c:	08136300 	call	813630 <alt_printf>
			  list_commands(local_commands);
  806240:	010020b4 	movhi	r4,130
  806244:	21226e04 	addi	r4,r4,-30280
  806248:	0805d840 	call	805d84 <list_commands>
			  if (scp != NULL)
  80624c:	98000226 	beq	r19,zero,806258 <shell_thread+0x144>
				  list_commands(scp);
  806250:	9809883a 	mov	r4,r19
  806254:	0805d840 	call	805d84 <list_commands>

			  alt_printf("\r\n");
  806258:	01002074 	movhi	r4,129
  80625c:	211f5b04 	addi	r4,r4,32108
  806260:	00001c06 	br	8062d4 <shell_thread+0x1c0>
	  cmd = lp;
	  n = 0;

	  while ((lp = _strtok(NULL, " \009", &tokp)) != NULL) {
		  if (n >= SHELL_MAX_ARGUMENTS) {
			  alt_printf("Too many arguments\r\n");
  806264:	010020b4 	movhi	r4,130
  806268:	21209b04 	addi	r4,r4,-32148
  80626c:	08136300 	call	813630 <alt_printf>
			  break;
		  }
		  args[n++] = lp;
	  }

	  args[n] = NULL;
  806270:	d8800404 	addi	r2,sp,16
  806274:	1405883a 	add	r2,r2,r16
  806278:	10000015 	stw	zero,0(r2)
  80627c:	00001606 	br	8062d8 <shell_thread+0x1c4>
			  if (scp != NULL)
				  list_commands(scp);

			  alt_printf("\r\n");
		  }
		  else if (cmdexec(local_commands, cmd, n, args) &&
  806280:	dc800104 	addi	r18,sp,4
  806284:	010020b4 	movhi	r4,130
  806288:	21226e04 	addi	r4,r4,-30280
  80628c:	880b883a 	mov	r5,r17
  806290:	800d883a 	mov	r6,r16
  806294:	900f883a 	mov	r7,r18
  806298:	0805ef40 	call	805ef4 <cmdexec>
  80629c:	10000e26 	beq	r2,zero,8062d8 <shell_thread+0x1c4>
  8062a0:	98000626 	beq	r19,zero,8062bc <shell_thread+0x1a8>
  8062a4:	800d883a 	mov	r6,r16
  8062a8:	900f883a 	mov	r7,r18
  8062ac:	9809883a 	mov	r4,r19
  8062b0:	880b883a 	mov	r5,r17
  8062b4:	0805ef40 	call	805ef4 <cmdexec>
  8062b8:	10000726 	beq	r2,zero,8062d8 <shell_thread+0x1c4>
			  ((scp == NULL) || cmdexec(scp, cmd, n, args))) {
			  alt_printf("%s", cmd);
  8062bc:	010020b4 	movhi	r4,130
  8062c0:	2120ac04 	addi	r4,r4,-32080
  8062c4:	880b883a 	mov	r5,r17
  8062c8:	08136300 	call	813630 <alt_printf>
			  alt_printf(" ???\r\n");
  8062cc:	010020b4 	movhi	r4,130
  8062d0:	2120ad04 	addi	r4,r4,-32076
  8062d4:	08136300 	call	813630 <alt_printf>
		  }
		}

		chThdSleepMilliseconds(100);
  8062d8:	01001904 	movi	r4,100
  8062dc:	08128680 	call	812868 <chThdSleep>
  8062e0:	003f9c06 	br	806154 <shell_thread+0x40>

008062e4 <shellCreate>:
 * @param[in] prio      priority level for the new shell
 * @return              A pointer to the shell thread.
 * @retval NULL         thread creation failed because memory allocation.
 */
#if CH_USE_HEAP && CH_USE_DYNAMIC
Thread *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
  8062e4:	defffe04 	addi	sp,sp,-8

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
  8062e8:	d9000015 	stw	r4,0(sp)
  8062ec:	01c02034 	movhi	r7,128
  8062f0:	39d84504 	addi	r7,r7,24852
  8062f4:	0009883a 	mov	r4,zero
 * @param[in] prio      priority level for the new shell
 * @return              A pointer to the shell thread.
 * @retval NULL         thread creation failed because memory allocation.
 */
#if CH_USE_HEAP && CH_USE_DYNAMIC
Thread *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
  8062f8:	dfc00115 	stw	ra,4(sp)

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
  8062fc:	080ffe00 	call	80ffe0 <chThdCreateFromHeap>
}
  806300:	dfc00117 	ldw	ra,4(sp)
  806304:	dec00204 	addi	sp,sp,8
  806308:	f800283a 	ret

0080630c <main>:
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: never                                                          */
/***************************************************************************/
int main (void)
{
  80630c:	deffff04 	addi	sp,sp,-4

	alt_printf("Hello from NIOS II ...\r\n");
  806310:	010020b4 	movhi	r4,130
  806314:	2120b004 	addi	r4,r4,-32064
/*  In    : none                                                           */
/*  Out   : none                                                           */
/*  Return: never                                                          */
/***************************************************************************/
int main (void)
{
  806318:	dfc00015 	stw	ra,0(sp)

	alt_printf("Hello from NIOS II ...\r\n");
  80631c:	08136300 	call	813630 <alt_printf>


	init_ledos(FS_32KHZ, BPS_16);
  806320:	000b883a 	mov	r5,zero
  806324:	01000044 	movi	r4,1
  806328:	08051680 	call	805168 <init_ledos>
   /*
    * Normal main() thread activity.
    */
   while(1)
   {
      chThdSleepMilliseconds(500);
  80632c:	01007d04 	movi	r4,500
  806330:	08128680 	call	812868 <chThdSleep>
  806334:	003ffd06 	br	80632c <main+0x20>

00806338 <udivmodsi4>:
  806338:	29001b2e 	bgeu	r5,r4,8063a8 <udivmodsi4+0x70>
  80633c:	28001a16 	blt	r5,zero,8063a8 <udivmodsi4+0x70>
  806340:	00800044 	movi	r2,1
  806344:	0007883a 	mov	r3,zero
  806348:	01c007c4 	movi	r7,31
  80634c:	00000306 	br	80635c <udivmodsi4+0x24>
  806350:	19c01326 	beq	r3,r7,8063a0 <udivmodsi4+0x68>
  806354:	18c00044 	addi	r3,r3,1
  806358:	28000416 	blt	r5,zero,80636c <udivmodsi4+0x34>
  80635c:	294b883a 	add	r5,r5,r5
  806360:	1085883a 	add	r2,r2,r2
  806364:	293ffa36 	bltu	r5,r4,806350 <udivmodsi4+0x18>
  806368:	10000d26 	beq	r2,zero,8063a0 <udivmodsi4+0x68>
  80636c:	0007883a 	mov	r3,zero
  806370:	21400236 	bltu	r4,r5,80637c <udivmodsi4+0x44>
  806374:	2149c83a 	sub	r4,r4,r5
  806378:	1886b03a 	or	r3,r3,r2
  80637c:	1004d07a 	srli	r2,r2,1
  806380:	280ad07a 	srli	r5,r5,1
  806384:	103ffa1e 	bne	r2,zero,806370 <udivmodsi4+0x38>
  806388:	30000226 	beq	r6,zero,806394 <udivmodsi4+0x5c>
  80638c:	2005883a 	mov	r2,r4
  806390:	f800283a 	ret
  806394:	1809883a 	mov	r4,r3
  806398:	2005883a 	mov	r2,r4
  80639c:	f800283a 	ret
  8063a0:	0007883a 	mov	r3,zero
  8063a4:	003ff806 	br	806388 <udivmodsi4+0x50>
  8063a8:	00800044 	movi	r2,1
  8063ac:	0007883a 	mov	r3,zero
  8063b0:	003fef06 	br	806370 <udivmodsi4+0x38>

008063b4 <__divsi3>:
  8063b4:	defffe04 	addi	sp,sp,-8
  8063b8:	dc000015 	stw	r16,0(sp)
  8063bc:	dfc00115 	stw	ra,4(sp)
  8063c0:	0021883a 	mov	r16,zero
  8063c4:	20000c16 	blt	r4,zero,8063f8 <__divsi3+0x44>
  8063c8:	000d883a 	mov	r6,zero
  8063cc:	28000e16 	blt	r5,zero,806408 <__divsi3+0x54>
  8063d0:	08063380 	call	806338 <udivmodsi4>
  8063d4:	1007883a 	mov	r3,r2
  8063d8:	8005003a 	cmpeq	r2,r16,zero
  8063dc:	1000011e 	bne	r2,zero,8063e4 <__divsi3+0x30>
  8063e0:	00c7c83a 	sub	r3,zero,r3
  8063e4:	1805883a 	mov	r2,r3
  8063e8:	dfc00117 	ldw	ra,4(sp)
  8063ec:	dc000017 	ldw	r16,0(sp)
  8063f0:	dec00204 	addi	sp,sp,8
  8063f4:	f800283a 	ret
  8063f8:	0109c83a 	sub	r4,zero,r4
  8063fc:	04000044 	movi	r16,1
  806400:	000d883a 	mov	r6,zero
  806404:	283ff20e 	bge	r5,zero,8063d0 <__divsi3+0x1c>
  806408:	014bc83a 	sub	r5,zero,r5
  80640c:	8021003a 	cmpeq	r16,r16,zero
  806410:	003fef06 	br	8063d0 <__divsi3+0x1c>

00806414 <__modsi3>:
  806414:	deffff04 	addi	sp,sp,-4
  806418:	dfc00015 	stw	ra,0(sp)
  80641c:	01800044 	movi	r6,1
  806420:	2807883a 	mov	r3,r5
  806424:	20000416 	blt	r4,zero,806438 <__modsi3+0x24>
  806428:	28000c16 	blt	r5,zero,80645c <__modsi3+0x48>
  80642c:	dfc00017 	ldw	ra,0(sp)
  806430:	dec00104 	addi	sp,sp,4
  806434:	08063381 	jmpi	806338 <udivmodsi4>
  806438:	0109c83a 	sub	r4,zero,r4
  80643c:	28000b16 	blt	r5,zero,80646c <__modsi3+0x58>
  806440:	180b883a 	mov	r5,r3
  806444:	01800044 	movi	r6,1
  806448:	08063380 	call	806338 <udivmodsi4>
  80644c:	0085c83a 	sub	r2,zero,r2
  806450:	dfc00017 	ldw	ra,0(sp)
  806454:	dec00104 	addi	sp,sp,4
  806458:	f800283a 	ret
  80645c:	014bc83a 	sub	r5,zero,r5
  806460:	dfc00017 	ldw	ra,0(sp)
  806464:	dec00104 	addi	sp,sp,4
  806468:	08063381 	jmpi	806338 <udivmodsi4>
  80646c:	0147c83a 	sub	r3,zero,r5
  806470:	003ff306 	br	806440 <__modsi3+0x2c>

00806474 <__udivsi3>:
  806474:	000d883a 	mov	r6,zero
  806478:	08063381 	jmpi	806338 <udivmodsi4>

0080647c <__umodsi3>:
  80647c:	01800044 	movi	r6,1
  806480:	08063381 	jmpi	806338 <udivmodsi4>

00806484 <__mulsi3>:
  806484:	20000a26 	beq	r4,zero,8064b0 <__mulsi3+0x2c>
  806488:	0007883a 	mov	r3,zero
  80648c:	2080004c 	andi	r2,r4,1
  806490:	1005003a 	cmpeq	r2,r2,zero
  806494:	2008d07a 	srli	r4,r4,1
  806498:	1000011e 	bne	r2,zero,8064a0 <__mulsi3+0x1c>
  80649c:	1947883a 	add	r3,r3,r5
  8064a0:	294b883a 	add	r5,r5,r5
  8064a4:	203ff91e 	bne	r4,zero,80648c <__mulsi3+0x8>
  8064a8:	1805883a 	mov	r2,r3
  8064ac:	f800283a 	ret
  8064b0:	0007883a 	mov	r3,zero
  8064b4:	1805883a 	mov	r2,r3
  8064b8:	f800283a 	ret

008064bc <printf>:
  8064bc:	defffb04 	addi	sp,sp,-20
  8064c0:	dfc00115 	stw	ra,4(sp)
  8064c4:	d9400215 	stw	r5,8(sp)
  8064c8:	d9800315 	stw	r6,12(sp)
  8064cc:	d9c00415 	stw	r7,16(sp)
  8064d0:	008020b4 	movhi	r2,130
  8064d4:	10a93104 	addi	r2,r2,-23356
  8064d8:	10c00017 	ldw	r3,0(r2)
  8064dc:	200b883a 	mov	r5,r4
  8064e0:	d8800204 	addi	r2,sp,8
  8064e4:	19000217 	ldw	r4,8(r3)
  8064e8:	100d883a 	mov	r6,r2
  8064ec:	d8800015 	stw	r2,0(sp)
  8064f0:	08085a80 	call	8085a8 <__vfprintf_internal>
  8064f4:	dfc00117 	ldw	ra,4(sp)
  8064f8:	dec00504 	addi	sp,sp,20
  8064fc:	f800283a 	ret

00806500 <_printf_r>:
  806500:	defffc04 	addi	sp,sp,-16
  806504:	dfc00115 	stw	ra,4(sp)
  806508:	d9800215 	stw	r6,8(sp)
  80650c:	d9c00315 	stw	r7,12(sp)
  806510:	280d883a 	mov	r6,r5
  806514:	21400217 	ldw	r5,8(r4)
  806518:	d8c00204 	addi	r3,sp,8
  80651c:	180f883a 	mov	r7,r3
  806520:	d8c00015 	stw	r3,0(sp)
  806524:	08066e40 	call	8066e4 <___vfprintf_internal_r>
  806528:	dfc00117 	ldw	ra,4(sp)
  80652c:	dec00404 	addi	sp,sp,16
  806530:	f800283a 	ret

00806534 <strcasecmp>:
  806534:	20800007 	ldb	r2,0(r4)
  806538:	10002726 	beq	r2,zero,8065d8 <strcasecmp+0xa4>
  80653c:	024020b4 	movhi	r9,130
  806540:	4a693004 	addi	r9,r9,-23360
  806544:	4a000017 	ldw	r8,0(r9)
  806548:	4087883a 	add	r3,r8,r2
  80654c:	100f883a 	mov	r7,r2
  806550:	18800003 	ldbu	r2,0(r3)
  806554:	1080004c 	andi	r2,r2,1
  806558:	1005003a 	cmpeq	r2,r2,zero
  80655c:	1000011e 	bne	r2,zero,806564 <strcasecmp+0x30>
  806560:	39c00804 	addi	r7,r7,32
  806564:	29800007 	ldb	r6,0(r5)
  806568:	4187883a 	add	r3,r8,r6
  80656c:	18800003 	ldbu	r2,0(r3)
  806570:	1080004c 	andi	r2,r2,1
  806574:	1005003a 	cmpeq	r2,r2,zero
  806578:	1000011e 	bne	r2,zero,806580 <strcasecmp+0x4c>
  80657c:	31800804 	addi	r6,r6,32
  806580:	3980041e 	bne	r7,r6,806594 <strcasecmp+0x60>
  806584:	21000044 	addi	r4,r4,1
  806588:	20800007 	ldb	r2,0(r4)
  80658c:	29400044 	addi	r5,r5,1
  806590:	103fed1e 	bne	r2,zero,806548 <strcasecmp+0x14>
  806594:	21000003 	ldbu	r4,0(r4)
  806598:	49800017 	ldw	r6,0(r9)
  80659c:	3107883a 	add	r3,r6,r4
  8065a0:	18800003 	ldbu	r2,0(r3)
  8065a4:	1080004c 	andi	r2,r2,1
  8065a8:	1005003a 	cmpeq	r2,r2,zero
  8065ac:	1000011e 	bne	r2,zero,8065b4 <strcasecmp+0x80>
  8065b0:	21000804 	addi	r4,r4,32
  8065b4:	29400003 	ldbu	r5,0(r5)
  8065b8:	3147883a 	add	r3,r6,r5
  8065bc:	18800003 	ldbu	r2,0(r3)
  8065c0:	1080004c 	andi	r2,r2,1
  8065c4:	1005003a 	cmpeq	r2,r2,zero
  8065c8:	1000011e 	bne	r2,zero,8065d0 <strcasecmp+0x9c>
  8065cc:	29400804 	addi	r5,r5,32
  8065d0:	2145c83a 	sub	r2,r4,r5
  8065d4:	f800283a 	ret
  8065d8:	024020b4 	movhi	r9,130
  8065dc:	4a693004 	addi	r9,r9,-23360
  8065e0:	003fec06 	br	806594 <strcasecmp+0x60>

008065e4 <strpbrk>:
  8065e4:	21800007 	ldb	r6,0(r4)
  8065e8:	30000d26 	beq	r6,zero,806620 <strpbrk+0x3c>
  8065ec:	2807883a 	mov	r3,r5
  8065f0:	18800007 	ldb	r2,0(r3)
  8065f4:	1000071e 	bne	r2,zero,806614 <strpbrk+0x30>
  8065f8:	21000044 	addi	r4,r4,1
  8065fc:	21800007 	ldb	r6,0(r4)
  806600:	303ffa1e 	bne	r6,zero,8065ec <strpbrk+0x8>
  806604:	18800007 	ldb	r2,0(r3)
  806608:	10000726 	beq	r2,zero,806628 <strpbrk+0x44>
  80660c:	2005883a 	mov	r2,r4
  806610:	f800283a 	ret
  806614:	11bffd26 	beq	r2,r6,80660c <strpbrk+0x28>
  806618:	18c00044 	addi	r3,r3,1
  80661c:	003ff406 	br	8065f0 <strpbrk+0xc>
  806620:	0005883a 	mov	r2,zero
  806624:	f800283a 	ret
  806628:	0009883a 	mov	r4,zero
  80662c:	2005883a 	mov	r2,r4
  806630:	f800283a 	ret

00806634 <strspn>:
  806634:	21c00007 	ldb	r7,0(r4)
  806638:	38001226 	beq	r7,zero,806684 <strspn+0x50>
  80663c:	2a000007 	ldb	r8,0(r5)
  806640:	40000e26 	beq	r8,zero,80667c <strspn+0x48>
  806644:	2005883a 	mov	r2,r4
  806648:	41c00826 	beq	r8,r7,80666c <strspn+0x38>
  80664c:	280d883a 	mov	r6,r5
  806650:	00000106 	br	806658 <strspn+0x24>
  806654:	19c00526 	beq	r3,r7,80666c <strspn+0x38>
  806658:	31800044 	addi	r6,r6,1
  80665c:	30c00007 	ldb	r3,0(r6)
  806660:	183ffc1e 	bne	r3,zero,806654 <strspn+0x20>
  806664:	1105c83a 	sub	r2,r2,r4
  806668:	f800283a 	ret
  80666c:	10800044 	addi	r2,r2,1
  806670:	11c00007 	ldb	r7,0(r2)
  806674:	383ff41e 	bne	r7,zero,806648 <strspn+0x14>
  806678:	003ffa06 	br	806664 <strspn+0x30>
  80667c:	0005883a 	mov	r2,zero
  806680:	f800283a 	ret
  806684:	0005883a 	mov	r2,zero
  806688:	f800283a 	ret

0080668c <__sprint_r>:
  80668c:	30800217 	ldw	r2,8(r6)
  806690:	defffe04 	addi	sp,sp,-8
  806694:	dc000015 	stw	r16,0(sp)
  806698:	dfc00115 	stw	ra,4(sp)
  80669c:	3021883a 	mov	r16,r6
  8066a0:	0007883a 	mov	r3,zero
  8066a4:	1000061e 	bne	r2,zero,8066c0 <__sprint_r+0x34>
  8066a8:	1805883a 	mov	r2,r3
  8066ac:	30000115 	stw	zero,4(r6)
  8066b0:	dfc00117 	ldw	ra,4(sp)
  8066b4:	dc000017 	ldw	r16,0(sp)
  8066b8:	dec00204 	addi	sp,sp,8
  8066bc:	f800283a 	ret
  8066c0:	080a8640 	call	80a864 <__sfvwrite_r>
  8066c4:	1007883a 	mov	r3,r2
  8066c8:	1805883a 	mov	r2,r3
  8066cc:	80000115 	stw	zero,4(r16)
  8066d0:	80000215 	stw	zero,8(r16)
  8066d4:	dfc00117 	ldw	ra,4(sp)
  8066d8:	dc000017 	ldw	r16,0(sp)
  8066dc:	dec00204 	addi	sp,sp,8
  8066e0:	f800283a 	ret

008066e4 <___vfprintf_internal_r>:
  8066e4:	defea404 	addi	sp,sp,-1392
  8066e8:	dd815815 	stw	r22,1376(sp)
  8066ec:	dc015215 	stw	r16,1352(sp)
  8066f0:	d9c15115 	stw	r7,1348(sp)
  8066f4:	dfc15b15 	stw	ra,1388(sp)
  8066f8:	df015a15 	stw	fp,1384(sp)
  8066fc:	ddc15915 	stw	r23,1380(sp)
  806700:	dd415715 	stw	r21,1372(sp)
  806704:	dd015615 	stw	r20,1368(sp)
  806708:	dcc15515 	stw	r19,1364(sp)
  80670c:	dc815415 	stw	r18,1360(sp)
  806710:	dc415315 	stw	r17,1356(sp)
  806714:	282d883a 	mov	r22,r5
  806718:	3021883a 	mov	r16,r6
  80671c:	d9014f15 	stw	r4,1340(sp)
  806720:	080ae880 	call	80ae88 <_localeconv_r>
  806724:	10800017 	ldw	r2,0(r2)
  806728:	d9c15117 	ldw	r7,1348(sp)
  80672c:	d8814915 	stw	r2,1316(sp)
  806730:	d8814f17 	ldw	r2,1340(sp)
  806734:	10000226 	beq	r2,zero,806740 <___vfprintf_internal_r+0x5c>
  806738:	10800e17 	ldw	r2,56(r2)
  80673c:	10020d26 	beq	r2,zero,806f74 <___vfprintf_internal_r+0x890>
  806740:	b080030b 	ldhu	r2,12(r22)
  806744:	1080020c 	andi	r2,r2,8
  806748:	10020e26 	beq	r2,zero,806f84 <___vfprintf_internal_r+0x8a0>
  80674c:	b0800417 	ldw	r2,16(r22)
  806750:	10020c26 	beq	r2,zero,806f84 <___vfprintf_internal_r+0x8a0>
  806754:	b200030b 	ldhu	r8,12(r22)
  806758:	00800284 	movi	r2,10
  80675c:	40c0068c 	andi	r3,r8,26
  806760:	18802f1e 	bne	r3,r2,806820 <___vfprintf_internal_r+0x13c>
  806764:	b080038f 	ldh	r2,14(r22)
  806768:	10002d16 	blt	r2,zero,806820 <___vfprintf_internal_r+0x13c>
  80676c:	b240038b 	ldhu	r9,14(r22)
  806770:	b2800717 	ldw	r10,28(r22)
  806774:	b2c00917 	ldw	r11,36(r22)
  806778:	d9014f17 	ldw	r4,1340(sp)
  80677c:	dc402904 	addi	r17,sp,164
  806780:	d8804004 	addi	r2,sp,256
  806784:	00c10004 	movi	r3,1024
  806788:	423fff4c 	andi	r8,r8,65533
  80678c:	800d883a 	mov	r6,r16
  806790:	880b883a 	mov	r5,r17
  806794:	da002c0d 	sth	r8,176(sp)
  806798:	da402c8d 	sth	r9,178(sp)
  80679c:	da803015 	stw	r10,192(sp)
  8067a0:	dac03215 	stw	r11,200(sp)
  8067a4:	d8802d15 	stw	r2,180(sp)
  8067a8:	d8c02e15 	stw	r3,184(sp)
  8067ac:	d8802915 	stw	r2,164(sp)
  8067b0:	d8c02b15 	stw	r3,172(sp)
  8067b4:	d8002f15 	stw	zero,188(sp)
  8067b8:	08066e40 	call	8066e4 <___vfprintf_internal_r>
  8067bc:	d8814b15 	stw	r2,1324(sp)
  8067c0:	10000416 	blt	r2,zero,8067d4 <___vfprintf_internal_r+0xf0>
  8067c4:	d9014f17 	ldw	r4,1340(sp)
  8067c8:	880b883a 	mov	r5,r17
  8067cc:	0809f000 	call	809f00 <_fflush_r>
  8067d0:	1002321e 	bne	r2,zero,80709c <___vfprintf_internal_r+0x9b8>
  8067d4:	d8802c0b 	ldhu	r2,176(sp)
  8067d8:	1080100c 	andi	r2,r2,64
  8067dc:	10000326 	beq	r2,zero,8067ec <___vfprintf_internal_r+0x108>
  8067e0:	b080030b 	ldhu	r2,12(r22)
  8067e4:	10801014 	ori	r2,r2,64
  8067e8:	b080030d 	sth	r2,12(r22)
  8067ec:	d8814b17 	ldw	r2,1324(sp)
  8067f0:	dfc15b17 	ldw	ra,1388(sp)
  8067f4:	df015a17 	ldw	fp,1384(sp)
  8067f8:	ddc15917 	ldw	r23,1380(sp)
  8067fc:	dd815817 	ldw	r22,1376(sp)
  806800:	dd415717 	ldw	r21,1372(sp)
  806804:	dd015617 	ldw	r20,1368(sp)
  806808:	dcc15517 	ldw	r19,1364(sp)
  80680c:	dc815417 	ldw	r18,1360(sp)
  806810:	dc415317 	ldw	r17,1356(sp)
  806814:	dc015217 	ldw	r16,1352(sp)
  806818:	dec15c04 	addi	sp,sp,1392
  80681c:	f800283a 	ret
  806820:	0005883a 	mov	r2,zero
  806824:	0007883a 	mov	r3,zero
  806828:	dd401904 	addi	r21,sp,100
  80682c:	d8814215 	stw	r2,1288(sp)
  806830:	802f883a 	mov	r23,r16
  806834:	d8c14315 	stw	r3,1292(sp)
  806838:	d8014b15 	stw	zero,1324(sp)
  80683c:	d8014815 	stw	zero,1312(sp)
  806840:	d8014415 	stw	zero,1296(sp)
  806844:	d8014715 	stw	zero,1308(sp)
  806848:	dd400c15 	stw	r21,48(sp)
  80684c:	d8000e15 	stw	zero,56(sp)
  806850:	d8000d15 	stw	zero,52(sp)
  806854:	b8800007 	ldb	r2,0(r23)
  806858:	10001926 	beq	r2,zero,8068c0 <___vfprintf_internal_r+0x1dc>
  80685c:	00c00944 	movi	r3,37
  806860:	10c01726 	beq	r2,r3,8068c0 <___vfprintf_internal_r+0x1dc>
  806864:	b821883a 	mov	r16,r23
  806868:	00000106 	br	806870 <___vfprintf_internal_r+0x18c>
  80686c:	10c00326 	beq	r2,r3,80687c <___vfprintf_internal_r+0x198>
  806870:	84000044 	addi	r16,r16,1
  806874:	80800007 	ldb	r2,0(r16)
  806878:	103ffc1e 	bne	r2,zero,80686c <___vfprintf_internal_r+0x188>
  80687c:	85e7c83a 	sub	r19,r16,r23
  806880:	98000e26 	beq	r19,zero,8068bc <___vfprintf_internal_r+0x1d8>
  806884:	dc800e17 	ldw	r18,56(sp)
  806888:	dc400d17 	ldw	r17,52(sp)
  80688c:	008001c4 	movi	r2,7
  806890:	94e5883a 	add	r18,r18,r19
  806894:	8c400044 	addi	r17,r17,1
  806898:	adc00015 	stw	r23,0(r21)
  80689c:	dc800e15 	stw	r18,56(sp)
  8068a0:	acc00115 	stw	r19,4(r21)
  8068a4:	dc400d15 	stw	r17,52(sp)
  8068a8:	14428b16 	blt	r2,r17,8072d8 <___vfprintf_internal_r+0xbf4>
  8068ac:	ad400204 	addi	r21,r21,8
  8068b0:	d9014b17 	ldw	r4,1324(sp)
  8068b4:	24c9883a 	add	r4,r4,r19
  8068b8:	d9014b15 	stw	r4,1324(sp)
  8068bc:	802f883a 	mov	r23,r16
  8068c0:	b8800007 	ldb	r2,0(r23)
  8068c4:	10013c26 	beq	r2,zero,806db8 <___vfprintf_internal_r+0x6d4>
  8068c8:	bdc00044 	addi	r23,r23,1
  8068cc:	d8000405 	stb	zero,16(sp)
  8068d0:	b8c00007 	ldb	r3,0(r23)
  8068d4:	04ffffc4 	movi	r19,-1
  8068d8:	d8014c15 	stw	zero,1328(sp)
  8068dc:	d8014a15 	stw	zero,1320(sp)
  8068e0:	d8c14d15 	stw	r3,1332(sp)
  8068e4:	bdc00044 	addi	r23,r23,1
  8068e8:	d9414d17 	ldw	r5,1332(sp)
  8068ec:	00801604 	movi	r2,88
  8068f0:	28fff804 	addi	r3,r5,-32
  8068f4:	10c06036 	bltu	r2,r3,806a78 <___vfprintf_internal_r+0x394>
  8068f8:	18c5883a 	add	r2,r3,r3
  8068fc:	1085883a 	add	r2,r2,r2
  806900:	00c02034 	movhi	r3,128
  806904:	18da4504 	addi	r3,r3,26900
  806908:	10c5883a 	add	r2,r2,r3
  80690c:	11000017 	ldw	r4,0(r2)
  806910:	2000683a 	jmp	r4
  806914:	00807888 	cmpgei	r2,zero,482
  806918:	00806a78 	rdprs	r2,zero,425
  80691c:	00806a78 	rdprs	r2,zero,425
  806920:	00807874 	movhi	r2,481
  806924:	00806a78 	rdprs	r2,zero,425
  806928:	00806a78 	rdprs	r2,zero,425
  80692c:	00806a78 	rdprs	r2,zero,425
  806930:	00806a78 	rdprs	r2,zero,425
  806934:	00806a78 	rdprs	r2,zero,425
  806938:	00806a78 	rdprs	r2,zero,425
  80693c:	00807654 	movui	r2,473
  806940:	00807864 	muli	r2,zero,481
  806944:	00806a78 	rdprs	r2,zero,425
  806948:	0080766c 	andhi	r2,zero,473
  80694c:	0080790c 	andi	r2,zero,484
  806950:	00806a78 	rdprs	r2,zero,425
  806954:	008078f8 	rdprs	r2,zero,483
  806958:	008078b4 	movhi	r2,482
  80695c:	008078b4 	movhi	r2,482
  806960:	008078b4 	movhi	r2,482
  806964:	008078b4 	movhi	r2,482
  806968:	008078b4 	movhi	r2,482
  80696c:	008078b4 	movhi	r2,482
  806970:	008078b4 	movhi	r2,482
  806974:	008078b4 	movhi	r2,482
  806978:	008078b4 	movhi	r2,482
  80697c:	00806a78 	rdprs	r2,zero,425
  806980:	00806a78 	rdprs	r2,zero,425
  806984:	00806a78 	rdprs	r2,zero,425
  806988:	00806a78 	rdprs	r2,zero,425
  80698c:	00806a78 	rdprs	r2,zero,425
  806990:	00806a78 	rdprs	r2,zero,425
  806994:	00806a78 	rdprs	r2,zero,425
  806998:	00806a78 	rdprs	r2,zero,425
  80699c:	00806a78 	rdprs	r2,zero,425
  8069a0:	00806a78 	rdprs	r2,zero,425
  8069a4:	008070d0 	cmplti	r2,zero,451
  8069a8:	0080773c 	xorhi	r2,zero,476
  8069ac:	00806a78 	rdprs	r2,zero,425
  8069b0:	0080773c 	xorhi	r2,zero,476
  8069b4:	00806a78 	rdprs	r2,zero,425
  8069b8:	00806a78 	rdprs	r2,zero,425
  8069bc:	00806a78 	rdprs	r2,zero,425
  8069c0:	00806a78 	rdprs	r2,zero,425
  8069c4:	008078a0 	cmpeqi	r2,zero,482
  8069c8:	00806a78 	rdprs	r2,zero,425
  8069cc:	00806a78 	rdprs	r2,zero,425
  8069d0:	00807184 	movi	r2,454
  8069d4:	00806a78 	rdprs	r2,zero,425
  8069d8:	00806a78 	rdprs	r2,zero,425
  8069dc:	00806a78 	rdprs	r2,zero,425
  8069e0:	00806a78 	rdprs	r2,zero,425
  8069e4:	00806a78 	rdprs	r2,zero,425
  8069e8:	008071d0 	cmplti	r2,zero,455
  8069ec:	00806a78 	rdprs	r2,zero,425
  8069f0:	00806a78 	rdprs	r2,zero,425
  8069f4:	008077f0 	cmpltui	r2,zero,479
  8069f8:	00806a78 	rdprs	r2,zero,425
  8069fc:	00806a78 	rdprs	r2,zero,425
  806a00:	00806a78 	rdprs	r2,zero,425
  806a04:	00806a78 	rdprs	r2,zero,425
  806a08:	00806a78 	rdprs	r2,zero,425
  806a0c:	00806a78 	rdprs	r2,zero,425
  806a10:	00806a78 	rdprs	r2,zero,425
  806a14:	00806a78 	rdprs	r2,zero,425
  806a18:	00806a78 	rdprs	r2,zero,425
  806a1c:	00806a78 	rdprs	r2,zero,425
  806a20:	008077c4 	movi	r2,479
  806a24:	008070dc 	xori	r2,zero,451
  806a28:	0080773c 	xorhi	r2,zero,476
  806a2c:	0080773c 	xorhi	r2,zero,476
  806a30:	0080773c 	xorhi	r2,zero,476
  806a34:	00807728 	cmpgeui	r2,zero,476
  806a38:	008070dc 	xori	r2,zero,451
  806a3c:	00806a78 	rdprs	r2,zero,425
  806a40:	00806a78 	rdprs	r2,zero,425
  806a44:	008076b0 	cmpltui	r2,zero,474
  806a48:	00806a78 	rdprs	r2,zero,425
  806a4c:	00807680 	call	80768 <__reset-0x77f898>
  806a50:	00807190 	cmplti	r2,zero,454
  806a54:	008076e0 	cmpeqi	r2,zero,475
  806a58:	008076cc 	andi	r2,zero,475
  806a5c:	00806a78 	rdprs	r2,zero,425
  806a60:	00807974 	movhi	r2,485
  806a64:	00806a78 	rdprs	r2,zero,425
  806a68:	008071dc 	xori	r2,zero,455
  806a6c:	00806a78 	rdprs	r2,zero,425
  806a70:	00806a78 	rdprs	r2,zero,425
  806a74:	00807854 	movui	r2,481
  806a78:	d9014d17 	ldw	r4,1332(sp)
  806a7c:	2000ce26 	beq	r4,zero,806db8 <___vfprintf_internal_r+0x6d4>
  806a80:	01400044 	movi	r5,1
  806a84:	d9800f04 	addi	r6,sp,60
  806a88:	d9c14015 	stw	r7,1280(sp)
  806a8c:	d9414515 	stw	r5,1300(sp)
  806a90:	d9814115 	stw	r6,1284(sp)
  806a94:	280f883a 	mov	r7,r5
  806a98:	d9000f05 	stb	r4,60(sp)
  806a9c:	d8000405 	stb	zero,16(sp)
  806aa0:	d8014615 	stw	zero,1304(sp)
  806aa4:	d8c14c17 	ldw	r3,1328(sp)
  806aa8:	1880008c 	andi	r2,r3,2
  806aac:	1005003a 	cmpeq	r2,r2,zero
  806ab0:	d8815015 	stw	r2,1344(sp)
  806ab4:	1000031e 	bne	r2,zero,806ac4 <___vfprintf_internal_r+0x3e0>
  806ab8:	d9014517 	ldw	r4,1300(sp)
  806abc:	21000084 	addi	r4,r4,2
  806ac0:	d9014515 	stw	r4,1300(sp)
  806ac4:	d9414c17 	ldw	r5,1328(sp)
  806ac8:	2940210c 	andi	r5,r5,132
  806acc:	d9414e15 	stw	r5,1336(sp)
  806ad0:	28002d1e 	bne	r5,zero,806b88 <___vfprintf_internal_r+0x4a4>
  806ad4:	d9814a17 	ldw	r6,1320(sp)
  806ad8:	d8814517 	ldw	r2,1300(sp)
  806adc:	30a1c83a 	sub	r16,r6,r2
  806ae0:	0400290e 	bge	zero,r16,806b88 <___vfprintf_internal_r+0x4a4>
  806ae4:	00800404 	movi	r2,16
  806ae8:	14045e0e 	bge	r2,r16,807c64 <___vfprintf_internal_r+0x1580>
  806aec:	dc800e17 	ldw	r18,56(sp)
  806af0:	dc400d17 	ldw	r17,52(sp)
  806af4:	1027883a 	mov	r19,r2
  806af8:	070020b4 	movhi	fp,130
  806afc:	e720d184 	addi	fp,fp,-31930
  806b00:	050001c4 	movi	r20,7
  806b04:	00000306 	br	806b14 <___vfprintf_internal_r+0x430>
  806b08:	843ffc04 	addi	r16,r16,-16
  806b0c:	ad400204 	addi	r21,r21,8
  806b10:	9c00130e 	bge	r19,r16,806b60 <___vfprintf_internal_r+0x47c>
  806b14:	94800404 	addi	r18,r18,16
  806b18:	8c400044 	addi	r17,r17,1
  806b1c:	af000015 	stw	fp,0(r21)
  806b20:	acc00115 	stw	r19,4(r21)
  806b24:	dc800e15 	stw	r18,56(sp)
  806b28:	dc400d15 	stw	r17,52(sp)
  806b2c:	a47ff60e 	bge	r20,r17,806b08 <___vfprintf_internal_r+0x424>
  806b30:	d9014f17 	ldw	r4,1340(sp)
  806b34:	b00b883a 	mov	r5,r22
  806b38:	d9800c04 	addi	r6,sp,48
  806b3c:	d9c15115 	stw	r7,1348(sp)
  806b40:	080668c0 	call	80668c <__sprint_r>
  806b44:	d9c15117 	ldw	r7,1348(sp)
  806b48:	10009e1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  806b4c:	843ffc04 	addi	r16,r16,-16
  806b50:	dc800e17 	ldw	r18,56(sp)
  806b54:	dc400d17 	ldw	r17,52(sp)
  806b58:	dd401904 	addi	r21,sp,100
  806b5c:	9c3fed16 	blt	r19,r16,806b14 <___vfprintf_internal_r+0x430>
  806b60:	9425883a 	add	r18,r18,r16
  806b64:	8c400044 	addi	r17,r17,1
  806b68:	008001c4 	movi	r2,7
  806b6c:	af000015 	stw	fp,0(r21)
  806b70:	ac000115 	stw	r16,4(r21)
  806b74:	dc800e15 	stw	r18,56(sp)
  806b78:	dc400d15 	stw	r17,52(sp)
  806b7c:	1441f516 	blt	r2,r17,807354 <___vfprintf_internal_r+0xc70>
  806b80:	ad400204 	addi	r21,r21,8
  806b84:	00000206 	br	806b90 <___vfprintf_internal_r+0x4ac>
  806b88:	dc800e17 	ldw	r18,56(sp)
  806b8c:	dc400d17 	ldw	r17,52(sp)
  806b90:	d8800407 	ldb	r2,16(sp)
  806b94:	10000b26 	beq	r2,zero,806bc4 <___vfprintf_internal_r+0x4e0>
  806b98:	00800044 	movi	r2,1
  806b9c:	94800044 	addi	r18,r18,1
  806ba0:	8c400044 	addi	r17,r17,1
  806ba4:	a8800115 	stw	r2,4(r21)
  806ba8:	d8c00404 	addi	r3,sp,16
  806bac:	008001c4 	movi	r2,7
  806bb0:	a8c00015 	stw	r3,0(r21)
  806bb4:	dc800e15 	stw	r18,56(sp)
  806bb8:	dc400d15 	stw	r17,52(sp)
  806bbc:	1441da16 	blt	r2,r17,807328 <___vfprintf_internal_r+0xc44>
  806bc0:	ad400204 	addi	r21,r21,8
  806bc4:	d9015017 	ldw	r4,1344(sp)
  806bc8:	20000b1e 	bne	r4,zero,806bf8 <___vfprintf_internal_r+0x514>
  806bcc:	d8800444 	addi	r2,sp,17
  806bd0:	94800084 	addi	r18,r18,2
  806bd4:	8c400044 	addi	r17,r17,1
  806bd8:	a8800015 	stw	r2,0(r21)
  806bdc:	00c00084 	movi	r3,2
  806be0:	008001c4 	movi	r2,7
  806be4:	a8c00115 	stw	r3,4(r21)
  806be8:	dc800e15 	stw	r18,56(sp)
  806bec:	dc400d15 	stw	r17,52(sp)
  806bf0:	1441c216 	blt	r2,r17,8072fc <___vfprintf_internal_r+0xc18>
  806bf4:	ad400204 	addi	r21,r21,8
  806bf8:	d9414e17 	ldw	r5,1336(sp)
  806bfc:	00802004 	movi	r2,128
  806c00:	2880b126 	beq	r5,r2,806ec8 <___vfprintf_internal_r+0x7e4>
  806c04:	d8c14617 	ldw	r3,1304(sp)
  806c08:	19e1c83a 	sub	r16,r3,r7
  806c0c:	0400260e 	bge	zero,r16,806ca8 <___vfprintf_internal_r+0x5c4>
  806c10:	00800404 	movi	r2,16
  806c14:	1403cf0e 	bge	r2,r16,807b54 <___vfprintf_internal_r+0x1470>
  806c18:	1027883a 	mov	r19,r2
  806c1c:	070020b4 	movhi	fp,130
  806c20:	e720cd84 	addi	fp,fp,-31946
  806c24:	050001c4 	movi	r20,7
  806c28:	00000306 	br	806c38 <___vfprintf_internal_r+0x554>
  806c2c:	843ffc04 	addi	r16,r16,-16
  806c30:	ad400204 	addi	r21,r21,8
  806c34:	9c00130e 	bge	r19,r16,806c84 <___vfprintf_internal_r+0x5a0>
  806c38:	94800404 	addi	r18,r18,16
  806c3c:	8c400044 	addi	r17,r17,1
  806c40:	af000015 	stw	fp,0(r21)
  806c44:	acc00115 	stw	r19,4(r21)
  806c48:	dc800e15 	stw	r18,56(sp)
  806c4c:	dc400d15 	stw	r17,52(sp)
  806c50:	a47ff60e 	bge	r20,r17,806c2c <___vfprintf_internal_r+0x548>
  806c54:	d9014f17 	ldw	r4,1340(sp)
  806c58:	b00b883a 	mov	r5,r22
  806c5c:	d9800c04 	addi	r6,sp,48
  806c60:	d9c15115 	stw	r7,1348(sp)
  806c64:	080668c0 	call	80668c <__sprint_r>
  806c68:	d9c15117 	ldw	r7,1348(sp)
  806c6c:	1000551e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  806c70:	843ffc04 	addi	r16,r16,-16
  806c74:	dc800e17 	ldw	r18,56(sp)
  806c78:	dc400d17 	ldw	r17,52(sp)
  806c7c:	dd401904 	addi	r21,sp,100
  806c80:	9c3fed16 	blt	r19,r16,806c38 <___vfprintf_internal_r+0x554>
  806c84:	9425883a 	add	r18,r18,r16
  806c88:	8c400044 	addi	r17,r17,1
  806c8c:	008001c4 	movi	r2,7
  806c90:	af000015 	stw	fp,0(r21)
  806c94:	ac000115 	stw	r16,4(r21)
  806c98:	dc800e15 	stw	r18,56(sp)
  806c9c:	dc400d15 	stw	r17,52(sp)
  806ca0:	14418216 	blt	r2,r17,8072ac <___vfprintf_internal_r+0xbc8>
  806ca4:	ad400204 	addi	r21,r21,8
  806ca8:	d9014c17 	ldw	r4,1328(sp)
  806cac:	2080400c 	andi	r2,r4,256
  806cb0:	10004a1e 	bne	r2,zero,806ddc <___vfprintf_internal_r+0x6f8>
  806cb4:	d9414117 	ldw	r5,1284(sp)
  806cb8:	91e5883a 	add	r18,r18,r7
  806cbc:	8c400044 	addi	r17,r17,1
  806cc0:	008001c4 	movi	r2,7
  806cc4:	a9400015 	stw	r5,0(r21)
  806cc8:	a9c00115 	stw	r7,4(r21)
  806ccc:	dc800e15 	stw	r18,56(sp)
  806cd0:	dc400d15 	stw	r17,52(sp)
  806cd4:	14416716 	blt	r2,r17,807274 <___vfprintf_internal_r+0xb90>
  806cd8:	a8c00204 	addi	r3,r21,8
  806cdc:	d9814c17 	ldw	r6,1328(sp)
  806ce0:	3080010c 	andi	r2,r6,4
  806ce4:	10002826 	beq	r2,zero,806d88 <___vfprintf_internal_r+0x6a4>
  806ce8:	d8814a17 	ldw	r2,1320(sp)
  806cec:	d9014517 	ldw	r4,1300(sp)
  806cf0:	1121c83a 	sub	r16,r2,r4
  806cf4:	0400240e 	bge	zero,r16,806d88 <___vfprintf_internal_r+0x6a4>
  806cf8:	00800404 	movi	r2,16
  806cfc:	1404550e 	bge	r2,r16,807e54 <___vfprintf_internal_r+0x1770>
  806d00:	dc400d17 	ldw	r17,52(sp)
  806d04:	1027883a 	mov	r19,r2
  806d08:	070020b4 	movhi	fp,130
  806d0c:	e720d184 	addi	fp,fp,-31930
  806d10:	050001c4 	movi	r20,7
  806d14:	00000306 	br	806d24 <___vfprintf_internal_r+0x640>
  806d18:	843ffc04 	addi	r16,r16,-16
  806d1c:	18c00204 	addi	r3,r3,8
  806d20:	9c00110e 	bge	r19,r16,806d68 <___vfprintf_internal_r+0x684>
  806d24:	94800404 	addi	r18,r18,16
  806d28:	8c400044 	addi	r17,r17,1
  806d2c:	1f000015 	stw	fp,0(r3)
  806d30:	1cc00115 	stw	r19,4(r3)
  806d34:	dc800e15 	stw	r18,56(sp)
  806d38:	dc400d15 	stw	r17,52(sp)
  806d3c:	a47ff60e 	bge	r20,r17,806d18 <___vfprintf_internal_r+0x634>
  806d40:	d9014f17 	ldw	r4,1340(sp)
  806d44:	b00b883a 	mov	r5,r22
  806d48:	d9800c04 	addi	r6,sp,48
  806d4c:	080668c0 	call	80668c <__sprint_r>
  806d50:	10001c1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  806d54:	843ffc04 	addi	r16,r16,-16
  806d58:	dc800e17 	ldw	r18,56(sp)
  806d5c:	dc400d17 	ldw	r17,52(sp)
  806d60:	d8c01904 	addi	r3,sp,100
  806d64:	9c3fef16 	blt	r19,r16,806d24 <___vfprintf_internal_r+0x640>
  806d68:	9425883a 	add	r18,r18,r16
  806d6c:	8c400044 	addi	r17,r17,1
  806d70:	008001c4 	movi	r2,7
  806d74:	1f000015 	stw	fp,0(r3)
  806d78:	1c000115 	stw	r16,4(r3)
  806d7c:	dc800e15 	stw	r18,56(sp)
  806d80:	dc400d15 	stw	r17,52(sp)
  806d84:	1440cb16 	blt	r2,r17,8070b4 <___vfprintf_internal_r+0x9d0>
  806d88:	d8814a17 	ldw	r2,1320(sp)
  806d8c:	d9414517 	ldw	r5,1300(sp)
  806d90:	1140010e 	bge	r2,r5,806d98 <___vfprintf_internal_r+0x6b4>
  806d94:	2805883a 	mov	r2,r5
  806d98:	d9814b17 	ldw	r6,1324(sp)
  806d9c:	308d883a 	add	r6,r6,r2
  806da0:	d9814b15 	stw	r6,1324(sp)
  806da4:	90013b1e 	bne	r18,zero,807294 <___vfprintf_internal_r+0xbb0>
  806da8:	d9c14017 	ldw	r7,1280(sp)
  806dac:	dd401904 	addi	r21,sp,100
  806db0:	d8000d15 	stw	zero,52(sp)
  806db4:	003ea706 	br	806854 <___vfprintf_internal_r+0x170>
  806db8:	d8800e17 	ldw	r2,56(sp)
  806dbc:	1005451e 	bne	r2,zero,8082d4 <___vfprintf_internal_r+0x1bf0>
  806dc0:	d8000d15 	stw	zero,52(sp)
  806dc4:	b080030b 	ldhu	r2,12(r22)
  806dc8:	1080100c 	andi	r2,r2,64
  806dcc:	103e8726 	beq	r2,zero,8067ec <___vfprintf_internal_r+0x108>
  806dd0:	00bfffc4 	movi	r2,-1
  806dd4:	d8814b15 	stw	r2,1324(sp)
  806dd8:	003e8406 	br	8067ec <___vfprintf_internal_r+0x108>
  806ddc:	d9814d17 	ldw	r6,1332(sp)
  806de0:	00801944 	movi	r2,101
  806de4:	11806e16 	blt	r2,r6,806fa0 <___vfprintf_internal_r+0x8bc>
  806de8:	d9414717 	ldw	r5,1308(sp)
  806dec:	00c00044 	movi	r3,1
  806df0:	1943490e 	bge	r3,r5,807b18 <___vfprintf_internal_r+0x1434>
  806df4:	d8814117 	ldw	r2,1284(sp)
  806df8:	94800044 	addi	r18,r18,1
  806dfc:	8c400044 	addi	r17,r17,1
  806e00:	a8800015 	stw	r2,0(r21)
  806e04:	008001c4 	movi	r2,7
  806e08:	a8c00115 	stw	r3,4(r21)
  806e0c:	dc800e15 	stw	r18,56(sp)
  806e10:	dc400d15 	stw	r17,52(sp)
  806e14:	1441ca16 	blt	r2,r17,807540 <___vfprintf_internal_r+0xe5c>
  806e18:	a8c00204 	addi	r3,r21,8
  806e1c:	d9014917 	ldw	r4,1316(sp)
  806e20:	00800044 	movi	r2,1
  806e24:	94800044 	addi	r18,r18,1
  806e28:	8c400044 	addi	r17,r17,1
  806e2c:	18800115 	stw	r2,4(r3)
  806e30:	008001c4 	movi	r2,7
  806e34:	19000015 	stw	r4,0(r3)
  806e38:	dc800e15 	stw	r18,56(sp)
  806e3c:	dc400d15 	stw	r17,52(sp)
  806e40:	1441b616 	blt	r2,r17,80751c <___vfprintf_internal_r+0xe38>
  806e44:	1cc00204 	addi	r19,r3,8
  806e48:	d9014217 	ldw	r4,1288(sp)
  806e4c:	d9414317 	ldw	r5,1292(sp)
  806e50:	000d883a 	mov	r6,zero
  806e54:	000f883a 	mov	r7,zero
  806e58:	080f20c0 	call	80f20c <__nedf2>
  806e5c:	10017426 	beq	r2,zero,807430 <___vfprintf_internal_r+0xd4c>
  806e60:	d9414717 	ldw	r5,1308(sp)
  806e64:	d9814117 	ldw	r6,1284(sp)
  806e68:	8c400044 	addi	r17,r17,1
  806e6c:	2c85883a 	add	r2,r5,r18
  806e70:	14bfffc4 	addi	r18,r2,-1
  806e74:	28bfffc4 	addi	r2,r5,-1
  806e78:	30c00044 	addi	r3,r6,1
  806e7c:	98800115 	stw	r2,4(r19)
  806e80:	008001c4 	movi	r2,7
  806e84:	98c00015 	stw	r3,0(r19)
  806e88:	dc800e15 	stw	r18,56(sp)
  806e8c:	dc400d15 	stw	r17,52(sp)
  806e90:	14418e16 	blt	r2,r17,8074cc <___vfprintf_internal_r+0xde8>
  806e94:	9cc00204 	addi	r19,r19,8
  806e98:	d9414817 	ldw	r5,1312(sp)
  806e9c:	d8800804 	addi	r2,sp,32
  806ea0:	8c400044 	addi	r17,r17,1
  806ea4:	9165883a 	add	r18,r18,r5
  806ea8:	98800015 	stw	r2,0(r19)
  806eac:	008001c4 	movi	r2,7
  806eb0:	99400115 	stw	r5,4(r19)
  806eb4:	dc800e15 	stw	r18,56(sp)
  806eb8:	dc400d15 	stw	r17,52(sp)
  806ebc:	1440ed16 	blt	r2,r17,807274 <___vfprintf_internal_r+0xb90>
  806ec0:	98c00204 	addi	r3,r19,8
  806ec4:	003f8506 	br	806cdc <___vfprintf_internal_r+0x5f8>
  806ec8:	d9814a17 	ldw	r6,1320(sp)
  806ecc:	d8814517 	ldw	r2,1300(sp)
  806ed0:	30a1c83a 	sub	r16,r6,r2
  806ed4:	043f4b0e 	bge	zero,r16,806c04 <___vfprintf_internal_r+0x520>
  806ed8:	00800404 	movi	r2,16
  806edc:	14043a0e 	bge	r2,r16,807fc8 <___vfprintf_internal_r+0x18e4>
  806ee0:	1027883a 	mov	r19,r2
  806ee4:	070020b4 	movhi	fp,130
  806ee8:	e720cd84 	addi	fp,fp,-31946
  806eec:	050001c4 	movi	r20,7
  806ef0:	00000306 	br	806f00 <___vfprintf_internal_r+0x81c>
  806ef4:	843ffc04 	addi	r16,r16,-16
  806ef8:	ad400204 	addi	r21,r21,8
  806efc:	9c00130e 	bge	r19,r16,806f4c <___vfprintf_internal_r+0x868>
  806f00:	94800404 	addi	r18,r18,16
  806f04:	8c400044 	addi	r17,r17,1
  806f08:	af000015 	stw	fp,0(r21)
  806f0c:	acc00115 	stw	r19,4(r21)
  806f10:	dc800e15 	stw	r18,56(sp)
  806f14:	dc400d15 	stw	r17,52(sp)
  806f18:	a47ff60e 	bge	r20,r17,806ef4 <___vfprintf_internal_r+0x810>
  806f1c:	d9014f17 	ldw	r4,1340(sp)
  806f20:	b00b883a 	mov	r5,r22
  806f24:	d9800c04 	addi	r6,sp,48
  806f28:	d9c15115 	stw	r7,1348(sp)
  806f2c:	080668c0 	call	80668c <__sprint_r>
  806f30:	d9c15117 	ldw	r7,1348(sp)
  806f34:	103fa31e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  806f38:	843ffc04 	addi	r16,r16,-16
  806f3c:	dc800e17 	ldw	r18,56(sp)
  806f40:	dc400d17 	ldw	r17,52(sp)
  806f44:	dd401904 	addi	r21,sp,100
  806f48:	9c3fed16 	blt	r19,r16,806f00 <___vfprintf_internal_r+0x81c>
  806f4c:	9425883a 	add	r18,r18,r16
  806f50:	8c400044 	addi	r17,r17,1
  806f54:	008001c4 	movi	r2,7
  806f58:	af000015 	stw	fp,0(r21)
  806f5c:	ac000115 	stw	r16,4(r21)
  806f60:	dc800e15 	stw	r18,56(sp)
  806f64:	dc400d15 	stw	r17,52(sp)
  806f68:	14416116 	blt	r2,r17,8074f0 <___vfprintf_internal_r+0xe0c>
  806f6c:	ad400204 	addi	r21,r21,8
  806f70:	003f2406 	br	806c04 <___vfprintf_internal_r+0x520>
  806f74:	d9014f17 	ldw	r4,1340(sp)
  806f78:	080a1980 	call	80a198 <__sinit>
  806f7c:	d9c15117 	ldw	r7,1348(sp)
  806f80:	003def06 	br	806740 <___vfprintf_internal_r+0x5c>
  806f84:	d9014f17 	ldw	r4,1340(sp)
  806f88:	b00b883a 	mov	r5,r22
  806f8c:	d9c15115 	stw	r7,1348(sp)
  806f90:	08085cc0 	call	8085cc <__swsetup_r>
  806f94:	d9c15117 	ldw	r7,1348(sp)
  806f98:	103dee26 	beq	r2,zero,806754 <___vfprintf_internal_r+0x70>
  806f9c:	003f8c06 	br	806dd0 <___vfprintf_internal_r+0x6ec>
  806fa0:	d9014217 	ldw	r4,1288(sp)
  806fa4:	d9414317 	ldw	r5,1292(sp)
  806fa8:	000d883a 	mov	r6,zero
  806fac:	000f883a 	mov	r7,zero
  806fb0:	080f1840 	call	80f184 <__eqdf2>
  806fb4:	1000f21e 	bne	r2,zero,807380 <___vfprintf_internal_r+0xc9c>
  806fb8:	008020b4 	movhi	r2,130
  806fbc:	10a06f04 	addi	r2,r2,-32324
  806fc0:	94800044 	addi	r18,r18,1
  806fc4:	8c400044 	addi	r17,r17,1
  806fc8:	a8800015 	stw	r2,0(r21)
  806fcc:	00c00044 	movi	r3,1
  806fd0:	008001c4 	movi	r2,7
  806fd4:	a8c00115 	stw	r3,4(r21)
  806fd8:	dc800e15 	stw	r18,56(sp)
  806fdc:	dc400d15 	stw	r17,52(sp)
  806fe0:	14430016 	blt	r2,r17,807be4 <___vfprintf_internal_r+0x1500>
  806fe4:	a8c00204 	addi	r3,r21,8
  806fe8:	d8800517 	ldw	r2,20(sp)
  806fec:	d9014717 	ldw	r4,1308(sp)
  806ff0:	11015c0e 	bge	r2,r4,807564 <___vfprintf_internal_r+0xe80>
  806ff4:	dc400d17 	ldw	r17,52(sp)
  806ff8:	d9814917 	ldw	r6,1316(sp)
  806ffc:	00800044 	movi	r2,1
  807000:	94800044 	addi	r18,r18,1
  807004:	8c400044 	addi	r17,r17,1
  807008:	18800115 	stw	r2,4(r3)
  80700c:	008001c4 	movi	r2,7
  807010:	19800015 	stw	r6,0(r3)
  807014:	dc800e15 	stw	r18,56(sp)
  807018:	dc400d15 	stw	r17,52(sp)
  80701c:	14431616 	blt	r2,r17,807c78 <___vfprintf_internal_r+0x1594>
  807020:	18c00204 	addi	r3,r3,8
  807024:	d8814717 	ldw	r2,1308(sp)
  807028:	143fffc4 	addi	r16,r2,-1
  80702c:	043f2b0e 	bge	zero,r16,806cdc <___vfprintf_internal_r+0x5f8>
  807030:	00800404 	movi	r2,16
  807034:	1402a80e 	bge	r2,r16,807ad8 <___vfprintf_internal_r+0x13f4>
  807038:	dc400d17 	ldw	r17,52(sp)
  80703c:	1027883a 	mov	r19,r2
  807040:	070020b4 	movhi	fp,130
  807044:	e720cd84 	addi	fp,fp,-31946
  807048:	050001c4 	movi	r20,7
  80704c:	00000306 	br	80705c <___vfprintf_internal_r+0x978>
  807050:	18c00204 	addi	r3,r3,8
  807054:	843ffc04 	addi	r16,r16,-16
  807058:	9c02a20e 	bge	r19,r16,807ae4 <___vfprintf_internal_r+0x1400>
  80705c:	94800404 	addi	r18,r18,16
  807060:	8c400044 	addi	r17,r17,1
  807064:	1f000015 	stw	fp,0(r3)
  807068:	1cc00115 	stw	r19,4(r3)
  80706c:	dc800e15 	stw	r18,56(sp)
  807070:	dc400d15 	stw	r17,52(sp)
  807074:	a47ff60e 	bge	r20,r17,807050 <___vfprintf_internal_r+0x96c>
  807078:	d9014f17 	ldw	r4,1340(sp)
  80707c:	b00b883a 	mov	r5,r22
  807080:	d9800c04 	addi	r6,sp,48
  807084:	080668c0 	call	80668c <__sprint_r>
  807088:	103f4e1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  80708c:	dc800e17 	ldw	r18,56(sp)
  807090:	dc400d17 	ldw	r17,52(sp)
  807094:	d8c01904 	addi	r3,sp,100
  807098:	003fee06 	br	807054 <___vfprintf_internal_r+0x970>
  80709c:	d8802c0b 	ldhu	r2,176(sp)
  8070a0:	00ffffc4 	movi	r3,-1
  8070a4:	d8c14b15 	stw	r3,1324(sp)
  8070a8:	1080100c 	andi	r2,r2,64
  8070ac:	103dcc1e 	bne	r2,zero,8067e0 <___vfprintf_internal_r+0xfc>
  8070b0:	003dce06 	br	8067ec <___vfprintf_internal_r+0x108>
  8070b4:	d9014f17 	ldw	r4,1340(sp)
  8070b8:	b00b883a 	mov	r5,r22
  8070bc:	d9800c04 	addi	r6,sp,48
  8070c0:	080668c0 	call	80668c <__sprint_r>
  8070c4:	103f3f1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  8070c8:	dc800e17 	ldw	r18,56(sp)
  8070cc:	003f2e06 	br	806d88 <___vfprintf_internal_r+0x6a4>
  8070d0:	d9414c17 	ldw	r5,1328(sp)
  8070d4:	29400414 	ori	r5,r5,16
  8070d8:	d9414c15 	stw	r5,1328(sp)
  8070dc:	d9814c17 	ldw	r6,1328(sp)
  8070e0:	3080080c 	andi	r2,r6,32
  8070e4:	10014f1e 	bne	r2,zero,807624 <___vfprintf_internal_r+0xf40>
  8070e8:	d8c14c17 	ldw	r3,1328(sp)
  8070ec:	1880040c 	andi	r2,r3,16
  8070f0:	1002f01e 	bne	r2,zero,807cb4 <___vfprintf_internal_r+0x15d0>
  8070f4:	d9014c17 	ldw	r4,1328(sp)
  8070f8:	2080100c 	andi	r2,r4,64
  8070fc:	1002ed26 	beq	r2,zero,807cb4 <___vfprintf_internal_r+0x15d0>
  807100:	3880000f 	ldh	r2,0(r7)
  807104:	39c00104 	addi	r7,r7,4
  807108:	d9c14015 	stw	r7,1280(sp)
  80710c:	1023d7fa 	srai	r17,r2,31
  807110:	1021883a 	mov	r16,r2
  807114:	88037816 	blt	r17,zero,807ef8 <___vfprintf_internal_r+0x1814>
  807118:	01000044 	movi	r4,1
  80711c:	98000416 	blt	r19,zero,807130 <___vfprintf_internal_r+0xa4c>
  807120:	d8c14c17 	ldw	r3,1328(sp)
  807124:	00bfdfc4 	movi	r2,-129
  807128:	1886703a 	and	r3,r3,r2
  80712c:	d8c14c15 	stw	r3,1328(sp)
  807130:	8444b03a 	or	r2,r16,r17
  807134:	10022c1e 	bne	r2,zero,8079e8 <___vfprintf_internal_r+0x1304>
  807138:	98022b1e 	bne	r19,zero,8079e8 <___vfprintf_internal_r+0x1304>
  80713c:	20803fcc 	andi	r2,r4,255
  807140:	1002a126 	beq	r2,zero,807bc8 <___vfprintf_internal_r+0x14e4>
  807144:	d8c01904 	addi	r3,sp,100
  807148:	dd000f04 	addi	r20,sp,60
  80714c:	d8c14115 	stw	r3,1284(sp)
  807150:	d8c14117 	ldw	r3,1284(sp)
  807154:	dcc14515 	stw	r19,1300(sp)
  807158:	a0c5c83a 	sub	r2,r20,r3
  80715c:	11c00a04 	addi	r7,r2,40
  807160:	99c0010e 	bge	r19,r7,807168 <___vfprintf_internal_r+0xa84>
  807164:	d9c14515 	stw	r7,1300(sp)
  807168:	dcc14615 	stw	r19,1304(sp)
  80716c:	d8800407 	ldb	r2,16(sp)
  807170:	103e4c26 	beq	r2,zero,806aa4 <___vfprintf_internal_r+0x3c0>
  807174:	d8814517 	ldw	r2,1300(sp)
  807178:	10800044 	addi	r2,r2,1
  80717c:	d8814515 	stw	r2,1300(sp)
  807180:	003e4806 	br	806aa4 <___vfprintf_internal_r+0x3c0>
  807184:	d9814c17 	ldw	r6,1328(sp)
  807188:	31800414 	ori	r6,r6,16
  80718c:	d9814c15 	stw	r6,1328(sp)
  807190:	d8c14c17 	ldw	r3,1328(sp)
  807194:	1880080c 	andi	r2,r3,32
  807198:	1001271e 	bne	r2,zero,807638 <___vfprintf_internal_r+0xf54>
  80719c:	d9414c17 	ldw	r5,1328(sp)
  8071a0:	2880040c 	andi	r2,r5,16
  8071a4:	1002bc1e 	bne	r2,zero,807c98 <___vfprintf_internal_r+0x15b4>
  8071a8:	d9814c17 	ldw	r6,1328(sp)
  8071ac:	3080100c 	andi	r2,r6,64
  8071b0:	1002b926 	beq	r2,zero,807c98 <___vfprintf_internal_r+0x15b4>
  8071b4:	3c00000b 	ldhu	r16,0(r7)
  8071b8:	0009883a 	mov	r4,zero
  8071bc:	39c00104 	addi	r7,r7,4
  8071c0:	0023883a 	mov	r17,zero
  8071c4:	d9c14015 	stw	r7,1280(sp)
  8071c8:	d8000405 	stb	zero,16(sp)
  8071cc:	003fd306 	br	80711c <___vfprintf_internal_r+0xa38>
  8071d0:	d9014c17 	ldw	r4,1328(sp)
  8071d4:	21000414 	ori	r4,r4,16
  8071d8:	d9014c15 	stw	r4,1328(sp)
  8071dc:	d9414c17 	ldw	r5,1328(sp)
  8071e0:	2880080c 	andi	r2,r5,32
  8071e4:	1001081e 	bne	r2,zero,807608 <___vfprintf_internal_r+0xf24>
  8071e8:	d8c14c17 	ldw	r3,1328(sp)
  8071ec:	1880040c 	andi	r2,r3,16
  8071f0:	1002b61e 	bne	r2,zero,807ccc <___vfprintf_internal_r+0x15e8>
  8071f4:	d9014c17 	ldw	r4,1328(sp)
  8071f8:	2080100c 	andi	r2,r4,64
  8071fc:	1002b326 	beq	r2,zero,807ccc <___vfprintf_internal_r+0x15e8>
  807200:	3c00000b 	ldhu	r16,0(r7)
  807204:	01000044 	movi	r4,1
  807208:	39c00104 	addi	r7,r7,4
  80720c:	0023883a 	mov	r17,zero
  807210:	d9c14015 	stw	r7,1280(sp)
  807214:	d8000405 	stb	zero,16(sp)
  807218:	003fc006 	br	80711c <___vfprintf_internal_r+0xa38>
  80721c:	d9014f17 	ldw	r4,1340(sp)
  807220:	b00b883a 	mov	r5,r22
  807224:	d9800c04 	addi	r6,sp,48
  807228:	080668c0 	call	80668c <__sprint_r>
  80722c:	103ee51e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807230:	dc800e17 	ldw	r18,56(sp)
  807234:	d8c01904 	addi	r3,sp,100
  807238:	d9814c17 	ldw	r6,1328(sp)
  80723c:	3080004c 	andi	r2,r6,1
  807240:	1005003a 	cmpeq	r2,r2,zero
  807244:	103ea51e 	bne	r2,zero,806cdc <___vfprintf_internal_r+0x5f8>
  807248:	00800044 	movi	r2,1
  80724c:	dc400d17 	ldw	r17,52(sp)
  807250:	18800115 	stw	r2,4(r3)
  807254:	d8814917 	ldw	r2,1316(sp)
  807258:	94800044 	addi	r18,r18,1
  80725c:	8c400044 	addi	r17,r17,1
  807260:	18800015 	stw	r2,0(r3)
  807264:	008001c4 	movi	r2,7
  807268:	dc800e15 	stw	r18,56(sp)
  80726c:	dc400d15 	stw	r17,52(sp)
  807270:	1442240e 	bge	r2,r17,807b04 <___vfprintf_internal_r+0x1420>
  807274:	d9014f17 	ldw	r4,1340(sp)
  807278:	b00b883a 	mov	r5,r22
  80727c:	d9800c04 	addi	r6,sp,48
  807280:	080668c0 	call	80668c <__sprint_r>
  807284:	103ecf1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807288:	dc800e17 	ldw	r18,56(sp)
  80728c:	d8c01904 	addi	r3,sp,100
  807290:	003e9206 	br	806cdc <___vfprintf_internal_r+0x5f8>
  807294:	d9014f17 	ldw	r4,1340(sp)
  807298:	b00b883a 	mov	r5,r22
  80729c:	d9800c04 	addi	r6,sp,48
  8072a0:	080668c0 	call	80668c <__sprint_r>
  8072a4:	103ec026 	beq	r2,zero,806da8 <___vfprintf_internal_r+0x6c4>
  8072a8:	003ec606 	br	806dc4 <___vfprintf_internal_r+0x6e0>
  8072ac:	d9014f17 	ldw	r4,1340(sp)
  8072b0:	b00b883a 	mov	r5,r22
  8072b4:	d9800c04 	addi	r6,sp,48
  8072b8:	d9c15115 	stw	r7,1348(sp)
  8072bc:	080668c0 	call	80668c <__sprint_r>
  8072c0:	d9c15117 	ldw	r7,1348(sp)
  8072c4:	103ebf1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  8072c8:	dc800e17 	ldw	r18,56(sp)
  8072cc:	dc400d17 	ldw	r17,52(sp)
  8072d0:	dd401904 	addi	r21,sp,100
  8072d4:	003e7406 	br	806ca8 <___vfprintf_internal_r+0x5c4>
  8072d8:	d9014f17 	ldw	r4,1340(sp)
  8072dc:	b00b883a 	mov	r5,r22
  8072e0:	d9800c04 	addi	r6,sp,48
  8072e4:	d9c15115 	stw	r7,1348(sp)
  8072e8:	080668c0 	call	80668c <__sprint_r>
  8072ec:	d9c15117 	ldw	r7,1348(sp)
  8072f0:	103eb41e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  8072f4:	dd401904 	addi	r21,sp,100
  8072f8:	003d6d06 	br	8068b0 <___vfprintf_internal_r+0x1cc>
  8072fc:	d9014f17 	ldw	r4,1340(sp)
  807300:	b00b883a 	mov	r5,r22
  807304:	d9800c04 	addi	r6,sp,48
  807308:	d9c15115 	stw	r7,1348(sp)
  80730c:	080668c0 	call	80668c <__sprint_r>
  807310:	d9c15117 	ldw	r7,1348(sp)
  807314:	103eab1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807318:	dc800e17 	ldw	r18,56(sp)
  80731c:	dc400d17 	ldw	r17,52(sp)
  807320:	dd401904 	addi	r21,sp,100
  807324:	003e3406 	br	806bf8 <___vfprintf_internal_r+0x514>
  807328:	d9014f17 	ldw	r4,1340(sp)
  80732c:	b00b883a 	mov	r5,r22
  807330:	d9800c04 	addi	r6,sp,48
  807334:	d9c15115 	stw	r7,1348(sp)
  807338:	080668c0 	call	80668c <__sprint_r>
  80733c:	d9c15117 	ldw	r7,1348(sp)
  807340:	103ea01e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807344:	dc800e17 	ldw	r18,56(sp)
  807348:	dc400d17 	ldw	r17,52(sp)
  80734c:	dd401904 	addi	r21,sp,100
  807350:	003e1c06 	br	806bc4 <___vfprintf_internal_r+0x4e0>
  807354:	d9014f17 	ldw	r4,1340(sp)
  807358:	b00b883a 	mov	r5,r22
  80735c:	d9800c04 	addi	r6,sp,48
  807360:	d9c15115 	stw	r7,1348(sp)
  807364:	080668c0 	call	80668c <__sprint_r>
  807368:	d9c15117 	ldw	r7,1348(sp)
  80736c:	103e951e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807370:	dc800e17 	ldw	r18,56(sp)
  807374:	dc400d17 	ldw	r17,52(sp)
  807378:	dd401904 	addi	r21,sp,100
  80737c:	003e0406 	br	806b90 <___vfprintf_internal_r+0x4ac>
  807380:	d9000517 	ldw	r4,20(sp)
  807384:	0102580e 	bge	zero,r4,807ce8 <___vfprintf_internal_r+0x1604>
  807388:	d9814717 	ldw	r6,1308(sp)
  80738c:	21807a16 	blt	r4,r6,807578 <___vfprintf_internal_r+0xe94>
  807390:	d8814117 	ldw	r2,1284(sp)
  807394:	91a5883a 	add	r18,r18,r6
  807398:	8c400044 	addi	r17,r17,1
  80739c:	a8800015 	stw	r2,0(r21)
  8073a0:	008001c4 	movi	r2,7
  8073a4:	a9800115 	stw	r6,4(r21)
  8073a8:	dc800e15 	stw	r18,56(sp)
  8073ac:	dc400d15 	stw	r17,52(sp)
  8073b0:	1442fc16 	blt	r2,r17,807fa4 <___vfprintf_internal_r+0x18c0>
  8073b4:	a8c00204 	addi	r3,r21,8
  8073b8:	d9414717 	ldw	r5,1308(sp)
  8073bc:	2161c83a 	sub	r16,r4,r5
  8073c0:	043f9d0e 	bge	zero,r16,807238 <___vfprintf_internal_r+0xb54>
  8073c4:	00800404 	movi	r2,16
  8073c8:	1402190e 	bge	r2,r16,807c30 <___vfprintf_internal_r+0x154c>
  8073cc:	dc400d17 	ldw	r17,52(sp)
  8073d0:	1027883a 	mov	r19,r2
  8073d4:	070020b4 	movhi	fp,130
  8073d8:	e720cd84 	addi	fp,fp,-31946
  8073dc:	050001c4 	movi	r20,7
  8073e0:	00000306 	br	8073f0 <___vfprintf_internal_r+0xd0c>
  8073e4:	18c00204 	addi	r3,r3,8
  8073e8:	843ffc04 	addi	r16,r16,-16
  8073ec:	9c02130e 	bge	r19,r16,807c3c <___vfprintf_internal_r+0x1558>
  8073f0:	94800404 	addi	r18,r18,16
  8073f4:	8c400044 	addi	r17,r17,1
  8073f8:	1f000015 	stw	fp,0(r3)
  8073fc:	1cc00115 	stw	r19,4(r3)
  807400:	dc800e15 	stw	r18,56(sp)
  807404:	dc400d15 	stw	r17,52(sp)
  807408:	a47ff60e 	bge	r20,r17,8073e4 <___vfprintf_internal_r+0xd00>
  80740c:	d9014f17 	ldw	r4,1340(sp)
  807410:	b00b883a 	mov	r5,r22
  807414:	d9800c04 	addi	r6,sp,48
  807418:	080668c0 	call	80668c <__sprint_r>
  80741c:	103e691e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807420:	dc800e17 	ldw	r18,56(sp)
  807424:	dc400d17 	ldw	r17,52(sp)
  807428:	d8c01904 	addi	r3,sp,100
  80742c:	003fee06 	br	8073e8 <___vfprintf_internal_r+0xd04>
  807430:	d8814717 	ldw	r2,1308(sp)
  807434:	143fffc4 	addi	r16,r2,-1
  807438:	043e970e 	bge	zero,r16,806e98 <___vfprintf_internal_r+0x7b4>
  80743c:	00800404 	movi	r2,16
  807440:	1400180e 	bge	r2,r16,8074a4 <___vfprintf_internal_r+0xdc0>
  807444:	1029883a 	mov	r20,r2
  807448:	070020b4 	movhi	fp,130
  80744c:	e720cd84 	addi	fp,fp,-31946
  807450:	054001c4 	movi	r21,7
  807454:	00000306 	br	807464 <___vfprintf_internal_r+0xd80>
  807458:	9cc00204 	addi	r19,r19,8
  80745c:	843ffc04 	addi	r16,r16,-16
  807460:	a400120e 	bge	r20,r16,8074ac <___vfprintf_internal_r+0xdc8>
  807464:	94800404 	addi	r18,r18,16
  807468:	8c400044 	addi	r17,r17,1
  80746c:	9f000015 	stw	fp,0(r19)
  807470:	9d000115 	stw	r20,4(r19)
  807474:	dc800e15 	stw	r18,56(sp)
  807478:	dc400d15 	stw	r17,52(sp)
  80747c:	ac7ff60e 	bge	r21,r17,807458 <___vfprintf_internal_r+0xd74>
  807480:	d9014f17 	ldw	r4,1340(sp)
  807484:	b00b883a 	mov	r5,r22
  807488:	d9800c04 	addi	r6,sp,48
  80748c:	080668c0 	call	80668c <__sprint_r>
  807490:	103e4c1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807494:	dc800e17 	ldw	r18,56(sp)
  807498:	dc400d17 	ldw	r17,52(sp)
  80749c:	dcc01904 	addi	r19,sp,100
  8074a0:	003fee06 	br	80745c <___vfprintf_internal_r+0xd78>
  8074a4:	070020b4 	movhi	fp,130
  8074a8:	e720cd84 	addi	fp,fp,-31946
  8074ac:	9425883a 	add	r18,r18,r16
  8074b0:	8c400044 	addi	r17,r17,1
  8074b4:	008001c4 	movi	r2,7
  8074b8:	9f000015 	stw	fp,0(r19)
  8074bc:	9c000115 	stw	r16,4(r19)
  8074c0:	dc800e15 	stw	r18,56(sp)
  8074c4:	dc400d15 	stw	r17,52(sp)
  8074c8:	147e720e 	bge	r2,r17,806e94 <___vfprintf_internal_r+0x7b0>
  8074cc:	d9014f17 	ldw	r4,1340(sp)
  8074d0:	b00b883a 	mov	r5,r22
  8074d4:	d9800c04 	addi	r6,sp,48
  8074d8:	080668c0 	call	80668c <__sprint_r>
  8074dc:	103e391e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  8074e0:	dc800e17 	ldw	r18,56(sp)
  8074e4:	dc400d17 	ldw	r17,52(sp)
  8074e8:	dcc01904 	addi	r19,sp,100
  8074ec:	003e6a06 	br	806e98 <___vfprintf_internal_r+0x7b4>
  8074f0:	d9014f17 	ldw	r4,1340(sp)
  8074f4:	b00b883a 	mov	r5,r22
  8074f8:	d9800c04 	addi	r6,sp,48
  8074fc:	d9c15115 	stw	r7,1348(sp)
  807500:	080668c0 	call	80668c <__sprint_r>
  807504:	d9c15117 	ldw	r7,1348(sp)
  807508:	103e2e1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  80750c:	dc800e17 	ldw	r18,56(sp)
  807510:	dc400d17 	ldw	r17,52(sp)
  807514:	dd401904 	addi	r21,sp,100
  807518:	003dba06 	br	806c04 <___vfprintf_internal_r+0x520>
  80751c:	d9014f17 	ldw	r4,1340(sp)
  807520:	b00b883a 	mov	r5,r22
  807524:	d9800c04 	addi	r6,sp,48
  807528:	080668c0 	call	80668c <__sprint_r>
  80752c:	103e251e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807530:	dc800e17 	ldw	r18,56(sp)
  807534:	dc400d17 	ldw	r17,52(sp)
  807538:	dcc01904 	addi	r19,sp,100
  80753c:	003e4206 	br	806e48 <___vfprintf_internal_r+0x764>
  807540:	d9014f17 	ldw	r4,1340(sp)
  807544:	b00b883a 	mov	r5,r22
  807548:	d9800c04 	addi	r6,sp,48
  80754c:	080668c0 	call	80668c <__sprint_r>
  807550:	103e1c1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807554:	dc800e17 	ldw	r18,56(sp)
  807558:	dc400d17 	ldw	r17,52(sp)
  80755c:	d8c01904 	addi	r3,sp,100
  807560:	003e2e06 	br	806e1c <___vfprintf_internal_r+0x738>
  807564:	d9414c17 	ldw	r5,1328(sp)
  807568:	2880004c 	andi	r2,r5,1
  80756c:	1005003a 	cmpeq	r2,r2,zero
  807570:	103dda1e 	bne	r2,zero,806cdc <___vfprintf_internal_r+0x5f8>
  807574:	003e9f06 	br	806ff4 <___vfprintf_internal_r+0x910>
  807578:	d8c14117 	ldw	r3,1284(sp)
  80757c:	9125883a 	add	r18,r18,r4
  807580:	8c400044 	addi	r17,r17,1
  807584:	008001c4 	movi	r2,7
  807588:	a8c00015 	stw	r3,0(r21)
  80758c:	a9000115 	stw	r4,4(r21)
  807590:	dc800e15 	stw	r18,56(sp)
  807594:	dc400d15 	stw	r17,52(sp)
  807598:	14426c16 	blt	r2,r17,807f4c <___vfprintf_internal_r+0x1868>
  80759c:	a8c00204 	addi	r3,r21,8
  8075a0:	d9414917 	ldw	r5,1316(sp)
  8075a4:	00800044 	movi	r2,1
  8075a8:	94800044 	addi	r18,r18,1
  8075ac:	8c400044 	addi	r17,r17,1
  8075b0:	18800115 	stw	r2,4(r3)
  8075b4:	008001c4 	movi	r2,7
  8075b8:	19400015 	stw	r5,0(r3)
  8075bc:	dc800e15 	stw	r18,56(sp)
  8075c0:	dc400d15 	stw	r17,52(sp)
  8075c4:	2021883a 	mov	r16,r4
  8075c8:	14425616 	blt	r2,r17,807f24 <___vfprintf_internal_r+0x1840>
  8075cc:	19400204 	addi	r5,r3,8
  8075d0:	d9814717 	ldw	r6,1308(sp)
  8075d4:	8c400044 	addi	r17,r17,1
  8075d8:	dc400d15 	stw	r17,52(sp)
  8075dc:	3107c83a 	sub	r3,r6,r4
  8075e0:	d9014117 	ldw	r4,1284(sp)
  8075e4:	90e5883a 	add	r18,r18,r3
  8075e8:	28c00115 	stw	r3,4(r5)
  8075ec:	8105883a 	add	r2,r16,r4
  8075f0:	28800015 	stw	r2,0(r5)
  8075f4:	008001c4 	movi	r2,7
  8075f8:	dc800e15 	stw	r18,56(sp)
  8075fc:	147f1d16 	blt	r2,r17,807274 <___vfprintf_internal_r+0xb90>
  807600:	28c00204 	addi	r3,r5,8
  807604:	003db506 	br	806cdc <___vfprintf_internal_r+0x5f8>
  807608:	3c000017 	ldw	r16,0(r7)
  80760c:	3c400117 	ldw	r17,4(r7)
  807610:	39800204 	addi	r6,r7,8
  807614:	01000044 	movi	r4,1
  807618:	d9814015 	stw	r6,1280(sp)
  80761c:	d8000405 	stb	zero,16(sp)
  807620:	003ebe06 	br	80711c <___vfprintf_internal_r+0xa38>
  807624:	3c000017 	ldw	r16,0(r7)
  807628:	3c400117 	ldw	r17,4(r7)
  80762c:	38800204 	addi	r2,r7,8
  807630:	d8814015 	stw	r2,1280(sp)
  807634:	003eb706 	br	807114 <___vfprintf_internal_r+0xa30>
  807638:	3c000017 	ldw	r16,0(r7)
  80763c:	3c400117 	ldw	r17,4(r7)
  807640:	39000204 	addi	r4,r7,8
  807644:	d9014015 	stw	r4,1280(sp)
  807648:	0009883a 	mov	r4,zero
  80764c:	d8000405 	stb	zero,16(sp)
  807650:	003eb206 	br	80711c <___vfprintf_internal_r+0xa38>
  807654:	38c00017 	ldw	r3,0(r7)
  807658:	39c00104 	addi	r7,r7,4
  80765c:	d8c14a15 	stw	r3,1320(sp)
  807660:	1800d70e 	bge	r3,zero,8079c0 <___vfprintf_internal_r+0x12dc>
  807664:	00c7c83a 	sub	r3,zero,r3
  807668:	d8c14a15 	stw	r3,1320(sp)
  80766c:	d9014c17 	ldw	r4,1328(sp)
  807670:	b8c00007 	ldb	r3,0(r23)
  807674:	21000114 	ori	r4,r4,4
  807678:	d9014c15 	stw	r4,1328(sp)
  80767c:	003c9806 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  807680:	d9814c17 	ldw	r6,1328(sp)
  807684:	3080080c 	andi	r2,r6,32
  807688:	1001f626 	beq	r2,zero,807e64 <___vfprintf_internal_r+0x1780>
  80768c:	d9014b17 	ldw	r4,1324(sp)
  807690:	38800017 	ldw	r2,0(r7)
  807694:	39c00104 	addi	r7,r7,4
  807698:	d9c14015 	stw	r7,1280(sp)
  80769c:	2007d7fa 	srai	r3,r4,31
  8076a0:	d9c14017 	ldw	r7,1280(sp)
  8076a4:	11000015 	stw	r4,0(r2)
  8076a8:	10c00115 	stw	r3,4(r2)
  8076ac:	003c6906 	br	806854 <___vfprintf_internal_r+0x170>
  8076b0:	b8c00007 	ldb	r3,0(r23)
  8076b4:	00801b04 	movi	r2,108
  8076b8:	18825526 	beq	r3,r2,808010 <___vfprintf_internal_r+0x192c>
  8076bc:	d9414c17 	ldw	r5,1328(sp)
  8076c0:	29400414 	ori	r5,r5,16
  8076c4:	d9414c15 	stw	r5,1328(sp)
  8076c8:	003c8506 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  8076cc:	d9814c17 	ldw	r6,1328(sp)
  8076d0:	b8c00007 	ldb	r3,0(r23)
  8076d4:	31800814 	ori	r6,r6,32
  8076d8:	d9814c15 	stw	r6,1328(sp)
  8076dc:	003c8006 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  8076e0:	d8814c17 	ldw	r2,1328(sp)
  8076e4:	3c000017 	ldw	r16,0(r7)
  8076e8:	00c01e04 	movi	r3,120
  8076ec:	10800094 	ori	r2,r2,2
  8076f0:	d8814c15 	stw	r2,1328(sp)
  8076f4:	39c00104 	addi	r7,r7,4
  8076f8:	014020b4 	movhi	r5,130
  8076fc:	2960b704 	addi	r5,r5,-32036
  807700:	00800c04 	movi	r2,48
  807704:	0023883a 	mov	r17,zero
  807708:	01000084 	movi	r4,2
  80770c:	d9c14015 	stw	r7,1280(sp)
  807710:	d8c14d15 	stw	r3,1332(sp)
  807714:	d9414415 	stw	r5,1296(sp)
  807718:	d8800445 	stb	r2,17(sp)
  80771c:	d8c00485 	stb	r3,18(sp)
  807720:	d8000405 	stb	zero,16(sp)
  807724:	003e7d06 	br	80711c <___vfprintf_internal_r+0xa38>
  807728:	d8814c17 	ldw	r2,1328(sp)
  80772c:	b8c00007 	ldb	r3,0(r23)
  807730:	10801014 	ori	r2,r2,64
  807734:	d8814c15 	stw	r2,1328(sp)
  807738:	003c6906 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  80773c:	d9414c17 	ldw	r5,1328(sp)
  807740:	2880020c 	andi	r2,r5,8
  807744:	1001e526 	beq	r2,zero,807edc <___vfprintf_internal_r+0x17f8>
  807748:	39800017 	ldw	r6,0(r7)
  80774c:	38800204 	addi	r2,r7,8
  807750:	d8814015 	stw	r2,1280(sp)
  807754:	d9814215 	stw	r6,1288(sp)
  807758:	39c00117 	ldw	r7,4(r7)
  80775c:	d9c14315 	stw	r7,1292(sp)
  807760:	d9014217 	ldw	r4,1288(sp)
  807764:	d9414317 	ldw	r5,1292(sp)
  807768:	080d1940 	call	80d194 <__isinfd>
  80776c:	10021d26 	beq	r2,zero,807fe4 <___vfprintf_internal_r+0x1900>
  807770:	d9014217 	ldw	r4,1288(sp)
  807774:	d9414317 	ldw	r5,1292(sp)
  807778:	000d883a 	mov	r6,zero
  80777c:	000f883a 	mov	r7,zero
  807780:	080f3a40 	call	80f3a4 <__ltdf2>
  807784:	1002d016 	blt	r2,zero,8082c8 <___vfprintf_internal_r+0x1be4>
  807788:	d9414d17 	ldw	r5,1332(sp)
  80778c:	008011c4 	movi	r2,71
  807790:	11421016 	blt	r2,r5,807fd4 <___vfprintf_internal_r+0x18f0>
  807794:	018020b4 	movhi	r6,130
  807798:	31a0bc04 	addi	r6,r6,-32016
  80779c:	d9814115 	stw	r6,1284(sp)
  8077a0:	d9014c17 	ldw	r4,1328(sp)
  8077a4:	00c000c4 	movi	r3,3
  8077a8:	00bfdfc4 	movi	r2,-129
  8077ac:	2088703a 	and	r4,r4,r2
  8077b0:	180f883a 	mov	r7,r3
  8077b4:	d8c14515 	stw	r3,1300(sp)
  8077b8:	d9014c15 	stw	r4,1328(sp)
  8077bc:	d8014615 	stw	zero,1304(sp)
  8077c0:	003e6a06 	br	80716c <___vfprintf_internal_r+0xa88>
  8077c4:	38800017 	ldw	r2,0(r7)
  8077c8:	00c00044 	movi	r3,1
  8077cc:	39c00104 	addi	r7,r7,4
  8077d0:	d9c14015 	stw	r7,1280(sp)
  8077d4:	d9000f04 	addi	r4,sp,60
  8077d8:	180f883a 	mov	r7,r3
  8077dc:	d8c14515 	stw	r3,1300(sp)
  8077e0:	d9014115 	stw	r4,1284(sp)
  8077e4:	d8800f05 	stb	r2,60(sp)
  8077e8:	d8000405 	stb	zero,16(sp)
  8077ec:	003cac06 	br	806aa0 <___vfprintf_internal_r+0x3bc>
  8077f0:	014020b4 	movhi	r5,130
  8077f4:	2960c204 	addi	r5,r5,-31992
  8077f8:	d9414415 	stw	r5,1296(sp)
  8077fc:	d9814c17 	ldw	r6,1328(sp)
  807800:	3080080c 	andi	r2,r6,32
  807804:	1000ff26 	beq	r2,zero,807c04 <___vfprintf_internal_r+0x1520>
  807808:	3c000017 	ldw	r16,0(r7)
  80780c:	3c400117 	ldw	r17,4(r7)
  807810:	38800204 	addi	r2,r7,8
  807814:	d8814015 	stw	r2,1280(sp)
  807818:	d9414c17 	ldw	r5,1328(sp)
  80781c:	2880004c 	andi	r2,r5,1
  807820:	1005003a 	cmpeq	r2,r2,zero
  807824:	1000b91e 	bne	r2,zero,807b0c <___vfprintf_internal_r+0x1428>
  807828:	8444b03a 	or	r2,r16,r17
  80782c:	1000b726 	beq	r2,zero,807b0c <___vfprintf_internal_r+0x1428>
  807830:	d9814d17 	ldw	r6,1332(sp)
  807834:	29400094 	ori	r5,r5,2
  807838:	00800c04 	movi	r2,48
  80783c:	01000084 	movi	r4,2
  807840:	d9414c15 	stw	r5,1328(sp)
  807844:	d8800445 	stb	r2,17(sp)
  807848:	d9800485 	stb	r6,18(sp)
  80784c:	d8000405 	stb	zero,16(sp)
  807850:	003e3206 	br	80711c <___vfprintf_internal_r+0xa38>
  807854:	018020b4 	movhi	r6,130
  807858:	31a0b704 	addi	r6,r6,-32036
  80785c:	d9814415 	stw	r6,1296(sp)
  807860:	003fe606 	br	8077fc <___vfprintf_internal_r+0x1118>
  807864:	00800ac4 	movi	r2,43
  807868:	d8800405 	stb	r2,16(sp)
  80786c:	b8c00007 	ldb	r3,0(r23)
  807870:	003c1b06 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  807874:	d8814c17 	ldw	r2,1328(sp)
  807878:	b8c00007 	ldb	r3,0(r23)
  80787c:	10800054 	ori	r2,r2,1
  807880:	d8814c15 	stw	r2,1328(sp)
  807884:	003c1606 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  807888:	d8800407 	ldb	r2,16(sp)
  80788c:	10004c1e 	bne	r2,zero,8079c0 <___vfprintf_internal_r+0x12dc>
  807890:	00800804 	movi	r2,32
  807894:	d8800405 	stb	r2,16(sp)
  807898:	b8c00007 	ldb	r3,0(r23)
  80789c:	003c1006 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  8078a0:	d9814c17 	ldw	r6,1328(sp)
  8078a4:	b8c00007 	ldb	r3,0(r23)
  8078a8:	31800214 	ori	r6,r6,8
  8078ac:	d9814c15 	stw	r6,1328(sp)
  8078b0:	003c0b06 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  8078b4:	0009883a 	mov	r4,zero
  8078b8:	04000244 	movi	r16,9
  8078bc:	01400284 	movi	r5,10
  8078c0:	d9c15115 	stw	r7,1348(sp)
  8078c4:	08064840 	call	806484 <__mulsi3>
  8078c8:	b9000007 	ldb	r4,0(r23)
  8078cc:	d8c14d17 	ldw	r3,1332(sp)
  8078d0:	bdc00044 	addi	r23,r23,1
  8078d4:	d9014d15 	stw	r4,1332(sp)
  8078d8:	d9414d17 	ldw	r5,1332(sp)
  8078dc:	1885883a 	add	r2,r3,r2
  8078e0:	113ff404 	addi	r4,r2,-48
  8078e4:	28bff404 	addi	r2,r5,-48
  8078e8:	d9c15117 	ldw	r7,1348(sp)
  8078ec:	80bff32e 	bgeu	r16,r2,8078bc <___vfprintf_internal_r+0x11d8>
  8078f0:	d9014a15 	stw	r4,1320(sp)
  8078f4:	003bfc06 	br	8068e8 <___vfprintf_internal_r+0x204>
  8078f8:	d8814c17 	ldw	r2,1328(sp)
  8078fc:	b8c00007 	ldb	r3,0(r23)
  807900:	10802014 	ori	r2,r2,128
  807904:	d8814c15 	stw	r2,1328(sp)
  807908:	003bf506 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  80790c:	b8c00007 	ldb	r3,0(r23)
  807910:	00800a84 	movi	r2,42
  807914:	bdc00044 	addi	r23,r23,1
  807918:	18831826 	beq	r3,r2,80857c <___vfprintf_internal_r+0x1e98>
  80791c:	d8c14d15 	stw	r3,1332(sp)
  807920:	18bff404 	addi	r2,r3,-48
  807924:	00c00244 	movi	r3,9
  807928:	18827b36 	bltu	r3,r2,808318 <___vfprintf_internal_r+0x1c34>
  80792c:	1821883a 	mov	r16,r3
  807930:	0009883a 	mov	r4,zero
  807934:	01400284 	movi	r5,10
  807938:	d9c15115 	stw	r7,1348(sp)
  80793c:	08064840 	call	806484 <__mulsi3>
  807940:	d9414d17 	ldw	r5,1332(sp)
  807944:	b9800007 	ldb	r6,0(r23)
  807948:	d9c15117 	ldw	r7,1348(sp)
  80794c:	1145883a 	add	r2,r2,r5
  807950:	113ff404 	addi	r4,r2,-48
  807954:	30bff404 	addi	r2,r6,-48
  807958:	d9814d15 	stw	r6,1332(sp)
  80795c:	bdc00044 	addi	r23,r23,1
  807960:	80bff42e 	bgeu	r16,r2,807934 <___vfprintf_internal_r+0x1250>
  807964:	2027883a 	mov	r19,r4
  807968:	203bdf0e 	bge	r4,zero,8068e8 <___vfprintf_internal_r+0x204>
  80796c:	04ffffc4 	movi	r19,-1
  807970:	003bdd06 	br	8068e8 <___vfprintf_internal_r+0x204>
  807974:	d8000405 	stb	zero,16(sp)
  807978:	39800017 	ldw	r6,0(r7)
  80797c:	39c00104 	addi	r7,r7,4
  807980:	d9c14015 	stw	r7,1280(sp)
  807984:	d9814115 	stw	r6,1284(sp)
  807988:	3001c926 	beq	r6,zero,8080b0 <___vfprintf_internal_r+0x19cc>
  80798c:	98000e16 	blt	r19,zero,8079c8 <___vfprintf_internal_r+0x12e4>
  807990:	d9014117 	ldw	r4,1284(sp)
  807994:	000b883a 	mov	r5,zero
  807998:	980d883a 	mov	r6,r19
  80799c:	080b8180 	call	80b818 <memchr>
  8079a0:	10025926 	beq	r2,zero,808308 <___vfprintf_internal_r+0x1c24>
  8079a4:	d8c14117 	ldw	r3,1284(sp)
  8079a8:	10cfc83a 	sub	r7,r2,r3
  8079ac:	99c19e16 	blt	r19,r7,808028 <___vfprintf_internal_r+0x1944>
  8079b0:	d9c14515 	stw	r7,1300(sp)
  8079b4:	38000916 	blt	r7,zero,8079dc <___vfprintf_internal_r+0x12f8>
  8079b8:	d8014615 	stw	zero,1304(sp)
  8079bc:	003deb06 	br	80716c <___vfprintf_internal_r+0xa88>
  8079c0:	b8c00007 	ldb	r3,0(r23)
  8079c4:	003bc606 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  8079c8:	d9014117 	ldw	r4,1284(sp)
  8079cc:	080d47c0 	call	80d47c <strlen>
  8079d0:	d8814515 	stw	r2,1300(sp)
  8079d4:	100f883a 	mov	r7,r2
  8079d8:	103ff70e 	bge	r2,zero,8079b8 <___vfprintf_internal_r+0x12d4>
  8079dc:	d8014515 	stw	zero,1300(sp)
  8079e0:	d8014615 	stw	zero,1304(sp)
  8079e4:	003de106 	br	80716c <___vfprintf_internal_r+0xa88>
  8079e8:	20c03fcc 	andi	r3,r4,255
  8079ec:	00800044 	movi	r2,1
  8079f0:	18802d26 	beq	r3,r2,807aa8 <___vfprintf_internal_r+0x13c4>
  8079f4:	18800e36 	bltu	r3,r2,807a30 <___vfprintf_internal_r+0x134c>
  8079f8:	00800084 	movi	r2,2
  8079fc:	1880fa26 	beq	r3,r2,807de8 <___vfprintf_internal_r+0x1704>
  807a00:	010020b4 	movhi	r4,130
  807a04:	2120c704 	addi	r4,r4,-31972
  807a08:	080d47c0 	call	80d47c <strlen>
  807a0c:	100f883a 	mov	r7,r2
  807a10:	dcc14515 	stw	r19,1300(sp)
  807a14:	9880010e 	bge	r19,r2,807a1c <___vfprintf_internal_r+0x1338>
  807a18:	d8814515 	stw	r2,1300(sp)
  807a1c:	008020b4 	movhi	r2,130
  807a20:	10a0c704 	addi	r2,r2,-31972
  807a24:	dcc14615 	stw	r19,1304(sp)
  807a28:	d8814115 	stw	r2,1284(sp)
  807a2c:	003dcf06 	br	80716c <___vfprintf_internal_r+0xa88>
  807a30:	d9401904 	addi	r5,sp,100
  807a34:	dd000f04 	addi	r20,sp,60
  807a38:	d9414115 	stw	r5,1284(sp)
  807a3c:	880a977a 	slli	r5,r17,29
  807a40:	d9814117 	ldw	r6,1284(sp)
  807a44:	8004d0fa 	srli	r2,r16,3
  807a48:	8806d0fa 	srli	r3,r17,3
  807a4c:	810001cc 	andi	r4,r16,7
  807a50:	2884b03a 	or	r2,r5,r2
  807a54:	31bfffc4 	addi	r6,r6,-1
  807a58:	21000c04 	addi	r4,r4,48
  807a5c:	d9814115 	stw	r6,1284(sp)
  807a60:	10cab03a 	or	r5,r2,r3
  807a64:	31000005 	stb	r4,0(r6)
  807a68:	1021883a 	mov	r16,r2
  807a6c:	1823883a 	mov	r17,r3
  807a70:	283ff21e 	bne	r5,zero,807a3c <___vfprintf_internal_r+0x1358>
  807a74:	d8c14c17 	ldw	r3,1328(sp)
  807a78:	1880004c 	andi	r2,r3,1
  807a7c:	1005003a 	cmpeq	r2,r2,zero
  807a80:	103db31e 	bne	r2,zero,807150 <___vfprintf_internal_r+0xa6c>
  807a84:	20803fcc 	andi	r2,r4,255
  807a88:	1080201c 	xori	r2,r2,128
  807a8c:	10bfe004 	addi	r2,r2,-128
  807a90:	00c00c04 	movi	r3,48
  807a94:	10fdae26 	beq	r2,r3,807150 <___vfprintf_internal_r+0xa6c>
  807a98:	31bfffc4 	addi	r6,r6,-1
  807a9c:	d9814115 	stw	r6,1284(sp)
  807aa0:	30c00005 	stb	r3,0(r6)
  807aa4:	003daa06 	br	807150 <___vfprintf_internal_r+0xa6c>
  807aa8:	88800068 	cmpgeui	r2,r17,1
  807aac:	10002c1e 	bne	r2,zero,807b60 <___vfprintf_internal_r+0x147c>
  807ab0:	8800021e 	bne	r17,zero,807abc <___vfprintf_internal_r+0x13d8>
  807ab4:	00800244 	movi	r2,9
  807ab8:	14002936 	bltu	r2,r16,807b60 <___vfprintf_internal_r+0x147c>
  807abc:	d90018c4 	addi	r4,sp,99
  807ac0:	dd000f04 	addi	r20,sp,60
  807ac4:	d9014115 	stw	r4,1284(sp)
  807ac8:	d9014117 	ldw	r4,1284(sp)
  807acc:	80800c04 	addi	r2,r16,48
  807ad0:	20800005 	stb	r2,0(r4)
  807ad4:	003d9e06 	br	807150 <___vfprintf_internal_r+0xa6c>
  807ad8:	dc400d17 	ldw	r17,52(sp)
  807adc:	070020b4 	movhi	fp,130
  807ae0:	e720cd84 	addi	fp,fp,-31946
  807ae4:	9425883a 	add	r18,r18,r16
  807ae8:	8c400044 	addi	r17,r17,1
  807aec:	008001c4 	movi	r2,7
  807af0:	1f000015 	stw	fp,0(r3)
  807af4:	1c000115 	stw	r16,4(r3)
  807af8:	dc800e15 	stw	r18,56(sp)
  807afc:	dc400d15 	stw	r17,52(sp)
  807b00:	147ddc16 	blt	r2,r17,807274 <___vfprintf_internal_r+0xb90>
  807b04:	18c00204 	addi	r3,r3,8
  807b08:	003c7406 	br	806cdc <___vfprintf_internal_r+0x5f8>
  807b0c:	01000084 	movi	r4,2
  807b10:	d8000405 	stb	zero,16(sp)
  807b14:	003d8106 	br	80711c <___vfprintf_internal_r+0xa38>
  807b18:	d9814c17 	ldw	r6,1328(sp)
  807b1c:	30c4703a 	and	r2,r6,r3
  807b20:	1005003a 	cmpeq	r2,r2,zero
  807b24:	103cb326 	beq	r2,zero,806df4 <___vfprintf_internal_r+0x710>
  807b28:	d9014117 	ldw	r4,1284(sp)
  807b2c:	94800044 	addi	r18,r18,1
  807b30:	8c400044 	addi	r17,r17,1
  807b34:	008001c4 	movi	r2,7
  807b38:	a9000015 	stw	r4,0(r21)
  807b3c:	a8c00115 	stw	r3,4(r21)
  807b40:	dc800e15 	stw	r18,56(sp)
  807b44:	dc400d15 	stw	r17,52(sp)
  807b48:	147e6016 	blt	r2,r17,8074cc <___vfprintf_internal_r+0xde8>
  807b4c:	acc00204 	addi	r19,r21,8
  807b50:	003cd106 	br	806e98 <___vfprintf_internal_r+0x7b4>
  807b54:	070020b4 	movhi	fp,130
  807b58:	e720cd84 	addi	fp,fp,-31946
  807b5c:	003c4906 	br	806c84 <___vfprintf_internal_r+0x5a0>
  807b60:	dd000f04 	addi	r20,sp,60
  807b64:	dc801904 	addi	r18,sp,100
  807b68:	8009883a 	mov	r4,r16
  807b6c:	880b883a 	mov	r5,r17
  807b70:	01800284 	movi	r6,10
  807b74:	000f883a 	mov	r7,zero
  807b78:	080e0040 	call	80e004 <__umoddi3>
  807b7c:	12000c04 	addi	r8,r2,48
  807b80:	94bfffc4 	addi	r18,r18,-1
  807b84:	8009883a 	mov	r4,r16
  807b88:	880b883a 	mov	r5,r17
  807b8c:	01800284 	movi	r6,10
  807b90:	000f883a 	mov	r7,zero
  807b94:	92000005 	stb	r8,0(r18)
  807b98:	080d9980 	call	80d998 <__udivdi3>
  807b9c:	1009883a 	mov	r4,r2
  807ba0:	1021883a 	mov	r16,r2
  807ba4:	18800068 	cmpgeui	r2,r3,1
  807ba8:	1823883a 	mov	r17,r3
  807bac:	103fee1e 	bne	r2,zero,807b68 <___vfprintf_internal_r+0x1484>
  807bb0:	1800021e 	bne	r3,zero,807bbc <___vfprintf_internal_r+0x14d8>
  807bb4:	00800244 	movi	r2,9
  807bb8:	113feb36 	bltu	r2,r4,807b68 <___vfprintf_internal_r+0x1484>
  807bbc:	94bfffc4 	addi	r18,r18,-1
  807bc0:	dc814115 	stw	r18,1284(sp)
  807bc4:	003fc006 	br	807ac8 <___vfprintf_internal_r+0x13e4>
  807bc8:	d9014c17 	ldw	r4,1328(sp)
  807bcc:	2080004c 	andi	r2,r4,1
  807bd0:	10009a1e 	bne	r2,zero,807e3c <___vfprintf_internal_r+0x1758>
  807bd4:	d9401904 	addi	r5,sp,100
  807bd8:	dd000f04 	addi	r20,sp,60
  807bdc:	d9414115 	stw	r5,1284(sp)
  807be0:	003d5b06 	br	807150 <___vfprintf_internal_r+0xa6c>
  807be4:	d9014f17 	ldw	r4,1340(sp)
  807be8:	b00b883a 	mov	r5,r22
  807bec:	d9800c04 	addi	r6,sp,48
  807bf0:	080668c0 	call	80668c <__sprint_r>
  807bf4:	103c731e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807bf8:	dc800e17 	ldw	r18,56(sp)
  807bfc:	d8c01904 	addi	r3,sp,100
  807c00:	003cf906 	br	806fe8 <___vfprintf_internal_r+0x904>
  807c04:	d8c14c17 	ldw	r3,1328(sp)
  807c08:	1880040c 	andi	r2,r3,16
  807c0c:	1000711e 	bne	r2,zero,807dd4 <___vfprintf_internal_r+0x16f0>
  807c10:	d9014c17 	ldw	r4,1328(sp)
  807c14:	2080100c 	andi	r2,r4,64
  807c18:	10006e26 	beq	r2,zero,807dd4 <___vfprintf_internal_r+0x16f0>
  807c1c:	3c00000b 	ldhu	r16,0(r7)
  807c20:	0023883a 	mov	r17,zero
  807c24:	39c00104 	addi	r7,r7,4
  807c28:	d9c14015 	stw	r7,1280(sp)
  807c2c:	003efa06 	br	807818 <___vfprintf_internal_r+0x1134>
  807c30:	dc400d17 	ldw	r17,52(sp)
  807c34:	070020b4 	movhi	fp,130
  807c38:	e720cd84 	addi	fp,fp,-31946
  807c3c:	9425883a 	add	r18,r18,r16
  807c40:	8c400044 	addi	r17,r17,1
  807c44:	008001c4 	movi	r2,7
  807c48:	1f000015 	stw	fp,0(r3)
  807c4c:	1c000115 	stw	r16,4(r3)
  807c50:	dc800e15 	stw	r18,56(sp)
  807c54:	dc400d15 	stw	r17,52(sp)
  807c58:	147d7016 	blt	r2,r17,80721c <___vfprintf_internal_r+0xb38>
  807c5c:	18c00204 	addi	r3,r3,8
  807c60:	003d7506 	br	807238 <___vfprintf_internal_r+0xb54>
  807c64:	dc800e17 	ldw	r18,56(sp)
  807c68:	dc400d17 	ldw	r17,52(sp)
  807c6c:	070020b4 	movhi	fp,130
  807c70:	e720d184 	addi	fp,fp,-31930
  807c74:	003bba06 	br	806b60 <___vfprintf_internal_r+0x47c>
  807c78:	d9014f17 	ldw	r4,1340(sp)
  807c7c:	b00b883a 	mov	r5,r22
  807c80:	d9800c04 	addi	r6,sp,48
  807c84:	080668c0 	call	80668c <__sprint_r>
  807c88:	103c4e1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807c8c:	dc800e17 	ldw	r18,56(sp)
  807c90:	d8c01904 	addi	r3,sp,100
  807c94:	003ce306 	br	807024 <___vfprintf_internal_r+0x940>
  807c98:	3c000017 	ldw	r16,0(r7)
  807c9c:	0009883a 	mov	r4,zero
  807ca0:	39c00104 	addi	r7,r7,4
  807ca4:	0023883a 	mov	r17,zero
  807ca8:	d9c14015 	stw	r7,1280(sp)
  807cac:	d8000405 	stb	zero,16(sp)
  807cb0:	003d1a06 	br	80711c <___vfprintf_internal_r+0xa38>
  807cb4:	38800017 	ldw	r2,0(r7)
  807cb8:	39c00104 	addi	r7,r7,4
  807cbc:	d9c14015 	stw	r7,1280(sp)
  807cc0:	1023d7fa 	srai	r17,r2,31
  807cc4:	1021883a 	mov	r16,r2
  807cc8:	003d1206 	br	807114 <___vfprintf_internal_r+0xa30>
  807ccc:	3c000017 	ldw	r16,0(r7)
  807cd0:	01000044 	movi	r4,1
  807cd4:	39c00104 	addi	r7,r7,4
  807cd8:	0023883a 	mov	r17,zero
  807cdc:	d9c14015 	stw	r7,1280(sp)
  807ce0:	d8000405 	stb	zero,16(sp)
  807ce4:	003d0d06 	br	80711c <___vfprintf_internal_r+0xa38>
  807ce8:	008020b4 	movhi	r2,130
  807cec:	10a06f04 	addi	r2,r2,-32324
  807cf0:	94800044 	addi	r18,r18,1
  807cf4:	8c400044 	addi	r17,r17,1
  807cf8:	a8800015 	stw	r2,0(r21)
  807cfc:	00c00044 	movi	r3,1
  807d00:	008001c4 	movi	r2,7
  807d04:	a8c00115 	stw	r3,4(r21)
  807d08:	dc800e15 	stw	r18,56(sp)
  807d0c:	dc400d15 	stw	r17,52(sp)
  807d10:	1440ca16 	blt	r2,r17,80803c <___vfprintf_internal_r+0x1958>
  807d14:	a8c00204 	addi	r3,r21,8
  807d18:	2000061e 	bne	r4,zero,807d34 <___vfprintf_internal_r+0x1650>
  807d1c:	d9414717 	ldw	r5,1308(sp)
  807d20:	2800041e 	bne	r5,zero,807d34 <___vfprintf_internal_r+0x1650>
  807d24:	d9814c17 	ldw	r6,1328(sp)
  807d28:	3080004c 	andi	r2,r6,1
  807d2c:	1005003a 	cmpeq	r2,r2,zero
  807d30:	103bea1e 	bne	r2,zero,806cdc <___vfprintf_internal_r+0x5f8>
  807d34:	00800044 	movi	r2,1
  807d38:	dc400d17 	ldw	r17,52(sp)
  807d3c:	18800115 	stw	r2,4(r3)
  807d40:	d8814917 	ldw	r2,1316(sp)
  807d44:	94800044 	addi	r18,r18,1
  807d48:	8c400044 	addi	r17,r17,1
  807d4c:	18800015 	stw	r2,0(r3)
  807d50:	008001c4 	movi	r2,7
  807d54:	dc800e15 	stw	r18,56(sp)
  807d58:	dc400d15 	stw	r17,52(sp)
  807d5c:	1440ca16 	blt	r2,r17,808088 <___vfprintf_internal_r+0x19a4>
  807d60:	18c00204 	addi	r3,r3,8
  807d64:	0121c83a 	sub	r16,zero,r4
  807d68:	0400500e 	bge	zero,r16,807eac <___vfprintf_internal_r+0x17c8>
  807d6c:	00800404 	movi	r2,16
  807d70:	1400800e 	bge	r2,r16,807f74 <___vfprintf_internal_r+0x1890>
  807d74:	1027883a 	mov	r19,r2
  807d78:	070020b4 	movhi	fp,130
  807d7c:	e720cd84 	addi	fp,fp,-31946
  807d80:	050001c4 	movi	r20,7
  807d84:	00000306 	br	807d94 <___vfprintf_internal_r+0x16b0>
  807d88:	18c00204 	addi	r3,r3,8
  807d8c:	843ffc04 	addi	r16,r16,-16
  807d90:	9c007a0e 	bge	r19,r16,807f7c <___vfprintf_internal_r+0x1898>
  807d94:	94800404 	addi	r18,r18,16
  807d98:	8c400044 	addi	r17,r17,1
  807d9c:	1f000015 	stw	fp,0(r3)
  807da0:	1cc00115 	stw	r19,4(r3)
  807da4:	dc800e15 	stw	r18,56(sp)
  807da8:	dc400d15 	stw	r17,52(sp)
  807dac:	a47ff60e 	bge	r20,r17,807d88 <___vfprintf_internal_r+0x16a4>
  807db0:	d9014f17 	ldw	r4,1340(sp)
  807db4:	b00b883a 	mov	r5,r22
  807db8:	d9800c04 	addi	r6,sp,48
  807dbc:	080668c0 	call	80668c <__sprint_r>
  807dc0:	103c001e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807dc4:	dc800e17 	ldw	r18,56(sp)
  807dc8:	dc400d17 	ldw	r17,52(sp)
  807dcc:	d8c01904 	addi	r3,sp,100
  807dd0:	003fee06 	br	807d8c <___vfprintf_internal_r+0x16a8>
  807dd4:	3c000017 	ldw	r16,0(r7)
  807dd8:	0023883a 	mov	r17,zero
  807ddc:	39c00104 	addi	r7,r7,4
  807de0:	d9c14015 	stw	r7,1280(sp)
  807de4:	003e8c06 	br	807818 <___vfprintf_internal_r+0x1134>
  807de8:	d9401904 	addi	r5,sp,100
  807dec:	dd000f04 	addi	r20,sp,60
  807df0:	d9414115 	stw	r5,1284(sp)
  807df4:	d9814417 	ldw	r6,1296(sp)
  807df8:	880a973a 	slli	r5,r17,28
  807dfc:	8004d13a 	srli	r2,r16,4
  807e00:	810003cc 	andi	r4,r16,15
  807e04:	3109883a 	add	r4,r6,r4
  807e08:	2884b03a 	or	r2,r5,r2
  807e0c:	21400003 	ldbu	r5,0(r4)
  807e10:	d9014117 	ldw	r4,1284(sp)
  807e14:	8806d13a 	srli	r3,r17,4
  807e18:	1021883a 	mov	r16,r2
  807e1c:	213fffc4 	addi	r4,r4,-1
  807e20:	d9014115 	stw	r4,1284(sp)
  807e24:	d9814117 	ldw	r6,1284(sp)
  807e28:	10c8b03a 	or	r4,r2,r3
  807e2c:	1823883a 	mov	r17,r3
  807e30:	31400005 	stb	r5,0(r6)
  807e34:	203fef1e 	bne	r4,zero,807df4 <___vfprintf_internal_r+0x1710>
  807e38:	003cc506 	br	807150 <___vfprintf_internal_r+0xa6c>
  807e3c:	00800c04 	movi	r2,48
  807e40:	d98018c4 	addi	r6,sp,99
  807e44:	dd000f04 	addi	r20,sp,60
  807e48:	d88018c5 	stb	r2,99(sp)
  807e4c:	d9814115 	stw	r6,1284(sp)
  807e50:	003cbf06 	br	807150 <___vfprintf_internal_r+0xa6c>
  807e54:	dc400d17 	ldw	r17,52(sp)
  807e58:	070020b4 	movhi	fp,130
  807e5c:	e720d184 	addi	fp,fp,-31930
  807e60:	003bc106 	br	806d68 <___vfprintf_internal_r+0x684>
  807e64:	d9414c17 	ldw	r5,1328(sp)
  807e68:	2880040c 	andi	r2,r5,16
  807e6c:	10007c26 	beq	r2,zero,808060 <___vfprintf_internal_r+0x197c>
  807e70:	38800017 	ldw	r2,0(r7)
  807e74:	39c00104 	addi	r7,r7,4
  807e78:	d9c14015 	stw	r7,1280(sp)
  807e7c:	d9814b17 	ldw	r6,1324(sp)
  807e80:	d9c14017 	ldw	r7,1280(sp)
  807e84:	11800015 	stw	r6,0(r2)
  807e88:	003a7206 	br	806854 <___vfprintf_internal_r+0x170>
  807e8c:	d9014f17 	ldw	r4,1340(sp)
  807e90:	b00b883a 	mov	r5,r22
  807e94:	d9800c04 	addi	r6,sp,48
  807e98:	080668c0 	call	80668c <__sprint_r>
  807e9c:	103bc91e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807ea0:	dc800e17 	ldw	r18,56(sp)
  807ea4:	dc400d17 	ldw	r17,52(sp)
  807ea8:	d8c01904 	addi	r3,sp,100
  807eac:	d9014717 	ldw	r4,1308(sp)
  807eb0:	d9414117 	ldw	r5,1284(sp)
  807eb4:	8c400044 	addi	r17,r17,1
  807eb8:	9125883a 	add	r18,r18,r4
  807ebc:	008001c4 	movi	r2,7
  807ec0:	19400015 	stw	r5,0(r3)
  807ec4:	19000115 	stw	r4,4(r3)
  807ec8:	dc800e15 	stw	r18,56(sp)
  807ecc:	dc400d15 	stw	r17,52(sp)
  807ed0:	147ce816 	blt	r2,r17,807274 <___vfprintf_internal_r+0xb90>
  807ed4:	18c00204 	addi	r3,r3,8
  807ed8:	003b8006 	br	806cdc <___vfprintf_internal_r+0x5f8>
  807edc:	38c00017 	ldw	r3,0(r7)
  807ee0:	39000204 	addi	r4,r7,8
  807ee4:	d9014015 	stw	r4,1280(sp)
  807ee8:	d8c14215 	stw	r3,1288(sp)
  807eec:	39c00117 	ldw	r7,4(r7)
  807ef0:	d9c14315 	stw	r7,1292(sp)
  807ef4:	003e1a06 	br	807760 <___vfprintf_internal_r+0x107c>
  807ef8:	0005883a 	mov	r2,zero
  807efc:	1409c83a 	sub	r4,r2,r16
  807f00:	1105803a 	cmpltu	r2,r2,r4
  807f04:	044bc83a 	sub	r5,zero,r17
  807f08:	2885c83a 	sub	r2,r5,r2
  807f0c:	2021883a 	mov	r16,r4
  807f10:	1023883a 	mov	r17,r2
  807f14:	01000044 	movi	r4,1
  807f18:	00800b44 	movi	r2,45
  807f1c:	d8800405 	stb	r2,16(sp)
  807f20:	003c7e06 	br	80711c <___vfprintf_internal_r+0xa38>
  807f24:	d9014f17 	ldw	r4,1340(sp)
  807f28:	b00b883a 	mov	r5,r22
  807f2c:	d9800c04 	addi	r6,sp,48
  807f30:	080668c0 	call	80668c <__sprint_r>
  807f34:	103ba31e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807f38:	dc800e17 	ldw	r18,56(sp)
  807f3c:	dc400d17 	ldw	r17,52(sp)
  807f40:	d9000517 	ldw	r4,20(sp)
  807f44:	d9401904 	addi	r5,sp,100
  807f48:	003da106 	br	8075d0 <___vfprintf_internal_r+0xeec>
  807f4c:	d9014f17 	ldw	r4,1340(sp)
  807f50:	b00b883a 	mov	r5,r22
  807f54:	d9800c04 	addi	r6,sp,48
  807f58:	080668c0 	call	80668c <__sprint_r>
  807f5c:	103b991e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807f60:	dc800e17 	ldw	r18,56(sp)
  807f64:	dc400d17 	ldw	r17,52(sp)
  807f68:	d9000517 	ldw	r4,20(sp)
  807f6c:	d8c01904 	addi	r3,sp,100
  807f70:	003d8b06 	br	8075a0 <___vfprintf_internal_r+0xebc>
  807f74:	070020b4 	movhi	fp,130
  807f78:	e720cd84 	addi	fp,fp,-31946
  807f7c:	9425883a 	add	r18,r18,r16
  807f80:	8c400044 	addi	r17,r17,1
  807f84:	008001c4 	movi	r2,7
  807f88:	1f000015 	stw	fp,0(r3)
  807f8c:	1c000115 	stw	r16,4(r3)
  807f90:	dc800e15 	stw	r18,56(sp)
  807f94:	dc400d15 	stw	r17,52(sp)
  807f98:	147fbc16 	blt	r2,r17,807e8c <___vfprintf_internal_r+0x17a8>
  807f9c:	18c00204 	addi	r3,r3,8
  807fa0:	003fc206 	br	807eac <___vfprintf_internal_r+0x17c8>
  807fa4:	d9014f17 	ldw	r4,1340(sp)
  807fa8:	b00b883a 	mov	r5,r22
  807fac:	d9800c04 	addi	r6,sp,48
  807fb0:	080668c0 	call	80668c <__sprint_r>
  807fb4:	103b831e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  807fb8:	dc800e17 	ldw	r18,56(sp)
  807fbc:	d9000517 	ldw	r4,20(sp)
  807fc0:	d8c01904 	addi	r3,sp,100
  807fc4:	003cfc06 	br	8073b8 <___vfprintf_internal_r+0xcd4>
  807fc8:	070020b4 	movhi	fp,130
  807fcc:	e720cd84 	addi	fp,fp,-31946
  807fd0:	003bde06 	br	806f4c <___vfprintf_internal_r+0x868>
  807fd4:	008020b4 	movhi	r2,130
  807fd8:	10a0bd04 	addi	r2,r2,-32012
  807fdc:	d8814115 	stw	r2,1284(sp)
  807fe0:	003def06 	br	8077a0 <___vfprintf_internal_r+0x10bc>
  807fe4:	d9014217 	ldw	r4,1288(sp)
  807fe8:	d9414317 	ldw	r5,1292(sp)
  807fec:	080d1d40 	call	80d1d4 <__isnand>
  807ff0:	10003926 	beq	r2,zero,8080d8 <___vfprintf_internal_r+0x19f4>
  807ff4:	d9414d17 	ldw	r5,1332(sp)
  807ff8:	008011c4 	movi	r2,71
  807ffc:	1140ce16 	blt	r2,r5,808338 <___vfprintf_internal_r+0x1c54>
  808000:	018020b4 	movhi	r6,130
  808004:	31a0be04 	addi	r6,r6,-32008
  808008:	d9814115 	stw	r6,1284(sp)
  80800c:	003de406 	br	8077a0 <___vfprintf_internal_r+0x10bc>
  808010:	d9014c17 	ldw	r4,1328(sp)
  808014:	bdc00044 	addi	r23,r23,1
  808018:	b8c00007 	ldb	r3,0(r23)
  80801c:	21000814 	ori	r4,r4,32
  808020:	d9014c15 	stw	r4,1328(sp)
  808024:	003a2e06 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  808028:	dcc14515 	stw	r19,1300(sp)
  80802c:	98011016 	blt	r19,zero,808470 <___vfprintf_internal_r+0x1d8c>
  808030:	980f883a 	mov	r7,r19
  808034:	d8014615 	stw	zero,1304(sp)
  808038:	003c4c06 	br	80716c <___vfprintf_internal_r+0xa88>
  80803c:	d9014f17 	ldw	r4,1340(sp)
  808040:	b00b883a 	mov	r5,r22
  808044:	d9800c04 	addi	r6,sp,48
  808048:	080668c0 	call	80668c <__sprint_r>
  80804c:	103b5d1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  808050:	dc800e17 	ldw	r18,56(sp)
  808054:	d9000517 	ldw	r4,20(sp)
  808058:	d8c01904 	addi	r3,sp,100
  80805c:	003f2e06 	br	807d18 <___vfprintf_internal_r+0x1634>
  808060:	d8c14c17 	ldw	r3,1328(sp)
  808064:	1880100c 	andi	r2,r3,64
  808068:	1000a026 	beq	r2,zero,8082ec <___vfprintf_internal_r+0x1c08>
  80806c:	38800017 	ldw	r2,0(r7)
  808070:	39c00104 	addi	r7,r7,4
  808074:	d9c14015 	stw	r7,1280(sp)
  808078:	d9014b17 	ldw	r4,1324(sp)
  80807c:	d9c14017 	ldw	r7,1280(sp)
  808080:	1100000d 	sth	r4,0(r2)
  808084:	0039f306 	br	806854 <___vfprintf_internal_r+0x170>
  808088:	d9014f17 	ldw	r4,1340(sp)
  80808c:	b00b883a 	mov	r5,r22
  808090:	d9800c04 	addi	r6,sp,48
  808094:	080668c0 	call	80668c <__sprint_r>
  808098:	103b4a1e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  80809c:	dc800e17 	ldw	r18,56(sp)
  8080a0:	dc400d17 	ldw	r17,52(sp)
  8080a4:	d9000517 	ldw	r4,20(sp)
  8080a8:	d8c01904 	addi	r3,sp,100
  8080ac:	003f2d06 	br	807d64 <___vfprintf_internal_r+0x1680>
  8080b0:	00800184 	movi	r2,6
  8080b4:	14c09a36 	bltu	r2,r19,808320 <___vfprintf_internal_r+0x1c3c>
  8080b8:	dcc14515 	stw	r19,1300(sp)
  8080bc:	9800010e 	bge	r19,zero,8080c4 <___vfprintf_internal_r+0x19e0>
  8080c0:	d8014515 	stw	zero,1300(sp)
  8080c4:	008020b4 	movhi	r2,130
  8080c8:	10a0c004 	addi	r2,r2,-32000
  8080cc:	980f883a 	mov	r7,r19
  8080d0:	d8814115 	stw	r2,1284(sp)
  8080d4:	003a7206 	br	806aa0 <___vfprintf_internal_r+0x3bc>
  8080d8:	00bfffc4 	movi	r2,-1
  8080dc:	9880e226 	beq	r19,r2,808468 <___vfprintf_internal_r+0x1d84>
  8080e0:	d9414d17 	ldw	r5,1332(sp)
  8080e4:	008019c4 	movi	r2,103
  8080e8:	2880dc26 	beq	r5,r2,80845c <___vfprintf_internal_r+0x1d78>
  8080ec:	008011c4 	movi	r2,71
  8080f0:	2880da26 	beq	r5,r2,80845c <___vfprintf_internal_r+0x1d78>
  8080f4:	d9414c17 	ldw	r5,1328(sp)
  8080f8:	d9014317 	ldw	r4,1292(sp)
  8080fc:	d9814217 	ldw	r6,1288(sp)
  808100:	29404014 	ori	r5,r5,256
  808104:	d9414c15 	stw	r5,1328(sp)
  808108:	2000cc16 	blt	r4,zero,80843c <___vfprintf_internal_r+0x1d58>
  80810c:	3021883a 	mov	r16,r6
  808110:	2023883a 	mov	r17,r4
  808114:	0039883a 	mov	fp,zero
  808118:	d9414d17 	ldw	r5,1332(sp)
  80811c:	00801984 	movi	r2,102
  808120:	2880b726 	beq	r5,r2,808400 <___vfprintf_internal_r+0x1d1c>
  808124:	00801184 	movi	r2,70
  808128:	2880b526 	beq	r5,r2,808400 <___vfprintf_internal_r+0x1d1c>
  80812c:	00801944 	movi	r2,101
  808130:	2880c826 	beq	r5,r2,808454 <___vfprintf_internal_r+0x1d70>
  808134:	00801144 	movi	r2,69
  808138:	2880c626 	beq	r5,r2,808454 <___vfprintf_internal_r+0x1d70>
  80813c:	9829883a 	mov	r20,r19
  808140:	d9014f17 	ldw	r4,1340(sp)
  808144:	d8800504 	addi	r2,sp,20
  808148:	880d883a 	mov	r6,r17
  80814c:	d8800115 	stw	r2,4(sp)
  808150:	d8c00604 	addi	r3,sp,24
  808154:	d8800704 	addi	r2,sp,28
  808158:	800b883a 	mov	r5,r16
  80815c:	01c00084 	movi	r7,2
  808160:	d8c00215 	stw	r3,8(sp)
  808164:	d8800315 	stw	r2,12(sp)
  808168:	dd000015 	stw	r20,0(sp)
  80816c:	080894c0 	call	80894c <_dtoa_r>
  808170:	d9814d17 	ldw	r6,1332(sp)
  808174:	d8814115 	stw	r2,1284(sp)
  808178:	008019c4 	movi	r2,103
  80817c:	30809526 	beq	r6,r2,8083d4 <___vfprintf_internal_r+0x1cf0>
  808180:	d8c14d17 	ldw	r3,1332(sp)
  808184:	008011c4 	movi	r2,71
  808188:	18809226 	beq	r3,r2,8083d4 <___vfprintf_internal_r+0x1cf0>
  80818c:	d9414117 	ldw	r5,1284(sp)
  808190:	d9814d17 	ldw	r6,1332(sp)
  808194:	00801984 	movi	r2,102
  808198:	2d25883a 	add	r18,r5,r20
  80819c:	30808626 	beq	r6,r2,8083b8 <___vfprintf_internal_r+0x1cd4>
  8081a0:	00801184 	movi	r2,70
  8081a4:	30808426 	beq	r6,r2,8083b8 <___vfprintf_internal_r+0x1cd4>
  8081a8:	000d883a 	mov	r6,zero
  8081ac:	000f883a 	mov	r7,zero
  8081b0:	880b883a 	mov	r5,r17
  8081b4:	8009883a 	mov	r4,r16
  8081b8:	080f1840 	call	80f184 <__eqdf2>
  8081bc:	1000751e 	bne	r2,zero,808394 <___vfprintf_internal_r+0x1cb0>
  8081c0:	9005883a 	mov	r2,r18
  8081c4:	dc800715 	stw	r18,28(sp)
  8081c8:	d9014117 	ldw	r4,1284(sp)
  8081cc:	d9414d17 	ldw	r5,1332(sp)
  8081d0:	00c019c4 	movi	r3,103
  8081d4:	1125c83a 	sub	r18,r2,r4
  8081d8:	28c06826 	beq	r5,r3,80837c <___vfprintf_internal_r+0x1c98>
  8081dc:	008011c4 	movi	r2,71
  8081e0:	28806626 	beq	r5,r2,80837c <___vfprintf_internal_r+0x1c98>
  8081e4:	d9000517 	ldw	r4,20(sp)
  8081e8:	d8c14d17 	ldw	r3,1332(sp)
  8081ec:	00801944 	movi	r2,101
  8081f0:	10c05516 	blt	r2,r3,808348 <___vfprintf_internal_r+0x1c64>
  8081f4:	213fffc4 	addi	r4,r4,-1
  8081f8:	d9000515 	stw	r4,20(sp)
  8081fc:	d8c00805 	stb	r3,32(sp)
  808200:	2021883a 	mov	r16,r4
  808204:	2000c116 	blt	r4,zero,80850c <___vfprintf_internal_r+0x1e28>
  808208:	00800ac4 	movi	r2,43
  80820c:	d8800845 	stb	r2,33(sp)
  808210:	00800244 	movi	r2,9
  808214:	1400af0e 	bge	r2,r16,8084d4 <___vfprintf_internal_r+0x1df0>
  808218:	1027883a 	mov	r19,r2
  80821c:	dc400b84 	addi	r17,sp,46
  808220:	8009883a 	mov	r4,r16
  808224:	01400284 	movi	r5,10
  808228:	08064140 	call	806414 <__modsi3>
  80822c:	10800c04 	addi	r2,r2,48
  808230:	8c7fffc4 	addi	r17,r17,-1
  808234:	8009883a 	mov	r4,r16
  808238:	01400284 	movi	r5,10
  80823c:	88800005 	stb	r2,0(r17)
  808240:	08063b40 	call	8063b4 <__divsi3>
  808244:	1021883a 	mov	r16,r2
  808248:	98bff516 	blt	r19,r2,808220 <___vfprintf_internal_r+0x1b3c>
  80824c:	10c00c04 	addi	r3,r2,48
  808250:	d88009c4 	addi	r2,sp,39
  808254:	108001c4 	addi	r2,r2,7
  808258:	897fffc4 	addi	r5,r17,-1
  80825c:	88ffffc5 	stb	r3,-1(r17)
  808260:	2880a72e 	bgeu	r5,r2,808500 <___vfprintf_internal_r+0x1e1c>
  808264:	1009883a 	mov	r4,r2
  808268:	d9800804 	addi	r6,sp,32
  80826c:	d8c00884 	addi	r3,sp,34
  808270:	28800003 	ldbu	r2,0(r5)
  808274:	29400044 	addi	r5,r5,1
  808278:	18800005 	stb	r2,0(r3)
  80827c:	18c00044 	addi	r3,r3,1
  808280:	293ffb36 	bltu	r5,r4,808270 <___vfprintf_internal_r+0x1b8c>
  808284:	1987c83a 	sub	r3,r3,r6
  808288:	00800044 	movi	r2,1
  80828c:	d8c14815 	stw	r3,1312(sp)
  808290:	90cf883a 	add	r7,r18,r3
  808294:	1480960e 	bge	r2,r18,8084f0 <___vfprintf_internal_r+0x1e0c>
  808298:	39c00044 	addi	r7,r7,1
  80829c:	d9c14515 	stw	r7,1300(sp)
  8082a0:	38003416 	blt	r7,zero,808374 <___vfprintf_internal_r+0x1c90>
  8082a4:	e0803fcc 	andi	r2,fp,255
  8082a8:	1080201c 	xori	r2,r2,128
  8082ac:	10bfe004 	addi	r2,r2,-128
  8082b0:	10004e26 	beq	r2,zero,8083ec <___vfprintf_internal_r+0x1d08>
  8082b4:	00800b44 	movi	r2,45
  8082b8:	dc814715 	stw	r18,1308(sp)
  8082bc:	d8014615 	stw	zero,1304(sp)
  8082c0:	d8800405 	stb	r2,16(sp)
  8082c4:	003bab06 	br	807174 <___vfprintf_internal_r+0xa90>
  8082c8:	00800b44 	movi	r2,45
  8082cc:	d8800405 	stb	r2,16(sp)
  8082d0:	003d2d06 	br	807788 <___vfprintf_internal_r+0x10a4>
  8082d4:	d9014f17 	ldw	r4,1340(sp)
  8082d8:	b00b883a 	mov	r5,r22
  8082dc:	d9800c04 	addi	r6,sp,48
  8082e0:	080668c0 	call	80668c <__sprint_r>
  8082e4:	103ab71e 	bne	r2,zero,806dc4 <___vfprintf_internal_r+0x6e0>
  8082e8:	003ab506 	br	806dc0 <___vfprintf_internal_r+0x6dc>
  8082ec:	38800017 	ldw	r2,0(r7)
  8082f0:	39c00104 	addi	r7,r7,4
  8082f4:	d9c14015 	stw	r7,1280(sp)
  8082f8:	d9414b17 	ldw	r5,1324(sp)
  8082fc:	d9c14017 	ldw	r7,1280(sp)
  808300:	11400015 	stw	r5,0(r2)
  808304:	00395306 	br	806854 <___vfprintf_internal_r+0x170>
  808308:	980f883a 	mov	r7,r19
  80830c:	dcc14515 	stw	r19,1300(sp)
  808310:	d8014615 	stw	zero,1304(sp)
  808314:	003b9506 	br	80716c <___vfprintf_internal_r+0xa88>
  808318:	0027883a 	mov	r19,zero
  80831c:	00397206 	br	8068e8 <___vfprintf_internal_r+0x204>
  808320:	00c020b4 	movhi	r3,130
  808324:	18e0c004 	addi	r3,r3,-32000
  808328:	100f883a 	mov	r7,r2
  80832c:	d8814515 	stw	r2,1300(sp)
  808330:	d8c14115 	stw	r3,1284(sp)
  808334:	0039da06 	br	806aa0 <___vfprintf_internal_r+0x3bc>
  808338:	008020b4 	movhi	r2,130
  80833c:	10a0bf04 	addi	r2,r2,-32004
  808340:	d8814115 	stw	r2,1284(sp)
  808344:	003d1606 	br	8077a0 <___vfprintf_internal_r+0x10bc>
  808348:	d9414d17 	ldw	r5,1332(sp)
  80834c:	00801984 	movi	r2,102
  808350:	28804926 	beq	r5,r2,808478 <___vfprintf_internal_r+0x1d94>
  808354:	200f883a 	mov	r7,r4
  808358:	24805716 	blt	r4,r18,8084b8 <___vfprintf_internal_r+0x1dd4>
  80835c:	d9414c17 	ldw	r5,1328(sp)
  808360:	2880004c 	andi	r2,r5,1
  808364:	10000126 	beq	r2,zero,80836c <___vfprintf_internal_r+0x1c88>
  808368:	21c00044 	addi	r7,r4,1
  80836c:	d9c14515 	stw	r7,1300(sp)
  808370:	383fcc0e 	bge	r7,zero,8082a4 <___vfprintf_internal_r+0x1bc0>
  808374:	d8014515 	stw	zero,1300(sp)
  808378:	003fca06 	br	8082a4 <___vfprintf_internal_r+0x1bc0>
  80837c:	d9000517 	ldw	r4,20(sp)
  808380:	00bfff04 	movi	r2,-4
  808384:	1100480e 	bge	r2,r4,8084a8 <___vfprintf_internal_r+0x1dc4>
  808388:	99004716 	blt	r19,r4,8084a8 <___vfprintf_internal_r+0x1dc4>
  80838c:	d8c14d15 	stw	r3,1332(sp)
  808390:	003ff006 	br	808354 <___vfprintf_internal_r+0x1c70>
  808394:	d8800717 	ldw	r2,28(sp)
  808398:	14bf8b2e 	bgeu	r2,r18,8081c8 <___vfprintf_internal_r+0x1ae4>
  80839c:	9007883a 	mov	r3,r18
  8083a0:	01000c04 	movi	r4,48
  8083a4:	11000005 	stb	r4,0(r2)
  8083a8:	10800044 	addi	r2,r2,1
  8083ac:	d8800715 	stw	r2,28(sp)
  8083b0:	18bffc1e 	bne	r3,r2,8083a4 <___vfprintf_internal_r+0x1cc0>
  8083b4:	003f8406 	br	8081c8 <___vfprintf_internal_r+0x1ae4>
  8083b8:	d8814117 	ldw	r2,1284(sp)
  8083bc:	10c00007 	ldb	r3,0(r2)
  8083c0:	00800c04 	movi	r2,48
  8083c4:	18805b26 	beq	r3,r2,808534 <___vfprintf_internal_r+0x1e50>
  8083c8:	d9000517 	ldw	r4,20(sp)
  8083cc:	9125883a 	add	r18,r18,r4
  8083d0:	003f7506 	br	8081a8 <___vfprintf_internal_r+0x1ac4>
  8083d4:	d9014c17 	ldw	r4,1328(sp)
  8083d8:	2080004c 	andi	r2,r4,1
  8083dc:	1005003a 	cmpeq	r2,r2,zero
  8083e0:	103f6a26 	beq	r2,zero,80818c <___vfprintf_internal_r+0x1aa8>
  8083e4:	d8800717 	ldw	r2,28(sp)
  8083e8:	003f7706 	br	8081c8 <___vfprintf_internal_r+0x1ae4>
  8083ec:	d9c14515 	stw	r7,1300(sp)
  8083f0:	38004d16 	blt	r7,zero,808528 <___vfprintf_internal_r+0x1e44>
  8083f4:	dc814715 	stw	r18,1308(sp)
  8083f8:	d8014615 	stw	zero,1304(sp)
  8083fc:	003b5b06 	br	80716c <___vfprintf_internal_r+0xa88>
  808400:	d9014f17 	ldw	r4,1340(sp)
  808404:	d8800504 	addi	r2,sp,20
  808408:	d8800115 	stw	r2,4(sp)
  80840c:	d8c00604 	addi	r3,sp,24
  808410:	d8800704 	addi	r2,sp,28
  808414:	800b883a 	mov	r5,r16
  808418:	880d883a 	mov	r6,r17
  80841c:	01c000c4 	movi	r7,3
  808420:	d8c00215 	stw	r3,8(sp)
  808424:	d8800315 	stw	r2,12(sp)
  808428:	dcc00015 	stw	r19,0(sp)
  80842c:	9829883a 	mov	r20,r19
  808430:	080894c0 	call	80894c <_dtoa_r>
  808434:	d8814115 	stw	r2,1284(sp)
  808438:	003f5106 	br	808180 <___vfprintf_internal_r+0x1a9c>
  80843c:	d8c14217 	ldw	r3,1288(sp)
  808440:	d9014317 	ldw	r4,1292(sp)
  808444:	07000b44 	movi	fp,45
  808448:	1821883a 	mov	r16,r3
  80844c:	2460003c 	xorhi	r17,r4,32768
  808450:	003f3106 	br	808118 <___vfprintf_internal_r+0x1a34>
  808454:	9d000044 	addi	r20,r19,1
  808458:	003f3906 	br	808140 <___vfprintf_internal_r+0x1a5c>
  80845c:	983f251e 	bne	r19,zero,8080f4 <___vfprintf_internal_r+0x1a10>
  808460:	04c00044 	movi	r19,1
  808464:	003f2306 	br	8080f4 <___vfprintf_internal_r+0x1a10>
  808468:	04c00184 	movi	r19,6
  80846c:	003f2106 	br	8080f4 <___vfprintf_internal_r+0x1a10>
  808470:	d8014515 	stw	zero,1300(sp)
  808474:	003eee06 	br	808030 <___vfprintf_internal_r+0x194c>
  808478:	200f883a 	mov	r7,r4
  80847c:	0100370e 	bge	zero,r4,80855c <___vfprintf_internal_r+0x1e78>
  808480:	9800031e 	bne	r19,zero,808490 <___vfprintf_internal_r+0x1dac>
  808484:	d9814c17 	ldw	r6,1328(sp)
  808488:	3080004c 	andi	r2,r6,1
  80848c:	103fb726 	beq	r2,zero,80836c <___vfprintf_internal_r+0x1c88>
  808490:	20800044 	addi	r2,r4,1
  808494:	98a7883a 	add	r19,r19,r2
  808498:	dcc14515 	stw	r19,1300(sp)
  80849c:	980f883a 	mov	r7,r19
  8084a0:	983f800e 	bge	r19,zero,8082a4 <___vfprintf_internal_r+0x1bc0>
  8084a4:	003fb306 	br	808374 <___vfprintf_internal_r+0x1c90>
  8084a8:	d9814d17 	ldw	r6,1332(sp)
  8084ac:	31bfff84 	addi	r6,r6,-2
  8084b0:	d9814d15 	stw	r6,1332(sp)
  8084b4:	003f4c06 	br	8081e8 <___vfprintf_internal_r+0x1b04>
  8084b8:	0100180e 	bge	zero,r4,80851c <___vfprintf_internal_r+0x1e38>
  8084bc:	00800044 	movi	r2,1
  8084c0:	1485883a 	add	r2,r2,r18
  8084c4:	d8814515 	stw	r2,1300(sp)
  8084c8:	100f883a 	mov	r7,r2
  8084cc:	103f750e 	bge	r2,zero,8082a4 <___vfprintf_internal_r+0x1bc0>
  8084d0:	003fa806 	br	808374 <___vfprintf_internal_r+0x1c90>
  8084d4:	80c00c04 	addi	r3,r16,48
  8084d8:	00800c04 	movi	r2,48
  8084dc:	d8c008c5 	stb	r3,35(sp)
  8084e0:	d9800804 	addi	r6,sp,32
  8084e4:	d8c00904 	addi	r3,sp,36
  8084e8:	d8800885 	stb	r2,34(sp)
  8084ec:	003f6506 	br	808284 <___vfprintf_internal_r+0x1ba0>
  8084f0:	d9014c17 	ldw	r4,1328(sp)
  8084f4:	2084703a 	and	r2,r4,r2
  8084f8:	103f9c26 	beq	r2,zero,80836c <___vfprintf_internal_r+0x1c88>
  8084fc:	003f6606 	br	808298 <___vfprintf_internal_r+0x1bb4>
  808500:	d9800804 	addi	r6,sp,32
  808504:	d8c00884 	addi	r3,sp,34
  808508:	003f5e06 	br	808284 <___vfprintf_internal_r+0x1ba0>
  80850c:	00800b44 	movi	r2,45
  808510:	0121c83a 	sub	r16,zero,r4
  808514:	d8800845 	stb	r2,33(sp)
  808518:	003f3d06 	br	808210 <___vfprintf_internal_r+0x1b2c>
  80851c:	00800084 	movi	r2,2
  808520:	1105c83a 	sub	r2,r2,r4
  808524:	003fe606 	br	8084c0 <___vfprintf_internal_r+0x1ddc>
  808528:	d8014515 	stw	zero,1300(sp)
  80852c:	dc814715 	stw	r18,1308(sp)
  808530:	003fb106 	br	8083f8 <___vfprintf_internal_r+0x1d14>
  808534:	000d883a 	mov	r6,zero
  808538:	000f883a 	mov	r7,zero
  80853c:	8009883a 	mov	r4,r16
  808540:	880b883a 	mov	r5,r17
  808544:	080f20c0 	call	80f20c <__nedf2>
  808548:	103f9f26 	beq	r2,zero,8083c8 <___vfprintf_internal_r+0x1ce4>
  80854c:	00800044 	movi	r2,1
  808550:	1509c83a 	sub	r4,r2,r20
  808554:	d9000515 	stw	r4,20(sp)
  808558:	003f9b06 	br	8083c8 <___vfprintf_internal_r+0x1ce4>
  80855c:	98000d1e 	bne	r19,zero,808594 <___vfprintf_internal_r+0x1eb0>
  808560:	d8c14c17 	ldw	r3,1328(sp)
  808564:	1880004c 	andi	r2,r3,1
  808568:	10000a1e 	bne	r2,zero,808594 <___vfprintf_internal_r+0x1eb0>
  80856c:	01000044 	movi	r4,1
  808570:	200f883a 	mov	r7,r4
  808574:	d9014515 	stw	r4,1300(sp)
  808578:	003f4a06 	br	8082a4 <___vfprintf_internal_r+0x1bc0>
  80857c:	3cc00017 	ldw	r19,0(r7)
  808580:	39c00104 	addi	r7,r7,4
  808584:	983d0e0e 	bge	r19,zero,8079c0 <___vfprintf_internal_r+0x12dc>
  808588:	b8c00007 	ldb	r3,0(r23)
  80858c:	04ffffc4 	movi	r19,-1
  808590:	0038d306 	br	8068e0 <___vfprintf_internal_r+0x1fc>
  808594:	9cc00084 	addi	r19,r19,2
  808598:	dcc14515 	stw	r19,1300(sp)
  80859c:	980f883a 	mov	r7,r19
  8085a0:	983f400e 	bge	r19,zero,8082a4 <___vfprintf_internal_r+0x1bc0>
  8085a4:	003f7306 	br	808374 <___vfprintf_internal_r+0x1c90>

008085a8 <__vfprintf_internal>:
  8085a8:	008020b4 	movhi	r2,130
  8085ac:	10a93104 	addi	r2,r2,-23356
  8085b0:	2013883a 	mov	r9,r4
  8085b4:	11000017 	ldw	r4,0(r2)
  8085b8:	2805883a 	mov	r2,r5
  8085bc:	300f883a 	mov	r7,r6
  8085c0:	480b883a 	mov	r5,r9
  8085c4:	100d883a 	mov	r6,r2
  8085c8:	08066e41 	jmpi	8066e4 <___vfprintf_internal_r>

008085cc <__swsetup_r>:
  8085cc:	008020b4 	movhi	r2,130
  8085d0:	10a93104 	addi	r2,r2,-23356
  8085d4:	10c00017 	ldw	r3,0(r2)
  8085d8:	defffd04 	addi	sp,sp,-12
  8085dc:	dc400115 	stw	r17,4(sp)
  8085e0:	dc000015 	stw	r16,0(sp)
  8085e4:	dfc00215 	stw	ra,8(sp)
  8085e8:	2023883a 	mov	r17,r4
  8085ec:	2821883a 	mov	r16,r5
  8085f0:	18000226 	beq	r3,zero,8085fc <__swsetup_r+0x30>
  8085f4:	18800e17 	ldw	r2,56(r3)
  8085f8:	10001f26 	beq	r2,zero,808678 <__swsetup_r+0xac>
  8085fc:	8100030b 	ldhu	r4,12(r16)
  808600:	2080020c 	andi	r2,r4,8
  808604:	10002826 	beq	r2,zero,8086a8 <__swsetup_r+0xdc>
  808608:	81400417 	ldw	r5,16(r16)
  80860c:	28001d26 	beq	r5,zero,808684 <__swsetup_r+0xb8>
  808610:	2080004c 	andi	r2,r4,1
  808614:	1005003a 	cmpeq	r2,r2,zero
  808618:	10000b26 	beq	r2,zero,808648 <__swsetup_r+0x7c>
  80861c:	2080008c 	andi	r2,r4,2
  808620:	10001226 	beq	r2,zero,80866c <__swsetup_r+0xa0>
  808624:	0005883a 	mov	r2,zero
  808628:	80800215 	stw	r2,8(r16)
  80862c:	28000b26 	beq	r5,zero,80865c <__swsetup_r+0x90>
  808630:	0005883a 	mov	r2,zero
  808634:	dfc00217 	ldw	ra,8(sp)
  808638:	dc400117 	ldw	r17,4(sp)
  80863c:	dc000017 	ldw	r16,0(sp)
  808640:	dec00304 	addi	sp,sp,12
  808644:	f800283a 	ret
  808648:	80800517 	ldw	r2,20(r16)
  80864c:	80000215 	stw	zero,8(r16)
  808650:	0085c83a 	sub	r2,zero,r2
  808654:	80800615 	stw	r2,24(r16)
  808658:	283ff51e 	bne	r5,zero,808630 <__swsetup_r+0x64>
  80865c:	2080200c 	andi	r2,r4,128
  808660:	103ff326 	beq	r2,zero,808630 <__swsetup_r+0x64>
  808664:	00bfffc4 	movi	r2,-1
  808668:	003ff206 	br	808634 <__swsetup_r+0x68>
  80866c:	80800517 	ldw	r2,20(r16)
  808670:	80800215 	stw	r2,8(r16)
  808674:	003fed06 	br	80862c <__swsetup_r+0x60>
  808678:	1809883a 	mov	r4,r3
  80867c:	080a1980 	call	80a198 <__sinit>
  808680:	003fde06 	br	8085fc <__swsetup_r+0x30>
  808684:	20c0a00c 	andi	r3,r4,640
  808688:	00808004 	movi	r2,512
  80868c:	18bfe026 	beq	r3,r2,808610 <__swsetup_r+0x44>
  808690:	8809883a 	mov	r4,r17
  808694:	800b883a 	mov	r5,r16
  808698:	080af440 	call	80af44 <__smakebuf_r>
  80869c:	8100030b 	ldhu	r4,12(r16)
  8086a0:	81400417 	ldw	r5,16(r16)
  8086a4:	003fda06 	br	808610 <__swsetup_r+0x44>
  8086a8:	2080040c 	andi	r2,r4,16
  8086ac:	103fed26 	beq	r2,zero,808664 <__swsetup_r+0x98>
  8086b0:	2080010c 	andi	r2,r4,4
  8086b4:	10001226 	beq	r2,zero,808700 <__swsetup_r+0x134>
  8086b8:	81400c17 	ldw	r5,48(r16)
  8086bc:	28000526 	beq	r5,zero,8086d4 <__swsetup_r+0x108>
  8086c0:	80801004 	addi	r2,r16,64
  8086c4:	28800226 	beq	r5,r2,8086d0 <__swsetup_r+0x104>
  8086c8:	8809883a 	mov	r4,r17
  8086cc:	080a5500 	call	80a550 <_free_r>
  8086d0:	80000c15 	stw	zero,48(r16)
  8086d4:	8080030b 	ldhu	r2,12(r16)
  8086d8:	81400417 	ldw	r5,16(r16)
  8086dc:	80000115 	stw	zero,4(r16)
  8086e0:	10bff6cc 	andi	r2,r2,65499
  8086e4:	8080030d 	sth	r2,12(r16)
  8086e8:	81400015 	stw	r5,0(r16)
  8086ec:	8080030b 	ldhu	r2,12(r16)
  8086f0:	10800214 	ori	r2,r2,8
  8086f4:	113fffcc 	andi	r4,r2,65535
  8086f8:	8080030d 	sth	r2,12(r16)
  8086fc:	003fc306 	br	80860c <__swsetup_r+0x40>
  808700:	81400417 	ldw	r5,16(r16)
  808704:	003ff906 	br	8086ec <__swsetup_r+0x120>

00808708 <quorem>:
  808708:	28c00417 	ldw	r3,16(r5)
  80870c:	20800417 	ldw	r2,16(r4)
  808710:	defff104 	addi	sp,sp,-60
  808714:	dfc00e15 	stw	ra,56(sp)
  808718:	df000d15 	stw	fp,52(sp)
  80871c:	ddc00c15 	stw	r23,48(sp)
  808720:	dd800b15 	stw	r22,44(sp)
  808724:	dd400a15 	stw	r21,40(sp)
  808728:	dd000915 	stw	r20,36(sp)
  80872c:	dcc00815 	stw	r19,32(sp)
  808730:	dc800715 	stw	r18,28(sp)
  808734:	dc400615 	stw	r17,24(sp)
  808738:	dc000515 	stw	r16,20(sp)
  80873c:	d9000315 	stw	r4,12(sp)
  808740:	d9400415 	stw	r5,16(sp)
  808744:	10c07f16 	blt	r2,r3,808944 <quorem+0x23c>
  808748:	1d3fffc4 	addi	r20,r3,-1
  80874c:	d8c00417 	ldw	r3,16(sp)
  808750:	d9000317 	ldw	r4,12(sp)
  808754:	a505883a 	add	r2,r20,r20
  808758:	1085883a 	add	r2,r2,r2
  80875c:	1cc00504 	addi	r19,r3,20
  808760:	25c00504 	addi	r23,r4,20
  808764:	98ad883a 	add	r22,r19,r2
  808768:	15c7883a 	add	r3,r2,r23
  80876c:	b1400017 	ldw	r5,0(r22)
  808770:	19000017 	ldw	r4,0(r3)
  808774:	d8c00015 	stw	r3,0(sp)
  808778:	29400044 	addi	r5,r5,1
  80877c:	d9000215 	stw	r4,8(sp)
  808780:	08064740 	call	806474 <__udivsi3>
  808784:	1039883a 	mov	fp,r2
  808788:	10003d1e 	bne	r2,zero,808880 <quorem+0x178>
  80878c:	d9400417 	ldw	r5,16(sp)
  808790:	d9000317 	ldw	r4,12(sp)
  808794:	080bc700 	call	80bc70 <__mcmp>
  808798:	10002c16 	blt	r2,zero,80884c <quorem+0x144>
  80879c:	e7000044 	addi	fp,fp,1
  8087a0:	b80f883a 	mov	r7,r23
  8087a4:	0011883a 	mov	r8,zero
  8087a8:	0009883a 	mov	r4,zero
  8087ac:	99400017 	ldw	r5,0(r19)
  8087b0:	38c00017 	ldw	r3,0(r7)
  8087b4:	9cc00104 	addi	r19,r19,4
  8087b8:	28bfffcc 	andi	r2,r5,65535
  8087bc:	2085883a 	add	r2,r4,r2
  8087c0:	11bfffcc 	andi	r6,r2,65535
  8087c4:	193fffcc 	andi	r4,r3,65535
  8087c8:	1004d43a 	srli	r2,r2,16
  8087cc:	280ad43a 	srli	r5,r5,16
  8087d0:	2189c83a 	sub	r4,r4,r6
  8087d4:	2209883a 	add	r4,r4,r8
  8087d8:	1806d43a 	srli	r3,r3,16
  8087dc:	288b883a 	add	r5,r5,r2
  8087e0:	200dd43a 	srai	r6,r4,16
  8087e4:	28bfffcc 	andi	r2,r5,65535
  8087e8:	1887c83a 	sub	r3,r3,r2
  8087ec:	1987883a 	add	r3,r3,r6
  8087f0:	3900000d 	sth	r4,0(r7)
  8087f4:	38c0008d 	sth	r3,2(r7)
  8087f8:	2808d43a 	srli	r4,r5,16
  8087fc:	39c00104 	addi	r7,r7,4
  808800:	1811d43a 	srai	r8,r3,16
  808804:	b4ffe92e 	bgeu	r22,r19,8087ac <quorem+0xa4>
  808808:	a505883a 	add	r2,r20,r20
  80880c:	1085883a 	add	r2,r2,r2
  808810:	b885883a 	add	r2,r23,r2
  808814:	10c00017 	ldw	r3,0(r2)
  808818:	18000c1e 	bne	r3,zero,80884c <quorem+0x144>
  80881c:	113fff04 	addi	r4,r2,-4
  808820:	b900082e 	bgeu	r23,r4,808844 <quorem+0x13c>
  808824:	10bfff17 	ldw	r2,-4(r2)
  808828:	10000326 	beq	r2,zero,808838 <quorem+0x130>
  80882c:	00000506 	br	808844 <quorem+0x13c>
  808830:	20800017 	ldw	r2,0(r4)
  808834:	1000031e 	bne	r2,zero,808844 <quorem+0x13c>
  808838:	213fff04 	addi	r4,r4,-4
  80883c:	a53fffc4 	addi	r20,r20,-1
  808840:	b93ffb36 	bltu	r23,r4,808830 <quorem+0x128>
  808844:	d9000317 	ldw	r4,12(sp)
  808848:	25000415 	stw	r20,16(r4)
  80884c:	e005883a 	mov	r2,fp
  808850:	dfc00e17 	ldw	ra,56(sp)
  808854:	df000d17 	ldw	fp,52(sp)
  808858:	ddc00c17 	ldw	r23,48(sp)
  80885c:	dd800b17 	ldw	r22,44(sp)
  808860:	dd400a17 	ldw	r21,40(sp)
  808864:	dd000917 	ldw	r20,36(sp)
  808868:	dcc00817 	ldw	r19,32(sp)
  80886c:	dc800717 	ldw	r18,28(sp)
  808870:	dc400617 	ldw	r17,24(sp)
  808874:	dc000517 	ldw	r16,20(sp)
  808878:	dec00f04 	addi	sp,sp,60
  80887c:	f800283a 	ret
  808880:	b823883a 	mov	r17,r23
  808884:	9825883a 	mov	r18,r19
  808888:	d8000115 	stw	zero,4(sp)
  80888c:	002b883a 	mov	r21,zero
  808890:	94000017 	ldw	r16,0(r18)
  808894:	e009883a 	mov	r4,fp
  808898:	94800104 	addi	r18,r18,4
  80889c:	817fffcc 	andi	r5,r16,65535
  8088a0:	08064840 	call	806484 <__mulsi3>
  8088a4:	800ad43a 	srli	r5,r16,16
  8088a8:	e009883a 	mov	r4,fp
  8088ac:	a8a1883a 	add	r16,r21,r2
  8088b0:	08064840 	call	806484 <__mulsi3>
  8088b4:	89000017 	ldw	r4,0(r17)
  8088b8:	80ffffcc 	andi	r3,r16,65535
  8088bc:	8020d43a 	srli	r16,r16,16
  8088c0:	217fffcc 	andi	r5,r4,65535
  8088c4:	28cbc83a 	sub	r5,r5,r3
  8088c8:	d8c00117 	ldw	r3,4(sp)
  8088cc:	2008d43a 	srli	r4,r4,16
  8088d0:	1405883a 	add	r2,r2,r16
  8088d4:	28cb883a 	add	r5,r5,r3
  8088d8:	280dd43a 	srai	r6,r5,16
  8088dc:	10ffffcc 	andi	r3,r2,65535
  8088e0:	20c9c83a 	sub	r4,r4,r3
  8088e4:	2189883a 	add	r4,r4,r6
  8088e8:	8900008d 	sth	r4,2(r17)
  8088ec:	2009d43a 	srai	r4,r4,16
  8088f0:	8940000d 	sth	r5,0(r17)
  8088f4:	102ad43a 	srli	r21,r2,16
  8088f8:	8c400104 	addi	r17,r17,4
  8088fc:	d9000115 	stw	r4,4(sp)
  808900:	b4bfe32e 	bgeu	r22,r18,808890 <quorem+0x188>
  808904:	d9000217 	ldw	r4,8(sp)
  808908:	203fa01e 	bne	r4,zero,80878c <quorem+0x84>
  80890c:	d8800017 	ldw	r2,0(sp)
  808910:	10ffff04 	addi	r3,r2,-4
  808914:	b8c0082e 	bgeu	r23,r3,808938 <quorem+0x230>
  808918:	10bfff17 	ldw	r2,-4(r2)
  80891c:	10000326 	beq	r2,zero,80892c <quorem+0x224>
  808920:	00000506 	br	808938 <quorem+0x230>
  808924:	18800017 	ldw	r2,0(r3)
  808928:	1000031e 	bne	r2,zero,808938 <quorem+0x230>
  80892c:	18ffff04 	addi	r3,r3,-4
  808930:	a53fffc4 	addi	r20,r20,-1
  808934:	b8fffb36 	bltu	r23,r3,808924 <quorem+0x21c>
  808938:	d8c00317 	ldw	r3,12(sp)
  80893c:	1d000415 	stw	r20,16(r3)
  808940:	003f9206 	br	80878c <quorem+0x84>
  808944:	0005883a 	mov	r2,zero
  808948:	003fc106 	br	808850 <quorem+0x148>

0080894c <_dtoa_r>:
  80894c:	22001017 	ldw	r8,64(r4)
  808950:	deffda04 	addi	sp,sp,-152
  808954:	dd402115 	stw	r21,132(sp)
  808958:	dd002015 	stw	r20,128(sp)
  80895c:	dc801e15 	stw	r18,120(sp)
  808960:	dc401d15 	stw	r17,116(sp)
  808964:	dfc02515 	stw	ra,148(sp)
  808968:	df002415 	stw	fp,144(sp)
  80896c:	ddc02315 	stw	r23,140(sp)
  808970:	dd802215 	stw	r22,136(sp)
  808974:	dcc01f15 	stw	r19,124(sp)
  808978:	dc001c15 	stw	r16,112(sp)
  80897c:	d9001615 	stw	r4,88(sp)
  808980:	3023883a 	mov	r17,r6
  808984:	2829883a 	mov	r20,r5
  808988:	d9c01715 	stw	r7,92(sp)
  80898c:	dc802817 	ldw	r18,160(sp)
  808990:	302b883a 	mov	r21,r6
  808994:	40000a26 	beq	r8,zero,8089c0 <_dtoa_r+0x74>
  808998:	20801117 	ldw	r2,68(r4)
  80899c:	400b883a 	mov	r5,r8
  8089a0:	40800115 	stw	r2,4(r8)
  8089a4:	20c01117 	ldw	r3,68(r4)
  8089a8:	00800044 	movi	r2,1
  8089ac:	10c4983a 	sll	r2,r2,r3
  8089b0:	40800215 	stw	r2,8(r8)
  8089b4:	080bb140 	call	80bb14 <_Bfree>
  8089b8:	d8c01617 	ldw	r3,88(sp)
  8089bc:	18001015 	stw	zero,64(r3)
  8089c0:	8800a316 	blt	r17,zero,808c50 <_dtoa_r+0x304>
  8089c4:	90000015 	stw	zero,0(r18)
  8089c8:	a8dffc2c 	andhi	r3,r21,32752
  8089cc:	009ffc34 	movhi	r2,32752
  8089d0:	18809126 	beq	r3,r2,808c18 <_dtoa_r+0x2cc>
  8089d4:	000d883a 	mov	r6,zero
  8089d8:	000f883a 	mov	r7,zero
  8089dc:	a009883a 	mov	r4,r20
  8089e0:	a80b883a 	mov	r5,r21
  8089e4:	dd001215 	stw	r20,72(sp)
  8089e8:	dd401315 	stw	r21,76(sp)
  8089ec:	080f20c0 	call	80f20c <__nedf2>
  8089f0:	1000171e 	bne	r2,zero,808a50 <_dtoa_r+0x104>
  8089f4:	d9802717 	ldw	r6,156(sp)
  8089f8:	00800044 	movi	r2,1
  8089fc:	30800015 	stw	r2,0(r6)
  808a00:	d8802917 	ldw	r2,164(sp)
  808a04:	10029b26 	beq	r2,zero,809474 <_dtoa_r+0xb28>
  808a08:	d9002917 	ldw	r4,164(sp)
  808a0c:	008020b4 	movhi	r2,130
  808a10:	10a06f44 	addi	r2,r2,-32323
  808a14:	10ffffc4 	addi	r3,r2,-1
  808a18:	20800015 	stw	r2,0(r4)
  808a1c:	1805883a 	mov	r2,r3
  808a20:	dfc02517 	ldw	ra,148(sp)
  808a24:	df002417 	ldw	fp,144(sp)
  808a28:	ddc02317 	ldw	r23,140(sp)
  808a2c:	dd802217 	ldw	r22,136(sp)
  808a30:	dd402117 	ldw	r21,132(sp)
  808a34:	dd002017 	ldw	r20,128(sp)
  808a38:	dcc01f17 	ldw	r19,124(sp)
  808a3c:	dc801e17 	ldw	r18,120(sp)
  808a40:	dc401d17 	ldw	r17,116(sp)
  808a44:	dc001c17 	ldw	r16,112(sp)
  808a48:	dec02604 	addi	sp,sp,152
  808a4c:	f800283a 	ret
  808a50:	d9001617 	ldw	r4,88(sp)
  808a54:	d9401217 	ldw	r5,72(sp)
  808a58:	d8800104 	addi	r2,sp,4
  808a5c:	a80d883a 	mov	r6,r21
  808a60:	d9c00204 	addi	r7,sp,8
  808a64:	d8800015 	stw	r2,0(sp)
  808a68:	080c1500 	call	80c150 <__d2b>
  808a6c:	d8800715 	stw	r2,28(sp)
  808a70:	a804d53a 	srli	r2,r21,20
  808a74:	1101ffcc 	andi	r4,r2,2047
  808a78:	20008626 	beq	r4,zero,808c94 <_dtoa_r+0x348>
  808a7c:	d8c01217 	ldw	r3,72(sp)
  808a80:	00800434 	movhi	r2,16
  808a84:	10bfffc4 	addi	r2,r2,-1
  808a88:	ddc00117 	ldw	r23,4(sp)
  808a8c:	a884703a 	and	r2,r21,r2
  808a90:	1811883a 	mov	r8,r3
  808a94:	124ffc34 	orhi	r9,r2,16368
  808a98:	25bf0044 	addi	r22,r4,-1023
  808a9c:	d8000815 	stw	zero,32(sp)
  808aa0:	0005883a 	mov	r2,zero
  808aa4:	00cffe34 	movhi	r3,16376
  808aa8:	480b883a 	mov	r5,r9
  808aac:	4009883a 	mov	r4,r8
  808ab0:	180f883a 	mov	r7,r3
  808ab4:	100d883a 	mov	r6,r2
  808ab8:	080ea740 	call	80ea74 <__subdf3>
  808abc:	0218dbf4 	movhi	r8,25455
  808ac0:	4210d844 	addi	r8,r8,17249
  808ac4:	024ff4f4 	movhi	r9,16339
  808ac8:	4a61e9c4 	addi	r9,r9,-30809
  808acc:	480f883a 	mov	r7,r9
  808ad0:	400d883a 	mov	r6,r8
  808ad4:	180b883a 	mov	r5,r3
  808ad8:	1009883a 	mov	r4,r2
  808adc:	080eb680 	call	80eb68 <__muldf3>
  808ae0:	0222d874 	movhi	r8,35681
  808ae4:	42322cc4 	addi	r8,r8,-14157
  808ae8:	024ff1f4 	movhi	r9,16327
  808aec:	4a628a04 	addi	r9,r9,-30168
  808af0:	480f883a 	mov	r7,r9
  808af4:	400d883a 	mov	r6,r8
  808af8:	180b883a 	mov	r5,r3
  808afc:	1009883a 	mov	r4,r2
  808b00:	080eaf40 	call	80eaf4 <__adddf3>
  808b04:	b009883a 	mov	r4,r22
  808b08:	1021883a 	mov	r16,r2
  808b0c:	1823883a 	mov	r17,r3
  808b10:	080f42c0 	call	80f42c <__floatsidf>
  808b14:	021427f4 	movhi	r8,20639
  808b18:	421e7ec4 	addi	r8,r8,31227
  808b1c:	024ff4f4 	movhi	r9,16339
  808b20:	4a5104c4 	addi	r9,r9,17427
  808b24:	480f883a 	mov	r7,r9
  808b28:	400d883a 	mov	r6,r8
  808b2c:	180b883a 	mov	r5,r3
  808b30:	1009883a 	mov	r4,r2
  808b34:	080eb680 	call	80eb68 <__muldf3>
  808b38:	180f883a 	mov	r7,r3
  808b3c:	880b883a 	mov	r5,r17
  808b40:	100d883a 	mov	r6,r2
  808b44:	8009883a 	mov	r4,r16
  808b48:	080eaf40 	call	80eaf4 <__adddf3>
  808b4c:	1009883a 	mov	r4,r2
  808b50:	180b883a 	mov	r5,r3
  808b54:	1021883a 	mov	r16,r2
  808b58:	1823883a 	mov	r17,r3
  808b5c:	080f5240 	call	80f524 <__fixdfsi>
  808b60:	000d883a 	mov	r6,zero
  808b64:	000f883a 	mov	r7,zero
  808b68:	8009883a 	mov	r4,r16
  808b6c:	880b883a 	mov	r5,r17
  808b70:	d8800d15 	stw	r2,52(sp)
  808b74:	080f3a40 	call	80f3a4 <__ltdf2>
  808b78:	10031716 	blt	r2,zero,8097d8 <_dtoa_r+0xe8c>
  808b7c:	d8c00d17 	ldw	r3,52(sp)
  808b80:	00800584 	movi	r2,22
  808b84:	10c1482e 	bgeu	r2,r3,8090a8 <_dtoa_r+0x75c>
  808b88:	01000044 	movi	r4,1
  808b8c:	d9000c15 	stw	r4,48(sp)
  808b90:	bd85c83a 	sub	r2,r23,r22
  808b94:	11bfffc4 	addi	r6,r2,-1
  808b98:	30030b16 	blt	r6,zero,8097c8 <_dtoa_r+0xe7c>
  808b9c:	d9800a15 	stw	r6,40(sp)
  808ba0:	d8001115 	stw	zero,68(sp)
  808ba4:	d8c00d17 	ldw	r3,52(sp)
  808ba8:	1802ff16 	blt	r3,zero,8097a8 <_dtoa_r+0xe5c>
  808bac:	d9000a17 	ldw	r4,40(sp)
  808bb0:	d8c00915 	stw	r3,36(sp)
  808bb4:	d8001015 	stw	zero,64(sp)
  808bb8:	20c9883a 	add	r4,r4,r3
  808bbc:	d9000a15 	stw	r4,40(sp)
  808bc0:	d9001717 	ldw	r4,92(sp)
  808bc4:	00800244 	movi	r2,9
  808bc8:	11004636 	bltu	r2,r4,808ce4 <_dtoa_r+0x398>
  808bcc:	00800144 	movi	r2,5
  808bd0:	11020416 	blt	r2,r4,8093e4 <_dtoa_r+0xa98>
  808bd4:	04400044 	movi	r17,1
  808bd8:	d8c01717 	ldw	r3,92(sp)
  808bdc:	00800144 	movi	r2,5
  808be0:	10c1ed36 	bltu	r2,r3,809398 <_dtoa_r+0xa4c>
  808be4:	18c5883a 	add	r2,r3,r3
  808be8:	1085883a 	add	r2,r2,r2
  808bec:	00c02074 	movhi	r3,129
  808bf0:	18e30004 	addi	r3,r3,-29696
  808bf4:	10c5883a 	add	r2,r2,r3
  808bf8:	11000017 	ldw	r4,0(r2)
  808bfc:	2000683a 	jmp	r4
  808c00:	00808cec 	andhi	r2,zero,563
  808c04:	00808cec 	andhi	r2,zero,563
  808c08:	008096ec 	andhi	r2,zero,603
  808c0c:	008096c4 	movi	r2,603
  808c10:	00809708 	cmpgei	r2,zero,604
  808c14:	00809714 	movui	r2,604
  808c18:	d9002717 	ldw	r4,156(sp)
  808c1c:	0089c3c4 	movi	r2,9999
  808c20:	20800015 	stw	r2,0(r4)
  808c24:	a0001026 	beq	r20,zero,808c68 <_dtoa_r+0x31c>
  808c28:	00c020b4 	movhi	r3,130
  808c2c:	18e17904 	addi	r3,r3,-31260
  808c30:	d9802917 	ldw	r6,164(sp)
  808c34:	303f7926 	beq	r6,zero,808a1c <_dtoa_r+0xd0>
  808c38:	188000c7 	ldb	r2,3(r3)
  808c3c:	190000c4 	addi	r4,r3,3
  808c40:	1000101e 	bne	r2,zero,808c84 <_dtoa_r+0x338>
  808c44:	d8802917 	ldw	r2,164(sp)
  808c48:	11000015 	stw	r4,0(r2)
  808c4c:	003f7306 	br	808a1c <_dtoa_r+0xd0>
  808c50:	00a00034 	movhi	r2,32768
  808c54:	10bfffc4 	addi	r2,r2,-1
  808c58:	00c00044 	movi	r3,1
  808c5c:	88aa703a 	and	r21,r17,r2
  808c60:	90c00015 	stw	r3,0(r18)
  808c64:	003f5806 	br	8089c8 <_dtoa_r+0x7c>
  808c68:	00800434 	movhi	r2,16
  808c6c:	10bfffc4 	addi	r2,r2,-1
  808c70:	a884703a 	and	r2,r21,r2
  808c74:	103fec1e 	bne	r2,zero,808c28 <_dtoa_r+0x2dc>
  808c78:	00c020b4 	movhi	r3,130
  808c7c:	18e17604 	addi	r3,r3,-31272
  808c80:	003feb06 	br	808c30 <_dtoa_r+0x2e4>
  808c84:	d8802917 	ldw	r2,164(sp)
  808c88:	19000204 	addi	r4,r3,8
  808c8c:	11000015 	stw	r4,0(r2)
  808c90:	003f6206 	br	808a1c <_dtoa_r+0xd0>
  808c94:	ddc00117 	ldw	r23,4(sp)
  808c98:	d8800217 	ldw	r2,8(sp)
  808c9c:	01000804 	movi	r4,32
  808ca0:	b8c10c84 	addi	r3,r23,1074
  808ca4:	18a3883a 	add	r17,r3,r2
  808ca8:	2441b80e 	bge	r4,r17,80938c <_dtoa_r+0xa40>
  808cac:	00c01004 	movi	r3,64
  808cb0:	1c47c83a 	sub	r3,r3,r17
  808cb4:	88bff804 	addi	r2,r17,-32
  808cb8:	a8c6983a 	sll	r3,r21,r3
  808cbc:	a084d83a 	srl	r2,r20,r2
  808cc0:	1888b03a 	or	r4,r3,r2
  808cc4:	080f5fc0 	call	80f5fc <__floatunsidf>
  808cc8:	1011883a 	mov	r8,r2
  808ccc:	00bf8434 	movhi	r2,65040
  808cd0:	01000044 	movi	r4,1
  808cd4:	10d3883a 	add	r9,r2,r3
  808cd8:	8dbef344 	addi	r22,r17,-1075
  808cdc:	d9000815 	stw	r4,32(sp)
  808ce0:	003f6f06 	br	808aa0 <_dtoa_r+0x154>
  808ce4:	d8001715 	stw	zero,92(sp)
  808ce8:	04400044 	movi	r17,1
  808cec:	00bfffc4 	movi	r2,-1
  808cf0:	00c00044 	movi	r3,1
  808cf4:	d8800e15 	stw	r2,56(sp)
  808cf8:	d8002615 	stw	zero,152(sp)
  808cfc:	d8800f15 	stw	r2,60(sp)
  808d00:	d8c00b15 	stw	r3,44(sp)
  808d04:	1021883a 	mov	r16,r2
  808d08:	d8801617 	ldw	r2,88(sp)
  808d0c:	10001115 	stw	zero,68(r2)
  808d10:	d8801617 	ldw	r2,88(sp)
  808d14:	11401117 	ldw	r5,68(r2)
  808d18:	1009883a 	mov	r4,r2
  808d1c:	080c0940 	call	80c094 <_Balloc>
  808d20:	d8c01617 	ldw	r3,88(sp)
  808d24:	d8800515 	stw	r2,20(sp)
  808d28:	18801015 	stw	r2,64(r3)
  808d2c:	00800384 	movi	r2,14
  808d30:	14006836 	bltu	r2,r16,808ed4 <_dtoa_r+0x588>
  808d34:	8805003a 	cmpeq	r2,r17,zero
  808d38:	1000661e 	bne	r2,zero,808ed4 <_dtoa_r+0x588>
  808d3c:	d9000d17 	ldw	r4,52(sp)
  808d40:	0102300e 	bge	zero,r4,809604 <_dtoa_r+0xcb8>
  808d44:	208003cc 	andi	r2,r4,15
  808d48:	100490fa 	slli	r2,r2,3
  808d4c:	2025d13a 	srai	r18,r4,4
  808d50:	00c020b4 	movhi	r3,130
  808d54:	18e18b04 	addi	r3,r3,-31188
  808d58:	10c5883a 	add	r2,r2,r3
  808d5c:	90c0040c 	andi	r3,r18,16
  808d60:	14000017 	ldw	r16,0(r2)
  808d64:	14400117 	ldw	r17,4(r2)
  808d68:	18036a1e 	bne	r3,zero,809b14 <_dtoa_r+0x11c8>
  808d6c:	05800084 	movi	r22,2
  808d70:	90001026 	beq	r18,zero,808db4 <_dtoa_r+0x468>
  808d74:	04c020b4 	movhi	r19,130
  808d78:	9ce1bd04 	addi	r19,r19,-30988
  808d7c:	9080004c 	andi	r2,r18,1
  808d80:	1005003a 	cmpeq	r2,r2,zero
  808d84:	1000081e 	bne	r2,zero,808da8 <_dtoa_r+0x45c>
  808d88:	99800017 	ldw	r6,0(r19)
  808d8c:	99c00117 	ldw	r7,4(r19)
  808d90:	880b883a 	mov	r5,r17
  808d94:	8009883a 	mov	r4,r16
  808d98:	080eb680 	call	80eb68 <__muldf3>
  808d9c:	1021883a 	mov	r16,r2
  808da0:	b5800044 	addi	r22,r22,1
  808da4:	1823883a 	mov	r17,r3
  808da8:	9025d07a 	srai	r18,r18,1
  808dac:	9cc00204 	addi	r19,r19,8
  808db0:	903ff21e 	bne	r18,zero,808d7c <_dtoa_r+0x430>
  808db4:	a80b883a 	mov	r5,r21
  808db8:	a009883a 	mov	r4,r20
  808dbc:	880f883a 	mov	r7,r17
  808dc0:	800d883a 	mov	r6,r16
  808dc4:	080ef2c0 	call	80ef2c <__divdf3>
  808dc8:	1029883a 	mov	r20,r2
  808dcc:	182b883a 	mov	r21,r3
  808dd0:	d8c00c17 	ldw	r3,48(sp)
  808dd4:	1805003a 	cmpeq	r2,r3,zero
  808dd8:	1000081e 	bne	r2,zero,808dfc <_dtoa_r+0x4b0>
  808ddc:	0005883a 	mov	r2,zero
  808de0:	00cffc34 	movhi	r3,16368
  808de4:	180f883a 	mov	r7,r3
  808de8:	a009883a 	mov	r4,r20
  808dec:	a80b883a 	mov	r5,r21
  808df0:	100d883a 	mov	r6,r2
  808df4:	080f3a40 	call	80f3a4 <__ltdf2>
  808df8:	1003fe16 	blt	r2,zero,809df4 <_dtoa_r+0x14a8>
  808dfc:	b009883a 	mov	r4,r22
  808e00:	080f42c0 	call	80f42c <__floatsidf>
  808e04:	180b883a 	mov	r5,r3
  808e08:	1009883a 	mov	r4,r2
  808e0c:	a00d883a 	mov	r6,r20
  808e10:	a80f883a 	mov	r7,r21
  808e14:	080eb680 	call	80eb68 <__muldf3>
  808e18:	0011883a 	mov	r8,zero
  808e1c:	02500734 	movhi	r9,16412
  808e20:	1009883a 	mov	r4,r2
  808e24:	180b883a 	mov	r5,r3
  808e28:	480f883a 	mov	r7,r9
  808e2c:	400d883a 	mov	r6,r8
  808e30:	080eaf40 	call	80eaf4 <__adddf3>
  808e34:	d9000f17 	ldw	r4,60(sp)
  808e38:	102d883a 	mov	r22,r2
  808e3c:	00bf3034 	movhi	r2,64704
  808e40:	18b9883a 	add	fp,r3,r2
  808e44:	e02f883a 	mov	r23,fp
  808e48:	20028f1e 	bne	r4,zero,809888 <_dtoa_r+0xf3c>
  808e4c:	0005883a 	mov	r2,zero
  808e50:	00d00534 	movhi	r3,16404
  808e54:	a009883a 	mov	r4,r20
  808e58:	a80b883a 	mov	r5,r21
  808e5c:	180f883a 	mov	r7,r3
  808e60:	100d883a 	mov	r6,r2
  808e64:	080ea740 	call	80ea74 <__subdf3>
  808e68:	1009883a 	mov	r4,r2
  808e6c:	e00f883a 	mov	r7,fp
  808e70:	180b883a 	mov	r5,r3
  808e74:	b00d883a 	mov	r6,r22
  808e78:	1025883a 	mov	r18,r2
  808e7c:	1827883a 	mov	r19,r3
  808e80:	080f2940 	call	80f294 <__gtdf2>
  808e84:	00834f16 	blt	zero,r2,809bc4 <_dtoa_r+0x1278>
  808e88:	e0e0003c 	xorhi	r3,fp,32768
  808e8c:	9009883a 	mov	r4,r18
  808e90:	980b883a 	mov	r5,r19
  808e94:	180f883a 	mov	r7,r3
  808e98:	b00d883a 	mov	r6,r22
  808e9c:	080f3a40 	call	80f3a4 <__ltdf2>
  808ea0:	1000080e 	bge	r2,zero,808ec4 <_dtoa_r+0x578>
  808ea4:	0027883a 	mov	r19,zero
  808ea8:	0025883a 	mov	r18,zero
  808eac:	d8802617 	ldw	r2,152(sp)
  808eb0:	df000517 	ldw	fp,20(sp)
  808eb4:	d8000615 	stw	zero,24(sp)
  808eb8:	0084303a 	nor	r2,zero,r2
  808ebc:	d8800d15 	stw	r2,52(sp)
  808ec0:	00019b06 	br	809530 <_dtoa_r+0xbe4>
  808ec4:	d9801217 	ldw	r6,72(sp)
  808ec8:	d8801317 	ldw	r2,76(sp)
  808ecc:	3029883a 	mov	r20,r6
  808ed0:	102b883a 	mov	r21,r2
  808ed4:	d8c00217 	ldw	r3,8(sp)
  808ed8:	18008516 	blt	r3,zero,8090f0 <_dtoa_r+0x7a4>
  808edc:	d9000d17 	ldw	r4,52(sp)
  808ee0:	00800384 	movi	r2,14
  808ee4:	11008216 	blt	r2,r4,8090f0 <_dtoa_r+0x7a4>
  808ee8:	200490fa 	slli	r2,r4,3
  808eec:	d9802617 	ldw	r6,152(sp)
  808ef0:	00c020b4 	movhi	r3,130
  808ef4:	18e18b04 	addi	r3,r3,-31188
  808ef8:	10c5883a 	add	r2,r2,r3
  808efc:	14800017 	ldw	r18,0(r2)
  808f00:	14c00117 	ldw	r19,4(r2)
  808f04:	30031e16 	blt	r6,zero,809b80 <_dtoa_r+0x1234>
  808f08:	d9000517 	ldw	r4,20(sp)
  808f0c:	d8c00f17 	ldw	r3,60(sp)
  808f10:	a823883a 	mov	r17,r21
  808f14:	a021883a 	mov	r16,r20
  808f18:	192b883a 	add	r21,r3,r4
  808f1c:	2039883a 	mov	fp,r4
  808f20:	00000f06 	br	808f60 <_dtoa_r+0x614>
  808f24:	0005883a 	mov	r2,zero
  808f28:	00d00934 	movhi	r3,16420
  808f2c:	5009883a 	mov	r4,r10
  808f30:	580b883a 	mov	r5,r11
  808f34:	180f883a 	mov	r7,r3
  808f38:	100d883a 	mov	r6,r2
  808f3c:	080eb680 	call	80eb68 <__muldf3>
  808f40:	180b883a 	mov	r5,r3
  808f44:	000d883a 	mov	r6,zero
  808f48:	000f883a 	mov	r7,zero
  808f4c:	1009883a 	mov	r4,r2
  808f50:	1021883a 	mov	r16,r2
  808f54:	1823883a 	mov	r17,r3
  808f58:	080f20c0 	call	80f20c <__nedf2>
  808f5c:	10004526 	beq	r2,zero,809074 <_dtoa_r+0x728>
  808f60:	900d883a 	mov	r6,r18
  808f64:	980f883a 	mov	r7,r19
  808f68:	8009883a 	mov	r4,r16
  808f6c:	880b883a 	mov	r5,r17
  808f70:	080ef2c0 	call	80ef2c <__divdf3>
  808f74:	180b883a 	mov	r5,r3
  808f78:	1009883a 	mov	r4,r2
  808f7c:	080f5240 	call	80f524 <__fixdfsi>
  808f80:	1009883a 	mov	r4,r2
  808f84:	1029883a 	mov	r20,r2
  808f88:	080f42c0 	call	80f42c <__floatsidf>
  808f8c:	180f883a 	mov	r7,r3
  808f90:	9009883a 	mov	r4,r18
  808f94:	980b883a 	mov	r5,r19
  808f98:	100d883a 	mov	r6,r2
  808f9c:	080eb680 	call	80eb68 <__muldf3>
  808fa0:	180f883a 	mov	r7,r3
  808fa4:	880b883a 	mov	r5,r17
  808fa8:	8009883a 	mov	r4,r16
  808fac:	100d883a 	mov	r6,r2
  808fb0:	080ea740 	call	80ea74 <__subdf3>
  808fb4:	1015883a 	mov	r10,r2
  808fb8:	a0800c04 	addi	r2,r20,48
  808fbc:	e0800005 	stb	r2,0(fp)
  808fc0:	e7000044 	addi	fp,fp,1
  808fc4:	1817883a 	mov	r11,r3
  808fc8:	e57fd61e 	bne	fp,r21,808f24 <_dtoa_r+0x5d8>
  808fcc:	500d883a 	mov	r6,r10
  808fd0:	180f883a 	mov	r7,r3
  808fd4:	5009883a 	mov	r4,r10
  808fd8:	180b883a 	mov	r5,r3
  808fdc:	080eaf40 	call	80eaf4 <__adddf3>
  808fe0:	100d883a 	mov	r6,r2
  808fe4:	9009883a 	mov	r4,r18
  808fe8:	980b883a 	mov	r5,r19
  808fec:	180f883a 	mov	r7,r3
  808ff0:	1021883a 	mov	r16,r2
  808ff4:	1823883a 	mov	r17,r3
  808ff8:	080f3a40 	call	80f3a4 <__ltdf2>
  808ffc:	10000816 	blt	r2,zero,809020 <_dtoa_r+0x6d4>
  809000:	980b883a 	mov	r5,r19
  809004:	800d883a 	mov	r6,r16
  809008:	880f883a 	mov	r7,r17
  80900c:	9009883a 	mov	r4,r18
  809010:	080f1840 	call	80f184 <__eqdf2>
  809014:	1000171e 	bne	r2,zero,809074 <_dtoa_r+0x728>
  809018:	a080004c 	andi	r2,r20,1
  80901c:	10001526 	beq	r2,zero,809074 <_dtoa_r+0x728>
  809020:	d8800d17 	ldw	r2,52(sp)
  809024:	d8800415 	stw	r2,16(sp)
  809028:	e009883a 	mov	r4,fp
  80902c:	213fffc4 	addi	r4,r4,-1
  809030:	20c00007 	ldb	r3,0(r4)
  809034:	00800e44 	movi	r2,57
  809038:	1880081e 	bne	r3,r2,80905c <_dtoa_r+0x710>
  80903c:	d8800517 	ldw	r2,20(sp)
  809040:	113ffa1e 	bne	r2,r4,80902c <_dtoa_r+0x6e0>
  809044:	d8c00417 	ldw	r3,16(sp)
  809048:	d9800517 	ldw	r6,20(sp)
  80904c:	00800c04 	movi	r2,48
  809050:	18c00044 	addi	r3,r3,1
  809054:	d8c00415 	stw	r3,16(sp)
  809058:	30800005 	stb	r2,0(r6)
  80905c:	20800003 	ldbu	r2,0(r4)
  809060:	d8c00417 	ldw	r3,16(sp)
  809064:	27000044 	addi	fp,r4,1
  809068:	10800044 	addi	r2,r2,1
  80906c:	d8c00d15 	stw	r3,52(sp)
  809070:	20800005 	stb	r2,0(r4)
  809074:	d9001617 	ldw	r4,88(sp)
  809078:	d9400717 	ldw	r5,28(sp)
  80907c:	080bb140 	call	80bb14 <_Bfree>
  809080:	e0000005 	stb	zero,0(fp)
  809084:	d9800d17 	ldw	r6,52(sp)
  809088:	d8c02717 	ldw	r3,156(sp)
  80908c:	d9002917 	ldw	r4,164(sp)
  809090:	30800044 	addi	r2,r6,1
  809094:	18800015 	stw	r2,0(r3)
  809098:	20029c26 	beq	r4,zero,809b0c <_dtoa_r+0x11c0>
  80909c:	d8c00517 	ldw	r3,20(sp)
  8090a0:	27000015 	stw	fp,0(r4)
  8090a4:	003e5d06 	br	808a1c <_dtoa_r+0xd0>
  8090a8:	d9800d17 	ldw	r6,52(sp)
  8090ac:	00c020b4 	movhi	r3,130
  8090b0:	18e18b04 	addi	r3,r3,-31188
  8090b4:	d9001217 	ldw	r4,72(sp)
  8090b8:	300490fa 	slli	r2,r6,3
  8090bc:	d9401317 	ldw	r5,76(sp)
  8090c0:	10c5883a 	add	r2,r2,r3
  8090c4:	12000017 	ldw	r8,0(r2)
  8090c8:	12400117 	ldw	r9,4(r2)
  8090cc:	400d883a 	mov	r6,r8
  8090d0:	480f883a 	mov	r7,r9
  8090d4:	080f3a40 	call	80f3a4 <__ltdf2>
  8090d8:	1000030e 	bge	r2,zero,8090e8 <_dtoa_r+0x79c>
  8090dc:	d8800d17 	ldw	r2,52(sp)
  8090e0:	10bfffc4 	addi	r2,r2,-1
  8090e4:	d8800d15 	stw	r2,52(sp)
  8090e8:	d8000c15 	stw	zero,48(sp)
  8090ec:	003ea806 	br	808b90 <_dtoa_r+0x244>
  8090f0:	d9000b17 	ldw	r4,44(sp)
  8090f4:	202cc03a 	cmpne	r22,r4,zero
  8090f8:	b000c71e 	bne	r22,zero,809418 <_dtoa_r+0xacc>
  8090fc:	dc001117 	ldw	r16,68(sp)
  809100:	dc801017 	ldw	r18,64(sp)
  809104:	0027883a 	mov	r19,zero
  809108:	04000b0e 	bge	zero,r16,809138 <_dtoa_r+0x7ec>
  80910c:	d8c00a17 	ldw	r3,40(sp)
  809110:	00c0090e 	bge	zero,r3,809138 <_dtoa_r+0x7ec>
  809114:	8005883a 	mov	r2,r16
  809118:	1c011316 	blt	r3,r16,809568 <_dtoa_r+0xc1c>
  80911c:	d9000a17 	ldw	r4,40(sp)
  809120:	d9801117 	ldw	r6,68(sp)
  809124:	80a1c83a 	sub	r16,r16,r2
  809128:	2089c83a 	sub	r4,r4,r2
  80912c:	308dc83a 	sub	r6,r6,r2
  809130:	d9000a15 	stw	r4,40(sp)
  809134:	d9801115 	stw	r6,68(sp)
  809138:	d8801017 	ldw	r2,64(sp)
  80913c:	0080150e 	bge	zero,r2,809194 <_dtoa_r+0x848>
  809140:	d8c00b17 	ldw	r3,44(sp)
  809144:	1805003a 	cmpeq	r2,r3,zero
  809148:	1001c91e 	bne	r2,zero,809870 <_dtoa_r+0xf24>
  80914c:	04800e0e 	bge	zero,r18,809188 <_dtoa_r+0x83c>
  809150:	d9001617 	ldw	r4,88(sp)
  809154:	980b883a 	mov	r5,r19
  809158:	900d883a 	mov	r6,r18
  80915c:	080c9600 	call	80c960 <__pow5mult>
  809160:	d9001617 	ldw	r4,88(sp)
  809164:	d9800717 	ldw	r6,28(sp)
  809168:	100b883a 	mov	r5,r2
  80916c:	1027883a 	mov	r19,r2
  809170:	080c5a40 	call	80c5a4 <__multiply>
  809174:	d9001617 	ldw	r4,88(sp)
  809178:	d9400717 	ldw	r5,28(sp)
  80917c:	1023883a 	mov	r17,r2
  809180:	080bb140 	call	80bb14 <_Bfree>
  809184:	dc400715 	stw	r17,28(sp)
  809188:	d9001017 	ldw	r4,64(sp)
  80918c:	248dc83a 	sub	r6,r4,r18
  809190:	30010e1e 	bne	r6,zero,8095cc <_dtoa_r+0xc80>
  809194:	d9001617 	ldw	r4,88(sp)
  809198:	04400044 	movi	r17,1
  80919c:	880b883a 	mov	r5,r17
  8091a0:	080c7f80 	call	80c7f8 <__i2b>
  8091a4:	d9800917 	ldw	r6,36(sp)
  8091a8:	1025883a 	mov	r18,r2
  8091ac:	0180040e 	bge	zero,r6,8091c0 <_dtoa_r+0x874>
  8091b0:	d9001617 	ldw	r4,88(sp)
  8091b4:	100b883a 	mov	r5,r2
  8091b8:	080c9600 	call	80c960 <__pow5mult>
  8091bc:	1025883a 	mov	r18,r2
  8091c0:	d8801717 	ldw	r2,92(sp)
  8091c4:	8880f30e 	bge	r17,r2,809594 <_dtoa_r+0xc48>
  8091c8:	0023883a 	mov	r17,zero
  8091cc:	d9800917 	ldw	r6,36(sp)
  8091d0:	30019e1e 	bne	r6,zero,80984c <_dtoa_r+0xf00>
  8091d4:	00c00044 	movi	r3,1
  8091d8:	d9000a17 	ldw	r4,40(sp)
  8091dc:	20c5883a 	add	r2,r4,r3
  8091e0:	10c007cc 	andi	r3,r2,31
  8091e4:	1800841e 	bne	r3,zero,8093f8 <_dtoa_r+0xaac>
  8091e8:	00800704 	movi	r2,28
  8091ec:	d9000a17 	ldw	r4,40(sp)
  8091f0:	d9801117 	ldw	r6,68(sp)
  8091f4:	80a1883a 	add	r16,r16,r2
  8091f8:	2089883a 	add	r4,r4,r2
  8091fc:	308d883a 	add	r6,r6,r2
  809200:	d9000a15 	stw	r4,40(sp)
  809204:	d9801115 	stw	r6,68(sp)
  809208:	d8801117 	ldw	r2,68(sp)
  80920c:	0080050e 	bge	zero,r2,809224 <_dtoa_r+0x8d8>
  809210:	d9400717 	ldw	r5,28(sp)
  809214:	d9001617 	ldw	r4,88(sp)
  809218:	100d883a 	mov	r6,r2
  80921c:	080c4580 	call	80c458 <__lshift>
  809220:	d8800715 	stw	r2,28(sp)
  809224:	d8c00a17 	ldw	r3,40(sp)
  809228:	00c0050e 	bge	zero,r3,809240 <_dtoa_r+0x8f4>
  80922c:	d9001617 	ldw	r4,88(sp)
  809230:	900b883a 	mov	r5,r18
  809234:	180d883a 	mov	r6,r3
  809238:	080c4580 	call	80c458 <__lshift>
  80923c:	1025883a 	mov	r18,r2
  809240:	d9000c17 	ldw	r4,48(sp)
  809244:	2005003a 	cmpeq	r2,r4,zero
  809248:	10016f26 	beq	r2,zero,809808 <_dtoa_r+0xebc>
  80924c:	d9000f17 	ldw	r4,60(sp)
  809250:	0102170e 	bge	zero,r4,809ab0 <_dtoa_r+0x1164>
  809254:	d9800b17 	ldw	r6,44(sp)
  809258:	3005003a 	cmpeq	r2,r6,zero
  80925c:	1000881e 	bne	r2,zero,809480 <_dtoa_r+0xb34>
  809260:	0400050e 	bge	zero,r16,809278 <_dtoa_r+0x92c>
  809264:	d9001617 	ldw	r4,88(sp)
  809268:	980b883a 	mov	r5,r19
  80926c:	800d883a 	mov	r6,r16
  809270:	080c4580 	call	80c458 <__lshift>
  809274:	1027883a 	mov	r19,r2
  809278:	8804c03a 	cmpne	r2,r17,zero
  80927c:	1002541e 	bne	r2,zero,809bd0 <_dtoa_r+0x1284>
  809280:	980b883a 	mov	r5,r19
  809284:	dd800517 	ldw	r22,20(sp)
  809288:	dcc00615 	stw	r19,24(sp)
  80928c:	a700004c 	andi	fp,r20,1
  809290:	2827883a 	mov	r19,r5
  809294:	d9000717 	ldw	r4,28(sp)
  809298:	900b883a 	mov	r5,r18
  80929c:	08087080 	call	808708 <quorem>
  8092a0:	d9000717 	ldw	r4,28(sp)
  8092a4:	d9400617 	ldw	r5,24(sp)
  8092a8:	1023883a 	mov	r17,r2
  8092ac:	8dc00c04 	addi	r23,r17,48
  8092b0:	080bc700 	call	80bc70 <__mcmp>
  8092b4:	d9001617 	ldw	r4,88(sp)
  8092b8:	900b883a 	mov	r5,r18
  8092bc:	980d883a 	mov	r6,r19
  8092c0:	1029883a 	mov	r20,r2
  8092c4:	080c2cc0 	call	80c2cc <__mdiff>
  8092c8:	102b883a 	mov	r21,r2
  8092cc:	10800317 	ldw	r2,12(r2)
  8092d0:	1001281e 	bne	r2,zero,809774 <_dtoa_r+0xe28>
  8092d4:	d9000717 	ldw	r4,28(sp)
  8092d8:	a80b883a 	mov	r5,r21
  8092dc:	080bc700 	call	80bc70 <__mcmp>
  8092e0:	d9001617 	ldw	r4,88(sp)
  8092e4:	1021883a 	mov	r16,r2
  8092e8:	a80b883a 	mov	r5,r21
  8092ec:	080bb140 	call	80bb14 <_Bfree>
  8092f0:	8000041e 	bne	r16,zero,809304 <_dtoa_r+0x9b8>
  8092f4:	d8801717 	ldw	r2,92(sp)
  8092f8:	1000021e 	bne	r2,zero,809304 <_dtoa_r+0x9b8>
  8092fc:	e004c03a 	cmpne	r2,fp,zero
  809300:	10011726 	beq	r2,zero,809760 <_dtoa_r+0xe14>
  809304:	a0010616 	blt	r20,zero,809720 <_dtoa_r+0xdd4>
  809308:	a000041e 	bne	r20,zero,80931c <_dtoa_r+0x9d0>
  80930c:	d8c01717 	ldw	r3,92(sp)
  809310:	1800021e 	bne	r3,zero,80931c <_dtoa_r+0x9d0>
  809314:	e004c03a 	cmpne	r2,fp,zero
  809318:	10010126 	beq	r2,zero,809720 <_dtoa_r+0xdd4>
  80931c:	04023d16 	blt	zero,r16,809c14 <_dtoa_r+0x12c8>
  809320:	b5c00005 	stb	r23,0(r22)
  809324:	d9800517 	ldw	r6,20(sp)
  809328:	d9000f17 	ldw	r4,60(sp)
  80932c:	b5800044 	addi	r22,r22,1
  809330:	3105883a 	add	r2,r6,r4
  809334:	b0806526 	beq	r22,r2,8094cc <_dtoa_r+0xb80>
  809338:	d9400717 	ldw	r5,28(sp)
  80933c:	d9001617 	ldw	r4,88(sp)
  809340:	01800284 	movi	r6,10
  809344:	000f883a 	mov	r7,zero
  809348:	080c8340 	call	80c834 <__multadd>
  80934c:	d8800715 	stw	r2,28(sp)
  809350:	d8800617 	ldw	r2,24(sp)
  809354:	14c10c26 	beq	r2,r19,809788 <_dtoa_r+0xe3c>
  809358:	d9400617 	ldw	r5,24(sp)
  80935c:	d9001617 	ldw	r4,88(sp)
  809360:	01800284 	movi	r6,10
  809364:	000f883a 	mov	r7,zero
  809368:	080c8340 	call	80c834 <__multadd>
  80936c:	d9001617 	ldw	r4,88(sp)
  809370:	980b883a 	mov	r5,r19
  809374:	01800284 	movi	r6,10
  809378:	000f883a 	mov	r7,zero
  80937c:	d8800615 	stw	r2,24(sp)
  809380:	080c8340 	call	80c834 <__multadd>
  809384:	1027883a 	mov	r19,r2
  809388:	003fc206 	br	809294 <_dtoa_r+0x948>
  80938c:	2445c83a 	sub	r2,r4,r17
  809390:	a088983a 	sll	r4,r20,r2
  809394:	003e4b06 	br	808cc4 <_dtoa_r+0x378>
  809398:	01bfffc4 	movi	r6,-1
  80939c:	00800044 	movi	r2,1
  8093a0:	d9800e15 	stw	r6,56(sp)
  8093a4:	d9800f15 	stw	r6,60(sp)
  8093a8:	d8800b15 	stw	r2,44(sp)
  8093ac:	d8c01617 	ldw	r3,88(sp)
  8093b0:	008005c4 	movi	r2,23
  8093b4:	18001115 	stw	zero,68(r3)
  8093b8:	1580082e 	bgeu	r2,r22,8093dc <_dtoa_r+0xa90>
  8093bc:	00c00104 	movi	r3,4
  8093c0:	0009883a 	mov	r4,zero
  8093c4:	18c7883a 	add	r3,r3,r3
  8093c8:	18800504 	addi	r2,r3,20
  8093cc:	21000044 	addi	r4,r4,1
  8093d0:	b0bffc2e 	bgeu	r22,r2,8093c4 <_dtoa_r+0xa78>
  8093d4:	d9801617 	ldw	r6,88(sp)
  8093d8:	31001115 	stw	r4,68(r6)
  8093dc:	dc000f17 	ldw	r16,60(sp)
  8093e0:	003e4b06 	br	808d10 <_dtoa_r+0x3c4>
  8093e4:	d9801717 	ldw	r6,92(sp)
  8093e8:	0023883a 	mov	r17,zero
  8093ec:	31bfff04 	addi	r6,r6,-4
  8093f0:	d9801715 	stw	r6,92(sp)
  8093f4:	003df806 	br	808bd8 <_dtoa_r+0x28c>
  8093f8:	00800804 	movi	r2,32
  8093fc:	10c9c83a 	sub	r4,r2,r3
  809400:	00c00104 	movi	r3,4
  809404:	19005a16 	blt	r3,r4,809570 <_dtoa_r+0xc24>
  809408:	008000c4 	movi	r2,3
  80940c:	113f7e16 	blt	r2,r4,809208 <_dtoa_r+0x8bc>
  809410:	20800704 	addi	r2,r4,28
  809414:	003f7506 	br	8091ec <_dtoa_r+0x8a0>
  809418:	d9801717 	ldw	r6,92(sp)
  80941c:	00800044 	movi	r2,1
  809420:	1180a10e 	bge	r2,r6,8096a8 <_dtoa_r+0xd5c>
  809424:	d9800f17 	ldw	r6,60(sp)
  809428:	d8c01017 	ldw	r3,64(sp)
  80942c:	30bfffc4 	addi	r2,r6,-1
  809430:	1881c616 	blt	r3,r2,809b4c <_dtoa_r+0x1200>
  809434:	18a5c83a 	sub	r18,r3,r2
  809438:	d8800f17 	ldw	r2,60(sp)
  80943c:	10026216 	blt	r2,zero,809dc8 <_dtoa_r+0x147c>
  809440:	dc001117 	ldw	r16,68(sp)
  809444:	1007883a 	mov	r3,r2
  809448:	d9800a17 	ldw	r6,40(sp)
  80944c:	d8801117 	ldw	r2,68(sp)
  809450:	d9001617 	ldw	r4,88(sp)
  809454:	30cd883a 	add	r6,r6,r3
  809458:	10c5883a 	add	r2,r2,r3
  80945c:	01400044 	movi	r5,1
  809460:	d9800a15 	stw	r6,40(sp)
  809464:	d8801115 	stw	r2,68(sp)
  809468:	080c7f80 	call	80c7f8 <__i2b>
  80946c:	1027883a 	mov	r19,r2
  809470:	003f2506 	br	809108 <_dtoa_r+0x7bc>
  809474:	00c020b4 	movhi	r3,130
  809478:	18e06f04 	addi	r3,r3,-32324
  80947c:	003d6706 	br	808a1c <_dtoa_r+0xd0>
  809480:	dd800517 	ldw	r22,20(sp)
  809484:	04000044 	movi	r16,1
  809488:	00000706 	br	8094a8 <_dtoa_r+0xb5c>
  80948c:	d9400717 	ldw	r5,28(sp)
  809490:	d9001617 	ldw	r4,88(sp)
  809494:	01800284 	movi	r6,10
  809498:	000f883a 	mov	r7,zero
  80949c:	080c8340 	call	80c834 <__multadd>
  8094a0:	d8800715 	stw	r2,28(sp)
  8094a4:	84000044 	addi	r16,r16,1
  8094a8:	d9000717 	ldw	r4,28(sp)
  8094ac:	900b883a 	mov	r5,r18
  8094b0:	08087080 	call	808708 <quorem>
  8094b4:	15c00c04 	addi	r23,r2,48
  8094b8:	b5c00005 	stb	r23,0(r22)
  8094bc:	d8c00f17 	ldw	r3,60(sp)
  8094c0:	b5800044 	addi	r22,r22,1
  8094c4:	80fff116 	blt	r16,r3,80948c <_dtoa_r+0xb40>
  8094c8:	d8000615 	stw	zero,24(sp)
  8094cc:	d9400717 	ldw	r5,28(sp)
  8094d0:	d9001617 	ldw	r4,88(sp)
  8094d4:	01800044 	movi	r6,1
  8094d8:	080c4580 	call	80c458 <__lshift>
  8094dc:	1009883a 	mov	r4,r2
  8094e0:	900b883a 	mov	r5,r18
  8094e4:	d8800715 	stw	r2,28(sp)
  8094e8:	080bc700 	call	80bc70 <__mcmp>
  8094ec:	00803c0e 	bge	zero,r2,8095e0 <_dtoa_r+0xc94>
  8094f0:	b009883a 	mov	r4,r22
  8094f4:	213fffc4 	addi	r4,r4,-1
  8094f8:	21400003 	ldbu	r5,0(r4)
  8094fc:	00800e44 	movi	r2,57
  809500:	28c03fcc 	andi	r3,r5,255
  809504:	18c0201c 	xori	r3,r3,128
  809508:	18ffe004 	addi	r3,r3,-128
  80950c:	1881981e 	bne	r3,r2,809b70 <_dtoa_r+0x1224>
  809510:	d9800517 	ldw	r6,20(sp)
  809514:	21bff71e 	bne	r4,r6,8094f4 <_dtoa_r+0xba8>
  809518:	d8800d17 	ldw	r2,52(sp)
  80951c:	37000044 	addi	fp,r6,1
  809520:	10800044 	addi	r2,r2,1
  809524:	d8800d15 	stw	r2,52(sp)
  809528:	00800c44 	movi	r2,49
  80952c:	30800005 	stb	r2,0(r6)
  809530:	d9001617 	ldw	r4,88(sp)
  809534:	900b883a 	mov	r5,r18
  809538:	080bb140 	call	80bb14 <_Bfree>
  80953c:	983ecd26 	beq	r19,zero,809074 <_dtoa_r+0x728>
  809540:	d8c00617 	ldw	r3,24(sp)
  809544:	18000426 	beq	r3,zero,809558 <_dtoa_r+0xc0c>
  809548:	1cc00326 	beq	r3,r19,809558 <_dtoa_r+0xc0c>
  80954c:	d9001617 	ldw	r4,88(sp)
  809550:	180b883a 	mov	r5,r3
  809554:	080bb140 	call	80bb14 <_Bfree>
  809558:	d9001617 	ldw	r4,88(sp)
  80955c:	980b883a 	mov	r5,r19
  809560:	080bb140 	call	80bb14 <_Bfree>
  809564:	003ec306 	br	809074 <_dtoa_r+0x728>
  809568:	1805883a 	mov	r2,r3
  80956c:	003eeb06 	br	80911c <_dtoa_r+0x7d0>
  809570:	d9800a17 	ldw	r6,40(sp)
  809574:	d8c01117 	ldw	r3,68(sp)
  809578:	20bfff04 	addi	r2,r4,-4
  80957c:	308d883a 	add	r6,r6,r2
  809580:	1887883a 	add	r3,r3,r2
  809584:	80a1883a 	add	r16,r16,r2
  809588:	d9800a15 	stw	r6,40(sp)
  80958c:	d8c01115 	stw	r3,68(sp)
  809590:	003f1d06 	br	809208 <_dtoa_r+0x8bc>
  809594:	a03f0c1e 	bne	r20,zero,8091c8 <_dtoa_r+0x87c>
  809598:	00800434 	movhi	r2,16
  80959c:	10bfffc4 	addi	r2,r2,-1
  8095a0:	a884703a 	and	r2,r21,r2
  8095a4:	103f081e 	bne	r2,zero,8091c8 <_dtoa_r+0x87c>
  8095a8:	a89ffc2c 	andhi	r2,r21,32752
  8095ac:	103f0626 	beq	r2,zero,8091c8 <_dtoa_r+0x87c>
  8095b0:	d8c01117 	ldw	r3,68(sp)
  8095b4:	d9000a17 	ldw	r4,40(sp)
  8095b8:	18c00044 	addi	r3,r3,1
  8095bc:	21000044 	addi	r4,r4,1
  8095c0:	d8c01115 	stw	r3,68(sp)
  8095c4:	d9000a15 	stw	r4,40(sp)
  8095c8:	003f0006 	br	8091cc <_dtoa_r+0x880>
  8095cc:	d9400717 	ldw	r5,28(sp)
  8095d0:	d9001617 	ldw	r4,88(sp)
  8095d4:	080c9600 	call	80c960 <__pow5mult>
  8095d8:	d8800715 	stw	r2,28(sp)
  8095dc:	003eed06 	br	809194 <_dtoa_r+0x848>
  8095e0:	1000021e 	bne	r2,zero,8095ec <_dtoa_r+0xca0>
  8095e4:	b880004c 	andi	r2,r23,1
  8095e8:	103fc11e 	bne	r2,zero,8094f0 <_dtoa_r+0xba4>
  8095ec:	b5bfffc4 	addi	r22,r22,-1
  8095f0:	b0c00007 	ldb	r3,0(r22)
  8095f4:	00800c04 	movi	r2,48
  8095f8:	18bffc26 	beq	r3,r2,8095ec <_dtoa_r+0xca0>
  8095fc:	b7000044 	addi	fp,r22,1
  809600:	003fcb06 	br	809530 <_dtoa_r+0xbe4>
  809604:	d9800d17 	ldw	r6,52(sp)
  809608:	018fc83a 	sub	r7,zero,r6
  80960c:	3801f726 	beq	r7,zero,809dec <_dtoa_r+0x14a0>
  809610:	398003cc 	andi	r6,r7,15
  809614:	300c90fa 	slli	r6,r6,3
  809618:	014020b4 	movhi	r5,130
  80961c:	29618b04 	addi	r5,r5,-31188
  809620:	d9001217 	ldw	r4,72(sp)
  809624:	314d883a 	add	r6,r6,r5
  809628:	30c00117 	ldw	r3,4(r6)
  80962c:	30800017 	ldw	r2,0(r6)
  809630:	d9401317 	ldw	r5,76(sp)
  809634:	3821d13a 	srai	r16,r7,4
  809638:	100d883a 	mov	r6,r2
  80963c:	180f883a 	mov	r7,r3
  809640:	080eb680 	call	80eb68 <__muldf3>
  809644:	1011883a 	mov	r8,r2
  809648:	1813883a 	mov	r9,r3
  80964c:	1029883a 	mov	r20,r2
  809650:	182b883a 	mov	r21,r3
  809654:	8001e526 	beq	r16,zero,809dec <_dtoa_r+0x14a0>
  809658:	05800084 	movi	r22,2
  80965c:	044020b4 	movhi	r17,130
  809660:	8c61bd04 	addi	r17,r17,-30988
  809664:	8080004c 	andi	r2,r16,1
  809668:	1005003a 	cmpeq	r2,r2,zero
  80966c:	1000081e 	bne	r2,zero,809690 <_dtoa_r+0xd44>
  809670:	89800017 	ldw	r6,0(r17)
  809674:	89c00117 	ldw	r7,4(r17)
  809678:	480b883a 	mov	r5,r9
  80967c:	4009883a 	mov	r4,r8
  809680:	080eb680 	call	80eb68 <__muldf3>
  809684:	1011883a 	mov	r8,r2
  809688:	b5800044 	addi	r22,r22,1
  80968c:	1813883a 	mov	r9,r3
  809690:	8021d07a 	srai	r16,r16,1
  809694:	8c400204 	addi	r17,r17,8
  809698:	803ff21e 	bne	r16,zero,809664 <_dtoa_r+0xd18>
  80969c:	4029883a 	mov	r20,r8
  8096a0:	482b883a 	mov	r21,r9
  8096a4:	003dca06 	br	808dd0 <_dtoa_r+0x484>
  8096a8:	d9000817 	ldw	r4,32(sp)
  8096ac:	2005003a 	cmpeq	r2,r4,zero
  8096b0:	1001f61e 	bne	r2,zero,809e8c <_dtoa_r+0x1540>
  8096b4:	dc001117 	ldw	r16,68(sp)
  8096b8:	dc801017 	ldw	r18,64(sp)
  8096bc:	18c10cc4 	addi	r3,r3,1075
  8096c0:	003f6106 	br	809448 <_dtoa_r+0xafc>
  8096c4:	d8000b15 	stw	zero,44(sp)
  8096c8:	d9802617 	ldw	r6,152(sp)
  8096cc:	d8c00d17 	ldw	r3,52(sp)
  8096d0:	30800044 	addi	r2,r6,1
  8096d4:	18ad883a 	add	r22,r3,r2
  8096d8:	b13fffc4 	addi	r4,r22,-1
  8096dc:	d9000e15 	stw	r4,56(sp)
  8096e0:	0581f60e 	bge	zero,r22,809ebc <_dtoa_r+0x1570>
  8096e4:	dd800f15 	stw	r22,60(sp)
  8096e8:	003f3006 	br	8093ac <_dtoa_r+0xa60>
  8096ec:	d8000b15 	stw	zero,44(sp)
  8096f0:	d9002617 	ldw	r4,152(sp)
  8096f4:	0101eb0e 	bge	zero,r4,809ea4 <_dtoa_r+0x1558>
  8096f8:	202d883a 	mov	r22,r4
  8096fc:	d9000e15 	stw	r4,56(sp)
  809700:	d9000f15 	stw	r4,60(sp)
  809704:	003f2906 	br	8093ac <_dtoa_r+0xa60>
  809708:	01800044 	movi	r6,1
  80970c:	d9800b15 	stw	r6,44(sp)
  809710:	003ff706 	br	8096f0 <_dtoa_r+0xda4>
  809714:	01000044 	movi	r4,1
  809718:	d9000b15 	stw	r4,44(sp)
  80971c:	003fea06 	br	8096c8 <_dtoa_r+0xd7c>
  809720:	04000c0e 	bge	zero,r16,809754 <_dtoa_r+0xe08>
  809724:	d9400717 	ldw	r5,28(sp)
  809728:	d9001617 	ldw	r4,88(sp)
  80972c:	01800044 	movi	r6,1
  809730:	080c4580 	call	80c458 <__lshift>
  809734:	1009883a 	mov	r4,r2
  809738:	900b883a 	mov	r5,r18
  80973c:	d8800715 	stw	r2,28(sp)
  809740:	080bc700 	call	80bc70 <__mcmp>
  809744:	0081e00e 	bge	zero,r2,809ec8 <_dtoa_r+0x157c>
  809748:	bdc00044 	addi	r23,r23,1
  80974c:	00800e84 	movi	r2,58
  809750:	b881a226 	beq	r23,r2,809ddc <_dtoa_r+0x1490>
  809754:	b7000044 	addi	fp,r22,1
  809758:	b5c00005 	stb	r23,0(r22)
  80975c:	003f7406 	br	809530 <_dtoa_r+0xbe4>
  809760:	00800e44 	movi	r2,57
  809764:	b8819d26 	beq	r23,r2,809ddc <_dtoa_r+0x1490>
  809768:	053ffa0e 	bge	zero,r20,809754 <_dtoa_r+0xe08>
  80976c:	8dc00c44 	addi	r23,r17,49
  809770:	003ff806 	br	809754 <_dtoa_r+0xe08>
  809774:	d9001617 	ldw	r4,88(sp)
  809778:	a80b883a 	mov	r5,r21
  80977c:	04000044 	movi	r16,1
  809780:	080bb140 	call	80bb14 <_Bfree>
  809784:	003edf06 	br	809304 <_dtoa_r+0x9b8>
  809788:	d9001617 	ldw	r4,88(sp)
  80978c:	980b883a 	mov	r5,r19
  809790:	01800284 	movi	r6,10
  809794:	000f883a 	mov	r7,zero
  809798:	080c8340 	call	80c834 <__multadd>
  80979c:	1027883a 	mov	r19,r2
  8097a0:	d8800615 	stw	r2,24(sp)
  8097a4:	003ebb06 	br	809294 <_dtoa_r+0x948>
  8097a8:	d9801117 	ldw	r6,68(sp)
  8097ac:	d8800d17 	ldw	r2,52(sp)
  8097b0:	d8000915 	stw	zero,36(sp)
  8097b4:	308dc83a 	sub	r6,r6,r2
  8097b8:	0087c83a 	sub	r3,zero,r2
  8097bc:	d9801115 	stw	r6,68(sp)
  8097c0:	d8c01015 	stw	r3,64(sp)
  8097c4:	003cfe06 	br	808bc0 <_dtoa_r+0x274>
  8097c8:	018dc83a 	sub	r6,zero,r6
  8097cc:	d9801115 	stw	r6,68(sp)
  8097d0:	d8000a15 	stw	zero,40(sp)
  8097d4:	003cf306 	br	808ba4 <_dtoa_r+0x258>
  8097d8:	d9000d17 	ldw	r4,52(sp)
  8097dc:	080f42c0 	call	80f42c <__floatsidf>
  8097e0:	880b883a 	mov	r5,r17
  8097e4:	8009883a 	mov	r4,r16
  8097e8:	180f883a 	mov	r7,r3
  8097ec:	100d883a 	mov	r6,r2
  8097f0:	080f20c0 	call	80f20c <__nedf2>
  8097f4:	103ce126 	beq	r2,zero,808b7c <_dtoa_r+0x230>
  8097f8:	d9800d17 	ldw	r6,52(sp)
  8097fc:	31bfffc4 	addi	r6,r6,-1
  809800:	d9800d15 	stw	r6,52(sp)
  809804:	003cdd06 	br	808b7c <_dtoa_r+0x230>
  809808:	d9000717 	ldw	r4,28(sp)
  80980c:	900b883a 	mov	r5,r18
  809810:	080bc700 	call	80bc70 <__mcmp>
  809814:	103e8d0e 	bge	r2,zero,80924c <_dtoa_r+0x900>
  809818:	d9400717 	ldw	r5,28(sp)
  80981c:	d9001617 	ldw	r4,88(sp)
  809820:	01800284 	movi	r6,10
  809824:	000f883a 	mov	r7,zero
  809828:	080c8340 	call	80c834 <__multadd>
  80982c:	d9800d17 	ldw	r6,52(sp)
  809830:	d8800715 	stw	r2,28(sp)
  809834:	31bfffc4 	addi	r6,r6,-1
  809838:	d9800d15 	stw	r6,52(sp)
  80983c:	b001a71e 	bne	r22,zero,809edc <_dtoa_r+0x1590>
  809840:	d8800e17 	ldw	r2,56(sp)
  809844:	d8800f15 	stw	r2,60(sp)
  809848:	003e8006 	br	80924c <_dtoa_r+0x900>
  80984c:	90800417 	ldw	r2,16(r18)
  809850:	1085883a 	add	r2,r2,r2
  809854:	1085883a 	add	r2,r2,r2
  809858:	1485883a 	add	r2,r2,r18
  80985c:	11000417 	ldw	r4,16(r2)
  809860:	080bb3c0 	call	80bb3c <__hi0bits>
  809864:	00c00804 	movi	r3,32
  809868:	1887c83a 	sub	r3,r3,r2
  80986c:	003e5a06 	br	8091d8 <_dtoa_r+0x88c>
  809870:	d9400717 	ldw	r5,28(sp)
  809874:	d9801017 	ldw	r6,64(sp)
  809878:	d9001617 	ldw	r4,88(sp)
  80987c:	080c9600 	call	80c960 <__pow5mult>
  809880:	d8800715 	stw	r2,28(sp)
  809884:	003e4306 	br	809194 <_dtoa_r+0x848>
  809888:	d9800f17 	ldw	r6,60(sp)
  80988c:	d8800d17 	ldw	r2,52(sp)
  809890:	d9800315 	stw	r6,12(sp)
  809894:	d8800415 	stw	r2,16(sp)
  809898:	d8c00b17 	ldw	r3,44(sp)
  80989c:	1805003a 	cmpeq	r2,r3,zero
  8098a0:	1000e21e 	bne	r2,zero,809c2c <_dtoa_r+0x12e0>
  8098a4:	d9000317 	ldw	r4,12(sp)
  8098a8:	0005883a 	mov	r2,zero
  8098ac:	00cff834 	movhi	r3,16352
  8098b0:	200c90fa 	slli	r6,r4,3
  8098b4:	010020b4 	movhi	r4,130
  8098b8:	21218b04 	addi	r4,r4,-31188
  8098bc:	180b883a 	mov	r5,r3
  8098c0:	310d883a 	add	r6,r6,r4
  8098c4:	327fff17 	ldw	r9,-4(r6)
  8098c8:	323ffe17 	ldw	r8,-8(r6)
  8098cc:	1009883a 	mov	r4,r2
  8098d0:	480f883a 	mov	r7,r9
  8098d4:	400d883a 	mov	r6,r8
  8098d8:	080ef2c0 	call	80ef2c <__divdf3>
  8098dc:	180b883a 	mov	r5,r3
  8098e0:	b00d883a 	mov	r6,r22
  8098e4:	b80f883a 	mov	r7,r23
  8098e8:	1009883a 	mov	r4,r2
  8098ec:	080ea740 	call	80ea74 <__subdf3>
  8098f0:	a80b883a 	mov	r5,r21
  8098f4:	a009883a 	mov	r4,r20
  8098f8:	d8c01915 	stw	r3,100(sp)
  8098fc:	d8801815 	stw	r2,96(sp)
  809900:	080f5240 	call	80f524 <__fixdfsi>
  809904:	1009883a 	mov	r4,r2
  809908:	1027883a 	mov	r19,r2
  80990c:	080f42c0 	call	80f42c <__floatsidf>
  809910:	a80b883a 	mov	r5,r21
  809914:	a009883a 	mov	r4,r20
  809918:	180f883a 	mov	r7,r3
  80991c:	100d883a 	mov	r6,r2
  809920:	080ea740 	call	80ea74 <__subdf3>
  809924:	d9801817 	ldw	r6,96(sp)
  809928:	1823883a 	mov	r17,r3
  80992c:	d8801415 	stw	r2,80(sp)
  809930:	302d883a 	mov	r22,r6
  809934:	d9800517 	ldw	r6,20(sp)
  809938:	9cc00c04 	addi	r19,r19,48
  80993c:	dc401515 	stw	r17,84(sp)
  809940:	d8c01917 	ldw	r3,100(sp)
  809944:	34c00005 	stb	r19,0(r6)
  809948:	d8800517 	ldw	r2,20(sp)
  80994c:	d9401917 	ldw	r5,100(sp)
  809950:	d9801417 	ldw	r6,80(sp)
  809954:	b009883a 	mov	r4,r22
  809958:	880f883a 	mov	r7,r17
  80995c:	182f883a 	mov	r23,r3
  809960:	17000044 	addi	fp,r2,1
  809964:	080f2940 	call	80f294 <__gtdf2>
  809968:	00804e16 	blt	zero,r2,809aa4 <_dtoa_r+0x1158>
  80996c:	d9801417 	ldw	r6,80(sp)
  809970:	0005883a 	mov	r2,zero
  809974:	00cffc34 	movhi	r3,16368
  809978:	180b883a 	mov	r5,r3
  80997c:	880f883a 	mov	r7,r17
  809980:	1009883a 	mov	r4,r2
  809984:	080ea740 	call	80ea74 <__subdf3>
  809988:	d9401917 	ldw	r5,100(sp)
  80998c:	180f883a 	mov	r7,r3
  809990:	b009883a 	mov	r4,r22
  809994:	100d883a 	mov	r6,r2
  809998:	080f2940 	call	80f294 <__gtdf2>
  80999c:	00bda216 	blt	zero,r2,809028 <_dtoa_r+0x6dc>
  8099a0:	d8c00317 	ldw	r3,12(sp)
  8099a4:	00800044 	movi	r2,1
  8099a8:	10c01216 	blt	r2,r3,8099f4 <_dtoa_r+0x10a8>
  8099ac:	003d4506 	br	808ec4 <_dtoa_r+0x578>
  8099b0:	d9801417 	ldw	r6,80(sp)
  8099b4:	0005883a 	mov	r2,zero
  8099b8:	00cffc34 	movhi	r3,16368
  8099bc:	180b883a 	mov	r5,r3
  8099c0:	880f883a 	mov	r7,r17
  8099c4:	1009883a 	mov	r4,r2
  8099c8:	080ea740 	call	80ea74 <__subdf3>
  8099cc:	d9c01b17 	ldw	r7,108(sp)
  8099d0:	180b883a 	mov	r5,r3
  8099d4:	1009883a 	mov	r4,r2
  8099d8:	b00d883a 	mov	r6,r22
  8099dc:	080f3a40 	call	80f3a4 <__ltdf2>
  8099e0:	103d9116 	blt	r2,zero,809028 <_dtoa_r+0x6dc>
  8099e4:	d9800517 	ldw	r6,20(sp)
  8099e8:	d9000317 	ldw	r4,12(sp)
  8099ec:	3105883a 	add	r2,r6,r4
  8099f0:	e0bd3426 	beq	fp,r2,808ec4 <_dtoa_r+0x578>
  8099f4:	04500934 	movhi	r17,16420
  8099f8:	0021883a 	mov	r16,zero
  8099fc:	b80b883a 	mov	r5,r23
  809a00:	b009883a 	mov	r4,r22
  809a04:	800d883a 	mov	r6,r16
  809a08:	880f883a 	mov	r7,r17
  809a0c:	080eb680 	call	80eb68 <__muldf3>
  809a10:	d9401517 	ldw	r5,84(sp)
  809a14:	d9001417 	ldw	r4,80(sp)
  809a18:	880f883a 	mov	r7,r17
  809a1c:	000d883a 	mov	r6,zero
  809a20:	d8801a15 	stw	r2,104(sp)
  809a24:	d8c01b15 	stw	r3,108(sp)
  809a28:	080eb680 	call	80eb68 <__muldf3>
  809a2c:	180b883a 	mov	r5,r3
  809a30:	1009883a 	mov	r4,r2
  809a34:	1823883a 	mov	r17,r3
  809a38:	1021883a 	mov	r16,r2
  809a3c:	080f5240 	call	80f524 <__fixdfsi>
  809a40:	1009883a 	mov	r4,r2
  809a44:	102b883a 	mov	r21,r2
  809a48:	080f42c0 	call	80f42c <__floatsidf>
  809a4c:	880b883a 	mov	r5,r17
  809a50:	8009883a 	mov	r4,r16
  809a54:	180f883a 	mov	r7,r3
  809a58:	100d883a 	mov	r6,r2
  809a5c:	080ea740 	call	80ea74 <__subdf3>
  809a60:	1021883a 	mov	r16,r2
  809a64:	d9001b17 	ldw	r4,108(sp)
  809a68:	1823883a 	mov	r17,r3
  809a6c:	dc001415 	stw	r16,80(sp)
  809a70:	ad400c04 	addi	r21,r21,48
  809a74:	dc401515 	stw	r17,84(sp)
  809a78:	d8801a17 	ldw	r2,104(sp)
  809a7c:	e5400005 	stb	r21,0(fp)
  809a80:	202f883a 	mov	r23,r4
  809a84:	d9c01b17 	ldw	r7,108(sp)
  809a88:	d9001417 	ldw	r4,80(sp)
  809a8c:	880b883a 	mov	r5,r17
  809a90:	100d883a 	mov	r6,r2
  809a94:	102d883a 	mov	r22,r2
  809a98:	e7000044 	addi	fp,fp,1
  809a9c:	080f3a40 	call	80f3a4 <__ltdf2>
  809aa0:	103fc30e 	bge	r2,zero,8099b0 <_dtoa_r+0x1064>
  809aa4:	d9000417 	ldw	r4,16(sp)
  809aa8:	d9000d15 	stw	r4,52(sp)
  809aac:	003d7106 	br	809074 <_dtoa_r+0x728>
  809ab0:	d9801717 	ldw	r6,92(sp)
  809ab4:	00800084 	movi	r2,2
  809ab8:	11bde60e 	bge	r2,r6,809254 <_dtoa_r+0x908>
  809abc:	203cfb1e 	bne	r4,zero,808eac <_dtoa_r+0x560>
  809ac0:	d9001617 	ldw	r4,88(sp)
  809ac4:	900b883a 	mov	r5,r18
  809ac8:	01800144 	movi	r6,5
  809acc:	000f883a 	mov	r7,zero
  809ad0:	080c8340 	call	80c834 <__multadd>
  809ad4:	d9000717 	ldw	r4,28(sp)
  809ad8:	100b883a 	mov	r5,r2
  809adc:	1025883a 	mov	r18,r2
  809ae0:	080bc700 	call	80bc70 <__mcmp>
  809ae4:	00bcf10e 	bge	zero,r2,808eac <_dtoa_r+0x560>
  809ae8:	d8c00d17 	ldw	r3,52(sp)
  809aec:	d9000517 	ldw	r4,20(sp)
  809af0:	d8000615 	stw	zero,24(sp)
  809af4:	18c00044 	addi	r3,r3,1
  809af8:	d8c00d15 	stw	r3,52(sp)
  809afc:	00800c44 	movi	r2,49
  809b00:	27000044 	addi	fp,r4,1
  809b04:	20800005 	stb	r2,0(r4)
  809b08:	003e8906 	br	809530 <_dtoa_r+0xbe4>
  809b0c:	d8c00517 	ldw	r3,20(sp)
  809b10:	003bc206 	br	808a1c <_dtoa_r+0xd0>
  809b14:	018020b4 	movhi	r6,130
  809b18:	31a1bd04 	addi	r6,r6,-30988
  809b1c:	30c00917 	ldw	r3,36(r6)
  809b20:	30800817 	ldw	r2,32(r6)
  809b24:	d9001217 	ldw	r4,72(sp)
  809b28:	d9401317 	ldw	r5,76(sp)
  809b2c:	180f883a 	mov	r7,r3
  809b30:	100d883a 	mov	r6,r2
  809b34:	080ef2c0 	call	80ef2c <__divdf3>
  809b38:	948003cc 	andi	r18,r18,15
  809b3c:	058000c4 	movi	r22,3
  809b40:	1029883a 	mov	r20,r2
  809b44:	182b883a 	mov	r21,r3
  809b48:	003c8906 	br	808d70 <_dtoa_r+0x424>
  809b4c:	d9001017 	ldw	r4,64(sp)
  809b50:	d9800917 	ldw	r6,36(sp)
  809b54:	0025883a 	mov	r18,zero
  809b58:	1105c83a 	sub	r2,r2,r4
  809b5c:	2089883a 	add	r4,r4,r2
  809b60:	308d883a 	add	r6,r6,r2
  809b64:	d9001015 	stw	r4,64(sp)
  809b68:	d9800915 	stw	r6,36(sp)
  809b6c:	003e3206 	br	809438 <_dtoa_r+0xaec>
  809b70:	28800044 	addi	r2,r5,1
  809b74:	27000044 	addi	fp,r4,1
  809b78:	20800005 	stb	r2,0(r4)
  809b7c:	003e6c06 	br	809530 <_dtoa_r+0xbe4>
  809b80:	d8800f17 	ldw	r2,60(sp)
  809b84:	00bce016 	blt	zero,r2,808f08 <_dtoa_r+0x5bc>
  809b88:	d9800f17 	ldw	r6,60(sp)
  809b8c:	303cc51e 	bne	r6,zero,808ea4 <_dtoa_r+0x558>
  809b90:	0005883a 	mov	r2,zero
  809b94:	00d00534 	movhi	r3,16404
  809b98:	980b883a 	mov	r5,r19
  809b9c:	180f883a 	mov	r7,r3
  809ba0:	9009883a 	mov	r4,r18
  809ba4:	100d883a 	mov	r6,r2
  809ba8:	080eb680 	call	80eb68 <__muldf3>
  809bac:	180b883a 	mov	r5,r3
  809bb0:	a80f883a 	mov	r7,r21
  809bb4:	1009883a 	mov	r4,r2
  809bb8:	a00d883a 	mov	r6,r20
  809bbc:	080f31c0 	call	80f31c <__gedf2>
  809bc0:	103cb80e 	bge	r2,zero,808ea4 <_dtoa_r+0x558>
  809bc4:	0027883a 	mov	r19,zero
  809bc8:	0025883a 	mov	r18,zero
  809bcc:	003fc606 	br	809ae8 <_dtoa_r+0x119c>
  809bd0:	99400117 	ldw	r5,4(r19)
  809bd4:	d9001617 	ldw	r4,88(sp)
  809bd8:	080c0940 	call	80c094 <_Balloc>
  809bdc:	99800417 	ldw	r6,16(r19)
  809be0:	11000304 	addi	r4,r2,12
  809be4:	99400304 	addi	r5,r19,12
  809be8:	318d883a 	add	r6,r6,r6
  809bec:	318d883a 	add	r6,r6,r6
  809bf0:	31800204 	addi	r6,r6,8
  809bf4:	1023883a 	mov	r17,r2
  809bf8:	080b8fc0 	call	80b8fc <memcpy>
  809bfc:	d9001617 	ldw	r4,88(sp)
  809c00:	880b883a 	mov	r5,r17
  809c04:	01800044 	movi	r6,1
  809c08:	080c4580 	call	80c458 <__lshift>
  809c0c:	100b883a 	mov	r5,r2
  809c10:	003d9c06 	br	809284 <_dtoa_r+0x938>
  809c14:	00800e44 	movi	r2,57
  809c18:	b8807026 	beq	r23,r2,809ddc <_dtoa_r+0x1490>
  809c1c:	b8800044 	addi	r2,r23,1
  809c20:	b7000044 	addi	fp,r22,1
  809c24:	b0800005 	stb	r2,0(r22)
  809c28:	003e4106 	br	809530 <_dtoa_r+0xbe4>
  809c2c:	d8800317 	ldw	r2,12(sp)
  809c30:	018020b4 	movhi	r6,130
  809c34:	31a18b04 	addi	r6,r6,-31188
  809c38:	b009883a 	mov	r4,r22
  809c3c:	100e90fa 	slli	r7,r2,3
  809c40:	b80b883a 	mov	r5,r23
  809c44:	398f883a 	add	r7,r7,r6
  809c48:	38bffe17 	ldw	r2,-8(r7)
  809c4c:	d9800517 	ldw	r6,20(sp)
  809c50:	38ffff17 	ldw	r3,-4(r7)
  809c54:	37000044 	addi	fp,r6,1
  809c58:	180f883a 	mov	r7,r3
  809c5c:	100d883a 	mov	r6,r2
  809c60:	080eb680 	call	80eb68 <__muldf3>
  809c64:	a80b883a 	mov	r5,r21
  809c68:	a009883a 	mov	r4,r20
  809c6c:	182f883a 	mov	r23,r3
  809c70:	102d883a 	mov	r22,r2
  809c74:	080f5240 	call	80f524 <__fixdfsi>
  809c78:	1009883a 	mov	r4,r2
  809c7c:	1027883a 	mov	r19,r2
  809c80:	080f42c0 	call	80f42c <__floatsidf>
  809c84:	a80b883a 	mov	r5,r21
  809c88:	a009883a 	mov	r4,r20
  809c8c:	180f883a 	mov	r7,r3
  809c90:	100d883a 	mov	r6,r2
  809c94:	080ea740 	call	80ea74 <__subdf3>
  809c98:	180b883a 	mov	r5,r3
  809c9c:	d8c00517 	ldw	r3,20(sp)
  809ca0:	9cc00c04 	addi	r19,r19,48
  809ca4:	1009883a 	mov	r4,r2
  809ca8:	1cc00005 	stb	r19,0(r3)
  809cac:	2021883a 	mov	r16,r4
  809cb0:	d9000317 	ldw	r4,12(sp)
  809cb4:	00800044 	movi	r2,1
  809cb8:	2823883a 	mov	r17,r5
  809cbc:	20802226 	beq	r4,r2,809d48 <_dtoa_r+0x13fc>
  809cc0:	1029883a 	mov	r20,r2
  809cc4:	0005883a 	mov	r2,zero
  809cc8:	00d00934 	movhi	r3,16420
  809ccc:	180f883a 	mov	r7,r3
  809cd0:	100d883a 	mov	r6,r2
  809cd4:	880b883a 	mov	r5,r17
  809cd8:	8009883a 	mov	r4,r16
  809cdc:	080eb680 	call	80eb68 <__muldf3>
  809ce0:	180b883a 	mov	r5,r3
  809ce4:	1009883a 	mov	r4,r2
  809ce8:	1823883a 	mov	r17,r3
  809cec:	1021883a 	mov	r16,r2
  809cf0:	080f5240 	call	80f524 <__fixdfsi>
  809cf4:	1009883a 	mov	r4,r2
  809cf8:	102b883a 	mov	r21,r2
  809cfc:	080f42c0 	call	80f42c <__floatsidf>
  809d00:	880b883a 	mov	r5,r17
  809d04:	8009883a 	mov	r4,r16
  809d08:	180f883a 	mov	r7,r3
  809d0c:	100d883a 	mov	r6,r2
  809d10:	080ea740 	call	80ea74 <__subdf3>
  809d14:	180b883a 	mov	r5,r3
  809d18:	d8c00517 	ldw	r3,20(sp)
  809d1c:	1009883a 	mov	r4,r2
  809d20:	ad400c04 	addi	r21,r21,48
  809d24:	1d05883a 	add	r2,r3,r20
  809d28:	15400005 	stb	r21,0(r2)
  809d2c:	2021883a 	mov	r16,r4
  809d30:	d9000317 	ldw	r4,12(sp)
  809d34:	a5000044 	addi	r20,r20,1
  809d38:	2823883a 	mov	r17,r5
  809d3c:	a13fe11e 	bne	r20,r4,809cc4 <_dtoa_r+0x1378>
  809d40:	e505883a 	add	r2,fp,r20
  809d44:	173fffc4 	addi	fp,r2,-1
  809d48:	0025883a 	mov	r18,zero
  809d4c:	04cff834 	movhi	r19,16352
  809d50:	b009883a 	mov	r4,r22
  809d54:	b80b883a 	mov	r5,r23
  809d58:	900d883a 	mov	r6,r18
  809d5c:	980f883a 	mov	r7,r19
  809d60:	080eaf40 	call	80eaf4 <__adddf3>
  809d64:	180b883a 	mov	r5,r3
  809d68:	1009883a 	mov	r4,r2
  809d6c:	800d883a 	mov	r6,r16
  809d70:	880f883a 	mov	r7,r17
  809d74:	080f3a40 	call	80f3a4 <__ltdf2>
  809d78:	103cab16 	blt	r2,zero,809028 <_dtoa_r+0x6dc>
  809d7c:	0009883a 	mov	r4,zero
  809d80:	980b883a 	mov	r5,r19
  809d84:	b80f883a 	mov	r7,r23
  809d88:	b00d883a 	mov	r6,r22
  809d8c:	080ea740 	call	80ea74 <__subdf3>
  809d90:	180b883a 	mov	r5,r3
  809d94:	880f883a 	mov	r7,r17
  809d98:	1009883a 	mov	r4,r2
  809d9c:	800d883a 	mov	r6,r16
  809da0:	080f2940 	call	80f294 <__gtdf2>
  809da4:	00bc470e 	bge	zero,r2,808ec4 <_dtoa_r+0x578>
  809da8:	00c00c04 	movi	r3,48
  809dac:	e73fffc4 	addi	fp,fp,-1
  809db0:	e0800007 	ldb	r2,0(fp)
  809db4:	10fffd26 	beq	r2,r3,809dac <_dtoa_r+0x1460>
  809db8:	d9800417 	ldw	r6,16(sp)
  809dbc:	e7000044 	addi	fp,fp,1
  809dc0:	d9800d15 	stw	r6,52(sp)
  809dc4:	003cab06 	br	809074 <_dtoa_r+0x728>
  809dc8:	d8c00f17 	ldw	r3,60(sp)
  809dcc:	d9001117 	ldw	r4,68(sp)
  809dd0:	20e1c83a 	sub	r16,r4,r3
  809dd4:	0007883a 	mov	r3,zero
  809dd8:	003d9b06 	br	809448 <_dtoa_r+0xafc>
  809ddc:	00800e44 	movi	r2,57
  809de0:	b0800005 	stb	r2,0(r22)
  809de4:	b5800044 	addi	r22,r22,1
  809de8:	003dc106 	br	8094f0 <_dtoa_r+0xba4>
  809dec:	05800084 	movi	r22,2
  809df0:	003bf706 	br	808dd0 <_dtoa_r+0x484>
  809df4:	d9000f17 	ldw	r4,60(sp)
  809df8:	013c000e 	bge	zero,r4,808dfc <_dtoa_r+0x4b0>
  809dfc:	d9800e17 	ldw	r6,56(sp)
  809e00:	01bc300e 	bge	zero,r6,808ec4 <_dtoa_r+0x578>
  809e04:	0005883a 	mov	r2,zero
  809e08:	00d00934 	movhi	r3,16420
  809e0c:	a80b883a 	mov	r5,r21
  809e10:	180f883a 	mov	r7,r3
  809e14:	a009883a 	mov	r4,r20
  809e18:	100d883a 	mov	r6,r2
  809e1c:	080eb680 	call	80eb68 <__muldf3>
  809e20:	b1000044 	addi	r4,r22,1
  809e24:	1021883a 	mov	r16,r2
  809e28:	1823883a 	mov	r17,r3
  809e2c:	080f42c0 	call	80f42c <__floatsidf>
  809e30:	880b883a 	mov	r5,r17
  809e34:	8009883a 	mov	r4,r16
  809e38:	180f883a 	mov	r7,r3
  809e3c:	100d883a 	mov	r6,r2
  809e40:	080eb680 	call	80eb68 <__muldf3>
  809e44:	0011883a 	mov	r8,zero
  809e48:	02500734 	movhi	r9,16412
  809e4c:	180b883a 	mov	r5,r3
  809e50:	480f883a 	mov	r7,r9
  809e54:	1009883a 	mov	r4,r2
  809e58:	400d883a 	mov	r6,r8
  809e5c:	080eaf40 	call	80eaf4 <__adddf3>
  809e60:	102d883a 	mov	r22,r2
  809e64:	00bf3034 	movhi	r2,64704
  809e68:	10ef883a 	add	r23,r2,r3
  809e6c:	d8800d17 	ldw	r2,52(sp)
  809e70:	d8c00e17 	ldw	r3,56(sp)
  809e74:	8029883a 	mov	r20,r16
  809e78:	10bfffc4 	addi	r2,r2,-1
  809e7c:	882b883a 	mov	r21,r17
  809e80:	d8800415 	stw	r2,16(sp)
  809e84:	d8c00315 	stw	r3,12(sp)
  809e88:	003e8306 	br	809898 <_dtoa_r+0xf4c>
  809e8c:	d8800117 	ldw	r2,4(sp)
  809e90:	dc001117 	ldw	r16,68(sp)
  809e94:	dc801017 	ldw	r18,64(sp)
  809e98:	00c00d84 	movi	r3,54
  809e9c:	1887c83a 	sub	r3,r3,r2
  809ea0:	003d6906 	br	809448 <_dtoa_r+0xafc>
  809ea4:	01800044 	movi	r6,1
  809ea8:	3021883a 	mov	r16,r6
  809eac:	d9800f15 	stw	r6,60(sp)
  809eb0:	d9802615 	stw	r6,152(sp)
  809eb4:	d9800e15 	stw	r6,56(sp)
  809eb8:	003b9306 	br	808d08 <_dtoa_r+0x3bc>
  809ebc:	b021883a 	mov	r16,r22
  809ec0:	dd800f15 	stw	r22,60(sp)
  809ec4:	003b9006 	br	808d08 <_dtoa_r+0x3bc>
  809ec8:	103e221e 	bne	r2,zero,809754 <_dtoa_r+0xe08>
  809ecc:	b880004c 	andi	r2,r23,1
  809ed0:	1005003a 	cmpeq	r2,r2,zero
  809ed4:	103e1f1e 	bne	r2,zero,809754 <_dtoa_r+0xe08>
  809ed8:	003e1b06 	br	809748 <_dtoa_r+0xdfc>
  809edc:	d9001617 	ldw	r4,88(sp)
  809ee0:	980b883a 	mov	r5,r19
  809ee4:	01800284 	movi	r6,10
  809ee8:	000f883a 	mov	r7,zero
  809eec:	080c8340 	call	80c834 <__multadd>
  809ef0:	d8c00e17 	ldw	r3,56(sp)
  809ef4:	1027883a 	mov	r19,r2
  809ef8:	d8c00f15 	stw	r3,60(sp)
  809efc:	003cd306 	br	80924c <_dtoa_r+0x900>

00809f00 <_fflush_r>:
  809f00:	defffb04 	addi	sp,sp,-20
  809f04:	dcc00315 	stw	r19,12(sp)
  809f08:	dc800215 	stw	r18,8(sp)
  809f0c:	dfc00415 	stw	ra,16(sp)
  809f10:	dc400115 	stw	r17,4(sp)
  809f14:	dc000015 	stw	r16,0(sp)
  809f18:	2027883a 	mov	r19,r4
  809f1c:	2825883a 	mov	r18,r5
  809f20:	20000226 	beq	r4,zero,809f2c <_fflush_r+0x2c>
  809f24:	20800e17 	ldw	r2,56(r4)
  809f28:	10005626 	beq	r2,zero,80a084 <_fflush_r+0x184>
  809f2c:	9100030b 	ldhu	r4,12(r18)
  809f30:	20ffffcc 	andi	r3,r4,65535
  809f34:	18e0001c 	xori	r3,r3,32768
  809f38:	18e00004 	addi	r3,r3,-32768
  809f3c:	1880020c 	andi	r2,r3,8
  809f40:	1000261e 	bne	r2,zero,809fdc <_fflush_r+0xdc>
  809f44:	90c00117 	ldw	r3,4(r18)
  809f48:	20820014 	ori	r2,r4,2048
  809f4c:	9080030d 	sth	r2,12(r18)
  809f50:	1009883a 	mov	r4,r2
  809f54:	00c0400e 	bge	zero,r3,80a058 <_fflush_r+0x158>
  809f58:	92000a17 	ldw	r8,40(r18)
  809f5c:	40004026 	beq	r8,zero,80a060 <_fflush_r+0x160>
  809f60:	2084000c 	andi	r2,r4,4096
  809f64:	10005326 	beq	r2,zero,80a0b4 <_fflush_r+0x1b4>
  809f68:	94001417 	ldw	r16,80(r18)
  809f6c:	9080030b 	ldhu	r2,12(r18)
  809f70:	1080010c 	andi	r2,r2,4
  809f74:	1000481e 	bne	r2,zero,80a098 <_fflush_r+0x198>
  809f78:	91400717 	ldw	r5,28(r18)
  809f7c:	9809883a 	mov	r4,r19
  809f80:	800d883a 	mov	r6,r16
  809f84:	000f883a 	mov	r7,zero
  809f88:	403ee83a 	callr	r8
  809f8c:	8080261e 	bne	r16,r2,80a028 <_fflush_r+0x128>
  809f90:	9080030b 	ldhu	r2,12(r18)
  809f94:	91000417 	ldw	r4,16(r18)
  809f98:	90000115 	stw	zero,4(r18)
  809f9c:	10bdffcc 	andi	r2,r2,63487
  809fa0:	10ffffcc 	andi	r3,r2,65535
  809fa4:	18c4000c 	andi	r3,r3,4096
  809fa8:	9080030d 	sth	r2,12(r18)
  809fac:	91000015 	stw	r4,0(r18)
  809fb0:	18002b26 	beq	r3,zero,80a060 <_fflush_r+0x160>
  809fb4:	0007883a 	mov	r3,zero
  809fb8:	1805883a 	mov	r2,r3
  809fbc:	94001415 	stw	r16,80(r18)
  809fc0:	dfc00417 	ldw	ra,16(sp)
  809fc4:	dcc00317 	ldw	r19,12(sp)
  809fc8:	dc800217 	ldw	r18,8(sp)
  809fcc:	dc400117 	ldw	r17,4(sp)
  809fd0:	dc000017 	ldw	r16,0(sp)
  809fd4:	dec00504 	addi	sp,sp,20
  809fd8:	f800283a 	ret
  809fdc:	94400417 	ldw	r17,16(r18)
  809fe0:	88001f26 	beq	r17,zero,80a060 <_fflush_r+0x160>
  809fe4:	90800017 	ldw	r2,0(r18)
  809fe8:	18c000cc 	andi	r3,r3,3
  809fec:	94400015 	stw	r17,0(r18)
  809ff0:	1461c83a 	sub	r16,r2,r17
  809ff4:	18002526 	beq	r3,zero,80a08c <_fflush_r+0x18c>
  809ff8:	0005883a 	mov	r2,zero
  809ffc:	90800215 	stw	r2,8(r18)
  80a000:	0400170e 	bge	zero,r16,80a060 <_fflush_r+0x160>
  80a004:	90c00917 	ldw	r3,36(r18)
  80a008:	91400717 	ldw	r5,28(r18)
  80a00c:	880d883a 	mov	r6,r17
  80a010:	800f883a 	mov	r7,r16
  80a014:	9809883a 	mov	r4,r19
  80a018:	183ee83a 	callr	r3
  80a01c:	88a3883a 	add	r17,r17,r2
  80a020:	80a1c83a 	sub	r16,r16,r2
  80a024:	00bff616 	blt	zero,r2,80a000 <_fflush_r+0x100>
  80a028:	9080030b 	ldhu	r2,12(r18)
  80a02c:	00ffffc4 	movi	r3,-1
  80a030:	10801014 	ori	r2,r2,64
  80a034:	9080030d 	sth	r2,12(r18)
  80a038:	1805883a 	mov	r2,r3
  80a03c:	dfc00417 	ldw	ra,16(sp)
  80a040:	dcc00317 	ldw	r19,12(sp)
  80a044:	dc800217 	ldw	r18,8(sp)
  80a048:	dc400117 	ldw	r17,4(sp)
  80a04c:	dc000017 	ldw	r16,0(sp)
  80a050:	dec00504 	addi	sp,sp,20
  80a054:	f800283a 	ret
  80a058:	90800f17 	ldw	r2,60(r18)
  80a05c:	00bfbe16 	blt	zero,r2,809f58 <_fflush_r+0x58>
  80a060:	0007883a 	mov	r3,zero
  80a064:	1805883a 	mov	r2,r3
  80a068:	dfc00417 	ldw	ra,16(sp)
  80a06c:	dcc00317 	ldw	r19,12(sp)
  80a070:	dc800217 	ldw	r18,8(sp)
  80a074:	dc400117 	ldw	r17,4(sp)
  80a078:	dc000017 	ldw	r16,0(sp)
  80a07c:	dec00504 	addi	sp,sp,20
  80a080:	f800283a 	ret
  80a084:	080a1980 	call	80a198 <__sinit>
  80a088:	003fa806 	br	809f2c <_fflush_r+0x2c>
  80a08c:	90800517 	ldw	r2,20(r18)
  80a090:	90800215 	stw	r2,8(r18)
  80a094:	003fda06 	br	80a000 <_fflush_r+0x100>
  80a098:	90800117 	ldw	r2,4(r18)
  80a09c:	90c00c17 	ldw	r3,48(r18)
  80a0a0:	80a1c83a 	sub	r16,r16,r2
  80a0a4:	183fb426 	beq	r3,zero,809f78 <_fflush_r+0x78>
  80a0a8:	90800f17 	ldw	r2,60(r18)
  80a0ac:	80a1c83a 	sub	r16,r16,r2
  80a0b0:	003fb106 	br	809f78 <_fflush_r+0x78>
  80a0b4:	91400717 	ldw	r5,28(r18)
  80a0b8:	9809883a 	mov	r4,r19
  80a0bc:	000d883a 	mov	r6,zero
  80a0c0:	01c00044 	movi	r7,1
  80a0c4:	403ee83a 	callr	r8
  80a0c8:	1021883a 	mov	r16,r2
  80a0cc:	00bfffc4 	movi	r2,-1
  80a0d0:	80800226 	beq	r16,r2,80a0dc <_fflush_r+0x1dc>
  80a0d4:	92000a17 	ldw	r8,40(r18)
  80a0d8:	003fa406 	br	809f6c <_fflush_r+0x6c>
  80a0dc:	98c00017 	ldw	r3,0(r19)
  80a0e0:	00800744 	movi	r2,29
  80a0e4:	18bfde26 	beq	r3,r2,80a060 <_fflush_r+0x160>
  80a0e8:	9080030b 	ldhu	r2,12(r18)
  80a0ec:	8007883a 	mov	r3,r16
  80a0f0:	10801014 	ori	r2,r2,64
  80a0f4:	9080030d 	sth	r2,12(r18)
  80a0f8:	003fcf06 	br	80a038 <_fflush_r+0x138>

0080a0fc <fflush>:
  80a0fc:	01402074 	movhi	r5,129
  80a100:	2967c004 	addi	r5,r5,-24832
  80a104:	2007883a 	mov	r3,r4
  80a108:	20000526 	beq	r4,zero,80a120 <fflush+0x24>
  80a10c:	008020b4 	movhi	r2,130
  80a110:	10a93104 	addi	r2,r2,-23356
  80a114:	11000017 	ldw	r4,0(r2)
  80a118:	180b883a 	mov	r5,r3
  80a11c:	0809f001 	jmpi	809f00 <_fflush_r>
  80a120:	008020b4 	movhi	r2,130
  80a124:	10a93204 	addi	r2,r2,-23352
  80a128:	11000017 	ldw	r4,0(r2)
  80a12c:	080ad001 	jmpi	80ad00 <_fwalk_reent>

0080a130 <std>:
  80a130:	00802074 	movhi	r2,129
  80a134:	10b49d04 	addi	r2,r2,-11660
  80a138:	20800b15 	stw	r2,44(r4)
  80a13c:	00802074 	movhi	r2,129
  80a140:	10b4d804 	addi	r2,r2,-11424
  80a144:	20800815 	stw	r2,32(r4)
  80a148:	00c02074 	movhi	r3,129
  80a14c:	18f4b904 	addi	r3,r3,-11548
  80a150:	00802074 	movhi	r2,129
  80a154:	10b49f04 	addi	r2,r2,-11652
  80a158:	2140030d 	sth	r5,12(r4)
  80a15c:	2180038d 	sth	r6,14(r4)
  80a160:	20c00915 	stw	r3,36(r4)
  80a164:	20800a15 	stw	r2,40(r4)
  80a168:	20000015 	stw	zero,0(r4)
  80a16c:	20000115 	stw	zero,4(r4)
  80a170:	20000215 	stw	zero,8(r4)
  80a174:	20000415 	stw	zero,16(r4)
  80a178:	20000515 	stw	zero,20(r4)
  80a17c:	20000615 	stw	zero,24(r4)
  80a180:	21000715 	stw	r4,28(r4)
  80a184:	f800283a 	ret

0080a188 <__sfp_lock_acquire>:
  80a188:	f800283a 	ret

0080a18c <__sfp_lock_release>:
  80a18c:	f800283a 	ret

0080a190 <__sinit_lock_acquire>:
  80a190:	f800283a 	ret

0080a194 <__sinit_lock_release>:
  80a194:	f800283a 	ret

0080a198 <__sinit>:
  80a198:	20800e17 	ldw	r2,56(r4)
  80a19c:	defffd04 	addi	sp,sp,-12
  80a1a0:	dc400115 	stw	r17,4(sp)
  80a1a4:	dc000015 	stw	r16,0(sp)
  80a1a8:	dfc00215 	stw	ra,8(sp)
  80a1ac:	04400044 	movi	r17,1
  80a1b0:	01400104 	movi	r5,4
  80a1b4:	000d883a 	mov	r6,zero
  80a1b8:	2021883a 	mov	r16,r4
  80a1bc:	2200bb04 	addi	r8,r4,748
  80a1c0:	200f883a 	mov	r7,r4
  80a1c4:	10000526 	beq	r2,zero,80a1dc <__sinit+0x44>
  80a1c8:	dfc00217 	ldw	ra,8(sp)
  80a1cc:	dc400117 	ldw	r17,4(sp)
  80a1d0:	dc000017 	ldw	r16,0(sp)
  80a1d4:	dec00304 	addi	sp,sp,12
  80a1d8:	f800283a 	ret
  80a1dc:	21000117 	ldw	r4,4(r4)
  80a1e0:	00802074 	movhi	r2,129
  80a1e4:	10a89f04 	addi	r2,r2,-23940
  80a1e8:	00c000c4 	movi	r3,3
  80a1ec:	80800f15 	stw	r2,60(r16)
  80a1f0:	80c0b915 	stw	r3,740(r16)
  80a1f4:	8200ba15 	stw	r8,744(r16)
  80a1f8:	84400e15 	stw	r17,56(r16)
  80a1fc:	8000b815 	stw	zero,736(r16)
  80a200:	080a1300 	call	80a130 <std>
  80a204:	81000217 	ldw	r4,8(r16)
  80a208:	880d883a 	mov	r6,r17
  80a20c:	800f883a 	mov	r7,r16
  80a210:	01400284 	movi	r5,10
  80a214:	080a1300 	call	80a130 <std>
  80a218:	81000317 	ldw	r4,12(r16)
  80a21c:	800f883a 	mov	r7,r16
  80a220:	01400484 	movi	r5,18
  80a224:	01800084 	movi	r6,2
  80a228:	dfc00217 	ldw	ra,8(sp)
  80a22c:	dc400117 	ldw	r17,4(sp)
  80a230:	dc000017 	ldw	r16,0(sp)
  80a234:	dec00304 	addi	sp,sp,12
  80a238:	080a1301 	jmpi	80a130 <std>

0080a23c <__fp_lock>:
  80a23c:	0005883a 	mov	r2,zero
  80a240:	f800283a 	ret

0080a244 <__fp_unlock>:
  80a244:	0005883a 	mov	r2,zero
  80a248:	f800283a 	ret

0080a24c <__fp_unlock_all>:
  80a24c:	008020b4 	movhi	r2,130
  80a250:	10a93104 	addi	r2,r2,-23356
  80a254:	11000017 	ldw	r4,0(r2)
  80a258:	01402074 	movhi	r5,129
  80a25c:	29689104 	addi	r5,r5,-23996
  80a260:	080adc81 	jmpi	80adc8 <_fwalk>

0080a264 <__fp_lock_all>:
  80a264:	008020b4 	movhi	r2,130
  80a268:	10a93104 	addi	r2,r2,-23356
  80a26c:	11000017 	ldw	r4,0(r2)
  80a270:	01402074 	movhi	r5,129
  80a274:	29688f04 	addi	r5,r5,-24004
  80a278:	080adc81 	jmpi	80adc8 <_fwalk>

0080a27c <_cleanup_r>:
  80a27c:	01402074 	movhi	r5,129
  80a280:	2975ec04 	addi	r5,r5,-10320
  80a284:	080adc81 	jmpi	80adc8 <_fwalk>

0080a288 <_cleanup>:
  80a288:	008020b4 	movhi	r2,130
  80a28c:	10a93204 	addi	r2,r2,-23352
  80a290:	11000017 	ldw	r4,0(r2)
  80a294:	080a27c1 	jmpi	80a27c <_cleanup_r>

0080a298 <__sfmoreglue>:
  80a298:	defffc04 	addi	sp,sp,-16
  80a29c:	dc000015 	stw	r16,0(sp)
  80a2a0:	2821883a 	mov	r16,r5
  80a2a4:	dc400115 	stw	r17,4(sp)
  80a2a8:	01401704 	movi	r5,92
  80a2ac:	2023883a 	mov	r17,r4
  80a2b0:	8009883a 	mov	r4,r16
  80a2b4:	dfc00315 	stw	ra,12(sp)
  80a2b8:	dcc00215 	stw	r19,8(sp)
  80a2bc:	08064840 	call	806484 <__mulsi3>
  80a2c0:	11400304 	addi	r5,r2,12
  80a2c4:	8809883a 	mov	r4,r17
  80a2c8:	1027883a 	mov	r19,r2
  80a2cc:	080b0d80 	call	80b0d8 <_malloc_r>
  80a2d0:	10c00304 	addi	r3,r2,12
  80a2d4:	1023883a 	mov	r17,r2
  80a2d8:	1809883a 	mov	r4,r3
  80a2dc:	980d883a 	mov	r6,r19
  80a2e0:	000b883a 	mov	r5,zero
  80a2e4:	10000b26 	beq	r2,zero,80a314 <__sfmoreglue+0x7c>
  80a2e8:	14000115 	stw	r16,4(r2)
  80a2ec:	10c00215 	stw	r3,8(r2)
  80a2f0:	10000015 	stw	zero,0(r2)
  80a2f4:	080ba7c0 	call	80ba7c <memset>
  80a2f8:	8805883a 	mov	r2,r17
  80a2fc:	dfc00317 	ldw	ra,12(sp)
  80a300:	dcc00217 	ldw	r19,8(sp)
  80a304:	dc400117 	ldw	r17,4(sp)
  80a308:	dc000017 	ldw	r16,0(sp)
  80a30c:	dec00404 	addi	sp,sp,16
  80a310:	f800283a 	ret
  80a314:	0023883a 	mov	r17,zero
  80a318:	8805883a 	mov	r2,r17
  80a31c:	dfc00317 	ldw	ra,12(sp)
  80a320:	dcc00217 	ldw	r19,8(sp)
  80a324:	dc400117 	ldw	r17,4(sp)
  80a328:	dc000017 	ldw	r16,0(sp)
  80a32c:	dec00404 	addi	sp,sp,16
  80a330:	f800283a 	ret

0080a334 <__sfp>:
  80a334:	defffd04 	addi	sp,sp,-12
  80a338:	008020b4 	movhi	r2,130
  80a33c:	10a93204 	addi	r2,r2,-23352
  80a340:	dc000015 	stw	r16,0(sp)
  80a344:	14000017 	ldw	r16,0(r2)
  80a348:	dc400115 	stw	r17,4(sp)
  80a34c:	dfc00215 	stw	ra,8(sp)
  80a350:	80800e17 	ldw	r2,56(r16)
  80a354:	2023883a 	mov	r17,r4
  80a358:	10002626 	beq	r2,zero,80a3f4 <__sfp+0xc0>
  80a35c:	8400b804 	addi	r16,r16,736
  80a360:	80800117 	ldw	r2,4(r16)
  80a364:	81000217 	ldw	r4,8(r16)
  80a368:	10ffffc4 	addi	r3,r2,-1
  80a36c:	18000916 	blt	r3,zero,80a394 <__sfp+0x60>
  80a370:	2080030f 	ldh	r2,12(r4)
  80a374:	10000b26 	beq	r2,zero,80a3a4 <__sfp+0x70>
  80a378:	017fffc4 	movi	r5,-1
  80a37c:	00000206 	br	80a388 <__sfp+0x54>
  80a380:	2080030f 	ldh	r2,12(r4)
  80a384:	10000726 	beq	r2,zero,80a3a4 <__sfp+0x70>
  80a388:	18ffffc4 	addi	r3,r3,-1
  80a38c:	21001704 	addi	r4,r4,92
  80a390:	197ffb1e 	bne	r3,r5,80a380 <__sfp+0x4c>
  80a394:	80800017 	ldw	r2,0(r16)
  80a398:	10001926 	beq	r2,zero,80a400 <__sfp+0xcc>
  80a39c:	1021883a 	mov	r16,r2
  80a3a0:	003fef06 	br	80a360 <__sfp+0x2c>
  80a3a4:	00bfffc4 	movi	r2,-1
  80a3a8:	00c00044 	movi	r3,1
  80a3ac:	2080038d 	sth	r2,14(r4)
  80a3b0:	20c0030d 	sth	r3,12(r4)
  80a3b4:	20000015 	stw	zero,0(r4)
  80a3b8:	20000215 	stw	zero,8(r4)
  80a3bc:	20000115 	stw	zero,4(r4)
  80a3c0:	20000415 	stw	zero,16(r4)
  80a3c4:	20000515 	stw	zero,20(r4)
  80a3c8:	20000615 	stw	zero,24(r4)
  80a3cc:	20000c15 	stw	zero,48(r4)
  80a3d0:	20000d15 	stw	zero,52(r4)
  80a3d4:	20001115 	stw	zero,68(r4)
  80a3d8:	20001215 	stw	zero,72(r4)
  80a3dc:	2005883a 	mov	r2,r4
  80a3e0:	dfc00217 	ldw	ra,8(sp)
  80a3e4:	dc400117 	ldw	r17,4(sp)
  80a3e8:	dc000017 	ldw	r16,0(sp)
  80a3ec:	dec00304 	addi	sp,sp,12
  80a3f0:	f800283a 	ret
  80a3f4:	8009883a 	mov	r4,r16
  80a3f8:	080a1980 	call	80a198 <__sinit>
  80a3fc:	003fd706 	br	80a35c <__sfp+0x28>
  80a400:	8809883a 	mov	r4,r17
  80a404:	01400104 	movi	r5,4
  80a408:	080a2980 	call	80a298 <__sfmoreglue>
  80a40c:	80800015 	stw	r2,0(r16)
  80a410:	103fe21e 	bne	r2,zero,80a39c <__sfp+0x68>
  80a414:	00800304 	movi	r2,12
  80a418:	0009883a 	mov	r4,zero
  80a41c:	88800015 	stw	r2,0(r17)
  80a420:	003fee06 	br	80a3dc <__sfp+0xa8>

0080a424 <_malloc_trim_r>:
  80a424:	defffb04 	addi	sp,sp,-20
  80a428:	dcc00315 	stw	r19,12(sp)
  80a42c:	04c020b4 	movhi	r19,130
  80a430:	9ce37704 	addi	r19,r19,-29220
  80a434:	dc800215 	stw	r18,8(sp)
  80a438:	dc400115 	stw	r17,4(sp)
  80a43c:	dc000015 	stw	r16,0(sp)
  80a440:	2823883a 	mov	r17,r5
  80a444:	2025883a 	mov	r18,r4
  80a448:	dfc00415 	stw	ra,16(sp)
  80a44c:	08135f00 	call	8135f0 <__malloc_lock>
  80a450:	98800217 	ldw	r2,8(r19)
  80a454:	9009883a 	mov	r4,r18
  80a458:	000b883a 	mov	r5,zero
  80a45c:	10c00117 	ldw	r3,4(r2)
  80a460:	00bfff04 	movi	r2,-4
  80a464:	18a0703a 	and	r16,r3,r2
  80a468:	8463c83a 	sub	r17,r16,r17
  80a46c:	8c43fbc4 	addi	r17,r17,4079
  80a470:	8822d33a 	srli	r17,r17,12
  80a474:	0083ffc4 	movi	r2,4095
  80a478:	8c7fffc4 	addi	r17,r17,-1
  80a47c:	8822933a 	slli	r17,r17,12
  80a480:	1440060e 	bge	r2,r17,80a49c <_malloc_trim_r+0x78>
  80a484:	080d2040 	call	80d204 <_sbrk_r>
  80a488:	98c00217 	ldw	r3,8(r19)
  80a48c:	9009883a 	mov	r4,r18
  80a490:	044bc83a 	sub	r5,zero,r17
  80a494:	80c7883a 	add	r3,r16,r3
  80a498:	10c00926 	beq	r2,r3,80a4c0 <_malloc_trim_r+0x9c>
  80a49c:	08136100 	call	813610 <__malloc_unlock>
  80a4a0:	0005883a 	mov	r2,zero
  80a4a4:	dfc00417 	ldw	ra,16(sp)
  80a4a8:	dcc00317 	ldw	r19,12(sp)
  80a4ac:	dc800217 	ldw	r18,8(sp)
  80a4b0:	dc400117 	ldw	r17,4(sp)
  80a4b4:	dc000017 	ldw	r16,0(sp)
  80a4b8:	dec00504 	addi	sp,sp,20
  80a4bc:	f800283a 	ret
  80a4c0:	9009883a 	mov	r4,r18
  80a4c4:	080d2040 	call	80d204 <_sbrk_r>
  80a4c8:	844dc83a 	sub	r6,r16,r17
  80a4cc:	00ffffc4 	movi	r3,-1
  80a4d0:	9009883a 	mov	r4,r18
  80a4d4:	000b883a 	mov	r5,zero
  80a4d8:	01c020f4 	movhi	r7,131
  80a4dc:	39f9d304 	addi	r7,r7,-6324
  80a4e0:	31800054 	ori	r6,r6,1
  80a4e4:	10c00926 	beq	r2,r3,80a50c <_malloc_trim_r+0xe8>
  80a4e8:	38800017 	ldw	r2,0(r7)
  80a4ec:	98c00217 	ldw	r3,8(r19)
  80a4f0:	9009883a 	mov	r4,r18
  80a4f4:	1445c83a 	sub	r2,r2,r17
  80a4f8:	38800015 	stw	r2,0(r7)
  80a4fc:	19800115 	stw	r6,4(r3)
  80a500:	08136100 	call	813610 <__malloc_unlock>
  80a504:	00800044 	movi	r2,1
  80a508:	003fe606 	br	80a4a4 <_malloc_trim_r+0x80>
  80a50c:	080d2040 	call	80d204 <_sbrk_r>
  80a510:	99800217 	ldw	r6,8(r19)
  80a514:	100f883a 	mov	r7,r2
  80a518:	9009883a 	mov	r4,r18
  80a51c:	1187c83a 	sub	r3,r2,r6
  80a520:	008003c4 	movi	r2,15
  80a524:	19400054 	ori	r5,r3,1
  80a528:	10ffdc0e 	bge	r2,r3,80a49c <_malloc_trim_r+0x78>
  80a52c:	008020b4 	movhi	r2,130
  80a530:	10a93604 	addi	r2,r2,-23336
  80a534:	10c00017 	ldw	r3,0(r2)
  80a538:	008020f4 	movhi	r2,131
  80a53c:	10b9d304 	addi	r2,r2,-6324
  80a540:	31400115 	stw	r5,4(r6)
  80a544:	38c7c83a 	sub	r3,r7,r3
  80a548:	10c00015 	stw	r3,0(r2)
  80a54c:	003fd306 	br	80a49c <_malloc_trim_r+0x78>

0080a550 <_free_r>:
  80a550:	defffd04 	addi	sp,sp,-12
  80a554:	dc400115 	stw	r17,4(sp)
  80a558:	dc000015 	stw	r16,0(sp)
  80a55c:	dfc00215 	stw	ra,8(sp)
  80a560:	2821883a 	mov	r16,r5
  80a564:	2023883a 	mov	r17,r4
  80a568:	28005a26 	beq	r5,zero,80a6d4 <_free_r+0x184>
  80a56c:	08135f00 	call	8135f0 <__malloc_lock>
  80a570:	823ffe04 	addi	r8,r16,-8
  80a574:	41400117 	ldw	r5,4(r8)
  80a578:	00bfff84 	movi	r2,-2
  80a57c:	028020b4 	movhi	r10,130
  80a580:	52a37704 	addi	r10,r10,-29220
  80a584:	288e703a 	and	r7,r5,r2
  80a588:	41cd883a 	add	r6,r8,r7
  80a58c:	30c00117 	ldw	r3,4(r6)
  80a590:	51000217 	ldw	r4,8(r10)
  80a594:	00bfff04 	movi	r2,-4
  80a598:	1892703a 	and	r9,r3,r2
  80a59c:	5017883a 	mov	r11,r10
  80a5a0:	31006726 	beq	r6,r4,80a740 <_free_r+0x1f0>
  80a5a4:	2880004c 	andi	r2,r5,1
  80a5a8:	1005003a 	cmpeq	r2,r2,zero
  80a5ac:	32400115 	stw	r9,4(r6)
  80a5b0:	10001a1e 	bne	r2,zero,80a61c <_free_r+0xcc>
  80a5b4:	000b883a 	mov	r5,zero
  80a5b8:	3247883a 	add	r3,r6,r9
  80a5bc:	18800117 	ldw	r2,4(r3)
  80a5c0:	1080004c 	andi	r2,r2,1
  80a5c4:	1000231e 	bne	r2,zero,80a654 <_free_r+0x104>
  80a5c8:	280ac03a 	cmpne	r5,r5,zero
  80a5cc:	3a4f883a 	add	r7,r7,r9
  80a5d0:	2800451e 	bne	r5,zero,80a6e8 <_free_r+0x198>
  80a5d4:	31000217 	ldw	r4,8(r6)
  80a5d8:	008020b4 	movhi	r2,130
  80a5dc:	10a37904 	addi	r2,r2,-29212
  80a5e0:	20807b26 	beq	r4,r2,80a7d0 <_free_r+0x280>
  80a5e4:	30800317 	ldw	r2,12(r6)
  80a5e8:	3a07883a 	add	r3,r7,r8
  80a5ec:	19c00015 	stw	r7,0(r3)
  80a5f0:	11000215 	stw	r4,8(r2)
  80a5f4:	20800315 	stw	r2,12(r4)
  80a5f8:	38800054 	ori	r2,r7,1
  80a5fc:	40800115 	stw	r2,4(r8)
  80a600:	28001a26 	beq	r5,zero,80a66c <_free_r+0x11c>
  80a604:	8809883a 	mov	r4,r17
  80a608:	dfc00217 	ldw	ra,8(sp)
  80a60c:	dc400117 	ldw	r17,4(sp)
  80a610:	dc000017 	ldw	r16,0(sp)
  80a614:	dec00304 	addi	sp,sp,12
  80a618:	08136101 	jmpi	813610 <__malloc_unlock>
  80a61c:	80bffe17 	ldw	r2,-8(r16)
  80a620:	50c00204 	addi	r3,r10,8
  80a624:	4091c83a 	sub	r8,r8,r2
  80a628:	41000217 	ldw	r4,8(r8)
  80a62c:	388f883a 	add	r7,r7,r2
  80a630:	20c06126 	beq	r4,r3,80a7b8 <_free_r+0x268>
  80a634:	40800317 	ldw	r2,12(r8)
  80a638:	3247883a 	add	r3,r6,r9
  80a63c:	000b883a 	mov	r5,zero
  80a640:	11000215 	stw	r4,8(r2)
  80a644:	20800315 	stw	r2,12(r4)
  80a648:	18800117 	ldw	r2,4(r3)
  80a64c:	1080004c 	andi	r2,r2,1
  80a650:	103fdd26 	beq	r2,zero,80a5c8 <_free_r+0x78>
  80a654:	38800054 	ori	r2,r7,1
  80a658:	3a07883a 	add	r3,r7,r8
  80a65c:	280ac03a 	cmpne	r5,r5,zero
  80a660:	40800115 	stw	r2,4(r8)
  80a664:	19c00015 	stw	r7,0(r3)
  80a668:	283fe61e 	bne	r5,zero,80a604 <_free_r+0xb4>
  80a66c:	00807fc4 	movi	r2,511
  80a670:	11c01f2e 	bgeu	r2,r7,80a6f0 <_free_r+0x1a0>
  80a674:	3806d27a 	srli	r3,r7,9
  80a678:	1800481e 	bne	r3,zero,80a79c <_free_r+0x24c>
  80a67c:	3804d0fa 	srli	r2,r7,3
  80a680:	100690fa 	slli	r3,r2,3
  80a684:	1acd883a 	add	r6,r3,r11
  80a688:	31400217 	ldw	r5,8(r6)
  80a68c:	31405926 	beq	r6,r5,80a7f4 <_free_r+0x2a4>
  80a690:	28800117 	ldw	r2,4(r5)
  80a694:	00ffff04 	movi	r3,-4
  80a698:	10c4703a 	and	r2,r2,r3
  80a69c:	3880022e 	bgeu	r7,r2,80a6a8 <_free_r+0x158>
  80a6a0:	29400217 	ldw	r5,8(r5)
  80a6a4:	317ffa1e 	bne	r6,r5,80a690 <_free_r+0x140>
  80a6a8:	29800317 	ldw	r6,12(r5)
  80a6ac:	41800315 	stw	r6,12(r8)
  80a6b0:	41400215 	stw	r5,8(r8)
  80a6b4:	8809883a 	mov	r4,r17
  80a6b8:	2a000315 	stw	r8,12(r5)
  80a6bc:	32000215 	stw	r8,8(r6)
  80a6c0:	dfc00217 	ldw	ra,8(sp)
  80a6c4:	dc400117 	ldw	r17,4(sp)
  80a6c8:	dc000017 	ldw	r16,0(sp)
  80a6cc:	dec00304 	addi	sp,sp,12
  80a6d0:	08136101 	jmpi	813610 <__malloc_unlock>
  80a6d4:	dfc00217 	ldw	ra,8(sp)
  80a6d8:	dc400117 	ldw	r17,4(sp)
  80a6dc:	dc000017 	ldw	r16,0(sp)
  80a6e0:	dec00304 	addi	sp,sp,12
  80a6e4:	f800283a 	ret
  80a6e8:	31000217 	ldw	r4,8(r6)
  80a6ec:	003fbd06 	br	80a5e4 <_free_r+0x94>
  80a6f0:	3806d0fa 	srli	r3,r7,3
  80a6f4:	00800044 	movi	r2,1
  80a6f8:	51400117 	ldw	r5,4(r10)
  80a6fc:	180890fa 	slli	r4,r3,3
  80a700:	1807d0ba 	srai	r3,r3,2
  80a704:	22c9883a 	add	r4,r4,r11
  80a708:	21800217 	ldw	r6,8(r4)
  80a70c:	10c4983a 	sll	r2,r2,r3
  80a710:	41000315 	stw	r4,12(r8)
  80a714:	41800215 	stw	r6,8(r8)
  80a718:	288ab03a 	or	r5,r5,r2
  80a71c:	22000215 	stw	r8,8(r4)
  80a720:	8809883a 	mov	r4,r17
  80a724:	51400115 	stw	r5,4(r10)
  80a728:	32000315 	stw	r8,12(r6)
  80a72c:	dfc00217 	ldw	ra,8(sp)
  80a730:	dc400117 	ldw	r17,4(sp)
  80a734:	dc000017 	ldw	r16,0(sp)
  80a738:	dec00304 	addi	sp,sp,12
  80a73c:	08136101 	jmpi	813610 <__malloc_unlock>
  80a740:	2880004c 	andi	r2,r5,1
  80a744:	3a4d883a 	add	r6,r7,r9
  80a748:	1000071e 	bne	r2,zero,80a768 <_free_r+0x218>
  80a74c:	80bffe17 	ldw	r2,-8(r16)
  80a750:	4091c83a 	sub	r8,r8,r2
  80a754:	41000317 	ldw	r4,12(r8)
  80a758:	40c00217 	ldw	r3,8(r8)
  80a75c:	308d883a 	add	r6,r6,r2
  80a760:	20c00215 	stw	r3,8(r4)
  80a764:	19000315 	stw	r4,12(r3)
  80a768:	008020b4 	movhi	r2,130
  80a76c:	10a93504 	addi	r2,r2,-23340
  80a770:	11000017 	ldw	r4,0(r2)
  80a774:	30c00054 	ori	r3,r6,1
  80a778:	52000215 	stw	r8,8(r10)
  80a77c:	40c00115 	stw	r3,4(r8)
  80a780:	313fa036 	bltu	r6,r4,80a604 <_free_r+0xb4>
  80a784:	008020b4 	movhi	r2,130
  80a788:	10b02104 	addi	r2,r2,-16252
  80a78c:	11400017 	ldw	r5,0(r2)
  80a790:	8809883a 	mov	r4,r17
  80a794:	080a4240 	call	80a424 <_malloc_trim_r>
  80a798:	003f9a06 	br	80a604 <_free_r+0xb4>
  80a79c:	00800104 	movi	r2,4
  80a7a0:	10c0072e 	bgeu	r2,r3,80a7c0 <_free_r+0x270>
  80a7a4:	00800504 	movi	r2,20
  80a7a8:	10c01936 	bltu	r2,r3,80a810 <_free_r+0x2c0>
  80a7ac:	188016c4 	addi	r2,r3,91
  80a7b0:	100690fa 	slli	r3,r2,3
  80a7b4:	003fb306 	br	80a684 <_free_r+0x134>
  80a7b8:	01400044 	movi	r5,1
  80a7bc:	003f7e06 	br	80a5b8 <_free_r+0x68>
  80a7c0:	3804d1ba 	srli	r2,r7,6
  80a7c4:	10800e04 	addi	r2,r2,56
  80a7c8:	100690fa 	slli	r3,r2,3
  80a7cc:	003fad06 	br	80a684 <_free_r+0x134>
  80a7d0:	22000315 	stw	r8,12(r4)
  80a7d4:	22000215 	stw	r8,8(r4)
  80a7d8:	3a05883a 	add	r2,r7,r8
  80a7dc:	38c00054 	ori	r3,r7,1
  80a7e0:	11c00015 	stw	r7,0(r2)
  80a7e4:	41000215 	stw	r4,8(r8)
  80a7e8:	40c00115 	stw	r3,4(r8)
  80a7ec:	41000315 	stw	r4,12(r8)
  80a7f0:	003f8406 	br	80a604 <_free_r+0xb4>
  80a7f4:	1005d0ba 	srai	r2,r2,2
  80a7f8:	00c00044 	movi	r3,1
  80a7fc:	51000117 	ldw	r4,4(r10)
  80a800:	1886983a 	sll	r3,r3,r2
  80a804:	20c8b03a 	or	r4,r4,r3
  80a808:	51000115 	stw	r4,4(r10)
  80a80c:	003fa706 	br	80a6ac <_free_r+0x15c>
  80a810:	00801504 	movi	r2,84
  80a814:	10c00436 	bltu	r2,r3,80a828 <_free_r+0x2d8>
  80a818:	3804d33a 	srli	r2,r7,12
  80a81c:	10801b84 	addi	r2,r2,110
  80a820:	100690fa 	slli	r3,r2,3
  80a824:	003f9706 	br	80a684 <_free_r+0x134>
  80a828:	00805504 	movi	r2,340
  80a82c:	10c00436 	bltu	r2,r3,80a840 <_free_r+0x2f0>
  80a830:	3804d3fa 	srli	r2,r7,15
  80a834:	10801dc4 	addi	r2,r2,119
  80a838:	100690fa 	slli	r3,r2,3
  80a83c:	003f9106 	br	80a684 <_free_r+0x134>
  80a840:	00815504 	movi	r2,1364
  80a844:	10c0032e 	bgeu	r2,r3,80a854 <_free_r+0x304>
  80a848:	00801f84 	movi	r2,126
  80a84c:	00c0fc04 	movi	r3,1008
  80a850:	003f8c06 	br	80a684 <_free_r+0x134>
  80a854:	3804d4ba 	srli	r2,r7,18
  80a858:	10801f04 	addi	r2,r2,124
  80a85c:	100690fa 	slli	r3,r2,3
  80a860:	003f8806 	br	80a684 <_free_r+0x134>

0080a864 <__sfvwrite_r>:
  80a864:	30800217 	ldw	r2,8(r6)
  80a868:	defff504 	addi	sp,sp,-44
  80a86c:	df000915 	stw	fp,36(sp)
  80a870:	dd800715 	stw	r22,28(sp)
  80a874:	dc800315 	stw	r18,12(sp)
  80a878:	dfc00a15 	stw	ra,40(sp)
  80a87c:	ddc00815 	stw	r23,32(sp)
  80a880:	dd400615 	stw	r21,24(sp)
  80a884:	dd000515 	stw	r20,20(sp)
  80a888:	dcc00415 	stw	r19,16(sp)
  80a88c:	dc400215 	stw	r17,8(sp)
  80a890:	dc000115 	stw	r16,4(sp)
  80a894:	302d883a 	mov	r22,r6
  80a898:	2039883a 	mov	fp,r4
  80a89c:	2825883a 	mov	r18,r5
  80a8a0:	10001c26 	beq	r2,zero,80a914 <__sfvwrite_r+0xb0>
  80a8a4:	29c0030b 	ldhu	r7,12(r5)
  80a8a8:	3880020c 	andi	r2,r7,8
  80a8ac:	10002726 	beq	r2,zero,80a94c <__sfvwrite_r+0xe8>
  80a8b0:	28800417 	ldw	r2,16(r5)
  80a8b4:	10002526 	beq	r2,zero,80a94c <__sfvwrite_r+0xe8>
  80a8b8:	3880008c 	andi	r2,r7,2
  80a8bc:	b5400017 	ldw	r21,0(r22)
  80a8c0:	10002826 	beq	r2,zero,80a964 <__sfvwrite_r+0x100>
  80a8c4:	0021883a 	mov	r16,zero
  80a8c8:	0023883a 	mov	r17,zero
  80a8cc:	880d883a 	mov	r6,r17
  80a8d0:	e009883a 	mov	r4,fp
  80a8d4:	00810004 	movi	r2,1024
  80a8d8:	80006e26 	beq	r16,zero,80aa94 <__sfvwrite_r+0x230>
  80a8dc:	800f883a 	mov	r7,r16
  80a8e0:	91400717 	ldw	r5,28(r18)
  80a8e4:	1400012e 	bgeu	r2,r16,80a8ec <__sfvwrite_r+0x88>
  80a8e8:	100f883a 	mov	r7,r2
  80a8ec:	90c00917 	ldw	r3,36(r18)
  80a8f0:	183ee83a 	callr	r3
  80a8f4:	1007883a 	mov	r3,r2
  80a8f8:	80a1c83a 	sub	r16,r16,r2
  80a8fc:	88a3883a 	add	r17,r17,r2
  80a900:	00806d0e 	bge	zero,r2,80aab8 <__sfvwrite_r+0x254>
  80a904:	b0800217 	ldw	r2,8(r22)
  80a908:	10c5c83a 	sub	r2,r2,r3
  80a90c:	b0800215 	stw	r2,8(r22)
  80a910:	103fee1e 	bne	r2,zero,80a8cc <__sfvwrite_r+0x68>
  80a914:	0009883a 	mov	r4,zero
  80a918:	2005883a 	mov	r2,r4
  80a91c:	dfc00a17 	ldw	ra,40(sp)
  80a920:	df000917 	ldw	fp,36(sp)
  80a924:	ddc00817 	ldw	r23,32(sp)
  80a928:	dd800717 	ldw	r22,28(sp)
  80a92c:	dd400617 	ldw	r21,24(sp)
  80a930:	dd000517 	ldw	r20,20(sp)
  80a934:	dcc00417 	ldw	r19,16(sp)
  80a938:	dc800317 	ldw	r18,12(sp)
  80a93c:	dc400217 	ldw	r17,8(sp)
  80a940:	dc000117 	ldw	r16,4(sp)
  80a944:	dec00b04 	addi	sp,sp,44
  80a948:	f800283a 	ret
  80a94c:	08085cc0 	call	8085cc <__swsetup_r>
  80a950:	1000e41e 	bne	r2,zero,80ace4 <__sfvwrite_r+0x480>
  80a954:	91c0030b 	ldhu	r7,12(r18)
  80a958:	b5400017 	ldw	r21,0(r22)
  80a95c:	3880008c 	andi	r2,r7,2
  80a960:	103fd81e 	bne	r2,zero,80a8c4 <__sfvwrite_r+0x60>
  80a964:	3880004c 	andi	r2,r7,1
  80a968:	1005003a 	cmpeq	r2,r2,zero
  80a96c:	10005726 	beq	r2,zero,80aacc <__sfvwrite_r+0x268>
  80a970:	0029883a 	mov	r20,zero
  80a974:	002f883a 	mov	r23,zero
  80a978:	a0004226 	beq	r20,zero,80aa84 <__sfvwrite_r+0x220>
  80a97c:	3880800c 	andi	r2,r7,512
  80a980:	94000217 	ldw	r16,8(r18)
  80a984:	10008b26 	beq	r2,zero,80abb4 <__sfvwrite_r+0x350>
  80a988:	800d883a 	mov	r6,r16
  80a98c:	a400a536 	bltu	r20,r16,80ac24 <__sfvwrite_r+0x3c0>
  80a990:	3881200c 	andi	r2,r7,1152
  80a994:	10002726 	beq	r2,zero,80aa34 <__sfvwrite_r+0x1d0>
  80a998:	90800517 	ldw	r2,20(r18)
  80a99c:	92000417 	ldw	r8,16(r18)
  80a9a0:	91400017 	ldw	r5,0(r18)
  80a9a4:	1087883a 	add	r3,r2,r2
  80a9a8:	1887883a 	add	r3,r3,r2
  80a9ac:	1808d7fa 	srli	r4,r3,31
  80a9b0:	2a21c83a 	sub	r16,r5,r8
  80a9b4:	80800044 	addi	r2,r16,1
  80a9b8:	20c9883a 	add	r4,r4,r3
  80a9bc:	2027d07a 	srai	r19,r4,1
  80a9c0:	a085883a 	add	r2,r20,r2
  80a9c4:	980d883a 	mov	r6,r19
  80a9c8:	9880022e 	bgeu	r19,r2,80a9d4 <__sfvwrite_r+0x170>
  80a9cc:	1027883a 	mov	r19,r2
  80a9d0:	100d883a 	mov	r6,r2
  80a9d4:	3881000c 	andi	r2,r7,1024
  80a9d8:	1000b826 	beq	r2,zero,80acbc <__sfvwrite_r+0x458>
  80a9dc:	300b883a 	mov	r5,r6
  80a9e0:	e009883a 	mov	r4,fp
  80a9e4:	080b0d80 	call	80b0d8 <_malloc_r>
  80a9e8:	10003126 	beq	r2,zero,80aab0 <__sfvwrite_r+0x24c>
  80a9ec:	91400417 	ldw	r5,16(r18)
  80a9f0:	1009883a 	mov	r4,r2
  80a9f4:	800d883a 	mov	r6,r16
  80a9f8:	1023883a 	mov	r17,r2
  80a9fc:	080b8fc0 	call	80b8fc <memcpy>
  80aa00:	90c0030b 	ldhu	r3,12(r18)
  80aa04:	00beffc4 	movi	r2,-1025
  80aa08:	1886703a 	and	r3,r3,r2
  80aa0c:	18c02014 	ori	r3,r3,128
  80aa10:	90c0030d 	sth	r3,12(r18)
  80aa14:	9c07c83a 	sub	r3,r19,r16
  80aa18:	8c05883a 	add	r2,r17,r16
  80aa1c:	a00d883a 	mov	r6,r20
  80aa20:	a021883a 	mov	r16,r20
  80aa24:	90800015 	stw	r2,0(r18)
  80aa28:	90c00215 	stw	r3,8(r18)
  80aa2c:	94400415 	stw	r17,16(r18)
  80aa30:	94c00515 	stw	r19,20(r18)
  80aa34:	91000017 	ldw	r4,0(r18)
  80aa38:	b80b883a 	mov	r5,r23
  80aa3c:	a023883a 	mov	r17,r20
  80aa40:	080b99c0 	call	80b99c <memmove>
  80aa44:	90c00217 	ldw	r3,8(r18)
  80aa48:	90800017 	ldw	r2,0(r18)
  80aa4c:	a027883a 	mov	r19,r20
  80aa50:	1c07c83a 	sub	r3,r3,r16
  80aa54:	1405883a 	add	r2,r2,r16
  80aa58:	90c00215 	stw	r3,8(r18)
  80aa5c:	a021883a 	mov	r16,r20
  80aa60:	90800015 	stw	r2,0(r18)
  80aa64:	b0800217 	ldw	r2,8(r22)
  80aa68:	1405c83a 	sub	r2,r2,r16
  80aa6c:	b0800215 	stw	r2,8(r22)
  80aa70:	103fa826 	beq	r2,zero,80a914 <__sfvwrite_r+0xb0>
  80aa74:	a469c83a 	sub	r20,r20,r17
  80aa78:	91c0030b 	ldhu	r7,12(r18)
  80aa7c:	bcef883a 	add	r23,r23,r19
  80aa80:	a03fbe1e 	bne	r20,zero,80a97c <__sfvwrite_r+0x118>
  80aa84:	adc00017 	ldw	r23,0(r21)
  80aa88:	ad000117 	ldw	r20,4(r21)
  80aa8c:	ad400204 	addi	r21,r21,8
  80aa90:	003fb906 	br	80a978 <__sfvwrite_r+0x114>
  80aa94:	ac400017 	ldw	r17,0(r21)
  80aa98:	ac000117 	ldw	r16,4(r21)
  80aa9c:	ad400204 	addi	r21,r21,8
  80aaa0:	003f8a06 	br	80a8cc <__sfvwrite_r+0x68>
  80aaa4:	91400417 	ldw	r5,16(r18)
  80aaa8:	e009883a 	mov	r4,fp
  80aaac:	080a5500 	call	80a550 <_free_r>
  80aab0:	00800304 	movi	r2,12
  80aab4:	e0800015 	stw	r2,0(fp)
  80aab8:	9080030b 	ldhu	r2,12(r18)
  80aabc:	013fffc4 	movi	r4,-1
  80aac0:	10801014 	ori	r2,r2,64
  80aac4:	9080030d 	sth	r2,12(r18)
  80aac8:	003f9306 	br	80a918 <__sfvwrite_r+0xb4>
  80aacc:	0027883a 	mov	r19,zero
  80aad0:	002f883a 	mov	r23,zero
  80aad4:	d8000015 	stw	zero,0(sp)
  80aad8:	0029883a 	mov	r20,zero
  80aadc:	98001e26 	beq	r19,zero,80ab58 <__sfvwrite_r+0x2f4>
  80aae0:	d8c00017 	ldw	r3,0(sp)
  80aae4:	1804c03a 	cmpne	r2,r3,zero
  80aae8:	10005e26 	beq	r2,zero,80ac64 <__sfvwrite_r+0x400>
  80aaec:	9821883a 	mov	r16,r19
  80aaf0:	a4c0012e 	bgeu	r20,r19,80aaf8 <__sfvwrite_r+0x294>
  80aaf4:	a021883a 	mov	r16,r20
  80aaf8:	91000017 	ldw	r4,0(r18)
  80aafc:	90800417 	ldw	r2,16(r18)
  80ab00:	91800217 	ldw	r6,8(r18)
  80ab04:	91c00517 	ldw	r7,20(r18)
  80ab08:	1100022e 	bgeu	r2,r4,80ab14 <__sfvwrite_r+0x2b0>
  80ab0c:	31e3883a 	add	r17,r6,r7
  80ab10:	8c001616 	blt	r17,r16,80ab6c <__sfvwrite_r+0x308>
  80ab14:	81c03816 	blt	r16,r7,80abf8 <__sfvwrite_r+0x394>
  80ab18:	90c00917 	ldw	r3,36(r18)
  80ab1c:	91400717 	ldw	r5,28(r18)
  80ab20:	e009883a 	mov	r4,fp
  80ab24:	b80d883a 	mov	r6,r23
  80ab28:	183ee83a 	callr	r3
  80ab2c:	1023883a 	mov	r17,r2
  80ab30:	00bfe10e 	bge	zero,r2,80aab8 <__sfvwrite_r+0x254>
  80ab34:	a469c83a 	sub	r20,r20,r17
  80ab38:	a0001826 	beq	r20,zero,80ab9c <__sfvwrite_r+0x338>
  80ab3c:	b0800217 	ldw	r2,8(r22)
  80ab40:	1445c83a 	sub	r2,r2,r17
  80ab44:	b0800215 	stw	r2,8(r22)
  80ab48:	103f7226 	beq	r2,zero,80a914 <__sfvwrite_r+0xb0>
  80ab4c:	9c67c83a 	sub	r19,r19,r17
  80ab50:	bc6f883a 	add	r23,r23,r17
  80ab54:	983fe21e 	bne	r19,zero,80aae0 <__sfvwrite_r+0x27c>
  80ab58:	adc00017 	ldw	r23,0(r21)
  80ab5c:	acc00117 	ldw	r19,4(r21)
  80ab60:	ad400204 	addi	r21,r21,8
  80ab64:	d8000015 	stw	zero,0(sp)
  80ab68:	003fdc06 	br	80aadc <__sfvwrite_r+0x278>
  80ab6c:	b80b883a 	mov	r5,r23
  80ab70:	880d883a 	mov	r6,r17
  80ab74:	080b99c0 	call	80b99c <memmove>
  80ab78:	90c00017 	ldw	r3,0(r18)
  80ab7c:	e009883a 	mov	r4,fp
  80ab80:	900b883a 	mov	r5,r18
  80ab84:	1c47883a 	add	r3,r3,r17
  80ab88:	90c00015 	stw	r3,0(r18)
  80ab8c:	0809f000 	call	809f00 <_fflush_r>
  80ab90:	103fc91e 	bne	r2,zero,80aab8 <__sfvwrite_r+0x254>
  80ab94:	a469c83a 	sub	r20,r20,r17
  80ab98:	a03fe81e 	bne	r20,zero,80ab3c <__sfvwrite_r+0x2d8>
  80ab9c:	e009883a 	mov	r4,fp
  80aba0:	900b883a 	mov	r5,r18
  80aba4:	0809f000 	call	809f00 <_fflush_r>
  80aba8:	103fc31e 	bne	r2,zero,80aab8 <__sfvwrite_r+0x254>
  80abac:	d8000015 	stw	zero,0(sp)
  80abb0:	003fe206 	br	80ab3c <__sfvwrite_r+0x2d8>
  80abb4:	91000017 	ldw	r4,0(r18)
  80abb8:	90800417 	ldw	r2,16(r18)
  80abbc:	1100022e 	bgeu	r2,r4,80abc8 <__sfvwrite_r+0x364>
  80abc0:	8023883a 	mov	r17,r16
  80abc4:	85003136 	bltu	r16,r20,80ac8c <__sfvwrite_r+0x428>
  80abc8:	91c00517 	ldw	r7,20(r18)
  80abcc:	a1c01836 	bltu	r20,r7,80ac30 <__sfvwrite_r+0x3cc>
  80abd0:	90c00917 	ldw	r3,36(r18)
  80abd4:	91400717 	ldw	r5,28(r18)
  80abd8:	e009883a 	mov	r4,fp
  80abdc:	b80d883a 	mov	r6,r23
  80abe0:	183ee83a 	callr	r3
  80abe4:	1021883a 	mov	r16,r2
  80abe8:	00bfb30e 	bge	zero,r2,80aab8 <__sfvwrite_r+0x254>
  80abec:	1023883a 	mov	r17,r2
  80abf0:	1027883a 	mov	r19,r2
  80abf4:	003f9b06 	br	80aa64 <__sfvwrite_r+0x200>
  80abf8:	b80b883a 	mov	r5,r23
  80abfc:	800d883a 	mov	r6,r16
  80ac00:	080b99c0 	call	80b99c <memmove>
  80ac04:	90c00217 	ldw	r3,8(r18)
  80ac08:	90800017 	ldw	r2,0(r18)
  80ac0c:	8023883a 	mov	r17,r16
  80ac10:	1c07c83a 	sub	r3,r3,r16
  80ac14:	1405883a 	add	r2,r2,r16
  80ac18:	90c00215 	stw	r3,8(r18)
  80ac1c:	90800015 	stw	r2,0(r18)
  80ac20:	003fc406 	br	80ab34 <__sfvwrite_r+0x2d0>
  80ac24:	a00d883a 	mov	r6,r20
  80ac28:	a021883a 	mov	r16,r20
  80ac2c:	003f8106 	br	80aa34 <__sfvwrite_r+0x1d0>
  80ac30:	b80b883a 	mov	r5,r23
  80ac34:	a00d883a 	mov	r6,r20
  80ac38:	080b99c0 	call	80b99c <memmove>
  80ac3c:	90c00217 	ldw	r3,8(r18)
  80ac40:	90800017 	ldw	r2,0(r18)
  80ac44:	a021883a 	mov	r16,r20
  80ac48:	1d07c83a 	sub	r3,r3,r20
  80ac4c:	1505883a 	add	r2,r2,r20
  80ac50:	a023883a 	mov	r17,r20
  80ac54:	a027883a 	mov	r19,r20
  80ac58:	90c00215 	stw	r3,8(r18)
  80ac5c:	90800015 	stw	r2,0(r18)
  80ac60:	003f8006 	br	80aa64 <__sfvwrite_r+0x200>
  80ac64:	b809883a 	mov	r4,r23
  80ac68:	01400284 	movi	r5,10
  80ac6c:	980d883a 	mov	r6,r19
  80ac70:	080b8180 	call	80b818 <memchr>
  80ac74:	10001726 	beq	r2,zero,80acd4 <__sfvwrite_r+0x470>
  80ac78:	15c5c83a 	sub	r2,r2,r23
  80ac7c:	15000044 	addi	r20,r2,1
  80ac80:	00800044 	movi	r2,1
  80ac84:	d8800015 	stw	r2,0(sp)
  80ac88:	003f9806 	br	80aaec <__sfvwrite_r+0x288>
  80ac8c:	b80b883a 	mov	r5,r23
  80ac90:	800d883a 	mov	r6,r16
  80ac94:	080b99c0 	call	80b99c <memmove>
  80ac98:	90c00017 	ldw	r3,0(r18)
  80ac9c:	e009883a 	mov	r4,fp
  80aca0:	900b883a 	mov	r5,r18
  80aca4:	1c07883a 	add	r3,r3,r16
  80aca8:	90c00015 	stw	r3,0(r18)
  80acac:	8027883a 	mov	r19,r16
  80acb0:	0809f000 	call	809f00 <_fflush_r>
  80acb4:	103f6b26 	beq	r2,zero,80aa64 <__sfvwrite_r+0x200>
  80acb8:	003f7f06 	br	80aab8 <__sfvwrite_r+0x254>
  80acbc:	400b883a 	mov	r5,r8
  80acc0:	e009883a 	mov	r4,fp
  80acc4:	080cba00 	call	80cba0 <_realloc_r>
  80acc8:	103f7626 	beq	r2,zero,80aaa4 <__sfvwrite_r+0x240>
  80accc:	1023883a 	mov	r17,r2
  80acd0:	003f5006 	br	80aa14 <__sfvwrite_r+0x1b0>
  80acd4:	00c00044 	movi	r3,1
  80acd8:	9d000044 	addi	r20,r19,1
  80acdc:	d8c00015 	stw	r3,0(sp)
  80ace0:	003f8206 	br	80aaec <__sfvwrite_r+0x288>
  80ace4:	9080030b 	ldhu	r2,12(r18)
  80ace8:	00c00244 	movi	r3,9
  80acec:	013fffc4 	movi	r4,-1
  80acf0:	10801014 	ori	r2,r2,64
  80acf4:	9080030d 	sth	r2,12(r18)
  80acf8:	e0c00015 	stw	r3,0(fp)
  80acfc:	003f0606 	br	80a918 <__sfvwrite_r+0xb4>

0080ad00 <_fwalk_reent>:
  80ad00:	defff704 	addi	sp,sp,-36
  80ad04:	dcc00315 	stw	r19,12(sp)
  80ad08:	24c0b804 	addi	r19,r4,736
  80ad0c:	dd800615 	stw	r22,24(sp)
  80ad10:	dd400515 	stw	r21,20(sp)
  80ad14:	dfc00815 	stw	ra,32(sp)
  80ad18:	ddc00715 	stw	r23,28(sp)
  80ad1c:	dd000415 	stw	r20,16(sp)
  80ad20:	dc800215 	stw	r18,8(sp)
  80ad24:	dc400115 	stw	r17,4(sp)
  80ad28:	dc000015 	stw	r16,0(sp)
  80ad2c:	202b883a 	mov	r21,r4
  80ad30:	282d883a 	mov	r22,r5
  80ad34:	080a1880 	call	80a188 <__sfp_lock_acquire>
  80ad38:	98002126 	beq	r19,zero,80adc0 <_fwalk_reent+0xc0>
  80ad3c:	002f883a 	mov	r23,zero
  80ad40:	9c800117 	ldw	r18,4(r19)
  80ad44:	9c000217 	ldw	r16,8(r19)
  80ad48:	90bfffc4 	addi	r2,r18,-1
  80ad4c:	10000d16 	blt	r2,zero,80ad84 <_fwalk_reent+0x84>
  80ad50:	0023883a 	mov	r17,zero
  80ad54:	053fffc4 	movi	r20,-1
  80ad58:	8080030f 	ldh	r2,12(r16)
  80ad5c:	8c400044 	addi	r17,r17,1
  80ad60:	10000626 	beq	r2,zero,80ad7c <_fwalk_reent+0x7c>
  80ad64:	8080038f 	ldh	r2,14(r16)
  80ad68:	800b883a 	mov	r5,r16
  80ad6c:	a809883a 	mov	r4,r21
  80ad70:	15000226 	beq	r2,r20,80ad7c <_fwalk_reent+0x7c>
  80ad74:	b03ee83a 	callr	r22
  80ad78:	b8aeb03a 	or	r23,r23,r2
  80ad7c:	84001704 	addi	r16,r16,92
  80ad80:	947ff51e 	bne	r18,r17,80ad58 <_fwalk_reent+0x58>
  80ad84:	9cc00017 	ldw	r19,0(r19)
  80ad88:	983fed1e 	bne	r19,zero,80ad40 <_fwalk_reent+0x40>
  80ad8c:	080a18c0 	call	80a18c <__sfp_lock_release>
  80ad90:	b805883a 	mov	r2,r23
  80ad94:	dfc00817 	ldw	ra,32(sp)
  80ad98:	ddc00717 	ldw	r23,28(sp)
  80ad9c:	dd800617 	ldw	r22,24(sp)
  80ada0:	dd400517 	ldw	r21,20(sp)
  80ada4:	dd000417 	ldw	r20,16(sp)
  80ada8:	dcc00317 	ldw	r19,12(sp)
  80adac:	dc800217 	ldw	r18,8(sp)
  80adb0:	dc400117 	ldw	r17,4(sp)
  80adb4:	dc000017 	ldw	r16,0(sp)
  80adb8:	dec00904 	addi	sp,sp,36
  80adbc:	f800283a 	ret
  80adc0:	002f883a 	mov	r23,zero
  80adc4:	003ff106 	br	80ad8c <_fwalk_reent+0x8c>

0080adc8 <_fwalk>:
  80adc8:	defff804 	addi	sp,sp,-32
  80adcc:	dcc00315 	stw	r19,12(sp)
  80add0:	24c0b804 	addi	r19,r4,736
  80add4:	dd400515 	stw	r21,20(sp)
  80add8:	dfc00715 	stw	ra,28(sp)
  80addc:	dd800615 	stw	r22,24(sp)
  80ade0:	dd000415 	stw	r20,16(sp)
  80ade4:	dc800215 	stw	r18,8(sp)
  80ade8:	dc400115 	stw	r17,4(sp)
  80adec:	dc000015 	stw	r16,0(sp)
  80adf0:	282b883a 	mov	r21,r5
  80adf4:	080a1880 	call	80a188 <__sfp_lock_acquire>
  80adf8:	98001f26 	beq	r19,zero,80ae78 <_fwalk+0xb0>
  80adfc:	002d883a 	mov	r22,zero
  80ae00:	9c800117 	ldw	r18,4(r19)
  80ae04:	9c000217 	ldw	r16,8(r19)
  80ae08:	90bfffc4 	addi	r2,r18,-1
  80ae0c:	10000c16 	blt	r2,zero,80ae40 <_fwalk+0x78>
  80ae10:	0023883a 	mov	r17,zero
  80ae14:	053fffc4 	movi	r20,-1
  80ae18:	8080030f 	ldh	r2,12(r16)
  80ae1c:	8c400044 	addi	r17,r17,1
  80ae20:	10000526 	beq	r2,zero,80ae38 <_fwalk+0x70>
  80ae24:	8080038f 	ldh	r2,14(r16)
  80ae28:	8009883a 	mov	r4,r16
  80ae2c:	15000226 	beq	r2,r20,80ae38 <_fwalk+0x70>
  80ae30:	a83ee83a 	callr	r21
  80ae34:	b0acb03a 	or	r22,r22,r2
  80ae38:	84001704 	addi	r16,r16,92
  80ae3c:	947ff61e 	bne	r18,r17,80ae18 <_fwalk+0x50>
  80ae40:	9cc00017 	ldw	r19,0(r19)
  80ae44:	983fee1e 	bne	r19,zero,80ae00 <_fwalk+0x38>
  80ae48:	080a18c0 	call	80a18c <__sfp_lock_release>
  80ae4c:	b005883a 	mov	r2,r22
  80ae50:	dfc00717 	ldw	ra,28(sp)
  80ae54:	dd800617 	ldw	r22,24(sp)
  80ae58:	dd400517 	ldw	r21,20(sp)
  80ae5c:	dd000417 	ldw	r20,16(sp)
  80ae60:	dcc00317 	ldw	r19,12(sp)
  80ae64:	dc800217 	ldw	r18,8(sp)
  80ae68:	dc400117 	ldw	r17,4(sp)
  80ae6c:	dc000017 	ldw	r16,0(sp)
  80ae70:	dec00804 	addi	sp,sp,32
  80ae74:	f800283a 	ret
  80ae78:	002d883a 	mov	r22,zero
  80ae7c:	003ff206 	br	80ae48 <_fwalk+0x80>

0080ae80 <__locale_charset>:
  80ae80:	d0a00817 	ldw	r2,-32736(gp)
  80ae84:	f800283a 	ret

0080ae88 <_localeconv_r>:
  80ae88:	008020b4 	movhi	r2,130
  80ae8c:	10a17f04 	addi	r2,r2,-31236
  80ae90:	f800283a 	ret

0080ae94 <localeconv>:
  80ae94:	008020b4 	movhi	r2,130
  80ae98:	10a93104 	addi	r2,r2,-23356
  80ae9c:	11000017 	ldw	r4,0(r2)
  80aea0:	080ae881 	jmpi	80ae88 <_localeconv_r>

0080aea4 <_setlocale_r>:
  80aea4:	defffc04 	addi	sp,sp,-16
  80aea8:	00c020b4 	movhi	r3,130
  80aeac:	18e17a04 	addi	r3,r3,-31256
  80aeb0:	dc800215 	stw	r18,8(sp)
  80aeb4:	dc400115 	stw	r17,4(sp)
  80aeb8:	dc000015 	stw	r16,0(sp)
  80aebc:	2023883a 	mov	r17,r4
  80aec0:	2825883a 	mov	r18,r5
  80aec4:	dfc00315 	stw	ra,12(sp)
  80aec8:	3021883a 	mov	r16,r6
  80aecc:	3009883a 	mov	r4,r6
  80aed0:	180b883a 	mov	r5,r3
  80aed4:	30000926 	beq	r6,zero,80aefc <_setlocale_r+0x58>
  80aed8:	080d3c00 	call	80d3c0 <strcmp>
  80aedc:	8009883a 	mov	r4,r16
  80aee0:	01402074 	movhi	r5,129
  80aee4:	295f0f04 	addi	r5,r5,31804
  80aee8:	10000b1e 	bne	r2,zero,80af18 <_setlocale_r+0x74>
  80aeec:	8c000d15 	stw	r16,52(r17)
  80aef0:	8c800c15 	stw	r18,48(r17)
  80aef4:	00c020b4 	movhi	r3,130
  80aef8:	18e17a04 	addi	r3,r3,-31256
  80aefc:	1805883a 	mov	r2,r3
  80af00:	dfc00317 	ldw	ra,12(sp)
  80af04:	dc800217 	ldw	r18,8(sp)
  80af08:	dc400117 	ldw	r17,4(sp)
  80af0c:	dc000017 	ldw	r16,0(sp)
  80af10:	dec00404 	addi	sp,sp,16
  80af14:	f800283a 	ret
  80af18:	080d3c00 	call	80d3c0 <strcmp>
  80af1c:	0007883a 	mov	r3,zero
  80af20:	103ff226 	beq	r2,zero,80aeec <_setlocale_r+0x48>
  80af24:	003ff506 	br	80aefc <_setlocale_r+0x58>

0080af28 <setlocale>:
  80af28:	018020b4 	movhi	r6,130
  80af2c:	31a93104 	addi	r6,r6,-23356
  80af30:	2007883a 	mov	r3,r4
  80af34:	31000017 	ldw	r4,0(r6)
  80af38:	280d883a 	mov	r6,r5
  80af3c:	180b883a 	mov	r5,r3
  80af40:	080aea41 	jmpi	80aea4 <_setlocale_r>

0080af44 <__smakebuf_r>:
  80af44:	2880030b 	ldhu	r2,12(r5)
  80af48:	deffed04 	addi	sp,sp,-76
  80af4c:	dc401015 	stw	r17,64(sp)
  80af50:	1080008c 	andi	r2,r2,2
  80af54:	dc000f15 	stw	r16,60(sp)
  80af58:	dfc01215 	stw	ra,72(sp)
  80af5c:	dc801115 	stw	r18,68(sp)
  80af60:	2821883a 	mov	r16,r5
  80af64:	2023883a 	mov	r17,r4
  80af68:	10000b26 	beq	r2,zero,80af98 <__smakebuf_r+0x54>
  80af6c:	28c010c4 	addi	r3,r5,67
  80af70:	00800044 	movi	r2,1
  80af74:	28800515 	stw	r2,20(r5)
  80af78:	28c00415 	stw	r3,16(r5)
  80af7c:	28c00015 	stw	r3,0(r5)
  80af80:	dfc01217 	ldw	ra,72(sp)
  80af84:	dc801117 	ldw	r18,68(sp)
  80af88:	dc401017 	ldw	r17,64(sp)
  80af8c:	dc000f17 	ldw	r16,60(sp)
  80af90:	dec01304 	addi	sp,sp,76
  80af94:	f800283a 	ret
  80af98:	2940038f 	ldh	r5,14(r5)
  80af9c:	28002116 	blt	r5,zero,80b024 <__smakebuf_r+0xe0>
  80afa0:	d80d883a 	mov	r6,sp
  80afa4:	080d7c40 	call	80d7c4 <_fstat_r>
  80afa8:	10001e16 	blt	r2,zero,80b024 <__smakebuf_r+0xe0>
  80afac:	d8800117 	ldw	r2,4(sp)
  80afb0:	00e00014 	movui	r3,32768
  80afb4:	113c000c 	andi	r4,r2,61440
  80afb8:	20c03126 	beq	r4,r3,80b080 <__smakebuf_r+0x13c>
  80afbc:	8080030b 	ldhu	r2,12(r16)
  80afc0:	00c80004 	movi	r3,8192
  80afc4:	10820014 	ori	r2,r2,2048
  80afc8:	8080030d 	sth	r2,12(r16)
  80afcc:	20c01e26 	beq	r4,r3,80b048 <__smakebuf_r+0x104>
  80afd0:	04810004 	movi	r18,1024
  80afd4:	8809883a 	mov	r4,r17
  80afd8:	900b883a 	mov	r5,r18
  80afdc:	080b0d80 	call	80b0d8 <_malloc_r>
  80afe0:	1009883a 	mov	r4,r2
  80afe4:	10003126 	beq	r2,zero,80b0ac <__smakebuf_r+0x168>
  80afe8:	80c0030b 	ldhu	r3,12(r16)
  80afec:	00802074 	movhi	r2,129
  80aff0:	10a89f04 	addi	r2,r2,-23940
  80aff4:	88800f15 	stw	r2,60(r17)
  80aff8:	18c02014 	ori	r3,r3,128
  80affc:	84800515 	stw	r18,20(r16)
  80b000:	80c0030d 	sth	r3,12(r16)
  80b004:	81000415 	stw	r4,16(r16)
  80b008:	81000015 	stw	r4,0(r16)
  80b00c:	dfc01217 	ldw	ra,72(sp)
  80b010:	dc801117 	ldw	r18,68(sp)
  80b014:	dc401017 	ldw	r17,64(sp)
  80b018:	dc000f17 	ldw	r16,60(sp)
  80b01c:	dec01304 	addi	sp,sp,76
  80b020:	f800283a 	ret
  80b024:	80c0030b 	ldhu	r3,12(r16)
  80b028:	1880200c 	andi	r2,r3,128
  80b02c:	10000426 	beq	r2,zero,80b040 <__smakebuf_r+0xfc>
  80b030:	04801004 	movi	r18,64
  80b034:	18820014 	ori	r2,r3,2048
  80b038:	8080030d 	sth	r2,12(r16)
  80b03c:	003fe506 	br	80afd4 <__smakebuf_r+0x90>
  80b040:	04810004 	movi	r18,1024
  80b044:	003ffb06 	br	80b034 <__smakebuf_r+0xf0>
  80b048:	8140038f 	ldh	r5,14(r16)
  80b04c:	8809883a 	mov	r4,r17
  80b050:	080d8380 	call	80d838 <_isatty_r>
  80b054:	103fde26 	beq	r2,zero,80afd0 <__smakebuf_r+0x8c>
  80b058:	8080030b 	ldhu	r2,12(r16)
  80b05c:	80c010c4 	addi	r3,r16,67
  80b060:	04810004 	movi	r18,1024
  80b064:	10800054 	ori	r2,r2,1
  80b068:	8080030d 	sth	r2,12(r16)
  80b06c:	00800044 	movi	r2,1
  80b070:	80c00415 	stw	r3,16(r16)
  80b074:	80800515 	stw	r2,20(r16)
  80b078:	80c00015 	stw	r3,0(r16)
  80b07c:	003fd506 	br	80afd4 <__smakebuf_r+0x90>
  80b080:	80c00a17 	ldw	r3,40(r16)
  80b084:	00802074 	movhi	r2,129
  80b088:	10b49f04 	addi	r2,r2,-11652
  80b08c:	18bfcb1e 	bne	r3,r2,80afbc <__smakebuf_r+0x78>
  80b090:	8080030b 	ldhu	r2,12(r16)
  80b094:	00c10004 	movi	r3,1024
  80b098:	1825883a 	mov	r18,r3
  80b09c:	10c4b03a 	or	r2,r2,r3
  80b0a0:	8080030d 	sth	r2,12(r16)
  80b0a4:	80c01315 	stw	r3,76(r16)
  80b0a8:	003fca06 	br	80afd4 <__smakebuf_r+0x90>
  80b0ac:	8100030b 	ldhu	r4,12(r16)
  80b0b0:	2080800c 	andi	r2,r4,512
  80b0b4:	103fb21e 	bne	r2,zero,80af80 <__smakebuf_r+0x3c>
  80b0b8:	80c010c4 	addi	r3,r16,67
  80b0bc:	21000094 	ori	r4,r4,2
  80b0c0:	00800044 	movi	r2,1
  80b0c4:	80800515 	stw	r2,20(r16)
  80b0c8:	8100030d 	sth	r4,12(r16)
  80b0cc:	80c00415 	stw	r3,16(r16)
  80b0d0:	80c00015 	stw	r3,0(r16)
  80b0d4:	003faa06 	br	80af80 <__smakebuf_r+0x3c>

0080b0d8 <_malloc_r>:
  80b0d8:	defff604 	addi	sp,sp,-40
  80b0dc:	28c002c4 	addi	r3,r5,11
  80b0e0:	00800584 	movi	r2,22
  80b0e4:	dc800215 	stw	r18,8(sp)
  80b0e8:	dfc00915 	stw	ra,36(sp)
  80b0ec:	df000815 	stw	fp,32(sp)
  80b0f0:	ddc00715 	stw	r23,28(sp)
  80b0f4:	dd800615 	stw	r22,24(sp)
  80b0f8:	dd400515 	stw	r21,20(sp)
  80b0fc:	dd000415 	stw	r20,16(sp)
  80b100:	dcc00315 	stw	r19,12(sp)
  80b104:	dc400115 	stw	r17,4(sp)
  80b108:	dc000015 	stw	r16,0(sp)
  80b10c:	2025883a 	mov	r18,r4
  80b110:	10c01236 	bltu	r2,r3,80b15c <_malloc_r+0x84>
  80b114:	04400404 	movi	r17,16
  80b118:	8940142e 	bgeu	r17,r5,80b16c <_malloc_r+0x94>
  80b11c:	00800304 	movi	r2,12
  80b120:	0007883a 	mov	r3,zero
  80b124:	90800015 	stw	r2,0(r18)
  80b128:	1805883a 	mov	r2,r3
  80b12c:	dfc00917 	ldw	ra,36(sp)
  80b130:	df000817 	ldw	fp,32(sp)
  80b134:	ddc00717 	ldw	r23,28(sp)
  80b138:	dd800617 	ldw	r22,24(sp)
  80b13c:	dd400517 	ldw	r21,20(sp)
  80b140:	dd000417 	ldw	r20,16(sp)
  80b144:	dcc00317 	ldw	r19,12(sp)
  80b148:	dc800217 	ldw	r18,8(sp)
  80b14c:	dc400117 	ldw	r17,4(sp)
  80b150:	dc000017 	ldw	r16,0(sp)
  80b154:	dec00a04 	addi	sp,sp,40
  80b158:	f800283a 	ret
  80b15c:	00bffe04 	movi	r2,-8
  80b160:	18a2703a 	and	r17,r3,r2
  80b164:	883fed16 	blt	r17,zero,80b11c <_malloc_r+0x44>
  80b168:	897fec36 	bltu	r17,r5,80b11c <_malloc_r+0x44>
  80b16c:	9009883a 	mov	r4,r18
  80b170:	08135f00 	call	8135f0 <__malloc_lock>
  80b174:	00807dc4 	movi	r2,503
  80b178:	14402b2e 	bgeu	r2,r17,80b228 <_malloc_r+0x150>
  80b17c:	8806d27a 	srli	r3,r17,9
  80b180:	18003f1e 	bne	r3,zero,80b280 <_malloc_r+0x1a8>
  80b184:	880cd0fa 	srli	r6,r17,3
  80b188:	300490fa 	slli	r2,r6,3
  80b18c:	02c020b4 	movhi	r11,130
  80b190:	5ae37704 	addi	r11,r11,-29220
  80b194:	12cb883a 	add	r5,r2,r11
  80b198:	2c000317 	ldw	r16,12(r5)
  80b19c:	580f883a 	mov	r7,r11
  80b1a0:	2c00041e 	bne	r5,r16,80b1b4 <_malloc_r+0xdc>
  80b1a4:	00000a06 	br	80b1d0 <_malloc_r+0xf8>
  80b1a8:	1800860e 	bge	r3,zero,80b3c4 <_malloc_r+0x2ec>
  80b1ac:	84000317 	ldw	r16,12(r16)
  80b1b0:	2c000726 	beq	r5,r16,80b1d0 <_malloc_r+0xf8>
  80b1b4:	80800117 	ldw	r2,4(r16)
  80b1b8:	00ffff04 	movi	r3,-4
  80b1bc:	10c8703a 	and	r4,r2,r3
  80b1c0:	2447c83a 	sub	r3,r4,r17
  80b1c4:	008003c4 	movi	r2,15
  80b1c8:	10fff70e 	bge	r2,r3,80b1a8 <_malloc_r+0xd0>
  80b1cc:	31bfffc4 	addi	r6,r6,-1
  80b1d0:	32400044 	addi	r9,r6,1
  80b1d4:	028020b4 	movhi	r10,130
  80b1d8:	52a37904 	addi	r10,r10,-29212
  80b1dc:	54000217 	ldw	r16,8(r10)
  80b1e0:	8280a026 	beq	r16,r10,80b464 <_malloc_r+0x38c>
  80b1e4:	80800117 	ldw	r2,4(r16)
  80b1e8:	00ffff04 	movi	r3,-4
  80b1ec:	10ca703a 	and	r5,r2,r3
  80b1f0:	2c4dc83a 	sub	r6,r5,r17
  80b1f4:	008003c4 	movi	r2,15
  80b1f8:	11808316 	blt	r2,r6,80b408 <_malloc_r+0x330>
  80b1fc:	52800315 	stw	r10,12(r10)
  80b200:	52800215 	stw	r10,8(r10)
  80b204:	30002916 	blt	r6,zero,80b2ac <_malloc_r+0x1d4>
  80b208:	8147883a 	add	r3,r16,r5
  80b20c:	18800117 	ldw	r2,4(r3)
  80b210:	9009883a 	mov	r4,r18
  80b214:	10800054 	ori	r2,r2,1
  80b218:	18800115 	stw	r2,4(r3)
  80b21c:	08136100 	call	813610 <__malloc_unlock>
  80b220:	80c00204 	addi	r3,r16,8
  80b224:	003fc006 	br	80b128 <_malloc_r+0x50>
  80b228:	02c020b4 	movhi	r11,130
  80b22c:	5ae37704 	addi	r11,r11,-29220
  80b230:	8ac5883a 	add	r2,r17,r11
  80b234:	14000317 	ldw	r16,12(r2)
  80b238:	580f883a 	mov	r7,r11
  80b23c:	8806d0fa 	srli	r3,r17,3
  80b240:	14006c26 	beq	r2,r16,80b3f4 <_malloc_r+0x31c>
  80b244:	80c00117 	ldw	r3,4(r16)
  80b248:	00bfff04 	movi	r2,-4
  80b24c:	81800317 	ldw	r6,12(r16)
  80b250:	1886703a 	and	r3,r3,r2
  80b254:	80c7883a 	add	r3,r16,r3
  80b258:	18800117 	ldw	r2,4(r3)
  80b25c:	81400217 	ldw	r5,8(r16)
  80b260:	9009883a 	mov	r4,r18
  80b264:	10800054 	ori	r2,r2,1
  80b268:	18800115 	stw	r2,4(r3)
  80b26c:	31400215 	stw	r5,8(r6)
  80b270:	29800315 	stw	r6,12(r5)
  80b274:	08136100 	call	813610 <__malloc_unlock>
  80b278:	80c00204 	addi	r3,r16,8
  80b27c:	003faa06 	br	80b128 <_malloc_r+0x50>
  80b280:	00800104 	movi	r2,4
  80b284:	10c0052e 	bgeu	r2,r3,80b29c <_malloc_r+0x1c4>
  80b288:	00800504 	movi	r2,20
  80b28c:	10c07836 	bltu	r2,r3,80b470 <_malloc_r+0x398>
  80b290:	198016c4 	addi	r6,r3,91
  80b294:	300490fa 	slli	r2,r6,3
  80b298:	003fbc06 	br	80b18c <_malloc_r+0xb4>
  80b29c:	8804d1ba 	srli	r2,r17,6
  80b2a0:	11800e04 	addi	r6,r2,56
  80b2a4:	300490fa 	slli	r2,r6,3
  80b2a8:	003fb806 	br	80b18c <_malloc_r+0xb4>
  80b2ac:	00807fc4 	movi	r2,511
  80b2b0:	1140bb36 	bltu	r2,r5,80b5a0 <_malloc_r+0x4c8>
  80b2b4:	2806d0fa 	srli	r3,r5,3
  80b2b8:	573ffe04 	addi	fp,r10,-8
  80b2bc:	00800044 	movi	r2,1
  80b2c0:	180890fa 	slli	r4,r3,3
  80b2c4:	1807d0ba 	srai	r3,r3,2
  80b2c8:	e1c00117 	ldw	r7,4(fp)
  80b2cc:	5909883a 	add	r4,r11,r4
  80b2d0:	21400217 	ldw	r5,8(r4)
  80b2d4:	10c4983a 	sll	r2,r2,r3
  80b2d8:	81000315 	stw	r4,12(r16)
  80b2dc:	81400215 	stw	r5,8(r16)
  80b2e0:	388eb03a 	or	r7,r7,r2
  80b2e4:	2c000315 	stw	r16,12(r5)
  80b2e8:	24000215 	stw	r16,8(r4)
  80b2ec:	e1c00115 	stw	r7,4(fp)
  80b2f0:	4807883a 	mov	r3,r9
  80b2f4:	4800cd16 	blt	r9,zero,80b62c <_malloc_r+0x554>
  80b2f8:	1807d0ba 	srai	r3,r3,2
  80b2fc:	00800044 	movi	r2,1
  80b300:	10c8983a 	sll	r4,r2,r3
  80b304:	39004436 	bltu	r7,r4,80b418 <_malloc_r+0x340>
  80b308:	21c4703a 	and	r2,r4,r7
  80b30c:	10000a1e 	bne	r2,zero,80b338 <_malloc_r+0x260>
  80b310:	2109883a 	add	r4,r4,r4
  80b314:	00bfff04 	movi	r2,-4
  80b318:	4884703a 	and	r2,r9,r2
  80b31c:	3906703a 	and	r3,r7,r4
  80b320:	12400104 	addi	r9,r2,4
  80b324:	1800041e 	bne	r3,zero,80b338 <_malloc_r+0x260>
  80b328:	2109883a 	add	r4,r4,r4
  80b32c:	3904703a 	and	r2,r7,r4
  80b330:	4a400104 	addi	r9,r9,4
  80b334:	103ffc26 	beq	r2,zero,80b328 <_malloc_r+0x250>
  80b338:	480490fa 	slli	r2,r9,3
  80b33c:	4819883a 	mov	r12,r9
  80b340:	023fff04 	movi	r8,-4
  80b344:	589b883a 	add	r13,r11,r2
  80b348:	6807883a 	mov	r3,r13
  80b34c:	014003c4 	movi	r5,15
  80b350:	1c000317 	ldw	r16,12(r3)
  80b354:	1c00041e 	bne	r3,r16,80b368 <_malloc_r+0x290>
  80b358:	0000a706 	br	80b5f8 <_malloc_r+0x520>
  80b35c:	3000ab0e 	bge	r6,zero,80b60c <_malloc_r+0x534>
  80b360:	84000317 	ldw	r16,12(r16)
  80b364:	1c00a426 	beq	r3,r16,80b5f8 <_malloc_r+0x520>
  80b368:	80800117 	ldw	r2,4(r16)
  80b36c:	1204703a 	and	r2,r2,r8
  80b370:	144dc83a 	sub	r6,r2,r17
  80b374:	29bff90e 	bge	r5,r6,80b35c <_malloc_r+0x284>
  80b378:	81000317 	ldw	r4,12(r16)
  80b37c:	80c00217 	ldw	r3,8(r16)
  80b380:	89400054 	ori	r5,r17,1
  80b384:	8445883a 	add	r2,r16,r17
  80b388:	20c00215 	stw	r3,8(r4)
  80b38c:	19000315 	stw	r4,12(r3)
  80b390:	81400115 	stw	r5,4(r16)
  80b394:	1187883a 	add	r3,r2,r6
  80b398:	31000054 	ori	r4,r6,1
  80b39c:	50800315 	stw	r2,12(r10)
  80b3a0:	50800215 	stw	r2,8(r10)
  80b3a4:	19800015 	stw	r6,0(r3)
  80b3a8:	11000115 	stw	r4,4(r2)
  80b3ac:	12800215 	stw	r10,8(r2)
  80b3b0:	12800315 	stw	r10,12(r2)
  80b3b4:	9009883a 	mov	r4,r18
  80b3b8:	08136100 	call	813610 <__malloc_unlock>
  80b3bc:	80c00204 	addi	r3,r16,8
  80b3c0:	003f5906 	br	80b128 <_malloc_r+0x50>
  80b3c4:	8109883a 	add	r4,r16,r4
  80b3c8:	20800117 	ldw	r2,4(r4)
  80b3cc:	80c00217 	ldw	r3,8(r16)
  80b3d0:	81400317 	ldw	r5,12(r16)
  80b3d4:	10800054 	ori	r2,r2,1
  80b3d8:	20800115 	stw	r2,4(r4)
  80b3dc:	28c00215 	stw	r3,8(r5)
  80b3e0:	19400315 	stw	r5,12(r3)
  80b3e4:	9009883a 	mov	r4,r18
  80b3e8:	08136100 	call	813610 <__malloc_unlock>
  80b3ec:	80c00204 	addi	r3,r16,8
  80b3f0:	003f4d06 	br	80b128 <_malloc_r+0x50>
  80b3f4:	80800204 	addi	r2,r16,8
  80b3f8:	14000317 	ldw	r16,12(r2)
  80b3fc:	143f911e 	bne	r2,r16,80b244 <_malloc_r+0x16c>
  80b400:	1a400084 	addi	r9,r3,2
  80b404:	003f7306 	br	80b1d4 <_malloc_r+0xfc>
  80b408:	88c00054 	ori	r3,r17,1
  80b40c:	8445883a 	add	r2,r16,r17
  80b410:	80c00115 	stw	r3,4(r16)
  80b414:	003fdf06 	br	80b394 <_malloc_r+0x2bc>
  80b418:	e4000217 	ldw	r16,8(fp)
  80b41c:	00bfff04 	movi	r2,-4
  80b420:	80c00117 	ldw	r3,4(r16)
  80b424:	802d883a 	mov	r22,r16
  80b428:	18aa703a 	and	r21,r3,r2
  80b42c:	ac401636 	bltu	r21,r17,80b488 <_malloc_r+0x3b0>
  80b430:	ac49c83a 	sub	r4,r21,r17
  80b434:	008003c4 	movi	r2,15
  80b438:	1100130e 	bge	r2,r4,80b488 <_malloc_r+0x3b0>
  80b43c:	88800054 	ori	r2,r17,1
  80b440:	8447883a 	add	r3,r16,r17
  80b444:	80800115 	stw	r2,4(r16)
  80b448:	20800054 	ori	r2,r4,1
  80b44c:	18800115 	stw	r2,4(r3)
  80b450:	e0c00215 	stw	r3,8(fp)
  80b454:	9009883a 	mov	r4,r18
  80b458:	08136100 	call	813610 <__malloc_unlock>
  80b45c:	80c00204 	addi	r3,r16,8
  80b460:	003f3106 	br	80b128 <_malloc_r+0x50>
  80b464:	39c00117 	ldw	r7,4(r7)
  80b468:	573ffe04 	addi	fp,r10,-8
  80b46c:	003fa006 	br	80b2f0 <_malloc_r+0x218>
  80b470:	00801504 	movi	r2,84
  80b474:	10c06736 	bltu	r2,r3,80b614 <_malloc_r+0x53c>
  80b478:	8804d33a 	srli	r2,r17,12
  80b47c:	11801b84 	addi	r6,r2,110
  80b480:	300490fa 	slli	r2,r6,3
  80b484:	003f4106 	br	80b18c <_malloc_r+0xb4>
  80b488:	d0a6f517 	ldw	r2,-25644(gp)
  80b48c:	d0e00a17 	ldw	r3,-32728(gp)
  80b490:	053fffc4 	movi	r20,-1
  80b494:	10800404 	addi	r2,r2,16
  80b498:	88a7883a 	add	r19,r17,r2
  80b49c:	1d000326 	beq	r3,r20,80b4ac <_malloc_r+0x3d4>
  80b4a0:	98c3ffc4 	addi	r3,r19,4095
  80b4a4:	00bc0004 	movi	r2,-4096
  80b4a8:	18a6703a 	and	r19,r3,r2
  80b4ac:	9009883a 	mov	r4,r18
  80b4b0:	980b883a 	mov	r5,r19
  80b4b4:	080d2040 	call	80d204 <_sbrk_r>
  80b4b8:	1009883a 	mov	r4,r2
  80b4bc:	15000426 	beq	r2,r20,80b4d0 <_malloc_r+0x3f8>
  80b4c0:	854b883a 	add	r5,r16,r21
  80b4c4:	1029883a 	mov	r20,r2
  80b4c8:	11405a2e 	bgeu	r2,r5,80b634 <_malloc_r+0x55c>
  80b4cc:	87000c26 	beq	r16,fp,80b500 <_malloc_r+0x428>
  80b4d0:	e4000217 	ldw	r16,8(fp)
  80b4d4:	80c00117 	ldw	r3,4(r16)
  80b4d8:	00bfff04 	movi	r2,-4
  80b4dc:	1884703a 	and	r2,r3,r2
  80b4e0:	14400336 	bltu	r2,r17,80b4f0 <_malloc_r+0x418>
  80b4e4:	1449c83a 	sub	r4,r2,r17
  80b4e8:	008003c4 	movi	r2,15
  80b4ec:	113fd316 	blt	r2,r4,80b43c <_malloc_r+0x364>
  80b4f0:	9009883a 	mov	r4,r18
  80b4f4:	08136100 	call	813610 <__malloc_unlock>
  80b4f8:	0007883a 	mov	r3,zero
  80b4fc:	003f0a06 	br	80b128 <_malloc_r+0x50>
  80b500:	05c020f4 	movhi	r23,131
  80b504:	bdf9d304 	addi	r23,r23,-6324
  80b508:	b8800017 	ldw	r2,0(r23)
  80b50c:	988d883a 	add	r6,r19,r2
  80b510:	b9800015 	stw	r6,0(r23)
  80b514:	d0e00a17 	ldw	r3,-32728(gp)
  80b518:	00bfffc4 	movi	r2,-1
  80b51c:	18808e26 	beq	r3,r2,80b758 <_malloc_r+0x680>
  80b520:	2145c83a 	sub	r2,r4,r5
  80b524:	3085883a 	add	r2,r6,r2
  80b528:	b8800015 	stw	r2,0(r23)
  80b52c:	20c001cc 	andi	r3,r4,7
  80b530:	18005f1e 	bne	r3,zero,80b6b0 <_malloc_r+0x5d8>
  80b534:	000b883a 	mov	r5,zero
  80b538:	a4c5883a 	add	r2,r20,r19
  80b53c:	1083ffcc 	andi	r2,r2,4095
  80b540:	00c40004 	movi	r3,4096
  80b544:	1887c83a 	sub	r3,r3,r2
  80b548:	28e7883a 	add	r19,r5,r3
  80b54c:	9009883a 	mov	r4,r18
  80b550:	980b883a 	mov	r5,r19
  80b554:	080d2040 	call	80d204 <_sbrk_r>
  80b558:	1007883a 	mov	r3,r2
  80b55c:	00bfffc4 	movi	r2,-1
  80b560:	18807a26 	beq	r3,r2,80b74c <_malloc_r+0x674>
  80b564:	1d05c83a 	sub	r2,r3,r20
  80b568:	9885883a 	add	r2,r19,r2
  80b56c:	10c00054 	ori	r3,r2,1
  80b570:	b8800017 	ldw	r2,0(r23)
  80b574:	a021883a 	mov	r16,r20
  80b578:	a0c00115 	stw	r3,4(r20)
  80b57c:	9885883a 	add	r2,r19,r2
  80b580:	b8800015 	stw	r2,0(r23)
  80b584:	e5000215 	stw	r20,8(fp)
  80b588:	b7003626 	beq	r22,fp,80b664 <_malloc_r+0x58c>
  80b58c:	018003c4 	movi	r6,15
  80b590:	35404b36 	bltu	r6,r21,80b6c0 <_malloc_r+0x5e8>
  80b594:	00800044 	movi	r2,1
  80b598:	a0800115 	stw	r2,4(r20)
  80b59c:	003fcd06 	br	80b4d4 <_malloc_r+0x3fc>
  80b5a0:	2808d27a 	srli	r4,r5,9
  80b5a4:	2000371e 	bne	r4,zero,80b684 <_malloc_r+0x5ac>
  80b5a8:	2808d0fa 	srli	r4,r5,3
  80b5ac:	200690fa 	slli	r3,r4,3
  80b5b0:	1ad1883a 	add	r8,r3,r11
  80b5b4:	41800217 	ldw	r6,8(r8)
  80b5b8:	41805b26 	beq	r8,r6,80b728 <_malloc_r+0x650>
  80b5bc:	30800117 	ldw	r2,4(r6)
  80b5c0:	00ffff04 	movi	r3,-4
  80b5c4:	10c4703a 	and	r2,r2,r3
  80b5c8:	2880022e 	bgeu	r5,r2,80b5d4 <_malloc_r+0x4fc>
  80b5cc:	31800217 	ldw	r6,8(r6)
  80b5d0:	41bffa1e 	bne	r8,r6,80b5bc <_malloc_r+0x4e4>
  80b5d4:	32000317 	ldw	r8,12(r6)
  80b5d8:	39c00117 	ldw	r7,4(r7)
  80b5dc:	82000315 	stw	r8,12(r16)
  80b5e0:	81800215 	stw	r6,8(r16)
  80b5e4:	070020b4 	movhi	fp,130
  80b5e8:	e7237704 	addi	fp,fp,-29220
  80b5ec:	34000315 	stw	r16,12(r6)
  80b5f0:	44000215 	stw	r16,8(r8)
  80b5f4:	003f3e06 	br	80b2f0 <_malloc_r+0x218>
  80b5f8:	63000044 	addi	r12,r12,1
  80b5fc:	608000cc 	andi	r2,r12,3
  80b600:	10005d26 	beq	r2,zero,80b778 <_malloc_r+0x6a0>
  80b604:	18c00204 	addi	r3,r3,8
  80b608:	003f5106 	br	80b350 <_malloc_r+0x278>
  80b60c:	8089883a 	add	r4,r16,r2
  80b610:	003f6d06 	br	80b3c8 <_malloc_r+0x2f0>
  80b614:	00805504 	movi	r2,340
  80b618:	10c02036 	bltu	r2,r3,80b69c <_malloc_r+0x5c4>
  80b61c:	8804d3fa 	srli	r2,r17,15
  80b620:	11801dc4 	addi	r6,r2,119
  80b624:	300490fa 	slli	r2,r6,3
  80b628:	003ed806 	br	80b18c <_malloc_r+0xb4>
  80b62c:	48c000c4 	addi	r3,r9,3
  80b630:	003f3106 	br	80b2f8 <_malloc_r+0x220>
  80b634:	05c020f4 	movhi	r23,131
  80b638:	bdf9d304 	addi	r23,r23,-6324
  80b63c:	b8800017 	ldw	r2,0(r23)
  80b640:	988d883a 	add	r6,r19,r2
  80b644:	b9800015 	stw	r6,0(r23)
  80b648:	293fb21e 	bne	r5,r4,80b514 <_malloc_r+0x43c>
  80b64c:	2083ffcc 	andi	r2,r4,4095
  80b650:	103fb01e 	bne	r2,zero,80b514 <_malloc_r+0x43c>
  80b654:	e4000217 	ldw	r16,8(fp)
  80b658:	9d45883a 	add	r2,r19,r21
  80b65c:	10800054 	ori	r2,r2,1
  80b660:	80800115 	stw	r2,4(r16)
  80b664:	b8c00017 	ldw	r3,0(r23)
  80b668:	d0a6f617 	ldw	r2,-25640(gp)
  80b66c:	10c0012e 	bgeu	r2,r3,80b674 <_malloc_r+0x59c>
  80b670:	d0e6f615 	stw	r3,-25640(gp)
  80b674:	d0a6f717 	ldw	r2,-25636(gp)
  80b678:	10ff962e 	bgeu	r2,r3,80b4d4 <_malloc_r+0x3fc>
  80b67c:	d0e6f715 	stw	r3,-25636(gp)
  80b680:	003f9406 	br	80b4d4 <_malloc_r+0x3fc>
  80b684:	00800104 	movi	r2,4
  80b688:	11001e36 	bltu	r2,r4,80b704 <_malloc_r+0x62c>
  80b68c:	2804d1ba 	srli	r2,r5,6
  80b690:	11000e04 	addi	r4,r2,56
  80b694:	200690fa 	slli	r3,r4,3
  80b698:	003fc506 	br	80b5b0 <_malloc_r+0x4d8>
  80b69c:	00815504 	movi	r2,1364
  80b6a0:	10c01d2e 	bgeu	r2,r3,80b718 <_malloc_r+0x640>
  80b6a4:	01801f84 	movi	r6,126
  80b6a8:	0080fc04 	movi	r2,1008
  80b6ac:	003eb706 	br	80b18c <_malloc_r+0xb4>
  80b6b0:	00800204 	movi	r2,8
  80b6b4:	10cbc83a 	sub	r5,r2,r3
  80b6b8:	2169883a 	add	r20,r4,r5
  80b6bc:	003f9e06 	br	80b538 <_malloc_r+0x460>
  80b6c0:	00bffe04 	movi	r2,-8
  80b6c4:	a93ffd04 	addi	r4,r21,-12
  80b6c8:	2088703a 	and	r4,r4,r2
  80b6cc:	b10b883a 	add	r5,r22,r4
  80b6d0:	00c00144 	movi	r3,5
  80b6d4:	28c00215 	stw	r3,8(r5)
  80b6d8:	28c00115 	stw	r3,4(r5)
  80b6dc:	b0800117 	ldw	r2,4(r22)
  80b6e0:	1080004c 	andi	r2,r2,1
  80b6e4:	2084b03a 	or	r2,r4,r2
  80b6e8:	b0800115 	stw	r2,4(r22)
  80b6ec:	313fdd2e 	bgeu	r6,r4,80b664 <_malloc_r+0x58c>
  80b6f0:	b1400204 	addi	r5,r22,8
  80b6f4:	9009883a 	mov	r4,r18
  80b6f8:	080a5500 	call	80a550 <_free_r>
  80b6fc:	e4000217 	ldw	r16,8(fp)
  80b700:	003fd806 	br	80b664 <_malloc_r+0x58c>
  80b704:	00800504 	movi	r2,20
  80b708:	11001536 	bltu	r2,r4,80b760 <_malloc_r+0x688>
  80b70c:	210016c4 	addi	r4,r4,91
  80b710:	200690fa 	slli	r3,r4,3
  80b714:	003fa606 	br	80b5b0 <_malloc_r+0x4d8>
  80b718:	8804d4ba 	srli	r2,r17,18
  80b71c:	11801f04 	addi	r6,r2,124
  80b720:	300490fa 	slli	r2,r6,3
  80b724:	003e9906 	br	80b18c <_malloc_r+0xb4>
  80b728:	2009d0ba 	srai	r4,r4,2
  80b72c:	014020b4 	movhi	r5,130
  80b730:	29637704 	addi	r5,r5,-29220
  80b734:	00c00044 	movi	r3,1
  80b738:	28800117 	ldw	r2,4(r5)
  80b73c:	1906983a 	sll	r3,r3,r4
  80b740:	10c4b03a 	or	r2,r2,r3
  80b744:	28800115 	stw	r2,4(r5)
  80b748:	003fa306 	br	80b5d8 <_malloc_r+0x500>
  80b74c:	0027883a 	mov	r19,zero
  80b750:	00c00044 	movi	r3,1
  80b754:	003f8606 	br	80b570 <_malloc_r+0x498>
  80b758:	d1200a15 	stw	r4,-32728(gp)
  80b75c:	003f7306 	br	80b52c <_malloc_r+0x454>
  80b760:	00801504 	movi	r2,84
  80b764:	11001936 	bltu	r2,r4,80b7cc <_malloc_r+0x6f4>
  80b768:	2804d33a 	srli	r2,r5,12
  80b76c:	11001b84 	addi	r4,r2,110
  80b770:	200690fa 	slli	r3,r4,3
  80b774:	003f8e06 	br	80b5b0 <_malloc_r+0x4d8>
  80b778:	480b883a 	mov	r5,r9
  80b77c:	6807883a 	mov	r3,r13
  80b780:	288000cc 	andi	r2,r5,3
  80b784:	18fffe04 	addi	r3,r3,-8
  80b788:	297fffc4 	addi	r5,r5,-1
  80b78c:	10001526 	beq	r2,zero,80b7e4 <_malloc_r+0x70c>
  80b790:	18800217 	ldw	r2,8(r3)
  80b794:	10fffa26 	beq	r2,r3,80b780 <_malloc_r+0x6a8>
  80b798:	2109883a 	add	r4,r4,r4
  80b79c:	393f1e36 	bltu	r7,r4,80b418 <_malloc_r+0x340>
  80b7a0:	203f1d26 	beq	r4,zero,80b418 <_malloc_r+0x340>
  80b7a4:	21c4703a 	and	r2,r4,r7
  80b7a8:	10000226 	beq	r2,zero,80b7b4 <_malloc_r+0x6dc>
  80b7ac:	6013883a 	mov	r9,r12
  80b7b0:	003ee106 	br	80b338 <_malloc_r+0x260>
  80b7b4:	2109883a 	add	r4,r4,r4
  80b7b8:	3904703a 	and	r2,r7,r4
  80b7bc:	63000104 	addi	r12,r12,4
  80b7c0:	103ffc26 	beq	r2,zero,80b7b4 <_malloc_r+0x6dc>
  80b7c4:	6013883a 	mov	r9,r12
  80b7c8:	003edb06 	br	80b338 <_malloc_r+0x260>
  80b7cc:	00805504 	movi	r2,340
  80b7d0:	11000836 	bltu	r2,r4,80b7f4 <_malloc_r+0x71c>
  80b7d4:	2804d3fa 	srli	r2,r5,15
  80b7d8:	11001dc4 	addi	r4,r2,119
  80b7dc:	200690fa 	slli	r3,r4,3
  80b7e0:	003f7306 	br	80b5b0 <_malloc_r+0x4d8>
  80b7e4:	0104303a 	nor	r2,zero,r4
  80b7e8:	388e703a 	and	r7,r7,r2
  80b7ec:	e1c00115 	stw	r7,4(fp)
  80b7f0:	003fe906 	br	80b798 <_malloc_r+0x6c0>
  80b7f4:	00815504 	movi	r2,1364
  80b7f8:	1100032e 	bgeu	r2,r4,80b808 <_malloc_r+0x730>
  80b7fc:	01001f84 	movi	r4,126
  80b800:	00c0fc04 	movi	r3,1008
  80b804:	003f6a06 	br	80b5b0 <_malloc_r+0x4d8>
  80b808:	2804d4ba 	srli	r2,r5,18
  80b80c:	11001f04 	addi	r4,r2,124
  80b810:	200690fa 	slli	r3,r4,3
  80b814:	003f6606 	br	80b5b0 <_malloc_r+0x4d8>

0080b818 <memchr>:
  80b818:	008000c4 	movi	r2,3
  80b81c:	29403fcc 	andi	r5,r5,255
  80b820:	2007883a 	mov	r3,r4
  80b824:	1180022e 	bgeu	r2,r6,80b830 <memchr+0x18>
  80b828:	2084703a 	and	r2,r4,r2
  80b82c:	10000b26 	beq	r2,zero,80b85c <memchr+0x44>
  80b830:	313fffc4 	addi	r4,r6,-1
  80b834:	3000051e 	bne	r6,zero,80b84c <memchr+0x34>
  80b838:	00002c06 	br	80b8ec <memchr+0xd4>
  80b83c:	213fffc4 	addi	r4,r4,-1
  80b840:	00bfffc4 	movi	r2,-1
  80b844:	18c00044 	addi	r3,r3,1
  80b848:	20802826 	beq	r4,r2,80b8ec <memchr+0xd4>
  80b84c:	18800003 	ldbu	r2,0(r3)
  80b850:	28bffa1e 	bne	r5,r2,80b83c <memchr+0x24>
  80b854:	1805883a 	mov	r2,r3
  80b858:	f800283a 	ret
  80b85c:	0011883a 	mov	r8,zero
  80b860:	0007883a 	mov	r3,zero
  80b864:	01c00104 	movi	r7,4
  80b868:	4004923a 	slli	r2,r8,8
  80b86c:	18c00044 	addi	r3,r3,1
  80b870:	1151883a 	add	r8,r2,r5
  80b874:	19fffc1e 	bne	r3,r7,80b868 <memchr+0x50>
  80b878:	02bfbff4 	movhi	r10,65279
  80b87c:	52bfbfc4 	addi	r10,r10,-257
  80b880:	02602074 	movhi	r9,32897
  80b884:	4a602004 	addi	r9,r9,-32640
  80b888:	02c000c4 	movi	r11,3
  80b88c:	20800017 	ldw	r2,0(r4)
  80b890:	31bfff04 	addi	r6,r6,-4
  80b894:	200f883a 	mov	r7,r4
  80b898:	1204f03a 	xor	r2,r2,r8
  80b89c:	1287883a 	add	r3,r2,r10
  80b8a0:	1a46703a 	and	r3,r3,r9
  80b8a4:	0084303a 	nor	r2,zero,r2
  80b8a8:	10c4703a 	and	r2,r2,r3
  80b8ac:	10000b26 	beq	r2,zero,80b8dc <memchr+0xc4>
  80b8b0:	20800003 	ldbu	r2,0(r4)
  80b8b4:	28800f26 	beq	r5,r2,80b8f4 <memchr+0xdc>
  80b8b8:	20800043 	ldbu	r2,1(r4)
  80b8bc:	21c00044 	addi	r7,r4,1
  80b8c0:	28800c26 	beq	r5,r2,80b8f4 <memchr+0xdc>
  80b8c4:	20800083 	ldbu	r2,2(r4)
  80b8c8:	21c00084 	addi	r7,r4,2
  80b8cc:	28800926 	beq	r5,r2,80b8f4 <memchr+0xdc>
  80b8d0:	208000c3 	ldbu	r2,3(r4)
  80b8d4:	21c000c4 	addi	r7,r4,3
  80b8d8:	28800626 	beq	r5,r2,80b8f4 <memchr+0xdc>
  80b8dc:	21000104 	addi	r4,r4,4
  80b8e0:	59bfea36 	bltu	r11,r6,80b88c <memchr+0x74>
  80b8e4:	2007883a 	mov	r3,r4
  80b8e8:	003fd106 	br	80b830 <memchr+0x18>
  80b8ec:	0005883a 	mov	r2,zero
  80b8f0:	f800283a 	ret
  80b8f4:	3805883a 	mov	r2,r7
  80b8f8:	f800283a 	ret

0080b8fc <memcpy>:
  80b8fc:	01c003c4 	movi	r7,15
  80b900:	2007883a 	mov	r3,r4
  80b904:	3980032e 	bgeu	r7,r6,80b914 <memcpy+0x18>
  80b908:	2904b03a 	or	r2,r5,r4
  80b90c:	108000cc 	andi	r2,r2,3
  80b910:	10000926 	beq	r2,zero,80b938 <memcpy+0x3c>
  80b914:	30000626 	beq	r6,zero,80b930 <memcpy+0x34>
  80b918:	30cd883a 	add	r6,r6,r3
  80b91c:	28800003 	ldbu	r2,0(r5)
  80b920:	29400044 	addi	r5,r5,1
  80b924:	18800005 	stb	r2,0(r3)
  80b928:	18c00044 	addi	r3,r3,1
  80b92c:	30fffb1e 	bne	r6,r3,80b91c <memcpy+0x20>
  80b930:	2005883a 	mov	r2,r4
  80b934:	f800283a 	ret
  80b938:	3811883a 	mov	r8,r7
  80b93c:	200f883a 	mov	r7,r4
  80b940:	28c00017 	ldw	r3,0(r5)
  80b944:	31bffc04 	addi	r6,r6,-16
  80b948:	38c00015 	stw	r3,0(r7)
  80b94c:	28800117 	ldw	r2,4(r5)
  80b950:	38800115 	stw	r2,4(r7)
  80b954:	28c00217 	ldw	r3,8(r5)
  80b958:	38c00215 	stw	r3,8(r7)
  80b95c:	28800317 	ldw	r2,12(r5)
  80b960:	29400404 	addi	r5,r5,16
  80b964:	38800315 	stw	r2,12(r7)
  80b968:	39c00404 	addi	r7,r7,16
  80b96c:	41bff436 	bltu	r8,r6,80b940 <memcpy+0x44>
  80b970:	008000c4 	movi	r2,3
  80b974:	1180072e 	bgeu	r2,r6,80b994 <memcpy+0x98>
  80b978:	1007883a 	mov	r3,r2
  80b97c:	28800017 	ldw	r2,0(r5)
  80b980:	31bfff04 	addi	r6,r6,-4
  80b984:	29400104 	addi	r5,r5,4
  80b988:	38800015 	stw	r2,0(r7)
  80b98c:	39c00104 	addi	r7,r7,4
  80b990:	19bffa36 	bltu	r3,r6,80b97c <memcpy+0x80>
  80b994:	3807883a 	mov	r3,r7
  80b998:	003fde06 	br	80b914 <memcpy+0x18>

0080b99c <memmove>:
  80b99c:	2807883a 	mov	r3,r5
  80b9a0:	2011883a 	mov	r8,r4
  80b9a4:	29000c2e 	bgeu	r5,r4,80b9d8 <memmove+0x3c>
  80b9a8:	298f883a 	add	r7,r5,r6
  80b9ac:	21c00a2e 	bgeu	r4,r7,80b9d8 <memmove+0x3c>
  80b9b0:	30000726 	beq	r6,zero,80b9d0 <memmove+0x34>
  80b9b4:	2187883a 	add	r3,r4,r6
  80b9b8:	198dc83a 	sub	r6,r3,r6
  80b9bc:	39ffffc4 	addi	r7,r7,-1
  80b9c0:	38800003 	ldbu	r2,0(r7)
  80b9c4:	18ffffc4 	addi	r3,r3,-1
  80b9c8:	18800005 	stb	r2,0(r3)
  80b9cc:	19bffb1e 	bne	r3,r6,80b9bc <memmove+0x20>
  80b9d0:	2005883a 	mov	r2,r4
  80b9d4:	f800283a 	ret
  80b9d8:	01c003c4 	movi	r7,15
  80b9dc:	39800a36 	bltu	r7,r6,80ba08 <memmove+0x6c>
  80b9e0:	303ffb26 	beq	r6,zero,80b9d0 <memmove+0x34>
  80b9e4:	400f883a 	mov	r7,r8
  80b9e8:	320d883a 	add	r6,r6,r8
  80b9ec:	28800003 	ldbu	r2,0(r5)
  80b9f0:	29400044 	addi	r5,r5,1
  80b9f4:	38800005 	stb	r2,0(r7)
  80b9f8:	39c00044 	addi	r7,r7,1
  80b9fc:	39bffb1e 	bne	r7,r6,80b9ec <memmove+0x50>
  80ba00:	2005883a 	mov	r2,r4
  80ba04:	f800283a 	ret
  80ba08:	1904b03a 	or	r2,r3,r4
  80ba0c:	108000cc 	andi	r2,r2,3
  80ba10:	103ff31e 	bne	r2,zero,80b9e0 <memmove+0x44>
  80ba14:	3811883a 	mov	r8,r7
  80ba18:	180b883a 	mov	r5,r3
  80ba1c:	200f883a 	mov	r7,r4
  80ba20:	28c00017 	ldw	r3,0(r5)
  80ba24:	31bffc04 	addi	r6,r6,-16
  80ba28:	38c00015 	stw	r3,0(r7)
  80ba2c:	28800117 	ldw	r2,4(r5)
  80ba30:	38800115 	stw	r2,4(r7)
  80ba34:	28c00217 	ldw	r3,8(r5)
  80ba38:	38c00215 	stw	r3,8(r7)
  80ba3c:	28800317 	ldw	r2,12(r5)
  80ba40:	29400404 	addi	r5,r5,16
  80ba44:	38800315 	stw	r2,12(r7)
  80ba48:	39c00404 	addi	r7,r7,16
  80ba4c:	41bff436 	bltu	r8,r6,80ba20 <memmove+0x84>
  80ba50:	008000c4 	movi	r2,3
  80ba54:	1180072e 	bgeu	r2,r6,80ba74 <memmove+0xd8>
  80ba58:	1007883a 	mov	r3,r2
  80ba5c:	28800017 	ldw	r2,0(r5)
  80ba60:	31bfff04 	addi	r6,r6,-4
  80ba64:	29400104 	addi	r5,r5,4
  80ba68:	38800015 	stw	r2,0(r7)
  80ba6c:	39c00104 	addi	r7,r7,4
  80ba70:	19bffa36 	bltu	r3,r6,80ba5c <memmove+0xc0>
  80ba74:	3811883a 	mov	r8,r7
  80ba78:	003fd906 	br	80b9e0 <memmove+0x44>

0080ba7c <memset>:
  80ba7c:	008000c4 	movi	r2,3
  80ba80:	29403fcc 	andi	r5,r5,255
  80ba84:	2007883a 	mov	r3,r4
  80ba88:	1180022e 	bgeu	r2,r6,80ba94 <memset+0x18>
  80ba8c:	2084703a 	and	r2,r4,r2
  80ba90:	10000826 	beq	r2,zero,80bab4 <memset+0x38>
  80ba94:	30000526 	beq	r6,zero,80baac <memset+0x30>
  80ba98:	2805883a 	mov	r2,r5
  80ba9c:	30cd883a 	add	r6,r6,r3
  80baa0:	18800005 	stb	r2,0(r3)
  80baa4:	18c00044 	addi	r3,r3,1
  80baa8:	19bffd1e 	bne	r3,r6,80baa0 <memset+0x24>
  80baac:	2005883a 	mov	r2,r4
  80bab0:	f800283a 	ret
  80bab4:	2804923a 	slli	r2,r5,8
  80bab8:	020003c4 	movi	r8,15
  80babc:	200f883a 	mov	r7,r4
  80bac0:	2884b03a 	or	r2,r5,r2
  80bac4:	1006943a 	slli	r3,r2,16
  80bac8:	10c6b03a 	or	r3,r2,r3
  80bacc:	41800a2e 	bgeu	r8,r6,80baf8 <memset+0x7c>
  80bad0:	4005883a 	mov	r2,r8
  80bad4:	31bffc04 	addi	r6,r6,-16
  80bad8:	38c00015 	stw	r3,0(r7)
  80badc:	38c00115 	stw	r3,4(r7)
  80bae0:	38c00215 	stw	r3,8(r7)
  80bae4:	38c00315 	stw	r3,12(r7)
  80bae8:	39c00404 	addi	r7,r7,16
  80baec:	11bff936 	bltu	r2,r6,80bad4 <memset+0x58>
  80baf0:	008000c4 	movi	r2,3
  80baf4:	1180052e 	bgeu	r2,r6,80bb0c <memset+0x90>
  80baf8:	31bfff04 	addi	r6,r6,-4
  80bafc:	008000c4 	movi	r2,3
  80bb00:	38c00015 	stw	r3,0(r7)
  80bb04:	39c00104 	addi	r7,r7,4
  80bb08:	11bffb36 	bltu	r2,r6,80baf8 <memset+0x7c>
  80bb0c:	3807883a 	mov	r3,r7
  80bb10:	003fe006 	br	80ba94 <memset+0x18>

0080bb14 <_Bfree>:
  80bb14:	28000826 	beq	r5,zero,80bb38 <_Bfree+0x24>
  80bb18:	28800117 	ldw	r2,4(r5)
  80bb1c:	21001317 	ldw	r4,76(r4)
  80bb20:	1085883a 	add	r2,r2,r2
  80bb24:	1085883a 	add	r2,r2,r2
  80bb28:	1105883a 	add	r2,r2,r4
  80bb2c:	10c00017 	ldw	r3,0(r2)
  80bb30:	28c00015 	stw	r3,0(r5)
  80bb34:	11400015 	stw	r5,0(r2)
  80bb38:	f800283a 	ret

0080bb3c <__hi0bits>:
  80bb3c:	20bfffec 	andhi	r2,r4,65535
  80bb40:	10001426 	beq	r2,zero,80bb94 <__hi0bits+0x58>
  80bb44:	0007883a 	mov	r3,zero
  80bb48:	20bfc02c 	andhi	r2,r4,65280
  80bb4c:	1000021e 	bne	r2,zero,80bb58 <__hi0bits+0x1c>
  80bb50:	2008923a 	slli	r4,r4,8
  80bb54:	18c00204 	addi	r3,r3,8
  80bb58:	20bc002c 	andhi	r2,r4,61440
  80bb5c:	1000021e 	bne	r2,zero,80bb68 <__hi0bits+0x2c>
  80bb60:	2008913a 	slli	r4,r4,4
  80bb64:	18c00104 	addi	r3,r3,4
  80bb68:	20b0002c 	andhi	r2,r4,49152
  80bb6c:	1000031e 	bne	r2,zero,80bb7c <__hi0bits+0x40>
  80bb70:	2105883a 	add	r2,r4,r4
  80bb74:	18c00084 	addi	r3,r3,2
  80bb78:	1089883a 	add	r4,r2,r2
  80bb7c:	20000316 	blt	r4,zero,80bb8c <__hi0bits+0x50>
  80bb80:	2090002c 	andhi	r2,r4,16384
  80bb84:	10000626 	beq	r2,zero,80bba0 <__hi0bits+0x64>
  80bb88:	18c00044 	addi	r3,r3,1
  80bb8c:	1805883a 	mov	r2,r3
  80bb90:	f800283a 	ret
  80bb94:	2008943a 	slli	r4,r4,16
  80bb98:	00c00404 	movi	r3,16
  80bb9c:	003fea06 	br	80bb48 <__hi0bits+0xc>
  80bba0:	00c00804 	movi	r3,32
  80bba4:	1805883a 	mov	r2,r3
  80bba8:	f800283a 	ret

0080bbac <__lo0bits>:
  80bbac:	20c00017 	ldw	r3,0(r4)
  80bbb0:	188001cc 	andi	r2,r3,7
  80bbb4:	10000a26 	beq	r2,zero,80bbe0 <__lo0bits+0x34>
  80bbb8:	1880004c 	andi	r2,r3,1
  80bbbc:	1005003a 	cmpeq	r2,r2,zero
  80bbc0:	10002126 	beq	r2,zero,80bc48 <__lo0bits+0x9c>
  80bbc4:	1880008c 	andi	r2,r3,2
  80bbc8:	1000251e 	bne	r2,zero,80bc60 <__lo0bits+0xb4>
  80bbcc:	1804d0ba 	srli	r2,r3,2
  80bbd0:	01400084 	movi	r5,2
  80bbd4:	20800015 	stw	r2,0(r4)
  80bbd8:	2805883a 	mov	r2,r5
  80bbdc:	f800283a 	ret
  80bbe0:	18bfffcc 	andi	r2,r3,65535
  80bbe4:	10001526 	beq	r2,zero,80bc3c <__lo0bits+0x90>
  80bbe8:	000b883a 	mov	r5,zero
  80bbec:	18803fcc 	andi	r2,r3,255
  80bbf0:	1000021e 	bne	r2,zero,80bbfc <__lo0bits+0x50>
  80bbf4:	1806d23a 	srli	r3,r3,8
  80bbf8:	29400204 	addi	r5,r5,8
  80bbfc:	188003cc 	andi	r2,r3,15
  80bc00:	1000021e 	bne	r2,zero,80bc0c <__lo0bits+0x60>
  80bc04:	1806d13a 	srli	r3,r3,4
  80bc08:	29400104 	addi	r5,r5,4
  80bc0c:	188000cc 	andi	r2,r3,3
  80bc10:	1000021e 	bne	r2,zero,80bc1c <__lo0bits+0x70>
  80bc14:	1806d0ba 	srli	r3,r3,2
  80bc18:	29400084 	addi	r5,r5,2
  80bc1c:	1880004c 	andi	r2,r3,1
  80bc20:	1000031e 	bne	r2,zero,80bc30 <__lo0bits+0x84>
  80bc24:	1806d07a 	srli	r3,r3,1
  80bc28:	18000a26 	beq	r3,zero,80bc54 <__lo0bits+0xa8>
  80bc2c:	29400044 	addi	r5,r5,1
  80bc30:	2805883a 	mov	r2,r5
  80bc34:	20c00015 	stw	r3,0(r4)
  80bc38:	f800283a 	ret
  80bc3c:	1806d43a 	srli	r3,r3,16
  80bc40:	01400404 	movi	r5,16
  80bc44:	003fe906 	br	80bbec <__lo0bits+0x40>
  80bc48:	000b883a 	mov	r5,zero
  80bc4c:	2805883a 	mov	r2,r5
  80bc50:	f800283a 	ret
  80bc54:	01400804 	movi	r5,32
  80bc58:	2805883a 	mov	r2,r5
  80bc5c:	f800283a 	ret
  80bc60:	1804d07a 	srli	r2,r3,1
  80bc64:	01400044 	movi	r5,1
  80bc68:	20800015 	stw	r2,0(r4)
  80bc6c:	003fda06 	br	80bbd8 <__lo0bits+0x2c>

0080bc70 <__mcmp>:
  80bc70:	20800417 	ldw	r2,16(r4)
  80bc74:	28c00417 	ldw	r3,16(r5)
  80bc78:	10cfc83a 	sub	r7,r2,r3
  80bc7c:	38000c1e 	bne	r7,zero,80bcb0 <__mcmp+0x40>
  80bc80:	18c5883a 	add	r2,r3,r3
  80bc84:	1085883a 	add	r2,r2,r2
  80bc88:	10c00504 	addi	r3,r2,20
  80bc8c:	21000504 	addi	r4,r4,20
  80bc90:	28cb883a 	add	r5,r5,r3
  80bc94:	2085883a 	add	r2,r4,r2
  80bc98:	10bfff04 	addi	r2,r2,-4
  80bc9c:	297fff04 	addi	r5,r5,-4
  80bca0:	11800017 	ldw	r6,0(r2)
  80bca4:	28c00017 	ldw	r3,0(r5)
  80bca8:	30c0031e 	bne	r6,r3,80bcb8 <__mcmp+0x48>
  80bcac:	20bffa36 	bltu	r4,r2,80bc98 <__mcmp+0x28>
  80bcb0:	3805883a 	mov	r2,r7
  80bcb4:	f800283a 	ret
  80bcb8:	30c00336 	bltu	r6,r3,80bcc8 <__mcmp+0x58>
  80bcbc:	01c00044 	movi	r7,1
  80bcc0:	3805883a 	mov	r2,r7
  80bcc4:	f800283a 	ret
  80bcc8:	01ffffc4 	movi	r7,-1
  80bccc:	003ff806 	br	80bcb0 <__mcmp+0x40>

0080bcd0 <__ulp>:
  80bcd0:	295ffc2c 	andhi	r5,r5,32752
  80bcd4:	013f3034 	movhi	r4,64704
  80bcd8:	290b883a 	add	r5,r5,r4
  80bcdc:	0145c83a 	sub	r2,zero,r5
  80bce0:	1007d53a 	srai	r3,r2,20
  80bce4:	000d883a 	mov	r6,zero
  80bce8:	0140040e 	bge	zero,r5,80bcfc <__ulp+0x2c>
  80bcec:	280f883a 	mov	r7,r5
  80bcf0:	3807883a 	mov	r3,r7
  80bcf4:	3005883a 	mov	r2,r6
  80bcf8:	f800283a 	ret
  80bcfc:	008004c4 	movi	r2,19
  80bd00:	193ffb04 	addi	r4,r3,-20
  80bd04:	10c00c0e 	bge	r2,r3,80bd38 <__ulp+0x68>
  80bd08:	008007c4 	movi	r2,31
  80bd0c:	1107c83a 	sub	r3,r2,r4
  80bd10:	00800784 	movi	r2,30
  80bd14:	01400044 	movi	r5,1
  80bd18:	11000216 	blt	r2,r4,80bd24 <__ulp+0x54>
  80bd1c:	00800044 	movi	r2,1
  80bd20:	10ca983a 	sll	r5,r2,r3
  80bd24:	000f883a 	mov	r7,zero
  80bd28:	280d883a 	mov	r6,r5
  80bd2c:	3807883a 	mov	r3,r7
  80bd30:	3005883a 	mov	r2,r6
  80bd34:	f800283a 	ret
  80bd38:	00800234 	movhi	r2,8
  80bd3c:	10cfd83a 	sra	r7,r2,r3
  80bd40:	000d883a 	mov	r6,zero
  80bd44:	3005883a 	mov	r2,r6
  80bd48:	3807883a 	mov	r3,r7
  80bd4c:	f800283a 	ret

0080bd50 <__b2d>:
  80bd50:	20800417 	ldw	r2,16(r4)
  80bd54:	defff904 	addi	sp,sp,-28
  80bd58:	dd000415 	stw	r20,16(sp)
  80bd5c:	1085883a 	add	r2,r2,r2
  80bd60:	25000504 	addi	r20,r4,20
  80bd64:	1085883a 	add	r2,r2,r2
  80bd68:	dc000015 	stw	r16,0(sp)
  80bd6c:	a0a1883a 	add	r16,r20,r2
  80bd70:	dd400515 	stw	r21,20(sp)
  80bd74:	857fff17 	ldw	r21,-4(r16)
  80bd78:	dc400115 	stw	r17,4(sp)
  80bd7c:	dfc00615 	stw	ra,24(sp)
  80bd80:	a809883a 	mov	r4,r21
  80bd84:	2823883a 	mov	r17,r5
  80bd88:	dcc00315 	stw	r19,12(sp)
  80bd8c:	dc800215 	stw	r18,8(sp)
  80bd90:	080bb3c0 	call	80bb3c <__hi0bits>
  80bd94:	100b883a 	mov	r5,r2
  80bd98:	00800804 	movi	r2,32
  80bd9c:	1145c83a 	sub	r2,r2,r5
  80bda0:	88800015 	stw	r2,0(r17)
  80bda4:	00800284 	movi	r2,10
  80bda8:	80ffff04 	addi	r3,r16,-4
  80bdac:	11401416 	blt	r2,r5,80be00 <__b2d+0xb0>
  80bdb0:	008002c4 	movi	r2,11
  80bdb4:	1149c83a 	sub	r4,r2,r5
  80bdb8:	a0c02736 	bltu	r20,r3,80be58 <__b2d+0x108>
  80bdbc:	000d883a 	mov	r6,zero
  80bdc0:	28800544 	addi	r2,r5,21
  80bdc4:	a906d83a 	srl	r3,r21,r4
  80bdc8:	a884983a 	sll	r2,r21,r2
  80bdcc:	1ccffc34 	orhi	r19,r3,16368
  80bdd0:	11a4b03a 	or	r18,r2,r6
  80bdd4:	9005883a 	mov	r2,r18
  80bdd8:	9807883a 	mov	r3,r19
  80bddc:	dfc00617 	ldw	ra,24(sp)
  80bde0:	dd400517 	ldw	r21,20(sp)
  80bde4:	dd000417 	ldw	r20,16(sp)
  80bde8:	dcc00317 	ldw	r19,12(sp)
  80bdec:	dc800217 	ldw	r18,8(sp)
  80bdf0:	dc400117 	ldw	r17,4(sp)
  80bdf4:	dc000017 	ldw	r16,0(sp)
  80bdf8:	dec00704 	addi	sp,sp,28
  80bdfc:	f800283a 	ret
  80be00:	a0c00e36 	bltu	r20,r3,80be3c <__b2d+0xec>
  80be04:	293ffd44 	addi	r4,r5,-11
  80be08:	000d883a 	mov	r6,zero
  80be0c:	20000f26 	beq	r4,zero,80be4c <__b2d+0xfc>
  80be10:	00800804 	movi	r2,32
  80be14:	110bc83a 	sub	r5,r2,r4
  80be18:	a0c01236 	bltu	r20,r3,80be64 <__b2d+0x114>
  80be1c:	000f883a 	mov	r7,zero
  80be20:	a904983a 	sll	r2,r21,r4
  80be24:	3146d83a 	srl	r3,r6,r5
  80be28:	3108983a 	sll	r4,r6,r4
  80be2c:	108ffc34 	orhi	r2,r2,16368
  80be30:	18a6b03a 	or	r19,r3,r2
  80be34:	3924b03a 	or	r18,r7,r4
  80be38:	003fe606 	br	80bdd4 <__b2d+0x84>
  80be3c:	293ffd44 	addi	r4,r5,-11
  80be40:	81bffe17 	ldw	r6,-8(r16)
  80be44:	80fffe04 	addi	r3,r16,-8
  80be48:	203ff11e 	bne	r4,zero,80be10 <__b2d+0xc0>
  80be4c:	accffc34 	orhi	r19,r21,16368
  80be50:	3025883a 	mov	r18,r6
  80be54:	003fdf06 	br	80bdd4 <__b2d+0x84>
  80be58:	18bfff17 	ldw	r2,-4(r3)
  80be5c:	110cd83a 	srl	r6,r2,r4
  80be60:	003fd706 	br	80bdc0 <__b2d+0x70>
  80be64:	18bfff17 	ldw	r2,-4(r3)
  80be68:	114ed83a 	srl	r7,r2,r5
  80be6c:	003fec06 	br	80be20 <__b2d+0xd0>

0080be70 <__ratio>:
  80be70:	defff904 	addi	sp,sp,-28
  80be74:	dc400215 	stw	r17,8(sp)
  80be78:	2823883a 	mov	r17,r5
  80be7c:	d80b883a 	mov	r5,sp
  80be80:	dfc00615 	stw	ra,24(sp)
  80be84:	dd000515 	stw	r20,20(sp)
  80be88:	dcc00415 	stw	r19,16(sp)
  80be8c:	dc800315 	stw	r18,12(sp)
  80be90:	2025883a 	mov	r18,r4
  80be94:	080bd500 	call	80bd50 <__b2d>
  80be98:	8809883a 	mov	r4,r17
  80be9c:	d9400104 	addi	r5,sp,4
  80bea0:	1027883a 	mov	r19,r2
  80bea4:	1829883a 	mov	r20,r3
  80bea8:	080bd500 	call	80bd50 <__b2d>
  80beac:	89000417 	ldw	r4,16(r17)
  80beb0:	91c00417 	ldw	r7,16(r18)
  80beb4:	d9800117 	ldw	r6,4(sp)
  80beb8:	180b883a 	mov	r5,r3
  80bebc:	390fc83a 	sub	r7,r7,r4
  80bec0:	1009883a 	mov	r4,r2
  80bec4:	d8800017 	ldw	r2,0(sp)
  80bec8:	380e917a 	slli	r7,r7,5
  80becc:	2011883a 	mov	r8,r4
  80bed0:	1185c83a 	sub	r2,r2,r6
  80bed4:	11c5883a 	add	r2,r2,r7
  80bed8:	1006953a 	slli	r3,r2,20
  80bedc:	2813883a 	mov	r9,r5
  80bee0:	00800d0e 	bge	zero,r2,80bf18 <__ratio+0xa8>
  80bee4:	1d29883a 	add	r20,r3,r20
  80bee8:	a00b883a 	mov	r5,r20
  80beec:	480f883a 	mov	r7,r9
  80bef0:	9809883a 	mov	r4,r19
  80bef4:	400d883a 	mov	r6,r8
  80bef8:	080ef2c0 	call	80ef2c <__divdf3>
  80befc:	dfc00617 	ldw	ra,24(sp)
  80bf00:	dd000517 	ldw	r20,20(sp)
  80bf04:	dcc00417 	ldw	r19,16(sp)
  80bf08:	dc800317 	ldw	r18,12(sp)
  80bf0c:	dc400217 	ldw	r17,8(sp)
  80bf10:	dec00704 	addi	sp,sp,28
  80bf14:	f800283a 	ret
  80bf18:	28d3c83a 	sub	r9,r5,r3
  80bf1c:	003ff206 	br	80bee8 <__ratio+0x78>

0080bf20 <_mprec_log10>:
  80bf20:	defffe04 	addi	sp,sp,-8
  80bf24:	008005c4 	movi	r2,23
  80bf28:	dc000015 	stw	r16,0(sp)
  80bf2c:	dfc00115 	stw	ra,4(sp)
  80bf30:	2021883a 	mov	r16,r4
  80bf34:	11000c16 	blt	r2,r4,80bf68 <_mprec_log10+0x48>
  80bf38:	200490fa 	slli	r2,r4,3
  80bf3c:	00c020b4 	movhi	r3,130
  80bf40:	18e18b04 	addi	r3,r3,-31188
  80bf44:	10c5883a 	add	r2,r2,r3
  80bf48:	12400117 	ldw	r9,4(r2)
  80bf4c:	12000017 	ldw	r8,0(r2)
  80bf50:	4807883a 	mov	r3,r9
  80bf54:	4005883a 	mov	r2,r8
  80bf58:	dfc00117 	ldw	ra,4(sp)
  80bf5c:	dc000017 	ldw	r16,0(sp)
  80bf60:	dec00204 	addi	sp,sp,8
  80bf64:	f800283a 	ret
  80bf68:	0011883a 	mov	r8,zero
  80bf6c:	024ffc34 	movhi	r9,16368
  80bf70:	0005883a 	mov	r2,zero
  80bf74:	00d00934 	movhi	r3,16420
  80bf78:	480b883a 	mov	r5,r9
  80bf7c:	4009883a 	mov	r4,r8
  80bf80:	180f883a 	mov	r7,r3
  80bf84:	100d883a 	mov	r6,r2
  80bf88:	080eb680 	call	80eb68 <__muldf3>
  80bf8c:	843fffc4 	addi	r16,r16,-1
  80bf90:	1011883a 	mov	r8,r2
  80bf94:	1813883a 	mov	r9,r3
  80bf98:	803ff51e 	bne	r16,zero,80bf70 <_mprec_log10+0x50>
  80bf9c:	4005883a 	mov	r2,r8
  80bfa0:	4807883a 	mov	r3,r9
  80bfa4:	dfc00117 	ldw	ra,4(sp)
  80bfa8:	dc000017 	ldw	r16,0(sp)
  80bfac:	dec00204 	addi	sp,sp,8
  80bfb0:	f800283a 	ret

0080bfb4 <__copybits>:
  80bfb4:	297fffc4 	addi	r5,r5,-1
  80bfb8:	30800417 	ldw	r2,16(r6)
  80bfbc:	280bd17a 	srai	r5,r5,5
  80bfc0:	31800504 	addi	r6,r6,20
  80bfc4:	1085883a 	add	r2,r2,r2
  80bfc8:	294b883a 	add	r5,r5,r5
  80bfcc:	294b883a 	add	r5,r5,r5
  80bfd0:	1085883a 	add	r2,r2,r2
  80bfd4:	290b883a 	add	r5,r5,r4
  80bfd8:	3087883a 	add	r3,r6,r2
  80bfdc:	29400104 	addi	r5,r5,4
  80bfe0:	30c0052e 	bgeu	r6,r3,80bff8 <__copybits+0x44>
  80bfe4:	30800017 	ldw	r2,0(r6)
  80bfe8:	31800104 	addi	r6,r6,4
  80bfec:	20800015 	stw	r2,0(r4)
  80bff0:	21000104 	addi	r4,r4,4
  80bff4:	30fffb36 	bltu	r6,r3,80bfe4 <__copybits+0x30>
  80bff8:	2140032e 	bgeu	r4,r5,80c008 <__copybits+0x54>
  80bffc:	20000015 	stw	zero,0(r4)
  80c000:	21000104 	addi	r4,r4,4
  80c004:	217ffd36 	bltu	r4,r5,80bffc <__copybits+0x48>
  80c008:	f800283a 	ret

0080c00c <__any_on>:
  80c00c:	20800417 	ldw	r2,16(r4)
  80c010:	2807d17a 	srai	r3,r5,5
  80c014:	21000504 	addi	r4,r4,20
  80c018:	10c00d0e 	bge	r2,r3,80c050 <__any_on+0x44>
  80c01c:	1085883a 	add	r2,r2,r2
  80c020:	1085883a 	add	r2,r2,r2
  80c024:	208d883a 	add	r6,r4,r2
  80c028:	2180182e 	bgeu	r4,r6,80c08c <__any_on+0x80>
  80c02c:	30bfff17 	ldw	r2,-4(r6)
  80c030:	30ffff04 	addi	r3,r6,-4
  80c034:	1000041e 	bne	r2,zero,80c048 <__any_on+0x3c>
  80c038:	20c0142e 	bgeu	r4,r3,80c08c <__any_on+0x80>
  80c03c:	18ffff04 	addi	r3,r3,-4
  80c040:	18800017 	ldw	r2,0(r3)
  80c044:	103ffc26 	beq	r2,zero,80c038 <__any_on+0x2c>
  80c048:	00800044 	movi	r2,1
  80c04c:	f800283a 	ret
  80c050:	18800a0e 	bge	r3,r2,80c07c <__any_on+0x70>
  80c054:	294007cc 	andi	r5,r5,31
  80c058:	28000826 	beq	r5,zero,80c07c <__any_on+0x70>
  80c05c:	18c5883a 	add	r2,r3,r3
  80c060:	1085883a 	add	r2,r2,r2
  80c064:	208d883a 	add	r6,r4,r2
  80c068:	30c00017 	ldw	r3,0(r6)
  80c06c:	1944d83a 	srl	r2,r3,r5
  80c070:	1144983a 	sll	r2,r2,r5
  80c074:	18bff41e 	bne	r3,r2,80c048 <__any_on+0x3c>
  80c078:	003feb06 	br	80c028 <__any_on+0x1c>
  80c07c:	18c5883a 	add	r2,r3,r3
  80c080:	1085883a 	add	r2,r2,r2
  80c084:	208d883a 	add	r6,r4,r2
  80c088:	003fe706 	br	80c028 <__any_on+0x1c>
  80c08c:	0005883a 	mov	r2,zero
  80c090:	f800283a 	ret

0080c094 <_Balloc>:
  80c094:	20c01317 	ldw	r3,76(r4)
  80c098:	defffb04 	addi	sp,sp,-20
  80c09c:	dcc00315 	stw	r19,12(sp)
  80c0a0:	dc800215 	stw	r18,8(sp)
  80c0a4:	dfc00415 	stw	ra,16(sp)
  80c0a8:	2825883a 	mov	r18,r5
  80c0ac:	dc400115 	stw	r17,4(sp)
  80c0b0:	dc000015 	stw	r16,0(sp)
  80c0b4:	2027883a 	mov	r19,r4
  80c0b8:	01800404 	movi	r6,16
  80c0bc:	01400104 	movi	r5,4
  80c0c0:	18001726 	beq	r3,zero,80c120 <_Balloc+0x8c>
  80c0c4:	01400044 	movi	r5,1
  80c0c8:	9485883a 	add	r2,r18,r18
  80c0cc:	2ca2983a 	sll	r17,r5,r18
  80c0d0:	1085883a 	add	r2,r2,r2
  80c0d4:	10c7883a 	add	r3,r2,r3
  80c0d8:	1c000017 	ldw	r16,0(r3)
  80c0dc:	8c4d883a 	add	r6,r17,r17
  80c0e0:	318d883a 	add	r6,r6,r6
  80c0e4:	9809883a 	mov	r4,r19
  80c0e8:	31800504 	addi	r6,r6,20
  80c0ec:	80001226 	beq	r16,zero,80c138 <_Balloc+0xa4>
  80c0f0:	80800017 	ldw	r2,0(r16)
  80c0f4:	18800015 	stw	r2,0(r3)
  80c0f8:	80000415 	stw	zero,16(r16)
  80c0fc:	80000315 	stw	zero,12(r16)
  80c100:	8005883a 	mov	r2,r16
  80c104:	dfc00417 	ldw	ra,16(sp)
  80c108:	dcc00317 	ldw	r19,12(sp)
  80c10c:	dc800217 	ldw	r18,8(sp)
  80c110:	dc400117 	ldw	r17,4(sp)
  80c114:	dc000017 	ldw	r16,0(sp)
  80c118:	dec00504 	addi	sp,sp,20
  80c11c:	f800283a 	ret
  80c120:	080d5680 	call	80d568 <_calloc_r>
  80c124:	1007883a 	mov	r3,r2
  80c128:	0021883a 	mov	r16,zero
  80c12c:	98801315 	stw	r2,76(r19)
  80c130:	103fe41e 	bne	r2,zero,80c0c4 <_Balloc+0x30>
  80c134:	003ff206 	br	80c100 <_Balloc+0x6c>
  80c138:	080d5680 	call	80d568 <_calloc_r>
  80c13c:	103ff026 	beq	r2,zero,80c100 <_Balloc+0x6c>
  80c140:	1021883a 	mov	r16,r2
  80c144:	14800115 	stw	r18,4(r2)
  80c148:	14400215 	stw	r17,8(r2)
  80c14c:	003fea06 	br	80c0f8 <_Balloc+0x64>

0080c150 <__d2b>:
  80c150:	defff504 	addi	sp,sp,-44
  80c154:	dcc00515 	stw	r19,20(sp)
  80c158:	04c00044 	movi	r19,1
  80c15c:	dc000215 	stw	r16,8(sp)
  80c160:	2821883a 	mov	r16,r5
  80c164:	980b883a 	mov	r5,r19
  80c168:	ddc00915 	stw	r23,36(sp)
  80c16c:	dd800815 	stw	r22,32(sp)
  80c170:	dd400715 	stw	r21,28(sp)
  80c174:	dd000615 	stw	r20,24(sp)
  80c178:	dc800415 	stw	r18,16(sp)
  80c17c:	dc400315 	stw	r17,12(sp)
  80c180:	dfc00a15 	stw	ra,40(sp)
  80c184:	3023883a 	mov	r17,r6
  80c188:	382d883a 	mov	r22,r7
  80c18c:	ddc00b17 	ldw	r23,44(sp)
  80c190:	080c0940 	call	80c094 <_Balloc>
  80c194:	1025883a 	mov	r18,r2
  80c198:	00a00034 	movhi	r2,32768
  80c19c:	10bfffc4 	addi	r2,r2,-1
  80c1a0:	8888703a 	and	r4,r17,r2
  80c1a4:	202ad53a 	srli	r21,r4,20
  80c1a8:	00800434 	movhi	r2,16
  80c1ac:	10bfffc4 	addi	r2,r2,-1
  80c1b0:	8886703a 	and	r3,r17,r2
  80c1b4:	a829003a 	cmpeq	r20,r21,zero
  80c1b8:	800b883a 	mov	r5,r16
  80c1bc:	d8c00115 	stw	r3,4(sp)
  80c1c0:	94000504 	addi	r16,r18,20
  80c1c4:	a000021e 	bne	r20,zero,80c1d0 <__d2b+0x80>
  80c1c8:	18c00434 	orhi	r3,r3,16
  80c1cc:	d8c00115 	stw	r3,4(sp)
  80c1d0:	28002726 	beq	r5,zero,80c270 <__d2b+0x120>
  80c1d4:	d809883a 	mov	r4,sp
  80c1d8:	d9400015 	stw	r5,0(sp)
  80c1dc:	080bbac0 	call	80bbac <__lo0bits>
  80c1e0:	100d883a 	mov	r6,r2
  80c1e4:	10003526 	beq	r2,zero,80c2bc <__d2b+0x16c>
  80c1e8:	d8c00117 	ldw	r3,4(sp)
  80c1ec:	00800804 	movi	r2,32
  80c1f0:	1185c83a 	sub	r2,r2,r6
  80c1f4:	d9000017 	ldw	r4,0(sp)
  80c1f8:	1886983a 	sll	r3,r3,r2
  80c1fc:	1906b03a 	or	r3,r3,r4
  80c200:	90c00515 	stw	r3,20(r18)
  80c204:	d8c00117 	ldw	r3,4(sp)
  80c208:	1986d83a 	srl	r3,r3,r6
  80c20c:	d8c00115 	stw	r3,4(sp)
  80c210:	180b003a 	cmpeq	r5,r3,zero
  80c214:	00800084 	movi	r2,2
  80c218:	114bc83a 	sub	r5,r2,r5
  80c21c:	80c00115 	stw	r3,4(r16)
  80c220:	91400415 	stw	r5,16(r18)
  80c224:	a0001a1e 	bne	r20,zero,80c290 <__d2b+0x140>
  80c228:	3545883a 	add	r2,r6,r21
  80c22c:	10bef344 	addi	r2,r2,-1075
  80c230:	00c00d44 	movi	r3,53
  80c234:	b0800015 	stw	r2,0(r22)
  80c238:	1987c83a 	sub	r3,r3,r6
  80c23c:	b8c00015 	stw	r3,0(r23)
  80c240:	9005883a 	mov	r2,r18
  80c244:	dfc00a17 	ldw	ra,40(sp)
  80c248:	ddc00917 	ldw	r23,36(sp)
  80c24c:	dd800817 	ldw	r22,32(sp)
  80c250:	dd400717 	ldw	r21,28(sp)
  80c254:	dd000617 	ldw	r20,24(sp)
  80c258:	dcc00517 	ldw	r19,20(sp)
  80c25c:	dc800417 	ldw	r18,16(sp)
  80c260:	dc400317 	ldw	r17,12(sp)
  80c264:	dc000217 	ldw	r16,8(sp)
  80c268:	dec00b04 	addi	sp,sp,44
  80c26c:	f800283a 	ret
  80c270:	d9000104 	addi	r4,sp,4
  80c274:	080bbac0 	call	80bbac <__lo0bits>
  80c278:	11800804 	addi	r6,r2,32
  80c27c:	d8800117 	ldw	r2,4(sp)
  80c280:	94c00415 	stw	r19,16(r18)
  80c284:	980b883a 	mov	r5,r19
  80c288:	90800515 	stw	r2,20(r18)
  80c28c:	a03fe626 	beq	r20,zero,80c228 <__d2b+0xd8>
  80c290:	2945883a 	add	r2,r5,r5
  80c294:	1085883a 	add	r2,r2,r2
  80c298:	1405883a 	add	r2,r2,r16
  80c29c:	113fff17 	ldw	r4,-4(r2)
  80c2a0:	30fef384 	addi	r3,r6,-1074
  80c2a4:	2820917a 	slli	r16,r5,5
  80c2a8:	b0c00015 	stw	r3,0(r22)
  80c2ac:	080bb3c0 	call	80bb3c <__hi0bits>
  80c2b0:	80a1c83a 	sub	r16,r16,r2
  80c2b4:	bc000015 	stw	r16,0(r23)
  80c2b8:	003fe106 	br	80c240 <__d2b+0xf0>
  80c2bc:	d8800017 	ldw	r2,0(sp)
  80c2c0:	90800515 	stw	r2,20(r18)
  80c2c4:	d8c00117 	ldw	r3,4(sp)
  80c2c8:	003fd106 	br	80c210 <__d2b+0xc0>

0080c2cc <__mdiff>:
  80c2cc:	defffb04 	addi	sp,sp,-20
  80c2d0:	dc000015 	stw	r16,0(sp)
  80c2d4:	2821883a 	mov	r16,r5
  80c2d8:	dc800215 	stw	r18,8(sp)
  80c2dc:	300b883a 	mov	r5,r6
  80c2e0:	2025883a 	mov	r18,r4
  80c2e4:	8009883a 	mov	r4,r16
  80c2e8:	dc400115 	stw	r17,4(sp)
  80c2ec:	dfc00415 	stw	ra,16(sp)
  80c2f0:	dcc00315 	stw	r19,12(sp)
  80c2f4:	3023883a 	mov	r17,r6
  80c2f8:	080bc700 	call	80bc70 <__mcmp>
  80c2fc:	10004226 	beq	r2,zero,80c408 <__mdiff+0x13c>
  80c300:	10005016 	blt	r2,zero,80c444 <__mdiff+0x178>
  80c304:	0027883a 	mov	r19,zero
  80c308:	81400117 	ldw	r5,4(r16)
  80c30c:	9009883a 	mov	r4,r18
  80c310:	080c0940 	call	80c094 <_Balloc>
  80c314:	1019883a 	mov	r12,r2
  80c318:	82800417 	ldw	r10,16(r16)
  80c31c:	88800417 	ldw	r2,16(r17)
  80c320:	81800504 	addi	r6,r16,20
  80c324:	5287883a 	add	r3,r10,r10
  80c328:	1085883a 	add	r2,r2,r2
  80c32c:	18c7883a 	add	r3,r3,r3
  80c330:	1085883a 	add	r2,r2,r2
  80c334:	8a000504 	addi	r8,r17,20
  80c338:	64c00315 	stw	r19,12(r12)
  80c33c:	30db883a 	add	r13,r6,r3
  80c340:	4097883a 	add	r11,r8,r2
  80c344:	61c00504 	addi	r7,r12,20
  80c348:	0013883a 	mov	r9,zero
  80c34c:	31000017 	ldw	r4,0(r6)
  80c350:	41400017 	ldw	r5,0(r8)
  80c354:	42000104 	addi	r8,r8,4
  80c358:	20bfffcc 	andi	r2,r4,65535
  80c35c:	28ffffcc 	andi	r3,r5,65535
  80c360:	10c5c83a 	sub	r2,r2,r3
  80c364:	1245883a 	add	r2,r2,r9
  80c368:	2008d43a 	srli	r4,r4,16
  80c36c:	280ad43a 	srli	r5,r5,16
  80c370:	1007d43a 	srai	r3,r2,16
  80c374:	3880000d 	sth	r2,0(r7)
  80c378:	2149c83a 	sub	r4,r4,r5
  80c37c:	20c9883a 	add	r4,r4,r3
  80c380:	3900008d 	sth	r4,2(r7)
  80c384:	31800104 	addi	r6,r6,4
  80c388:	39c00104 	addi	r7,r7,4
  80c38c:	2013d43a 	srai	r9,r4,16
  80c390:	42ffee36 	bltu	r8,r11,80c34c <__mdiff+0x80>
  80c394:	33400c2e 	bgeu	r6,r13,80c3c8 <__mdiff+0xfc>
  80c398:	30800017 	ldw	r2,0(r6)
  80c39c:	31800104 	addi	r6,r6,4
  80c3a0:	10ffffcc 	andi	r3,r2,65535
  80c3a4:	1a47883a 	add	r3,r3,r9
  80c3a8:	1004d43a 	srli	r2,r2,16
  80c3ac:	1809d43a 	srai	r4,r3,16
  80c3b0:	38c0000d 	sth	r3,0(r7)
  80c3b4:	1105883a 	add	r2,r2,r4
  80c3b8:	3880008d 	sth	r2,2(r7)
  80c3bc:	1013d43a 	srai	r9,r2,16
  80c3c0:	39c00104 	addi	r7,r7,4
  80c3c4:	337ff436 	bltu	r6,r13,80c398 <__mdiff+0xcc>
  80c3c8:	38bfff17 	ldw	r2,-4(r7)
  80c3cc:	38ffff04 	addi	r3,r7,-4
  80c3d0:	1000041e 	bne	r2,zero,80c3e4 <__mdiff+0x118>
  80c3d4:	18ffff04 	addi	r3,r3,-4
  80c3d8:	18800017 	ldw	r2,0(r3)
  80c3dc:	52bfffc4 	addi	r10,r10,-1
  80c3e0:	103ffc26 	beq	r2,zero,80c3d4 <__mdiff+0x108>
  80c3e4:	6005883a 	mov	r2,r12
  80c3e8:	62800415 	stw	r10,16(r12)
  80c3ec:	dfc00417 	ldw	ra,16(sp)
  80c3f0:	dcc00317 	ldw	r19,12(sp)
  80c3f4:	dc800217 	ldw	r18,8(sp)
  80c3f8:	dc400117 	ldw	r17,4(sp)
  80c3fc:	dc000017 	ldw	r16,0(sp)
  80c400:	dec00504 	addi	sp,sp,20
  80c404:	f800283a 	ret
  80c408:	9009883a 	mov	r4,r18
  80c40c:	000b883a 	mov	r5,zero
  80c410:	080c0940 	call	80c094 <_Balloc>
  80c414:	1019883a 	mov	r12,r2
  80c418:	00800044 	movi	r2,1
  80c41c:	60800415 	stw	r2,16(r12)
  80c420:	6005883a 	mov	r2,r12
  80c424:	60000515 	stw	zero,20(r12)
  80c428:	dfc00417 	ldw	ra,16(sp)
  80c42c:	dcc00317 	ldw	r19,12(sp)
  80c430:	dc800217 	ldw	r18,8(sp)
  80c434:	dc400117 	ldw	r17,4(sp)
  80c438:	dc000017 	ldw	r16,0(sp)
  80c43c:	dec00504 	addi	sp,sp,20
  80c440:	f800283a 	ret
  80c444:	880d883a 	mov	r6,r17
  80c448:	04c00044 	movi	r19,1
  80c44c:	8023883a 	mov	r17,r16
  80c450:	3021883a 	mov	r16,r6
  80c454:	003fac06 	br	80c308 <__mdiff+0x3c>

0080c458 <__lshift>:
  80c458:	defff904 	addi	sp,sp,-28
  80c45c:	28800417 	ldw	r2,16(r5)
  80c460:	dc000015 	stw	r16,0(sp)
  80c464:	3021d17a 	srai	r16,r6,5
  80c468:	28c00217 	ldw	r3,8(r5)
  80c46c:	10800044 	addi	r2,r2,1
  80c470:	dc400115 	stw	r17,4(sp)
  80c474:	80a3883a 	add	r17,r16,r2
  80c478:	dd400515 	stw	r21,20(sp)
  80c47c:	dd000415 	stw	r20,16(sp)
  80c480:	dc800215 	stw	r18,8(sp)
  80c484:	dfc00615 	stw	ra,24(sp)
  80c488:	2825883a 	mov	r18,r5
  80c48c:	dcc00315 	stw	r19,12(sp)
  80c490:	3029883a 	mov	r20,r6
  80c494:	202b883a 	mov	r21,r4
  80c498:	29400117 	ldw	r5,4(r5)
  80c49c:	1c40030e 	bge	r3,r17,80c4ac <__lshift+0x54>
  80c4a0:	18c7883a 	add	r3,r3,r3
  80c4a4:	29400044 	addi	r5,r5,1
  80c4a8:	1c7ffd16 	blt	r3,r17,80c4a0 <__lshift+0x48>
  80c4ac:	a809883a 	mov	r4,r21
  80c4b0:	080c0940 	call	80c094 <_Balloc>
  80c4b4:	1027883a 	mov	r19,r2
  80c4b8:	11400504 	addi	r5,r2,20
  80c4bc:	0400090e 	bge	zero,r16,80c4e4 <__lshift+0x8c>
  80c4c0:	2805883a 	mov	r2,r5
  80c4c4:	0007883a 	mov	r3,zero
  80c4c8:	18c00044 	addi	r3,r3,1
  80c4cc:	10000015 	stw	zero,0(r2)
  80c4d0:	10800104 	addi	r2,r2,4
  80c4d4:	80fffc1e 	bne	r16,r3,80c4c8 <__lshift+0x70>
  80c4d8:	8405883a 	add	r2,r16,r16
  80c4dc:	1085883a 	add	r2,r2,r2
  80c4e0:	288b883a 	add	r5,r5,r2
  80c4e4:	90800417 	ldw	r2,16(r18)
  80c4e8:	91000504 	addi	r4,r18,20
  80c4ec:	a18007cc 	andi	r6,r20,31
  80c4f0:	1085883a 	add	r2,r2,r2
  80c4f4:	1085883a 	add	r2,r2,r2
  80c4f8:	208f883a 	add	r7,r4,r2
  80c4fc:	30001e26 	beq	r6,zero,80c578 <__lshift+0x120>
  80c500:	00800804 	movi	r2,32
  80c504:	1191c83a 	sub	r8,r2,r6
  80c508:	0007883a 	mov	r3,zero
  80c50c:	20800017 	ldw	r2,0(r4)
  80c510:	1184983a 	sll	r2,r2,r6
  80c514:	1884b03a 	or	r2,r3,r2
  80c518:	28800015 	stw	r2,0(r5)
  80c51c:	20c00017 	ldw	r3,0(r4)
  80c520:	21000104 	addi	r4,r4,4
  80c524:	29400104 	addi	r5,r5,4
  80c528:	1a06d83a 	srl	r3,r3,r8
  80c52c:	21fff736 	bltu	r4,r7,80c50c <__lshift+0xb4>
  80c530:	28c00015 	stw	r3,0(r5)
  80c534:	18000126 	beq	r3,zero,80c53c <__lshift+0xe4>
  80c538:	8c400044 	addi	r17,r17,1
  80c53c:	88bfffc4 	addi	r2,r17,-1
  80c540:	98800415 	stw	r2,16(r19)
  80c544:	a809883a 	mov	r4,r21
  80c548:	900b883a 	mov	r5,r18
  80c54c:	080bb140 	call	80bb14 <_Bfree>
  80c550:	9805883a 	mov	r2,r19
  80c554:	dfc00617 	ldw	ra,24(sp)
  80c558:	dd400517 	ldw	r21,20(sp)
  80c55c:	dd000417 	ldw	r20,16(sp)
  80c560:	dcc00317 	ldw	r19,12(sp)
  80c564:	dc800217 	ldw	r18,8(sp)
  80c568:	dc400117 	ldw	r17,4(sp)
  80c56c:	dc000017 	ldw	r16,0(sp)
  80c570:	dec00704 	addi	sp,sp,28
  80c574:	f800283a 	ret
  80c578:	20800017 	ldw	r2,0(r4)
  80c57c:	21000104 	addi	r4,r4,4
  80c580:	28800015 	stw	r2,0(r5)
  80c584:	29400104 	addi	r5,r5,4
  80c588:	21ffec2e 	bgeu	r4,r7,80c53c <__lshift+0xe4>
  80c58c:	20800017 	ldw	r2,0(r4)
  80c590:	21000104 	addi	r4,r4,4
  80c594:	28800015 	stw	r2,0(r5)
  80c598:	29400104 	addi	r5,r5,4
  80c59c:	21fff636 	bltu	r4,r7,80c578 <__lshift+0x120>
  80c5a0:	003fe606 	br	80c53c <__lshift+0xe4>

0080c5a4 <__multiply>:
  80c5a4:	defff004 	addi	sp,sp,-64
  80c5a8:	dc800815 	stw	r18,32(sp)
  80c5ac:	dc400715 	stw	r17,28(sp)
  80c5b0:	2c800417 	ldw	r18,16(r5)
  80c5b4:	34400417 	ldw	r17,16(r6)
  80c5b8:	dcc00915 	stw	r19,36(sp)
  80c5bc:	dc000615 	stw	r16,24(sp)
  80c5c0:	dfc00f15 	stw	ra,60(sp)
  80c5c4:	df000e15 	stw	fp,56(sp)
  80c5c8:	ddc00d15 	stw	r23,52(sp)
  80c5cc:	dd800c15 	stw	r22,48(sp)
  80c5d0:	dd400b15 	stw	r21,44(sp)
  80c5d4:	dd000a15 	stw	r20,40(sp)
  80c5d8:	2821883a 	mov	r16,r5
  80c5dc:	3027883a 	mov	r19,r6
  80c5e0:	9440040e 	bge	r18,r17,80c5f4 <__multiply+0x50>
  80c5e4:	8825883a 	mov	r18,r17
  80c5e8:	2c400417 	ldw	r17,16(r5)
  80c5ec:	2827883a 	mov	r19,r5
  80c5f0:	3021883a 	mov	r16,r6
  80c5f4:	80800217 	ldw	r2,8(r16)
  80c5f8:	9447883a 	add	r3,r18,r17
  80c5fc:	d8c00415 	stw	r3,16(sp)
  80c600:	81400117 	ldw	r5,4(r16)
  80c604:	10c0010e 	bge	r2,r3,80c60c <__multiply+0x68>
  80c608:	29400044 	addi	r5,r5,1
  80c60c:	080c0940 	call	80c094 <_Balloc>
  80c610:	d8800515 	stw	r2,20(sp)
  80c614:	d9000417 	ldw	r4,16(sp)
  80c618:	d8c00517 	ldw	r3,20(sp)
  80c61c:	2105883a 	add	r2,r4,r4
  80c620:	1085883a 	add	r2,r2,r2
  80c624:	19000504 	addi	r4,r3,20
  80c628:	2085883a 	add	r2,r4,r2
  80c62c:	d8800315 	stw	r2,12(sp)
  80c630:	2080052e 	bgeu	r4,r2,80c648 <__multiply+0xa4>
  80c634:	2005883a 	mov	r2,r4
  80c638:	d8c00317 	ldw	r3,12(sp)
  80c63c:	10000015 	stw	zero,0(r2)
  80c640:	10800104 	addi	r2,r2,4
  80c644:	10fffc36 	bltu	r2,r3,80c638 <__multiply+0x94>
  80c648:	8c45883a 	add	r2,r17,r17
  80c64c:	9487883a 	add	r3,r18,r18
  80c650:	9dc00504 	addi	r23,r19,20
  80c654:	1085883a 	add	r2,r2,r2
  80c658:	84000504 	addi	r16,r16,20
  80c65c:	18c7883a 	add	r3,r3,r3
  80c660:	b885883a 	add	r2,r23,r2
  80c664:	dc000015 	stw	r16,0(sp)
  80c668:	d8800215 	stw	r2,8(sp)
  80c66c:	80f9883a 	add	fp,r16,r3
  80c670:	b880432e 	bgeu	r23,r2,80c780 <__multiply+0x1dc>
  80c674:	d9000115 	stw	r4,4(sp)
  80c678:	b9000017 	ldw	r4,0(r23)
  80c67c:	253fffcc 	andi	r20,r4,65535
  80c680:	a0001a26 	beq	r20,zero,80c6ec <__multiply+0x148>
  80c684:	dcc00017 	ldw	r19,0(sp)
  80c688:	dc800117 	ldw	r18,4(sp)
  80c68c:	002b883a 	mov	r21,zero
  80c690:	9c400017 	ldw	r17,0(r19)
  80c694:	94000017 	ldw	r16,0(r18)
  80c698:	a009883a 	mov	r4,r20
  80c69c:	897fffcc 	andi	r5,r17,65535
  80c6a0:	08064840 	call	806484 <__mulsi3>
  80c6a4:	880ad43a 	srli	r5,r17,16
  80c6a8:	80ffffcc 	andi	r3,r16,65535
  80c6ac:	a8c7883a 	add	r3,r21,r3
  80c6b0:	a009883a 	mov	r4,r20
  80c6b4:	10e3883a 	add	r17,r2,r3
  80c6b8:	8020d43a 	srli	r16,r16,16
  80c6bc:	08064840 	call	806484 <__mulsi3>
  80c6c0:	8806d43a 	srli	r3,r17,16
  80c6c4:	1405883a 	add	r2,r2,r16
  80c6c8:	9cc00104 	addi	r19,r19,4
  80c6cc:	1887883a 	add	r3,r3,r2
  80c6d0:	90c0008d 	sth	r3,2(r18)
  80c6d4:	9440000d 	sth	r17,0(r18)
  80c6d8:	182ad43a 	srli	r21,r3,16
  80c6dc:	94800104 	addi	r18,r18,4
  80c6e0:	9f3feb36 	bltu	r19,fp,80c690 <__multiply+0xec>
  80c6e4:	95400015 	stw	r21,0(r18)
  80c6e8:	b9000017 	ldw	r4,0(r23)
  80c6ec:	202ad43a 	srli	r21,r4,16
  80c6f0:	a8001c26 	beq	r21,zero,80c764 <__multiply+0x1c0>
  80c6f4:	d9000117 	ldw	r4,4(sp)
  80c6f8:	dd000017 	ldw	r20,0(sp)
  80c6fc:	002d883a 	mov	r22,zero
  80c700:	24c00017 	ldw	r19,0(r4)
  80c704:	2025883a 	mov	r18,r4
  80c708:	9823883a 	mov	r17,r19
  80c70c:	a4000017 	ldw	r16,0(r20)
  80c710:	a809883a 	mov	r4,r21
  80c714:	a5000104 	addi	r20,r20,4
  80c718:	817fffcc 	andi	r5,r16,65535
  80c71c:	08064840 	call	806484 <__mulsi3>
  80c720:	8806d43a 	srli	r3,r17,16
  80c724:	800ad43a 	srli	r5,r16,16
  80c728:	94c0000d 	sth	r19,0(r18)
  80c72c:	b0c7883a 	add	r3,r22,r3
  80c730:	10e1883a 	add	r16,r2,r3
  80c734:	9400008d 	sth	r16,2(r18)
  80c738:	a809883a 	mov	r4,r21
  80c73c:	94800104 	addi	r18,r18,4
  80c740:	08064840 	call	806484 <__mulsi3>
  80c744:	94400017 	ldw	r17,0(r18)
  80c748:	8020d43a 	srli	r16,r16,16
  80c74c:	88ffffcc 	andi	r3,r17,65535
  80c750:	10c5883a 	add	r2,r2,r3
  80c754:	80a7883a 	add	r19,r16,r2
  80c758:	982cd43a 	srli	r22,r19,16
  80c75c:	a73feb36 	bltu	r20,fp,80c70c <__multiply+0x168>
  80c760:	94c00015 	stw	r19,0(r18)
  80c764:	d8800217 	ldw	r2,8(sp)
  80c768:	bdc00104 	addi	r23,r23,4
  80c76c:	b880042e 	bgeu	r23,r2,80c780 <__multiply+0x1dc>
  80c770:	d8c00117 	ldw	r3,4(sp)
  80c774:	18c00104 	addi	r3,r3,4
  80c778:	d8c00115 	stw	r3,4(sp)
  80c77c:	003fbe06 	br	80c678 <__multiply+0xd4>
  80c780:	d9000417 	ldw	r4,16(sp)
  80c784:	01000c0e 	bge	zero,r4,80c7b8 <__multiply+0x214>
  80c788:	d8c00317 	ldw	r3,12(sp)
  80c78c:	18bfff17 	ldw	r2,-4(r3)
  80c790:	18ffff04 	addi	r3,r3,-4
  80c794:	10000326 	beq	r2,zero,80c7a4 <__multiply+0x200>
  80c798:	00000706 	br	80c7b8 <__multiply+0x214>
  80c79c:	18800017 	ldw	r2,0(r3)
  80c7a0:	1000051e 	bne	r2,zero,80c7b8 <__multiply+0x214>
  80c7a4:	d9000417 	ldw	r4,16(sp)
  80c7a8:	18ffff04 	addi	r3,r3,-4
  80c7ac:	213fffc4 	addi	r4,r4,-1
  80c7b0:	d9000415 	stw	r4,16(sp)
  80c7b4:	203ff91e 	bne	r4,zero,80c79c <__multiply+0x1f8>
  80c7b8:	d8800417 	ldw	r2,16(sp)
  80c7bc:	d8c00517 	ldw	r3,20(sp)
  80c7c0:	18800415 	stw	r2,16(r3)
  80c7c4:	1805883a 	mov	r2,r3
  80c7c8:	dfc00f17 	ldw	ra,60(sp)
  80c7cc:	df000e17 	ldw	fp,56(sp)
  80c7d0:	ddc00d17 	ldw	r23,52(sp)
  80c7d4:	dd800c17 	ldw	r22,48(sp)
  80c7d8:	dd400b17 	ldw	r21,44(sp)
  80c7dc:	dd000a17 	ldw	r20,40(sp)
  80c7e0:	dcc00917 	ldw	r19,36(sp)
  80c7e4:	dc800817 	ldw	r18,32(sp)
  80c7e8:	dc400717 	ldw	r17,28(sp)
  80c7ec:	dc000617 	ldw	r16,24(sp)
  80c7f0:	dec01004 	addi	sp,sp,64
  80c7f4:	f800283a 	ret

0080c7f8 <__i2b>:
  80c7f8:	defffd04 	addi	sp,sp,-12
  80c7fc:	dc000015 	stw	r16,0(sp)
  80c800:	04000044 	movi	r16,1
  80c804:	dc800115 	stw	r18,4(sp)
  80c808:	2825883a 	mov	r18,r5
  80c80c:	800b883a 	mov	r5,r16
  80c810:	dfc00215 	stw	ra,8(sp)
  80c814:	080c0940 	call	80c094 <_Balloc>
  80c818:	14000415 	stw	r16,16(r2)
  80c81c:	14800515 	stw	r18,20(r2)
  80c820:	dfc00217 	ldw	ra,8(sp)
  80c824:	dc800117 	ldw	r18,4(sp)
  80c828:	dc000017 	ldw	r16,0(sp)
  80c82c:	dec00304 	addi	sp,sp,12
  80c830:	f800283a 	ret

0080c834 <__multadd>:
  80c834:	defff604 	addi	sp,sp,-40
  80c838:	dd800615 	stw	r22,24(sp)
  80c83c:	2d800417 	ldw	r22,16(r5)
  80c840:	df000815 	stw	fp,32(sp)
  80c844:	ddc00715 	stw	r23,28(sp)
  80c848:	dd400515 	stw	r21,20(sp)
  80c84c:	dd000415 	stw	r20,16(sp)
  80c850:	dcc00315 	stw	r19,12(sp)
  80c854:	dc800215 	stw	r18,8(sp)
  80c858:	dfc00915 	stw	ra,36(sp)
  80c85c:	dc400115 	stw	r17,4(sp)
  80c860:	dc000015 	stw	r16,0(sp)
  80c864:	282f883a 	mov	r23,r5
  80c868:	2039883a 	mov	fp,r4
  80c86c:	302b883a 	mov	r21,r6
  80c870:	3829883a 	mov	r20,r7
  80c874:	2c800504 	addi	r18,r5,20
  80c878:	0027883a 	mov	r19,zero
  80c87c:	94400017 	ldw	r17,0(r18)
  80c880:	a80b883a 	mov	r5,r21
  80c884:	9cc00044 	addi	r19,r19,1
  80c888:	893fffcc 	andi	r4,r17,65535
  80c88c:	08064840 	call	806484 <__mulsi3>
  80c890:	8808d43a 	srli	r4,r17,16
  80c894:	1521883a 	add	r16,r2,r20
  80c898:	a80b883a 	mov	r5,r21
  80c89c:	08064840 	call	806484 <__mulsi3>
  80c8a0:	8008d43a 	srli	r4,r16,16
  80c8a4:	843fffcc 	andi	r16,r16,65535
  80c8a8:	1105883a 	add	r2,r2,r4
  80c8ac:	1006943a 	slli	r3,r2,16
  80c8b0:	1028d43a 	srli	r20,r2,16
  80c8b4:	1c07883a 	add	r3,r3,r16
  80c8b8:	90c00015 	stw	r3,0(r18)
  80c8bc:	94800104 	addi	r18,r18,4
  80c8c0:	9dbfee16 	blt	r19,r22,80c87c <__multadd+0x48>
  80c8c4:	a0000826 	beq	r20,zero,80c8e8 <__multadd+0xb4>
  80c8c8:	b8800217 	ldw	r2,8(r23)
  80c8cc:	b080130e 	bge	r22,r2,80c91c <__multadd+0xe8>
  80c8d0:	b585883a 	add	r2,r22,r22
  80c8d4:	1085883a 	add	r2,r2,r2
  80c8d8:	15c5883a 	add	r2,r2,r23
  80c8dc:	b0c00044 	addi	r3,r22,1
  80c8e0:	15000515 	stw	r20,20(r2)
  80c8e4:	b8c00415 	stw	r3,16(r23)
  80c8e8:	b805883a 	mov	r2,r23
  80c8ec:	dfc00917 	ldw	ra,36(sp)
  80c8f0:	df000817 	ldw	fp,32(sp)
  80c8f4:	ddc00717 	ldw	r23,28(sp)
  80c8f8:	dd800617 	ldw	r22,24(sp)
  80c8fc:	dd400517 	ldw	r21,20(sp)
  80c900:	dd000417 	ldw	r20,16(sp)
  80c904:	dcc00317 	ldw	r19,12(sp)
  80c908:	dc800217 	ldw	r18,8(sp)
  80c90c:	dc400117 	ldw	r17,4(sp)
  80c910:	dc000017 	ldw	r16,0(sp)
  80c914:	dec00a04 	addi	sp,sp,40
  80c918:	f800283a 	ret
  80c91c:	b9400117 	ldw	r5,4(r23)
  80c920:	e009883a 	mov	r4,fp
  80c924:	29400044 	addi	r5,r5,1
  80c928:	080c0940 	call	80c094 <_Balloc>
  80c92c:	b9800417 	ldw	r6,16(r23)
  80c930:	b9400304 	addi	r5,r23,12
  80c934:	11000304 	addi	r4,r2,12
  80c938:	318d883a 	add	r6,r6,r6
  80c93c:	318d883a 	add	r6,r6,r6
  80c940:	31800204 	addi	r6,r6,8
  80c944:	1023883a 	mov	r17,r2
  80c948:	080b8fc0 	call	80b8fc <memcpy>
  80c94c:	b80b883a 	mov	r5,r23
  80c950:	e009883a 	mov	r4,fp
  80c954:	080bb140 	call	80bb14 <_Bfree>
  80c958:	882f883a 	mov	r23,r17
  80c95c:	003fdc06 	br	80c8d0 <__multadd+0x9c>

0080c960 <__pow5mult>:
  80c960:	defffa04 	addi	sp,sp,-24
  80c964:	308000cc 	andi	r2,r6,3
  80c968:	dd000415 	stw	r20,16(sp)
  80c96c:	dcc00315 	stw	r19,12(sp)
  80c970:	dc000015 	stw	r16,0(sp)
  80c974:	dfc00515 	stw	ra,20(sp)
  80c978:	dc800215 	stw	r18,8(sp)
  80c97c:	dc400115 	stw	r17,4(sp)
  80c980:	3021883a 	mov	r16,r6
  80c984:	2027883a 	mov	r19,r4
  80c988:	2829883a 	mov	r20,r5
  80c98c:	10002b1e 	bne	r2,zero,80ca3c <__pow5mult+0xdc>
  80c990:	8025d0ba 	srai	r18,r16,2
  80c994:	90001b26 	beq	r18,zero,80ca04 <__pow5mult+0xa4>
  80c998:	9c001217 	ldw	r16,72(r19)
  80c99c:	8000081e 	bne	r16,zero,80c9c0 <__pow5mult+0x60>
  80c9a0:	00003006 	br	80ca64 <__pow5mult+0x104>
  80c9a4:	800b883a 	mov	r5,r16
  80c9a8:	800d883a 	mov	r6,r16
  80c9ac:	9809883a 	mov	r4,r19
  80c9b0:	90001426 	beq	r18,zero,80ca04 <__pow5mult+0xa4>
  80c9b4:	80800017 	ldw	r2,0(r16)
  80c9b8:	10001b26 	beq	r2,zero,80ca28 <__pow5mult+0xc8>
  80c9bc:	1021883a 	mov	r16,r2
  80c9c0:	9080004c 	andi	r2,r18,1
  80c9c4:	1005003a 	cmpeq	r2,r2,zero
  80c9c8:	9025d07a 	srai	r18,r18,1
  80c9cc:	800d883a 	mov	r6,r16
  80c9d0:	9809883a 	mov	r4,r19
  80c9d4:	a00b883a 	mov	r5,r20
  80c9d8:	103ff21e 	bne	r2,zero,80c9a4 <__pow5mult+0x44>
  80c9dc:	080c5a40 	call	80c5a4 <__multiply>
  80c9e0:	a00b883a 	mov	r5,r20
  80c9e4:	9809883a 	mov	r4,r19
  80c9e8:	1023883a 	mov	r17,r2
  80c9ec:	080bb140 	call	80bb14 <_Bfree>
  80c9f0:	8829883a 	mov	r20,r17
  80c9f4:	800b883a 	mov	r5,r16
  80c9f8:	800d883a 	mov	r6,r16
  80c9fc:	9809883a 	mov	r4,r19
  80ca00:	903fec1e 	bne	r18,zero,80c9b4 <__pow5mult+0x54>
  80ca04:	a005883a 	mov	r2,r20
  80ca08:	dfc00517 	ldw	ra,20(sp)
  80ca0c:	dd000417 	ldw	r20,16(sp)
  80ca10:	dcc00317 	ldw	r19,12(sp)
  80ca14:	dc800217 	ldw	r18,8(sp)
  80ca18:	dc400117 	ldw	r17,4(sp)
  80ca1c:	dc000017 	ldw	r16,0(sp)
  80ca20:	dec00604 	addi	sp,sp,24
  80ca24:	f800283a 	ret
  80ca28:	080c5a40 	call	80c5a4 <__multiply>
  80ca2c:	80800015 	stw	r2,0(r16)
  80ca30:	1021883a 	mov	r16,r2
  80ca34:	10000015 	stw	zero,0(r2)
  80ca38:	003fe106 	br	80c9c0 <__pow5mult+0x60>
  80ca3c:	1085883a 	add	r2,r2,r2
  80ca40:	00c020b4 	movhi	r3,130
  80ca44:	18e1d104 	addi	r3,r3,-30908
  80ca48:	1085883a 	add	r2,r2,r2
  80ca4c:	10c5883a 	add	r2,r2,r3
  80ca50:	11bfff17 	ldw	r6,-4(r2)
  80ca54:	000f883a 	mov	r7,zero
  80ca58:	080c8340 	call	80c834 <__multadd>
  80ca5c:	1029883a 	mov	r20,r2
  80ca60:	003fcb06 	br	80c990 <__pow5mult+0x30>
  80ca64:	9809883a 	mov	r4,r19
  80ca68:	01409c44 	movi	r5,625
  80ca6c:	080c7f80 	call	80c7f8 <__i2b>
  80ca70:	98801215 	stw	r2,72(r19)
  80ca74:	1021883a 	mov	r16,r2
  80ca78:	10000015 	stw	zero,0(r2)
  80ca7c:	003fd006 	br	80c9c0 <__pow5mult+0x60>

0080ca80 <__s2b>:
  80ca80:	defff904 	addi	sp,sp,-28
  80ca84:	dcc00315 	stw	r19,12(sp)
  80ca88:	dc800215 	stw	r18,8(sp)
  80ca8c:	2827883a 	mov	r19,r5
  80ca90:	2025883a 	mov	r18,r4
  80ca94:	01400244 	movi	r5,9
  80ca98:	39000204 	addi	r4,r7,8
  80ca9c:	dd000415 	stw	r20,16(sp)
  80caa0:	dc400115 	stw	r17,4(sp)
  80caa4:	dfc00615 	stw	ra,24(sp)
  80caa8:	dd400515 	stw	r21,20(sp)
  80caac:	dc000015 	stw	r16,0(sp)
  80cab0:	3829883a 	mov	r20,r7
  80cab4:	3023883a 	mov	r17,r6
  80cab8:	08063b40 	call	8063b4 <__divsi3>
  80cabc:	00c00044 	movi	r3,1
  80cac0:	1880350e 	bge	r3,r2,80cb98 <__s2b+0x118>
  80cac4:	000b883a 	mov	r5,zero
  80cac8:	18c7883a 	add	r3,r3,r3
  80cacc:	29400044 	addi	r5,r5,1
  80cad0:	18bffd16 	blt	r3,r2,80cac8 <__s2b+0x48>
  80cad4:	9009883a 	mov	r4,r18
  80cad8:	080c0940 	call	80c094 <_Balloc>
  80cadc:	1011883a 	mov	r8,r2
  80cae0:	d8800717 	ldw	r2,28(sp)
  80cae4:	00c00044 	movi	r3,1
  80cae8:	01800244 	movi	r6,9
  80caec:	40800515 	stw	r2,20(r8)
  80caf0:	40c00415 	stw	r3,16(r8)
  80caf4:	3440260e 	bge	r6,r17,80cb90 <__s2b+0x110>
  80caf8:	3021883a 	mov	r16,r6
  80cafc:	99ab883a 	add	r21,r19,r6
  80cb00:	9c05883a 	add	r2,r19,r16
  80cb04:	11c00007 	ldb	r7,0(r2)
  80cb08:	400b883a 	mov	r5,r8
  80cb0c:	9009883a 	mov	r4,r18
  80cb10:	39fff404 	addi	r7,r7,-48
  80cb14:	01800284 	movi	r6,10
  80cb18:	080c8340 	call	80c834 <__multadd>
  80cb1c:	84000044 	addi	r16,r16,1
  80cb20:	1011883a 	mov	r8,r2
  80cb24:	8c3ff61e 	bne	r17,r16,80cb00 <__s2b+0x80>
  80cb28:	ac45883a 	add	r2,r21,r17
  80cb2c:	117ffe04 	addi	r5,r2,-8
  80cb30:	880d883a 	mov	r6,r17
  80cb34:	35000c0e 	bge	r6,r20,80cb68 <__s2b+0xe8>
  80cb38:	a185c83a 	sub	r2,r20,r6
  80cb3c:	2821883a 	mov	r16,r5
  80cb40:	28a3883a 	add	r17,r5,r2
  80cb44:	81c00007 	ldb	r7,0(r16)
  80cb48:	400b883a 	mov	r5,r8
  80cb4c:	9009883a 	mov	r4,r18
  80cb50:	39fff404 	addi	r7,r7,-48
  80cb54:	01800284 	movi	r6,10
  80cb58:	080c8340 	call	80c834 <__multadd>
  80cb5c:	84000044 	addi	r16,r16,1
  80cb60:	1011883a 	mov	r8,r2
  80cb64:	847ff71e 	bne	r16,r17,80cb44 <__s2b+0xc4>
  80cb68:	4005883a 	mov	r2,r8
  80cb6c:	dfc00617 	ldw	ra,24(sp)
  80cb70:	dd400517 	ldw	r21,20(sp)
  80cb74:	dd000417 	ldw	r20,16(sp)
  80cb78:	dcc00317 	ldw	r19,12(sp)
  80cb7c:	dc800217 	ldw	r18,8(sp)
  80cb80:	dc400117 	ldw	r17,4(sp)
  80cb84:	dc000017 	ldw	r16,0(sp)
  80cb88:	dec00704 	addi	sp,sp,28
  80cb8c:	f800283a 	ret
  80cb90:	99400284 	addi	r5,r19,10
  80cb94:	003fe706 	br	80cb34 <__s2b+0xb4>
  80cb98:	000b883a 	mov	r5,zero
  80cb9c:	003fcd06 	br	80cad4 <__s2b+0x54>

0080cba0 <_realloc_r>:
  80cba0:	defff404 	addi	sp,sp,-48
  80cba4:	dd800815 	stw	r22,32(sp)
  80cba8:	dc800415 	stw	r18,16(sp)
  80cbac:	dc400315 	stw	r17,12(sp)
  80cbb0:	dfc00b15 	stw	ra,44(sp)
  80cbb4:	df000a15 	stw	fp,40(sp)
  80cbb8:	ddc00915 	stw	r23,36(sp)
  80cbbc:	dd400715 	stw	r21,28(sp)
  80cbc0:	dd000615 	stw	r20,24(sp)
  80cbc4:	dcc00515 	stw	r19,20(sp)
  80cbc8:	dc000215 	stw	r16,8(sp)
  80cbcc:	2825883a 	mov	r18,r5
  80cbd0:	3023883a 	mov	r17,r6
  80cbd4:	202d883a 	mov	r22,r4
  80cbd8:	2800c926 	beq	r5,zero,80cf00 <_realloc_r+0x360>
  80cbdc:	08135f00 	call	8135f0 <__malloc_lock>
  80cbe0:	943ffe04 	addi	r16,r18,-8
  80cbe4:	88c002c4 	addi	r3,r17,11
  80cbe8:	00800584 	movi	r2,22
  80cbec:	82000117 	ldw	r8,4(r16)
  80cbf0:	10c01b2e 	bgeu	r2,r3,80cc60 <_realloc_r+0xc0>
  80cbf4:	00bffe04 	movi	r2,-8
  80cbf8:	188e703a 	and	r7,r3,r2
  80cbfc:	3839883a 	mov	fp,r7
  80cc00:	38001a16 	blt	r7,zero,80cc6c <_realloc_r+0xcc>
  80cc04:	e4401936 	bltu	fp,r17,80cc6c <_realloc_r+0xcc>
  80cc08:	013fff04 	movi	r4,-4
  80cc0c:	4126703a 	and	r19,r8,r4
  80cc10:	99c02616 	blt	r19,r7,80ccac <_realloc_r+0x10c>
  80cc14:	802b883a 	mov	r21,r16
  80cc18:	9829883a 	mov	r20,r19
  80cc1c:	84000204 	addi	r16,r16,8
  80cc20:	a80f883a 	mov	r7,r21
  80cc24:	a70dc83a 	sub	r6,r20,fp
  80cc28:	008003c4 	movi	r2,15
  80cc2c:	1180c136 	bltu	r2,r6,80cf34 <_realloc_r+0x394>
  80cc30:	38800117 	ldw	r2,4(r7)
  80cc34:	a549883a 	add	r4,r20,r21
  80cc38:	1080004c 	andi	r2,r2,1
  80cc3c:	a084b03a 	or	r2,r20,r2
  80cc40:	38800115 	stw	r2,4(r7)
  80cc44:	20c00117 	ldw	r3,4(r4)
  80cc48:	18c00054 	ori	r3,r3,1
  80cc4c:	20c00115 	stw	r3,4(r4)
  80cc50:	b009883a 	mov	r4,r22
  80cc54:	08136100 	call	813610 <__malloc_unlock>
  80cc58:	8023883a 	mov	r17,r16
  80cc5c:	00000606 	br	80cc78 <_realloc_r+0xd8>
  80cc60:	01c00404 	movi	r7,16
  80cc64:	3839883a 	mov	fp,r7
  80cc68:	e47fe72e 	bgeu	fp,r17,80cc08 <_realloc_r+0x68>
  80cc6c:	00800304 	movi	r2,12
  80cc70:	0023883a 	mov	r17,zero
  80cc74:	b0800015 	stw	r2,0(r22)
  80cc78:	8805883a 	mov	r2,r17
  80cc7c:	dfc00b17 	ldw	ra,44(sp)
  80cc80:	df000a17 	ldw	fp,40(sp)
  80cc84:	ddc00917 	ldw	r23,36(sp)
  80cc88:	dd800817 	ldw	r22,32(sp)
  80cc8c:	dd400717 	ldw	r21,28(sp)
  80cc90:	dd000617 	ldw	r20,24(sp)
  80cc94:	dcc00517 	ldw	r19,20(sp)
  80cc98:	dc800417 	ldw	r18,16(sp)
  80cc9c:	dc400317 	ldw	r17,12(sp)
  80cca0:	dc000217 	ldw	r16,8(sp)
  80cca4:	dec00c04 	addi	sp,sp,48
  80cca8:	f800283a 	ret
  80ccac:	008020b4 	movhi	r2,130
  80ccb0:	10a37704 	addi	r2,r2,-29220
  80ccb4:	12400217 	ldw	r9,8(r2)
  80ccb8:	84cd883a 	add	r6,r16,r19
  80ccbc:	802b883a 	mov	r21,r16
  80ccc0:	3240b926 	beq	r6,r9,80cfa8 <_realloc_r+0x408>
  80ccc4:	31400117 	ldw	r5,4(r6)
  80ccc8:	00bfff84 	movi	r2,-2
  80cccc:	2884703a 	and	r2,r5,r2
  80ccd0:	1185883a 	add	r2,r2,r6
  80ccd4:	10c00117 	ldw	r3,4(r2)
  80ccd8:	18c0004c 	andi	r3,r3,1
  80ccdc:	1807003a 	cmpeq	r3,r3,zero
  80cce0:	1800a326 	beq	r3,zero,80cf70 <_realloc_r+0x3d0>
  80cce4:	2908703a 	and	r4,r5,r4
  80cce8:	9929883a 	add	r20,r19,r4
  80ccec:	a1c0a30e 	bge	r20,r7,80cf7c <_realloc_r+0x3dc>
  80ccf0:	4080004c 	andi	r2,r8,1
  80ccf4:	1000551e 	bne	r2,zero,80ce4c <_realloc_r+0x2ac>
  80ccf8:	80800017 	ldw	r2,0(r16)
  80ccfc:	80afc83a 	sub	r23,r16,r2
  80cd00:	b8c00117 	ldw	r3,4(r23)
  80cd04:	00bfff04 	movi	r2,-4
  80cd08:	1884703a 	and	r2,r3,r2
  80cd0c:	30002e26 	beq	r6,zero,80cdc8 <_realloc_r+0x228>
  80cd10:	3240b926 	beq	r6,r9,80cff8 <_realloc_r+0x458>
  80cd14:	98a9883a 	add	r20,r19,r2
  80cd18:	2509883a 	add	r4,r4,r20
  80cd1c:	d9000015 	stw	r4,0(sp)
  80cd20:	21c02a16 	blt	r4,r7,80cdcc <_realloc_r+0x22c>
  80cd24:	30800317 	ldw	r2,12(r6)
  80cd28:	30c00217 	ldw	r3,8(r6)
  80cd2c:	01400904 	movi	r5,36
  80cd30:	99bfff04 	addi	r6,r19,-4
  80cd34:	18800315 	stw	r2,12(r3)
  80cd38:	10c00215 	stw	r3,8(r2)
  80cd3c:	b9000317 	ldw	r4,12(r23)
  80cd40:	b8800217 	ldw	r2,8(r23)
  80cd44:	b82b883a 	mov	r21,r23
  80cd48:	bc000204 	addi	r16,r23,8
  80cd4c:	20800215 	stw	r2,8(r4)
  80cd50:	11000315 	stw	r4,12(r2)
  80cd54:	2980e436 	bltu	r5,r6,80d0e8 <_realloc_r+0x548>
  80cd58:	008004c4 	movi	r2,19
  80cd5c:	9009883a 	mov	r4,r18
  80cd60:	8011883a 	mov	r8,r16
  80cd64:	11800f2e 	bgeu	r2,r6,80cda4 <_realloc_r+0x204>
  80cd68:	90800017 	ldw	r2,0(r18)
  80cd6c:	ba000404 	addi	r8,r23,16
  80cd70:	91000204 	addi	r4,r18,8
  80cd74:	b8800215 	stw	r2,8(r23)
  80cd78:	90c00117 	ldw	r3,4(r18)
  80cd7c:	008006c4 	movi	r2,27
  80cd80:	b8c00315 	stw	r3,12(r23)
  80cd84:	1180072e 	bgeu	r2,r6,80cda4 <_realloc_r+0x204>
  80cd88:	90c00217 	ldw	r3,8(r18)
  80cd8c:	ba000604 	addi	r8,r23,24
  80cd90:	91000404 	addi	r4,r18,16
  80cd94:	b8c00415 	stw	r3,16(r23)
  80cd98:	90800317 	ldw	r2,12(r18)
  80cd9c:	b8800515 	stw	r2,20(r23)
  80cda0:	3140e726 	beq	r6,r5,80d140 <_realloc_r+0x5a0>
  80cda4:	20800017 	ldw	r2,0(r4)
  80cda8:	dd000017 	ldw	r20,0(sp)
  80cdac:	b80f883a 	mov	r7,r23
  80cdb0:	40800015 	stw	r2,0(r8)
  80cdb4:	20c00117 	ldw	r3,4(r4)
  80cdb8:	40c00115 	stw	r3,4(r8)
  80cdbc:	20800217 	ldw	r2,8(r4)
  80cdc0:	40800215 	stw	r2,8(r8)
  80cdc4:	003f9706 	br	80cc24 <_realloc_r+0x84>
  80cdc8:	98a9883a 	add	r20,r19,r2
  80cdcc:	a1c01f16 	blt	r20,r7,80ce4c <_realloc_r+0x2ac>
  80cdd0:	b8c00317 	ldw	r3,12(r23)
  80cdd4:	b8800217 	ldw	r2,8(r23)
  80cdd8:	99bfff04 	addi	r6,r19,-4
  80cddc:	01400904 	movi	r5,36
  80cde0:	b82b883a 	mov	r21,r23
  80cde4:	18800215 	stw	r2,8(r3)
  80cde8:	10c00315 	stw	r3,12(r2)
  80cdec:	bc000204 	addi	r16,r23,8
  80cdf0:	2980c336 	bltu	r5,r6,80d100 <_realloc_r+0x560>
  80cdf4:	008004c4 	movi	r2,19
  80cdf8:	9009883a 	mov	r4,r18
  80cdfc:	8011883a 	mov	r8,r16
  80ce00:	11800f2e 	bgeu	r2,r6,80ce40 <_realloc_r+0x2a0>
  80ce04:	90800017 	ldw	r2,0(r18)
  80ce08:	ba000404 	addi	r8,r23,16
  80ce0c:	91000204 	addi	r4,r18,8
  80ce10:	b8800215 	stw	r2,8(r23)
  80ce14:	90c00117 	ldw	r3,4(r18)
  80ce18:	008006c4 	movi	r2,27
  80ce1c:	b8c00315 	stw	r3,12(r23)
  80ce20:	1180072e 	bgeu	r2,r6,80ce40 <_realloc_r+0x2a0>
  80ce24:	90c00217 	ldw	r3,8(r18)
  80ce28:	ba000604 	addi	r8,r23,24
  80ce2c:	91000404 	addi	r4,r18,16
  80ce30:	b8c00415 	stw	r3,16(r23)
  80ce34:	90800317 	ldw	r2,12(r18)
  80ce38:	b8800515 	stw	r2,20(r23)
  80ce3c:	3140c726 	beq	r6,r5,80d15c <_realloc_r+0x5bc>
  80ce40:	20800017 	ldw	r2,0(r4)
  80ce44:	b80f883a 	mov	r7,r23
  80ce48:	003fd906 	br	80cdb0 <_realloc_r+0x210>
  80ce4c:	880b883a 	mov	r5,r17
  80ce50:	b009883a 	mov	r4,r22
  80ce54:	080b0d80 	call	80b0d8 <_malloc_r>
  80ce58:	1023883a 	mov	r17,r2
  80ce5c:	10002526 	beq	r2,zero,80cef4 <_realloc_r+0x354>
  80ce60:	80800117 	ldw	r2,4(r16)
  80ce64:	00ffff84 	movi	r3,-2
  80ce68:	893ffe04 	addi	r4,r17,-8
  80ce6c:	10c4703a 	and	r2,r2,r3
  80ce70:	8085883a 	add	r2,r16,r2
  80ce74:	20809526 	beq	r4,r2,80d0cc <_realloc_r+0x52c>
  80ce78:	99bfff04 	addi	r6,r19,-4
  80ce7c:	01c00904 	movi	r7,36
  80ce80:	39804536 	bltu	r7,r6,80cf98 <_realloc_r+0x3f8>
  80ce84:	008004c4 	movi	r2,19
  80ce88:	9009883a 	mov	r4,r18
  80ce8c:	880b883a 	mov	r5,r17
  80ce90:	11800f2e 	bgeu	r2,r6,80ced0 <_realloc_r+0x330>
  80ce94:	90800017 	ldw	r2,0(r18)
  80ce98:	89400204 	addi	r5,r17,8
  80ce9c:	91000204 	addi	r4,r18,8
  80cea0:	88800015 	stw	r2,0(r17)
  80cea4:	90c00117 	ldw	r3,4(r18)
  80cea8:	008006c4 	movi	r2,27
  80ceac:	88c00115 	stw	r3,4(r17)
  80ceb0:	1180072e 	bgeu	r2,r6,80ced0 <_realloc_r+0x330>
  80ceb4:	90c00217 	ldw	r3,8(r18)
  80ceb8:	89400404 	addi	r5,r17,16
  80cebc:	91000404 	addi	r4,r18,16
  80cec0:	88c00215 	stw	r3,8(r17)
  80cec4:	90800317 	ldw	r2,12(r18)
  80cec8:	88800315 	stw	r2,12(r17)
  80cecc:	31c09126 	beq	r6,r7,80d114 <_realloc_r+0x574>
  80ced0:	20800017 	ldw	r2,0(r4)
  80ced4:	28800015 	stw	r2,0(r5)
  80ced8:	20c00117 	ldw	r3,4(r4)
  80cedc:	28c00115 	stw	r3,4(r5)
  80cee0:	20800217 	ldw	r2,8(r4)
  80cee4:	28800215 	stw	r2,8(r5)
  80cee8:	900b883a 	mov	r5,r18
  80ceec:	b009883a 	mov	r4,r22
  80cef0:	080a5500 	call	80a550 <_free_r>
  80cef4:	b009883a 	mov	r4,r22
  80cef8:	08136100 	call	813610 <__malloc_unlock>
  80cefc:	003f5e06 	br	80cc78 <_realloc_r+0xd8>
  80cf00:	300b883a 	mov	r5,r6
  80cf04:	dfc00b17 	ldw	ra,44(sp)
  80cf08:	df000a17 	ldw	fp,40(sp)
  80cf0c:	ddc00917 	ldw	r23,36(sp)
  80cf10:	dd800817 	ldw	r22,32(sp)
  80cf14:	dd400717 	ldw	r21,28(sp)
  80cf18:	dd000617 	ldw	r20,24(sp)
  80cf1c:	dcc00517 	ldw	r19,20(sp)
  80cf20:	dc800417 	ldw	r18,16(sp)
  80cf24:	dc400317 	ldw	r17,12(sp)
  80cf28:	dc000217 	ldw	r16,8(sp)
  80cf2c:	dec00c04 	addi	sp,sp,48
  80cf30:	080b0d81 	jmpi	80b0d8 <_malloc_r>
  80cf34:	38800117 	ldw	r2,4(r7)
  80cf38:	e54b883a 	add	r5,fp,r21
  80cf3c:	31000054 	ori	r4,r6,1
  80cf40:	1080004c 	andi	r2,r2,1
  80cf44:	1704b03a 	or	r2,r2,fp
  80cf48:	38800115 	stw	r2,4(r7)
  80cf4c:	29000115 	stw	r4,4(r5)
  80cf50:	2987883a 	add	r3,r5,r6
  80cf54:	18800117 	ldw	r2,4(r3)
  80cf58:	29400204 	addi	r5,r5,8
  80cf5c:	b009883a 	mov	r4,r22
  80cf60:	10800054 	ori	r2,r2,1
  80cf64:	18800115 	stw	r2,4(r3)
  80cf68:	080a5500 	call	80a550 <_free_r>
  80cf6c:	003f3806 	br	80cc50 <_realloc_r+0xb0>
  80cf70:	000d883a 	mov	r6,zero
  80cf74:	0009883a 	mov	r4,zero
  80cf78:	003f5d06 	br	80ccf0 <_realloc_r+0x150>
  80cf7c:	30c00217 	ldw	r3,8(r6)
  80cf80:	30800317 	ldw	r2,12(r6)
  80cf84:	800f883a 	mov	r7,r16
  80cf88:	84000204 	addi	r16,r16,8
  80cf8c:	10c00215 	stw	r3,8(r2)
  80cf90:	18800315 	stw	r2,12(r3)
  80cf94:	003f2306 	br	80cc24 <_realloc_r+0x84>
  80cf98:	8809883a 	mov	r4,r17
  80cf9c:	900b883a 	mov	r5,r18
  80cfa0:	080b99c0 	call	80b99c <memmove>
  80cfa4:	003fd006 	br	80cee8 <_realloc_r+0x348>
  80cfa8:	30800117 	ldw	r2,4(r6)
  80cfac:	e0c00404 	addi	r3,fp,16
  80cfb0:	1108703a 	and	r4,r2,r4
  80cfb4:	9905883a 	add	r2,r19,r4
  80cfb8:	10ff4d16 	blt	r2,r3,80ccf0 <_realloc_r+0x150>
  80cfbc:	1705c83a 	sub	r2,r2,fp
  80cfc0:	870b883a 	add	r5,r16,fp
  80cfc4:	10800054 	ori	r2,r2,1
  80cfc8:	28800115 	stw	r2,4(r5)
  80cfcc:	80c00117 	ldw	r3,4(r16)
  80cfd0:	008020b4 	movhi	r2,130
  80cfd4:	10a37704 	addi	r2,r2,-29220
  80cfd8:	b009883a 	mov	r4,r22
  80cfdc:	18c0004c 	andi	r3,r3,1
  80cfe0:	e0c6b03a 	or	r3,fp,r3
  80cfe4:	11400215 	stw	r5,8(r2)
  80cfe8:	80c00115 	stw	r3,4(r16)
  80cfec:	08136100 	call	813610 <__malloc_unlock>
  80cff0:	84400204 	addi	r17,r16,8
  80cff4:	003f2006 	br	80cc78 <_realloc_r+0xd8>
  80cff8:	98a9883a 	add	r20,r19,r2
  80cffc:	2509883a 	add	r4,r4,r20
  80d000:	e0800404 	addi	r2,fp,16
  80d004:	d9000115 	stw	r4,4(sp)
  80d008:	20bf7016 	blt	r4,r2,80cdcc <_realloc_r+0x22c>
  80d00c:	b8c00317 	ldw	r3,12(r23)
  80d010:	b8800217 	ldw	r2,8(r23)
  80d014:	99bfff04 	addi	r6,r19,-4
  80d018:	01400904 	movi	r5,36
  80d01c:	18800215 	stw	r2,8(r3)
  80d020:	10c00315 	stw	r3,12(r2)
  80d024:	bc400204 	addi	r17,r23,8
  80d028:	29804136 	bltu	r5,r6,80d130 <_realloc_r+0x590>
  80d02c:	008004c4 	movi	r2,19
  80d030:	9009883a 	mov	r4,r18
  80d034:	880f883a 	mov	r7,r17
  80d038:	11800f2e 	bgeu	r2,r6,80d078 <_realloc_r+0x4d8>
  80d03c:	90800017 	ldw	r2,0(r18)
  80d040:	b9c00404 	addi	r7,r23,16
  80d044:	91000204 	addi	r4,r18,8
  80d048:	b8800215 	stw	r2,8(r23)
  80d04c:	90c00117 	ldw	r3,4(r18)
  80d050:	008006c4 	movi	r2,27
  80d054:	b8c00315 	stw	r3,12(r23)
  80d058:	1180072e 	bgeu	r2,r6,80d078 <_realloc_r+0x4d8>
  80d05c:	90c00217 	ldw	r3,8(r18)
  80d060:	b9c00604 	addi	r7,r23,24
  80d064:	91000404 	addi	r4,r18,16
  80d068:	b8c00415 	stw	r3,16(r23)
  80d06c:	90800317 	ldw	r2,12(r18)
  80d070:	b8800515 	stw	r2,20(r23)
  80d074:	31404026 	beq	r6,r5,80d178 <_realloc_r+0x5d8>
  80d078:	20800017 	ldw	r2,0(r4)
  80d07c:	38800015 	stw	r2,0(r7)
  80d080:	20c00117 	ldw	r3,4(r4)
  80d084:	38c00115 	stw	r3,4(r7)
  80d088:	20800217 	ldw	r2,8(r4)
  80d08c:	38800215 	stw	r2,8(r7)
  80d090:	d8c00117 	ldw	r3,4(sp)
  80d094:	bf0b883a 	add	r5,r23,fp
  80d098:	b009883a 	mov	r4,r22
  80d09c:	1f05c83a 	sub	r2,r3,fp
  80d0a0:	10800054 	ori	r2,r2,1
  80d0a4:	28800115 	stw	r2,4(r5)
  80d0a8:	b8c00117 	ldw	r3,4(r23)
  80d0ac:	008020b4 	movhi	r2,130
  80d0b0:	10a37704 	addi	r2,r2,-29220
  80d0b4:	11400215 	stw	r5,8(r2)
  80d0b8:	18c0004c 	andi	r3,r3,1
  80d0bc:	e0c6b03a 	or	r3,fp,r3
  80d0c0:	b8c00115 	stw	r3,4(r23)
  80d0c4:	08136100 	call	813610 <__malloc_unlock>
  80d0c8:	003eeb06 	br	80cc78 <_realloc_r+0xd8>
  80d0cc:	20800117 	ldw	r2,4(r4)
  80d0d0:	00ffff04 	movi	r3,-4
  80d0d4:	800f883a 	mov	r7,r16
  80d0d8:	10c4703a 	and	r2,r2,r3
  80d0dc:	98a9883a 	add	r20,r19,r2
  80d0e0:	84000204 	addi	r16,r16,8
  80d0e4:	003ecf06 	br	80cc24 <_realloc_r+0x84>
  80d0e8:	900b883a 	mov	r5,r18
  80d0ec:	8009883a 	mov	r4,r16
  80d0f0:	080b99c0 	call	80b99c <memmove>
  80d0f4:	dd000017 	ldw	r20,0(sp)
  80d0f8:	b80f883a 	mov	r7,r23
  80d0fc:	003ec906 	br	80cc24 <_realloc_r+0x84>
  80d100:	900b883a 	mov	r5,r18
  80d104:	8009883a 	mov	r4,r16
  80d108:	080b99c0 	call	80b99c <memmove>
  80d10c:	b80f883a 	mov	r7,r23
  80d110:	003ec406 	br	80cc24 <_realloc_r+0x84>
  80d114:	90c00417 	ldw	r3,16(r18)
  80d118:	89400604 	addi	r5,r17,24
  80d11c:	91000604 	addi	r4,r18,24
  80d120:	88c00415 	stw	r3,16(r17)
  80d124:	90800517 	ldw	r2,20(r18)
  80d128:	88800515 	stw	r2,20(r17)
  80d12c:	003f6806 	br	80ced0 <_realloc_r+0x330>
  80d130:	900b883a 	mov	r5,r18
  80d134:	8809883a 	mov	r4,r17
  80d138:	080b99c0 	call	80b99c <memmove>
  80d13c:	003fd406 	br	80d090 <_realloc_r+0x4f0>
  80d140:	90c00417 	ldw	r3,16(r18)
  80d144:	91000604 	addi	r4,r18,24
  80d148:	ba000804 	addi	r8,r23,32
  80d14c:	b8c00615 	stw	r3,24(r23)
  80d150:	90800517 	ldw	r2,20(r18)
  80d154:	b8800715 	stw	r2,28(r23)
  80d158:	003f1206 	br	80cda4 <_realloc_r+0x204>
  80d15c:	90c00417 	ldw	r3,16(r18)
  80d160:	91000604 	addi	r4,r18,24
  80d164:	ba000804 	addi	r8,r23,32
  80d168:	b8c00615 	stw	r3,24(r23)
  80d16c:	90800517 	ldw	r2,20(r18)
  80d170:	b8800715 	stw	r2,28(r23)
  80d174:	003f3206 	br	80ce40 <_realloc_r+0x2a0>
  80d178:	90c00417 	ldw	r3,16(r18)
  80d17c:	91000604 	addi	r4,r18,24
  80d180:	b9c00804 	addi	r7,r23,32
  80d184:	b8c00615 	stw	r3,24(r23)
  80d188:	90800517 	ldw	r2,20(r18)
  80d18c:	b8800715 	stw	r2,28(r23)
  80d190:	003fb906 	br	80d078 <_realloc_r+0x4d8>

0080d194 <__isinfd>:
  80d194:	200d883a 	mov	r6,r4
  80d198:	0109c83a 	sub	r4,zero,r4
  80d19c:	2188b03a 	or	r4,r4,r6
  80d1a0:	2008d7fa 	srli	r4,r4,31
  80d1a4:	00a00034 	movhi	r2,32768
  80d1a8:	10bfffc4 	addi	r2,r2,-1
  80d1ac:	1144703a 	and	r2,r2,r5
  80d1b0:	2088b03a 	or	r4,r4,r2
  80d1b4:	009ffc34 	movhi	r2,32752
  80d1b8:	1105c83a 	sub	r2,r2,r4
  80d1bc:	0087c83a 	sub	r3,zero,r2
  80d1c0:	10c4b03a 	or	r2,r2,r3
  80d1c4:	1004d7fa 	srli	r2,r2,31
  80d1c8:	00c00044 	movi	r3,1
  80d1cc:	1885c83a 	sub	r2,r3,r2
  80d1d0:	f800283a 	ret

0080d1d4 <__isnand>:
  80d1d4:	200d883a 	mov	r6,r4
  80d1d8:	0109c83a 	sub	r4,zero,r4
  80d1dc:	2188b03a 	or	r4,r4,r6
  80d1e0:	2008d7fa 	srli	r4,r4,31
  80d1e4:	00a00034 	movhi	r2,32768
  80d1e8:	10bfffc4 	addi	r2,r2,-1
  80d1ec:	1144703a 	and	r2,r2,r5
  80d1f0:	2088b03a 	or	r4,r4,r2
  80d1f4:	009ffc34 	movhi	r2,32752
  80d1f8:	1105c83a 	sub	r2,r2,r4
  80d1fc:	1004d7fa 	srli	r2,r2,31
  80d200:	f800283a 	ret

0080d204 <_sbrk_r>:
  80d204:	defffd04 	addi	sp,sp,-12
  80d208:	dc000015 	stw	r16,0(sp)
  80d20c:	040020b4 	movhi	r16,130
  80d210:	84302404 	addi	r16,r16,-16240
  80d214:	dc400115 	stw	r17,4(sp)
  80d218:	80000015 	stw	zero,0(r16)
  80d21c:	2023883a 	mov	r17,r4
  80d220:	2809883a 	mov	r4,r5
  80d224:	dfc00215 	stw	ra,8(sp)
  80d228:	0813ac40 	call	813ac4 <sbrk>
  80d22c:	1007883a 	mov	r3,r2
  80d230:	00bfffc4 	movi	r2,-1
  80d234:	18800626 	beq	r3,r2,80d250 <_sbrk_r+0x4c>
  80d238:	1805883a 	mov	r2,r3
  80d23c:	dfc00217 	ldw	ra,8(sp)
  80d240:	dc400117 	ldw	r17,4(sp)
  80d244:	dc000017 	ldw	r16,0(sp)
  80d248:	dec00304 	addi	sp,sp,12
  80d24c:	f800283a 	ret
  80d250:	80800017 	ldw	r2,0(r16)
  80d254:	103ff826 	beq	r2,zero,80d238 <_sbrk_r+0x34>
  80d258:	88800015 	stw	r2,0(r17)
  80d25c:	1805883a 	mov	r2,r3
  80d260:	dfc00217 	ldw	ra,8(sp)
  80d264:	dc400117 	ldw	r17,4(sp)
  80d268:	dc000017 	ldw	r16,0(sp)
  80d26c:	dec00304 	addi	sp,sp,12
  80d270:	f800283a 	ret

0080d274 <__sclose>:
  80d274:	2940038f 	ldh	r5,14(r5)
  80d278:	080d6301 	jmpi	80d630 <_close_r>

0080d27c <__sseek>:
  80d27c:	defffe04 	addi	sp,sp,-8
  80d280:	dc000015 	stw	r16,0(sp)
  80d284:	2821883a 	mov	r16,r5
  80d288:	2940038f 	ldh	r5,14(r5)
  80d28c:	dfc00115 	stw	ra,4(sp)
  80d290:	080d8a80 	call	80d8a8 <_lseek_r>
  80d294:	1007883a 	mov	r3,r2
  80d298:	00bfffc4 	movi	r2,-1
  80d29c:	18800926 	beq	r3,r2,80d2c4 <__sseek+0x48>
  80d2a0:	8080030b 	ldhu	r2,12(r16)
  80d2a4:	80c01415 	stw	r3,80(r16)
  80d2a8:	10840014 	ori	r2,r2,4096
  80d2ac:	8080030d 	sth	r2,12(r16)
  80d2b0:	1805883a 	mov	r2,r3
  80d2b4:	dfc00117 	ldw	ra,4(sp)
  80d2b8:	dc000017 	ldw	r16,0(sp)
  80d2bc:	dec00204 	addi	sp,sp,8
  80d2c0:	f800283a 	ret
  80d2c4:	8080030b 	ldhu	r2,12(r16)
  80d2c8:	10bbffcc 	andi	r2,r2,61439
  80d2cc:	8080030d 	sth	r2,12(r16)
  80d2d0:	1805883a 	mov	r2,r3
  80d2d4:	dfc00117 	ldw	ra,4(sp)
  80d2d8:	dc000017 	ldw	r16,0(sp)
  80d2dc:	dec00204 	addi	sp,sp,8
  80d2e0:	f800283a 	ret

0080d2e4 <__swrite>:
  80d2e4:	2880030b 	ldhu	r2,12(r5)
  80d2e8:	defffb04 	addi	sp,sp,-20
  80d2ec:	dcc00315 	stw	r19,12(sp)
  80d2f0:	1080400c 	andi	r2,r2,256
  80d2f4:	dc800215 	stw	r18,8(sp)
  80d2f8:	dc400115 	stw	r17,4(sp)
  80d2fc:	dc000015 	stw	r16,0(sp)
  80d300:	3027883a 	mov	r19,r6
  80d304:	3825883a 	mov	r18,r7
  80d308:	dfc00415 	stw	ra,16(sp)
  80d30c:	2821883a 	mov	r16,r5
  80d310:	000d883a 	mov	r6,zero
  80d314:	01c00084 	movi	r7,2
  80d318:	2023883a 	mov	r17,r4
  80d31c:	10000226 	beq	r2,zero,80d328 <__swrite+0x44>
  80d320:	2940038f 	ldh	r5,14(r5)
  80d324:	080d8a80 	call	80d8a8 <_lseek_r>
  80d328:	8080030b 	ldhu	r2,12(r16)
  80d32c:	8140038f 	ldh	r5,14(r16)
  80d330:	8809883a 	mov	r4,r17
  80d334:	10bbffcc 	andi	r2,r2,61439
  80d338:	980d883a 	mov	r6,r19
  80d33c:	900f883a 	mov	r7,r18
  80d340:	8080030d 	sth	r2,12(r16)
  80d344:	dfc00417 	ldw	ra,16(sp)
  80d348:	dcc00317 	ldw	r19,12(sp)
  80d34c:	dc800217 	ldw	r18,8(sp)
  80d350:	dc400117 	ldw	r17,4(sp)
  80d354:	dc000017 	ldw	r16,0(sp)
  80d358:	dec00504 	addi	sp,sp,20
  80d35c:	080d4f01 	jmpi	80d4f0 <_write_r>

0080d360 <__sread>:
  80d360:	defffe04 	addi	sp,sp,-8
  80d364:	dc000015 	stw	r16,0(sp)
  80d368:	2821883a 	mov	r16,r5
  80d36c:	2940038f 	ldh	r5,14(r5)
  80d370:	dfc00115 	stw	ra,4(sp)
  80d374:	080d9200 	call	80d920 <_read_r>
  80d378:	1007883a 	mov	r3,r2
  80d37c:	10000816 	blt	r2,zero,80d3a0 <__sread+0x40>
  80d380:	80801417 	ldw	r2,80(r16)
  80d384:	10c5883a 	add	r2,r2,r3
  80d388:	80801415 	stw	r2,80(r16)
  80d38c:	1805883a 	mov	r2,r3
  80d390:	dfc00117 	ldw	ra,4(sp)
  80d394:	dc000017 	ldw	r16,0(sp)
  80d398:	dec00204 	addi	sp,sp,8
  80d39c:	f800283a 	ret
  80d3a0:	8080030b 	ldhu	r2,12(r16)
  80d3a4:	10bbffcc 	andi	r2,r2,61439
  80d3a8:	8080030d 	sth	r2,12(r16)
  80d3ac:	1805883a 	mov	r2,r3
  80d3b0:	dfc00117 	ldw	ra,4(sp)
  80d3b4:	dc000017 	ldw	r16,0(sp)
  80d3b8:	dec00204 	addi	sp,sp,8
  80d3bc:	f800283a 	ret

0080d3c0 <strcmp>:
  80d3c0:	2144b03a 	or	r2,r4,r5
  80d3c4:	108000cc 	andi	r2,r2,3
  80d3c8:	10001d1e 	bne	r2,zero,80d440 <strcmp+0x80>
  80d3cc:	200f883a 	mov	r7,r4
  80d3d0:	28800017 	ldw	r2,0(r5)
  80d3d4:	21000017 	ldw	r4,0(r4)
  80d3d8:	280d883a 	mov	r6,r5
  80d3dc:	2080161e 	bne	r4,r2,80d438 <strcmp+0x78>
  80d3e0:	023fbff4 	movhi	r8,65279
  80d3e4:	423fbfc4 	addi	r8,r8,-257
  80d3e8:	2207883a 	add	r3,r4,r8
  80d3ec:	01602074 	movhi	r5,32897
  80d3f0:	29602004 	addi	r5,r5,-32640
  80d3f4:	1946703a 	and	r3,r3,r5
  80d3f8:	0104303a 	nor	r2,zero,r4
  80d3fc:	10c4703a 	and	r2,r2,r3
  80d400:	10001c1e 	bne	r2,zero,80d474 <strcmp+0xb4>
  80d404:	4013883a 	mov	r9,r8
  80d408:	2811883a 	mov	r8,r5
  80d40c:	00000106 	br	80d414 <strcmp+0x54>
  80d410:	1800181e 	bne	r3,zero,80d474 <strcmp+0xb4>
  80d414:	39c00104 	addi	r7,r7,4
  80d418:	39000017 	ldw	r4,0(r7)
  80d41c:	31800104 	addi	r6,r6,4
  80d420:	31400017 	ldw	r5,0(r6)
  80d424:	2245883a 	add	r2,r4,r9
  80d428:	1204703a 	and	r2,r2,r8
  80d42c:	0106303a 	nor	r3,zero,r4
  80d430:	1886703a 	and	r3,r3,r2
  80d434:	217ff626 	beq	r4,r5,80d410 <strcmp+0x50>
  80d438:	3809883a 	mov	r4,r7
  80d43c:	300b883a 	mov	r5,r6
  80d440:	20c00007 	ldb	r3,0(r4)
  80d444:	1800051e 	bne	r3,zero,80d45c <strcmp+0x9c>
  80d448:	00000606 	br	80d464 <strcmp+0xa4>
  80d44c:	21000044 	addi	r4,r4,1
  80d450:	20c00007 	ldb	r3,0(r4)
  80d454:	29400044 	addi	r5,r5,1
  80d458:	18000226 	beq	r3,zero,80d464 <strcmp+0xa4>
  80d45c:	28800007 	ldb	r2,0(r5)
  80d460:	18bffa26 	beq	r3,r2,80d44c <strcmp+0x8c>
  80d464:	20c00003 	ldbu	r3,0(r4)
  80d468:	28800003 	ldbu	r2,0(r5)
  80d46c:	1885c83a 	sub	r2,r3,r2
  80d470:	f800283a 	ret
  80d474:	0005883a 	mov	r2,zero
  80d478:	f800283a 	ret

0080d47c <strlen>:
  80d47c:	208000cc 	andi	r2,r4,3
  80d480:	2011883a 	mov	r8,r4
  80d484:	1000161e 	bne	r2,zero,80d4e0 <strlen+0x64>
  80d488:	20c00017 	ldw	r3,0(r4)
  80d48c:	017fbff4 	movhi	r5,65279
  80d490:	297fbfc4 	addi	r5,r5,-257
  80d494:	01e02074 	movhi	r7,32897
  80d498:	39e02004 	addi	r7,r7,-32640
  80d49c:	1945883a 	add	r2,r3,r5
  80d4a0:	11c4703a 	and	r2,r2,r7
  80d4a4:	00c6303a 	nor	r3,zero,r3
  80d4a8:	1886703a 	and	r3,r3,r2
  80d4ac:	18000c1e 	bne	r3,zero,80d4e0 <strlen+0x64>
  80d4b0:	280d883a 	mov	r6,r5
  80d4b4:	380b883a 	mov	r5,r7
  80d4b8:	21000104 	addi	r4,r4,4
  80d4bc:	20800017 	ldw	r2,0(r4)
  80d4c0:	1187883a 	add	r3,r2,r6
  80d4c4:	1946703a 	and	r3,r3,r5
  80d4c8:	0084303a 	nor	r2,zero,r2
  80d4cc:	10c4703a 	and	r2,r2,r3
  80d4d0:	103ff926 	beq	r2,zero,80d4b8 <strlen+0x3c>
  80d4d4:	20800007 	ldb	r2,0(r4)
  80d4d8:	10000326 	beq	r2,zero,80d4e8 <strlen+0x6c>
  80d4dc:	21000044 	addi	r4,r4,1
  80d4e0:	20800007 	ldb	r2,0(r4)
  80d4e4:	103ffd1e 	bne	r2,zero,80d4dc <strlen+0x60>
  80d4e8:	2205c83a 	sub	r2,r4,r8
  80d4ec:	f800283a 	ret

0080d4f0 <_write_r>:
  80d4f0:	defffd04 	addi	sp,sp,-12
  80d4f4:	dc000015 	stw	r16,0(sp)
  80d4f8:	040020b4 	movhi	r16,130
  80d4fc:	84302404 	addi	r16,r16,-16240
  80d500:	dc400115 	stw	r17,4(sp)
  80d504:	80000015 	stw	zero,0(r16)
  80d508:	2023883a 	mov	r17,r4
  80d50c:	2809883a 	mov	r4,r5
  80d510:	300b883a 	mov	r5,r6
  80d514:	380d883a 	mov	r6,r7
  80d518:	dfc00215 	stw	ra,8(sp)
  80d51c:	0813b800 	call	813b80 <write>
  80d520:	1007883a 	mov	r3,r2
  80d524:	00bfffc4 	movi	r2,-1
  80d528:	18800626 	beq	r3,r2,80d544 <_write_r+0x54>
  80d52c:	1805883a 	mov	r2,r3
  80d530:	dfc00217 	ldw	ra,8(sp)
  80d534:	dc400117 	ldw	r17,4(sp)
  80d538:	dc000017 	ldw	r16,0(sp)
  80d53c:	dec00304 	addi	sp,sp,12
  80d540:	f800283a 	ret
  80d544:	80800017 	ldw	r2,0(r16)
  80d548:	103ff826 	beq	r2,zero,80d52c <_write_r+0x3c>
  80d54c:	88800015 	stw	r2,0(r17)
  80d550:	1805883a 	mov	r2,r3
  80d554:	dfc00217 	ldw	ra,8(sp)
  80d558:	dc400117 	ldw	r17,4(sp)
  80d55c:	dc000017 	ldw	r16,0(sp)
  80d560:	dec00304 	addi	sp,sp,12
  80d564:	f800283a 	ret

0080d568 <_calloc_r>:
  80d568:	defffe04 	addi	sp,sp,-8
  80d56c:	dc400015 	stw	r17,0(sp)
  80d570:	2023883a 	mov	r17,r4
  80d574:	2809883a 	mov	r4,r5
  80d578:	300b883a 	mov	r5,r6
  80d57c:	dfc00115 	stw	ra,4(sp)
  80d580:	08064840 	call	806484 <__mulsi3>
  80d584:	100b883a 	mov	r5,r2
  80d588:	8809883a 	mov	r4,r17
  80d58c:	080b0d80 	call	80b0d8 <_malloc_r>
  80d590:	1023883a 	mov	r17,r2
  80d594:	01c00904 	movi	r7,36
  80d598:	10000d26 	beq	r2,zero,80d5d0 <_calloc_r+0x68>
  80d59c:	10ffff17 	ldw	r3,-4(r2)
  80d5a0:	1009883a 	mov	r4,r2
  80d5a4:	00bfff04 	movi	r2,-4
  80d5a8:	1886703a 	and	r3,r3,r2
  80d5ac:	1887883a 	add	r3,r3,r2
  80d5b0:	180d883a 	mov	r6,r3
  80d5b4:	000b883a 	mov	r5,zero
  80d5b8:	38c01736 	bltu	r7,r3,80d618 <_calloc_r+0xb0>
  80d5bc:	008004c4 	movi	r2,19
  80d5c0:	10c00836 	bltu	r2,r3,80d5e4 <_calloc_r+0x7c>
  80d5c4:	20000215 	stw	zero,8(r4)
  80d5c8:	20000015 	stw	zero,0(r4)
  80d5cc:	20000115 	stw	zero,4(r4)
  80d5d0:	8805883a 	mov	r2,r17
  80d5d4:	dfc00117 	ldw	ra,4(sp)
  80d5d8:	dc400017 	ldw	r17,0(sp)
  80d5dc:	dec00204 	addi	sp,sp,8
  80d5e0:	f800283a 	ret
  80d5e4:	008006c4 	movi	r2,27
  80d5e8:	88000015 	stw	zero,0(r17)
  80d5ec:	88000115 	stw	zero,4(r17)
  80d5f0:	89000204 	addi	r4,r17,8
  80d5f4:	10fff32e 	bgeu	r2,r3,80d5c4 <_calloc_r+0x5c>
  80d5f8:	88000215 	stw	zero,8(r17)
  80d5fc:	88000315 	stw	zero,12(r17)
  80d600:	89000404 	addi	r4,r17,16
  80d604:	19ffef1e 	bne	r3,r7,80d5c4 <_calloc_r+0x5c>
  80d608:	89000604 	addi	r4,r17,24
  80d60c:	88000415 	stw	zero,16(r17)
  80d610:	88000515 	stw	zero,20(r17)
  80d614:	003feb06 	br	80d5c4 <_calloc_r+0x5c>
  80d618:	080ba7c0 	call	80ba7c <memset>
  80d61c:	8805883a 	mov	r2,r17
  80d620:	dfc00117 	ldw	ra,4(sp)
  80d624:	dc400017 	ldw	r17,0(sp)
  80d628:	dec00204 	addi	sp,sp,8
  80d62c:	f800283a 	ret

0080d630 <_close_r>:
  80d630:	defffd04 	addi	sp,sp,-12
  80d634:	dc000015 	stw	r16,0(sp)
  80d638:	040020b4 	movhi	r16,130
  80d63c:	84302404 	addi	r16,r16,-16240
  80d640:	dc400115 	stw	r17,4(sp)
  80d644:	80000015 	stw	zero,0(r16)
  80d648:	2023883a 	mov	r17,r4
  80d64c:	2809883a 	mov	r4,r5
  80d650:	dfc00215 	stw	ra,8(sp)
  80d654:	0812f080 	call	812f08 <close>
  80d658:	1007883a 	mov	r3,r2
  80d65c:	00bfffc4 	movi	r2,-1
  80d660:	18800626 	beq	r3,r2,80d67c <_close_r+0x4c>
  80d664:	1805883a 	mov	r2,r3
  80d668:	dfc00217 	ldw	ra,8(sp)
  80d66c:	dc400117 	ldw	r17,4(sp)
  80d670:	dc000017 	ldw	r16,0(sp)
  80d674:	dec00304 	addi	sp,sp,12
  80d678:	f800283a 	ret
  80d67c:	80800017 	ldw	r2,0(r16)
  80d680:	103ff826 	beq	r2,zero,80d664 <_close_r+0x34>
  80d684:	88800015 	stw	r2,0(r17)
  80d688:	1805883a 	mov	r2,r3
  80d68c:	dfc00217 	ldw	ra,8(sp)
  80d690:	dc400117 	ldw	r17,4(sp)
  80d694:	dc000017 	ldw	r16,0(sp)
  80d698:	dec00304 	addi	sp,sp,12
  80d69c:	f800283a 	ret

0080d6a0 <_fclose_r>:
  80d6a0:	defffc04 	addi	sp,sp,-16
  80d6a4:	dc400115 	stw	r17,4(sp)
  80d6a8:	dc000015 	stw	r16,0(sp)
  80d6ac:	dfc00315 	stw	ra,12(sp)
  80d6b0:	dc800215 	stw	r18,8(sp)
  80d6b4:	2821883a 	mov	r16,r5
  80d6b8:	2023883a 	mov	r17,r4
  80d6bc:	28002926 	beq	r5,zero,80d764 <_fclose_r+0xc4>
  80d6c0:	080a1880 	call	80a188 <__sfp_lock_acquire>
  80d6c4:	88000226 	beq	r17,zero,80d6d0 <_fclose_r+0x30>
  80d6c8:	88800e17 	ldw	r2,56(r17)
  80d6cc:	10002d26 	beq	r2,zero,80d784 <_fclose_r+0xe4>
  80d6d0:	8080030f 	ldh	r2,12(r16)
  80d6d4:	10002226 	beq	r2,zero,80d760 <_fclose_r+0xc0>
  80d6d8:	8809883a 	mov	r4,r17
  80d6dc:	800b883a 	mov	r5,r16
  80d6e0:	0809f000 	call	809f00 <_fflush_r>
  80d6e4:	1025883a 	mov	r18,r2
  80d6e8:	80800b17 	ldw	r2,44(r16)
  80d6ec:	10000426 	beq	r2,zero,80d700 <_fclose_r+0x60>
  80d6f0:	81400717 	ldw	r5,28(r16)
  80d6f4:	8809883a 	mov	r4,r17
  80d6f8:	103ee83a 	callr	r2
  80d6fc:	10002a16 	blt	r2,zero,80d7a8 <_fclose_r+0x108>
  80d700:	8080030b 	ldhu	r2,12(r16)
  80d704:	1080200c 	andi	r2,r2,128
  80d708:	1000231e 	bne	r2,zero,80d798 <_fclose_r+0xf8>
  80d70c:	81400c17 	ldw	r5,48(r16)
  80d710:	28000526 	beq	r5,zero,80d728 <_fclose_r+0x88>
  80d714:	80801004 	addi	r2,r16,64
  80d718:	28800226 	beq	r5,r2,80d724 <_fclose_r+0x84>
  80d71c:	8809883a 	mov	r4,r17
  80d720:	080a5500 	call	80a550 <_free_r>
  80d724:	80000c15 	stw	zero,48(r16)
  80d728:	81401117 	ldw	r5,68(r16)
  80d72c:	28000326 	beq	r5,zero,80d73c <_fclose_r+0x9c>
  80d730:	8809883a 	mov	r4,r17
  80d734:	080a5500 	call	80a550 <_free_r>
  80d738:	80001115 	stw	zero,68(r16)
  80d73c:	8000030d 	sth	zero,12(r16)
  80d740:	080a18c0 	call	80a18c <__sfp_lock_release>
  80d744:	9005883a 	mov	r2,r18
  80d748:	dfc00317 	ldw	ra,12(sp)
  80d74c:	dc800217 	ldw	r18,8(sp)
  80d750:	dc400117 	ldw	r17,4(sp)
  80d754:	dc000017 	ldw	r16,0(sp)
  80d758:	dec00404 	addi	sp,sp,16
  80d75c:	f800283a 	ret
  80d760:	080a18c0 	call	80a18c <__sfp_lock_release>
  80d764:	0025883a 	mov	r18,zero
  80d768:	9005883a 	mov	r2,r18
  80d76c:	dfc00317 	ldw	ra,12(sp)
  80d770:	dc800217 	ldw	r18,8(sp)
  80d774:	dc400117 	ldw	r17,4(sp)
  80d778:	dc000017 	ldw	r16,0(sp)
  80d77c:	dec00404 	addi	sp,sp,16
  80d780:	f800283a 	ret
  80d784:	8809883a 	mov	r4,r17
  80d788:	080a1980 	call	80a198 <__sinit>
  80d78c:	8080030f 	ldh	r2,12(r16)
  80d790:	103fd11e 	bne	r2,zero,80d6d8 <_fclose_r+0x38>
  80d794:	003ff206 	br	80d760 <_fclose_r+0xc0>
  80d798:	81400417 	ldw	r5,16(r16)
  80d79c:	8809883a 	mov	r4,r17
  80d7a0:	080a5500 	call	80a550 <_free_r>
  80d7a4:	003fd906 	br	80d70c <_fclose_r+0x6c>
  80d7a8:	04bfffc4 	movi	r18,-1
  80d7ac:	003fd406 	br	80d700 <_fclose_r+0x60>

0080d7b0 <fclose>:
  80d7b0:	008020b4 	movhi	r2,130
  80d7b4:	10a93104 	addi	r2,r2,-23356
  80d7b8:	200b883a 	mov	r5,r4
  80d7bc:	11000017 	ldw	r4,0(r2)
  80d7c0:	080d6a01 	jmpi	80d6a0 <_fclose_r>

0080d7c4 <_fstat_r>:
  80d7c4:	defffd04 	addi	sp,sp,-12
  80d7c8:	dc000015 	stw	r16,0(sp)
  80d7cc:	040020b4 	movhi	r16,130
  80d7d0:	84302404 	addi	r16,r16,-16240
  80d7d4:	dc400115 	stw	r17,4(sp)
  80d7d8:	80000015 	stw	zero,0(r16)
  80d7dc:	2023883a 	mov	r17,r4
  80d7e0:	2809883a 	mov	r4,r5
  80d7e4:	300b883a 	mov	r5,r6
  80d7e8:	dfc00215 	stw	ra,8(sp)
  80d7ec:	08130940 	call	813094 <fstat>
  80d7f0:	1007883a 	mov	r3,r2
  80d7f4:	00bfffc4 	movi	r2,-1
  80d7f8:	18800626 	beq	r3,r2,80d814 <_fstat_r+0x50>
  80d7fc:	1805883a 	mov	r2,r3
  80d800:	dfc00217 	ldw	ra,8(sp)
  80d804:	dc400117 	ldw	r17,4(sp)
  80d808:	dc000017 	ldw	r16,0(sp)
  80d80c:	dec00304 	addi	sp,sp,12
  80d810:	f800283a 	ret
  80d814:	80800017 	ldw	r2,0(r16)
  80d818:	103ff826 	beq	r2,zero,80d7fc <_fstat_r+0x38>
  80d81c:	88800015 	stw	r2,0(r17)
  80d820:	1805883a 	mov	r2,r3
  80d824:	dfc00217 	ldw	ra,8(sp)
  80d828:	dc400117 	ldw	r17,4(sp)
  80d82c:	dc000017 	ldw	r16,0(sp)
  80d830:	dec00304 	addi	sp,sp,12
  80d834:	f800283a 	ret

0080d838 <_isatty_r>:
  80d838:	defffd04 	addi	sp,sp,-12
  80d83c:	dc000015 	stw	r16,0(sp)
  80d840:	040020b4 	movhi	r16,130
  80d844:	84302404 	addi	r16,r16,-16240
  80d848:	dc400115 	stw	r17,4(sp)
  80d84c:	80000015 	stw	zero,0(r16)
  80d850:	2023883a 	mov	r17,r4
  80d854:	2809883a 	mov	r4,r5
  80d858:	dfc00215 	stw	ra,8(sp)
  80d85c:	08132040 	call	813204 <isatty>
  80d860:	1007883a 	mov	r3,r2
  80d864:	00bfffc4 	movi	r2,-1
  80d868:	18800626 	beq	r3,r2,80d884 <_isatty_r+0x4c>
  80d86c:	1805883a 	mov	r2,r3
  80d870:	dfc00217 	ldw	ra,8(sp)
  80d874:	dc400117 	ldw	r17,4(sp)
  80d878:	dc000017 	ldw	r16,0(sp)
  80d87c:	dec00304 	addi	sp,sp,12
  80d880:	f800283a 	ret
  80d884:	80800017 	ldw	r2,0(r16)
  80d888:	103ff826 	beq	r2,zero,80d86c <_isatty_r+0x34>
  80d88c:	88800015 	stw	r2,0(r17)
  80d890:	1805883a 	mov	r2,r3
  80d894:	dfc00217 	ldw	ra,8(sp)
  80d898:	dc400117 	ldw	r17,4(sp)
  80d89c:	dc000017 	ldw	r16,0(sp)
  80d8a0:	dec00304 	addi	sp,sp,12
  80d8a4:	f800283a 	ret

0080d8a8 <_lseek_r>:
  80d8a8:	defffd04 	addi	sp,sp,-12
  80d8ac:	dc000015 	stw	r16,0(sp)
  80d8b0:	040020b4 	movhi	r16,130
  80d8b4:	84302404 	addi	r16,r16,-16240
  80d8b8:	dc400115 	stw	r17,4(sp)
  80d8bc:	80000015 	stw	zero,0(r16)
  80d8c0:	2023883a 	mov	r17,r4
  80d8c4:	2809883a 	mov	r4,r5
  80d8c8:	300b883a 	mov	r5,r6
  80d8cc:	380d883a 	mov	r6,r7
  80d8d0:	dfc00215 	stw	ra,8(sp)
  80d8d4:	08134140 	call	813414 <lseek>
  80d8d8:	1007883a 	mov	r3,r2
  80d8dc:	00bfffc4 	movi	r2,-1
  80d8e0:	18800626 	beq	r3,r2,80d8fc <_lseek_r+0x54>
  80d8e4:	1805883a 	mov	r2,r3
  80d8e8:	dfc00217 	ldw	ra,8(sp)
  80d8ec:	dc400117 	ldw	r17,4(sp)
  80d8f0:	dc000017 	ldw	r16,0(sp)
  80d8f4:	dec00304 	addi	sp,sp,12
  80d8f8:	f800283a 	ret
  80d8fc:	80800017 	ldw	r2,0(r16)
  80d900:	103ff826 	beq	r2,zero,80d8e4 <_lseek_r+0x3c>
  80d904:	88800015 	stw	r2,0(r17)
  80d908:	1805883a 	mov	r2,r3
  80d90c:	dfc00217 	ldw	ra,8(sp)
  80d910:	dc400117 	ldw	r17,4(sp)
  80d914:	dc000017 	ldw	r16,0(sp)
  80d918:	dec00304 	addi	sp,sp,12
  80d91c:	f800283a 	ret

0080d920 <_read_r>:
  80d920:	defffd04 	addi	sp,sp,-12
  80d924:	dc000015 	stw	r16,0(sp)
  80d928:	040020b4 	movhi	r16,130
  80d92c:	84302404 	addi	r16,r16,-16240
  80d930:	dc400115 	stw	r17,4(sp)
  80d934:	80000015 	stw	zero,0(r16)
  80d938:	2023883a 	mov	r17,r4
  80d93c:	2809883a 	mov	r4,r5
  80d940:	300b883a 	mov	r5,r6
  80d944:	380d883a 	mov	r6,r7
  80d948:	dfc00215 	stw	ra,8(sp)
  80d94c:	08138c80 	call	8138c8 <read>
  80d950:	1007883a 	mov	r3,r2
  80d954:	00bfffc4 	movi	r2,-1
  80d958:	18800626 	beq	r3,r2,80d974 <_read_r+0x54>
  80d95c:	1805883a 	mov	r2,r3
  80d960:	dfc00217 	ldw	ra,8(sp)
  80d964:	dc400117 	ldw	r17,4(sp)
  80d968:	dc000017 	ldw	r16,0(sp)
  80d96c:	dec00304 	addi	sp,sp,12
  80d970:	f800283a 	ret
  80d974:	80800017 	ldw	r2,0(r16)
  80d978:	103ff826 	beq	r2,zero,80d95c <_read_r+0x3c>
  80d97c:	88800015 	stw	r2,0(r17)
  80d980:	1805883a 	mov	r2,r3
  80d984:	dfc00217 	ldw	ra,8(sp)
  80d988:	dc400117 	ldw	r17,4(sp)
  80d98c:	dc000017 	ldw	r16,0(sp)
  80d990:	dec00304 	addi	sp,sp,12
  80d994:	f800283a 	ret

0080d998 <__udivdi3>:
  80d998:	defff104 	addi	sp,sp,-60
  80d99c:	0015883a 	mov	r10,zero
  80d9a0:	2005883a 	mov	r2,r4
  80d9a4:	3011883a 	mov	r8,r6
  80d9a8:	df000d15 	stw	fp,52(sp)
  80d9ac:	dd400a15 	stw	r21,40(sp)
  80d9b0:	dcc00815 	stw	r19,32(sp)
  80d9b4:	dfc00e15 	stw	ra,56(sp)
  80d9b8:	ddc00c15 	stw	r23,48(sp)
  80d9bc:	dd800b15 	stw	r22,44(sp)
  80d9c0:	dd000915 	stw	r20,36(sp)
  80d9c4:	dc800715 	stw	r18,28(sp)
  80d9c8:	dc400615 	stw	r17,24(sp)
  80d9cc:	dc000515 	stw	r16,20(sp)
  80d9d0:	da800315 	stw	r10,12(sp)
  80d9d4:	4027883a 	mov	r19,r8
  80d9d8:	1039883a 	mov	fp,r2
  80d9dc:	282b883a 	mov	r21,r5
  80d9e0:	da800415 	stw	r10,16(sp)
  80d9e4:	3800401e 	bne	r7,zero,80dae8 <__udivdi3+0x150>
  80d9e8:	2a006536 	bltu	r5,r8,80db80 <__udivdi3+0x1e8>
  80d9ec:	4000b526 	beq	r8,zero,80dcc4 <__udivdi3+0x32c>
  80d9f0:	00bfffd4 	movui	r2,65535
  80d9f4:	14c0ad36 	bltu	r2,r19,80dcac <__udivdi3+0x314>
  80d9f8:	00803fc4 	movi	r2,255
  80d9fc:	14c15e36 	bltu	r2,r19,80df78 <__udivdi3+0x5e0>
  80da00:	000b883a 	mov	r5,zero
  80da04:	0005883a 	mov	r2,zero
  80da08:	9884d83a 	srl	r2,r19,r2
  80da0c:	010020b4 	movhi	r4,130
  80da10:	2121d904 	addi	r4,r4,-30876
  80da14:	01800804 	movi	r6,32
  80da18:	1105883a 	add	r2,r2,r4
  80da1c:	10c00003 	ldbu	r3,0(r2)
  80da20:	28c7883a 	add	r3,r5,r3
  80da24:	30e9c83a 	sub	r20,r6,r3
  80da28:	a0010a1e 	bne	r20,zero,80de54 <__udivdi3+0x4bc>
  80da2c:	982ed43a 	srli	r23,r19,16
  80da30:	acebc83a 	sub	r21,r21,r19
  80da34:	9dbfffcc 	andi	r22,r19,65535
  80da38:	05000044 	movi	r20,1
  80da3c:	a809883a 	mov	r4,r21
  80da40:	b80b883a 	mov	r5,r23
  80da44:	08064740 	call	806474 <__udivsi3>
  80da48:	100b883a 	mov	r5,r2
  80da4c:	b009883a 	mov	r4,r22
  80da50:	1021883a 	mov	r16,r2
  80da54:	08064840 	call	806484 <__mulsi3>
  80da58:	a809883a 	mov	r4,r21
  80da5c:	b80b883a 	mov	r5,r23
  80da60:	1023883a 	mov	r17,r2
  80da64:	080647c0 	call	80647c <__umodsi3>
  80da68:	1004943a 	slli	r2,r2,16
  80da6c:	e006d43a 	srli	r3,fp,16
  80da70:	10c4b03a 	or	r2,r2,r3
  80da74:	1440042e 	bgeu	r2,r17,80da88 <__udivdi3+0xf0>
  80da78:	14c5883a 	add	r2,r2,r19
  80da7c:	843fffc4 	addi	r16,r16,-1
  80da80:	14c00136 	bltu	r2,r19,80da88 <__udivdi3+0xf0>
  80da84:	14415c36 	bltu	r2,r17,80dff8 <__udivdi3+0x660>
  80da88:	1463c83a 	sub	r17,r2,r17
  80da8c:	8809883a 	mov	r4,r17
  80da90:	b80b883a 	mov	r5,r23
  80da94:	08064740 	call	806474 <__udivsi3>
  80da98:	100b883a 	mov	r5,r2
  80da9c:	b009883a 	mov	r4,r22
  80daa0:	102b883a 	mov	r21,r2
  80daa4:	08064840 	call	806484 <__mulsi3>
  80daa8:	8809883a 	mov	r4,r17
  80daac:	b80b883a 	mov	r5,r23
  80dab0:	1025883a 	mov	r18,r2
  80dab4:	080647c0 	call	80647c <__umodsi3>
  80dab8:	1004943a 	slli	r2,r2,16
  80dabc:	e0ffffcc 	andi	r3,fp,65535
  80dac0:	10c4b03a 	or	r2,r2,r3
  80dac4:	1480042e 	bgeu	r2,r18,80dad8 <__udivdi3+0x140>
  80dac8:	9885883a 	add	r2,r19,r2
  80dacc:	ad7fffc4 	addi	r21,r21,-1
  80dad0:	14c00136 	bltu	r2,r19,80dad8 <__udivdi3+0x140>
  80dad4:	14813c36 	bltu	r2,r18,80dfc8 <__udivdi3+0x630>
  80dad8:	8004943a 	slli	r2,r16,16
  80dadc:	a009883a 	mov	r4,r20
  80dae0:	a884b03a 	or	r2,r21,r2
  80dae4:	00001506 	br	80db3c <__udivdi3+0x1a4>
  80dae8:	380d883a 	mov	r6,r7
  80daec:	29c06c36 	bltu	r5,r7,80dca0 <__udivdi3+0x308>
  80daf0:	00bfffd4 	movui	r2,65535
  80daf4:	11c06436 	bltu	r2,r7,80dc88 <__udivdi3+0x2f0>
  80daf8:	00803fc4 	movi	r2,255
  80dafc:	11c11836 	bltu	r2,r7,80df60 <__udivdi3+0x5c8>
  80db00:	000b883a 	mov	r5,zero
  80db04:	0005883a 	mov	r2,zero
  80db08:	3084d83a 	srl	r2,r6,r2
  80db0c:	010020b4 	movhi	r4,130
  80db10:	2121d904 	addi	r4,r4,-30876
  80db14:	01c00804 	movi	r7,32
  80db18:	1105883a 	add	r2,r2,r4
  80db1c:	10c00003 	ldbu	r3,0(r2)
  80db20:	28c7883a 	add	r3,r5,r3
  80db24:	38edc83a 	sub	r22,r7,r3
  80db28:	b000731e 	bne	r22,zero,80dcf8 <__udivdi3+0x360>
  80db2c:	35400136 	bltu	r6,r21,80db34 <__udivdi3+0x19c>
  80db30:	e4c05b36 	bltu	fp,r19,80dca0 <__udivdi3+0x308>
  80db34:	00800044 	movi	r2,1
  80db38:	0009883a 	mov	r4,zero
  80db3c:	d8800315 	stw	r2,12(sp)
  80db40:	d9400317 	ldw	r5,12(sp)
  80db44:	d9000415 	stw	r4,16(sp)
  80db48:	2007883a 	mov	r3,r4
  80db4c:	2805883a 	mov	r2,r5
  80db50:	dfc00e17 	ldw	ra,56(sp)
  80db54:	df000d17 	ldw	fp,52(sp)
  80db58:	ddc00c17 	ldw	r23,48(sp)
  80db5c:	dd800b17 	ldw	r22,44(sp)
  80db60:	dd400a17 	ldw	r21,40(sp)
  80db64:	dd000917 	ldw	r20,36(sp)
  80db68:	dcc00817 	ldw	r19,32(sp)
  80db6c:	dc800717 	ldw	r18,28(sp)
  80db70:	dc400617 	ldw	r17,24(sp)
  80db74:	dc000517 	ldw	r16,20(sp)
  80db78:	dec00f04 	addi	sp,sp,60
  80db7c:	f800283a 	ret
  80db80:	00bfffd4 	movui	r2,65535
  80db84:	12005636 	bltu	r2,r8,80dce0 <__udivdi3+0x348>
  80db88:	00803fc4 	movi	r2,255
  80db8c:	12010036 	bltu	r2,r8,80df90 <__udivdi3+0x5f8>
  80db90:	000b883a 	mov	r5,zero
  80db94:	0005883a 	mov	r2,zero
  80db98:	9884d83a 	srl	r2,r19,r2
  80db9c:	010020b4 	movhi	r4,130
  80dba0:	2121d904 	addi	r4,r4,-30876
  80dba4:	01800804 	movi	r6,32
  80dba8:	1105883a 	add	r2,r2,r4
  80dbac:	10c00003 	ldbu	r3,0(r2)
  80dbb0:	28c7883a 	add	r3,r5,r3
  80dbb4:	30cbc83a 	sub	r5,r6,r3
  80dbb8:	28000626 	beq	r5,zero,80dbd4 <__udivdi3+0x23c>
  80dbbc:	3145c83a 	sub	r2,r6,r5
  80dbc0:	e084d83a 	srl	r2,fp,r2
  80dbc4:	a946983a 	sll	r3,r21,r5
  80dbc8:	e178983a 	sll	fp,fp,r5
  80dbcc:	9966983a 	sll	r19,r19,r5
  80dbd0:	18aab03a 	or	r21,r3,r2
  80dbd4:	982ed43a 	srli	r23,r19,16
  80dbd8:	a809883a 	mov	r4,r21
  80dbdc:	9cbfffcc 	andi	r18,r19,65535
  80dbe0:	b80b883a 	mov	r5,r23
  80dbe4:	08064740 	call	806474 <__udivsi3>
  80dbe8:	100b883a 	mov	r5,r2
  80dbec:	9009883a 	mov	r4,r18
  80dbf0:	1021883a 	mov	r16,r2
  80dbf4:	08064840 	call	806484 <__mulsi3>
  80dbf8:	a809883a 	mov	r4,r21
  80dbfc:	b80b883a 	mov	r5,r23
  80dc00:	1023883a 	mov	r17,r2
  80dc04:	080647c0 	call	80647c <__umodsi3>
  80dc08:	1004943a 	slli	r2,r2,16
  80dc0c:	e006d43a 	srli	r3,fp,16
  80dc10:	10c4b03a 	or	r2,r2,r3
  80dc14:	1440042e 	bgeu	r2,r17,80dc28 <__udivdi3+0x290>
  80dc18:	14c5883a 	add	r2,r2,r19
  80dc1c:	843fffc4 	addi	r16,r16,-1
  80dc20:	14c00136 	bltu	r2,r19,80dc28 <__udivdi3+0x290>
  80dc24:	1440ea36 	bltu	r2,r17,80dfd0 <__udivdi3+0x638>
  80dc28:	1463c83a 	sub	r17,r2,r17
  80dc2c:	8809883a 	mov	r4,r17
  80dc30:	b80b883a 	mov	r5,r23
  80dc34:	08064740 	call	806474 <__udivsi3>
  80dc38:	100b883a 	mov	r5,r2
  80dc3c:	9009883a 	mov	r4,r18
  80dc40:	102b883a 	mov	r21,r2
  80dc44:	08064840 	call	806484 <__mulsi3>
  80dc48:	8809883a 	mov	r4,r17
  80dc4c:	b80b883a 	mov	r5,r23
  80dc50:	1025883a 	mov	r18,r2
  80dc54:	080647c0 	call	80647c <__umodsi3>
  80dc58:	1004943a 	slli	r2,r2,16
  80dc5c:	e0ffffcc 	andi	r3,fp,65535
  80dc60:	10c4b03a 	or	r2,r2,r3
  80dc64:	1480042e 	bgeu	r2,r18,80dc78 <__udivdi3+0x2e0>
  80dc68:	9885883a 	add	r2,r19,r2
  80dc6c:	ad7fffc4 	addi	r21,r21,-1
  80dc70:	14c00136 	bltu	r2,r19,80dc78 <__udivdi3+0x2e0>
  80dc74:	1480d936 	bltu	r2,r18,80dfdc <__udivdi3+0x644>
  80dc78:	8004943a 	slli	r2,r16,16
  80dc7c:	0009883a 	mov	r4,zero
  80dc80:	a884b03a 	or	r2,r21,r2
  80dc84:	003fad06 	br	80db3c <__udivdi3+0x1a4>
  80dc88:	00804034 	movhi	r2,256
  80dc8c:	10bfffc4 	addi	r2,r2,-1
  80dc90:	11c0b636 	bltu	r2,r7,80df6c <__udivdi3+0x5d4>
  80dc94:	01400404 	movi	r5,16
  80dc98:	2805883a 	mov	r2,r5
  80dc9c:	003f9a06 	br	80db08 <__udivdi3+0x170>
  80dca0:	0005883a 	mov	r2,zero
  80dca4:	0009883a 	mov	r4,zero
  80dca8:	003fa406 	br	80db3c <__udivdi3+0x1a4>
  80dcac:	00804034 	movhi	r2,256
  80dcb0:	10bfffc4 	addi	r2,r2,-1
  80dcb4:	14c0b336 	bltu	r2,r19,80df84 <__udivdi3+0x5ec>
  80dcb8:	01400404 	movi	r5,16
  80dcbc:	2805883a 	mov	r2,r5
  80dcc0:	003f5106 	br	80da08 <__udivdi3+0x70>
  80dcc4:	01000044 	movi	r4,1
  80dcc8:	000b883a 	mov	r5,zero
  80dccc:	08064740 	call	806474 <__udivsi3>
  80dcd0:	1027883a 	mov	r19,r2
  80dcd4:	00bfffd4 	movui	r2,65535
  80dcd8:	14fff436 	bltu	r2,r19,80dcac <__udivdi3+0x314>
  80dcdc:	003f4606 	br	80d9f8 <__udivdi3+0x60>
  80dce0:	00804034 	movhi	r2,256
  80dce4:	10bfffc4 	addi	r2,r2,-1
  80dce8:	1200ac36 	bltu	r2,r8,80df9c <__udivdi3+0x604>
  80dcec:	01400404 	movi	r5,16
  80dcf0:	2805883a 	mov	r2,r5
  80dcf4:	003fa806 	br	80db98 <__udivdi3+0x200>
  80dcf8:	3d85c83a 	sub	r2,r7,r22
  80dcfc:	3588983a 	sll	r4,r6,r22
  80dd00:	9886d83a 	srl	r3,r19,r2
  80dd04:	a8a2d83a 	srl	r17,r21,r2
  80dd08:	e084d83a 	srl	r2,fp,r2
  80dd0c:	20eeb03a 	or	r23,r4,r3
  80dd10:	b824d43a 	srli	r18,r23,16
  80dd14:	ad86983a 	sll	r3,r21,r22
  80dd18:	8809883a 	mov	r4,r17
  80dd1c:	900b883a 	mov	r5,r18
  80dd20:	1886b03a 	or	r3,r3,r2
  80dd24:	d8c00115 	stw	r3,4(sp)
  80dd28:	bc3fffcc 	andi	r16,r23,65535
  80dd2c:	08064740 	call	806474 <__udivsi3>
  80dd30:	100b883a 	mov	r5,r2
  80dd34:	8009883a 	mov	r4,r16
  80dd38:	1029883a 	mov	r20,r2
  80dd3c:	08064840 	call	806484 <__mulsi3>
  80dd40:	900b883a 	mov	r5,r18
  80dd44:	8809883a 	mov	r4,r17
  80dd48:	102b883a 	mov	r21,r2
  80dd4c:	080647c0 	call	80647c <__umodsi3>
  80dd50:	d9400117 	ldw	r5,4(sp)
  80dd54:	1004943a 	slli	r2,r2,16
  80dd58:	9da6983a 	sll	r19,r19,r22
  80dd5c:	2806d43a 	srli	r3,r5,16
  80dd60:	10c4b03a 	or	r2,r2,r3
  80dd64:	1540032e 	bgeu	r2,r21,80dd74 <__udivdi3+0x3dc>
  80dd68:	15c5883a 	add	r2,r2,r23
  80dd6c:	a53fffc4 	addi	r20,r20,-1
  80dd70:	15c0912e 	bgeu	r2,r23,80dfb8 <__udivdi3+0x620>
  80dd74:	1563c83a 	sub	r17,r2,r21
  80dd78:	8809883a 	mov	r4,r17
  80dd7c:	900b883a 	mov	r5,r18
  80dd80:	08064740 	call	806474 <__udivsi3>
  80dd84:	100b883a 	mov	r5,r2
  80dd88:	8009883a 	mov	r4,r16
  80dd8c:	102b883a 	mov	r21,r2
  80dd90:	08064840 	call	806484 <__mulsi3>
  80dd94:	8809883a 	mov	r4,r17
  80dd98:	900b883a 	mov	r5,r18
  80dd9c:	1021883a 	mov	r16,r2
  80dda0:	080647c0 	call	80647c <__umodsi3>
  80dda4:	da800117 	ldw	r10,4(sp)
  80dda8:	1004943a 	slli	r2,r2,16
  80ddac:	50ffffcc 	andi	r3,r10,65535
  80ddb0:	10c6b03a 	or	r3,r2,r3
  80ddb4:	1c00032e 	bgeu	r3,r16,80ddc4 <__udivdi3+0x42c>
  80ddb8:	1dc7883a 	add	r3,r3,r23
  80ddbc:	ad7fffc4 	addi	r21,r21,-1
  80ddc0:	1dc0792e 	bgeu	r3,r23,80dfa8 <__udivdi3+0x610>
  80ddc4:	a004943a 	slli	r2,r20,16
  80ddc8:	982ed43a 	srli	r23,r19,16
  80ddcc:	9cffffcc 	andi	r19,r19,65535
  80ddd0:	a8a4b03a 	or	r18,r21,r2
  80ddd4:	947fffcc 	andi	r17,r18,65535
  80ddd8:	902ad43a 	srli	r21,r18,16
  80dddc:	8809883a 	mov	r4,r17
  80dde0:	980b883a 	mov	r5,r19
  80dde4:	1c21c83a 	sub	r16,r3,r16
  80dde8:	08064840 	call	806484 <__mulsi3>
  80ddec:	8809883a 	mov	r4,r17
  80ddf0:	b80b883a 	mov	r5,r23
  80ddf4:	1029883a 	mov	r20,r2
  80ddf8:	08064840 	call	806484 <__mulsi3>
  80ddfc:	980b883a 	mov	r5,r19
  80de00:	a809883a 	mov	r4,r21
  80de04:	1023883a 	mov	r17,r2
  80de08:	08064840 	call	806484 <__mulsi3>
  80de0c:	a809883a 	mov	r4,r21
  80de10:	b80b883a 	mov	r5,r23
  80de14:	1027883a 	mov	r19,r2
  80de18:	08064840 	call	806484 <__mulsi3>
  80de1c:	1009883a 	mov	r4,r2
  80de20:	a004d43a 	srli	r2,r20,16
  80de24:	8ce3883a 	add	r17,r17,r19
  80de28:	1447883a 	add	r3,r2,r17
  80de2c:	1cc0022e 	bgeu	r3,r19,80de38 <__udivdi3+0x4a0>
  80de30:	00800074 	movhi	r2,1
  80de34:	2089883a 	add	r4,r4,r2
  80de38:	1804d43a 	srli	r2,r3,16
  80de3c:	2085883a 	add	r2,r4,r2
  80de40:	80804436 	bltu	r16,r2,80df54 <__udivdi3+0x5bc>
  80de44:	80803e26 	beq	r16,r2,80df40 <__udivdi3+0x5a8>
  80de48:	9005883a 	mov	r2,r18
  80de4c:	0009883a 	mov	r4,zero
  80de50:	003f3a06 	br	80db3c <__udivdi3+0x1a4>
  80de54:	9d26983a 	sll	r19,r19,r20
  80de58:	3505c83a 	sub	r2,r6,r20
  80de5c:	a8a2d83a 	srl	r17,r21,r2
  80de60:	982ed43a 	srli	r23,r19,16
  80de64:	e084d83a 	srl	r2,fp,r2
  80de68:	ad06983a 	sll	r3,r21,r20
  80de6c:	8809883a 	mov	r4,r17
  80de70:	b80b883a 	mov	r5,r23
  80de74:	1886b03a 	or	r3,r3,r2
  80de78:	d8c00015 	stw	r3,0(sp)
  80de7c:	9dbfffcc 	andi	r22,r19,65535
  80de80:	08064740 	call	806474 <__udivsi3>
  80de84:	100b883a 	mov	r5,r2
  80de88:	b009883a 	mov	r4,r22
  80de8c:	d8800215 	stw	r2,8(sp)
  80de90:	08064840 	call	806484 <__mulsi3>
  80de94:	8809883a 	mov	r4,r17
  80de98:	b80b883a 	mov	r5,r23
  80de9c:	102b883a 	mov	r21,r2
  80dea0:	080647c0 	call	80647c <__umodsi3>
  80dea4:	d9000017 	ldw	r4,0(sp)
  80dea8:	1004943a 	slli	r2,r2,16
  80deac:	2006d43a 	srli	r3,r4,16
  80deb0:	10c4b03a 	or	r2,r2,r3
  80deb4:	1540052e 	bgeu	r2,r21,80decc <__udivdi3+0x534>
  80deb8:	d9400217 	ldw	r5,8(sp)
  80debc:	14c5883a 	add	r2,r2,r19
  80dec0:	297fffc4 	addi	r5,r5,-1
  80dec4:	d9400215 	stw	r5,8(sp)
  80dec8:	14c0462e 	bgeu	r2,r19,80dfe4 <__udivdi3+0x64c>
  80decc:	1563c83a 	sub	r17,r2,r21
  80ded0:	8809883a 	mov	r4,r17
  80ded4:	b80b883a 	mov	r5,r23
  80ded8:	08064740 	call	806474 <__udivsi3>
  80dedc:	100b883a 	mov	r5,r2
  80dee0:	b009883a 	mov	r4,r22
  80dee4:	1025883a 	mov	r18,r2
  80dee8:	08064840 	call	806484 <__mulsi3>
  80deec:	8809883a 	mov	r4,r17
  80def0:	b80b883a 	mov	r5,r23
  80def4:	1021883a 	mov	r16,r2
  80def8:	080647c0 	call	80647c <__umodsi3>
  80defc:	da800017 	ldw	r10,0(sp)
  80df00:	1004943a 	slli	r2,r2,16
  80df04:	50ffffcc 	andi	r3,r10,65535
  80df08:	10c6b03a 	or	r3,r2,r3
  80df0c:	1c00062e 	bgeu	r3,r16,80df28 <__udivdi3+0x590>
  80df10:	1cc7883a 	add	r3,r3,r19
  80df14:	94bfffc4 	addi	r18,r18,-1
  80df18:	1cc00336 	bltu	r3,r19,80df28 <__udivdi3+0x590>
  80df1c:	1c00022e 	bgeu	r3,r16,80df28 <__udivdi3+0x590>
  80df20:	94bfffc4 	addi	r18,r18,-1
  80df24:	1cc7883a 	add	r3,r3,r19
  80df28:	d9000217 	ldw	r4,8(sp)
  80df2c:	e538983a 	sll	fp,fp,r20
  80df30:	1c2bc83a 	sub	r21,r3,r16
  80df34:	2004943a 	slli	r2,r4,16
  80df38:	90a8b03a 	or	r20,r18,r2
  80df3c:	003ebf06 	br	80da3c <__udivdi3+0xa4>
  80df40:	1804943a 	slli	r2,r3,16
  80df44:	e588983a 	sll	r4,fp,r22
  80df48:	a0ffffcc 	andi	r3,r20,65535
  80df4c:	10c5883a 	add	r2,r2,r3
  80df50:	20bfbd2e 	bgeu	r4,r2,80de48 <__udivdi3+0x4b0>
  80df54:	90bfffc4 	addi	r2,r18,-1
  80df58:	0009883a 	mov	r4,zero
  80df5c:	003ef706 	br	80db3c <__udivdi3+0x1a4>
  80df60:	01400204 	movi	r5,8
  80df64:	2805883a 	mov	r2,r5
  80df68:	003ee706 	br	80db08 <__udivdi3+0x170>
  80df6c:	01400604 	movi	r5,24
  80df70:	2805883a 	mov	r2,r5
  80df74:	003ee406 	br	80db08 <__udivdi3+0x170>
  80df78:	01400204 	movi	r5,8
  80df7c:	2805883a 	mov	r2,r5
  80df80:	003ea106 	br	80da08 <__udivdi3+0x70>
  80df84:	01400604 	movi	r5,24
  80df88:	2805883a 	mov	r2,r5
  80df8c:	003e9e06 	br	80da08 <__udivdi3+0x70>
  80df90:	01400204 	movi	r5,8
  80df94:	2805883a 	mov	r2,r5
  80df98:	003eff06 	br	80db98 <__udivdi3+0x200>
  80df9c:	01400604 	movi	r5,24
  80dfa0:	2805883a 	mov	r2,r5
  80dfa4:	003efc06 	br	80db98 <__udivdi3+0x200>
  80dfa8:	1c3f862e 	bgeu	r3,r16,80ddc4 <__udivdi3+0x42c>
  80dfac:	1dc7883a 	add	r3,r3,r23
  80dfb0:	ad7fffc4 	addi	r21,r21,-1
  80dfb4:	003f8306 	br	80ddc4 <__udivdi3+0x42c>
  80dfb8:	157f6e2e 	bgeu	r2,r21,80dd74 <__udivdi3+0x3dc>
  80dfbc:	a53fffc4 	addi	r20,r20,-1
  80dfc0:	15c5883a 	add	r2,r2,r23
  80dfc4:	003f6b06 	br	80dd74 <__udivdi3+0x3dc>
  80dfc8:	ad7fffc4 	addi	r21,r21,-1
  80dfcc:	003ec206 	br	80dad8 <__udivdi3+0x140>
  80dfd0:	843fffc4 	addi	r16,r16,-1
  80dfd4:	14c5883a 	add	r2,r2,r19
  80dfd8:	003f1306 	br	80dc28 <__udivdi3+0x290>
  80dfdc:	ad7fffc4 	addi	r21,r21,-1
  80dfe0:	003f2506 	br	80dc78 <__udivdi3+0x2e0>
  80dfe4:	157fb92e 	bgeu	r2,r21,80decc <__udivdi3+0x534>
  80dfe8:	297fffc4 	addi	r5,r5,-1
  80dfec:	14c5883a 	add	r2,r2,r19
  80dff0:	d9400215 	stw	r5,8(sp)
  80dff4:	003fb506 	br	80decc <__udivdi3+0x534>
  80dff8:	843fffc4 	addi	r16,r16,-1
  80dffc:	14c5883a 	add	r2,r2,r19
  80e000:	003ea106 	br	80da88 <__udivdi3+0xf0>

0080e004 <__umoddi3>:
  80e004:	defff004 	addi	sp,sp,-64
  80e008:	3011883a 	mov	r8,r6
  80e00c:	000d883a 	mov	r6,zero
  80e010:	dd400b15 	stw	r21,44(sp)
  80e014:	dcc00915 	stw	r19,36(sp)
  80e018:	dc000615 	stw	r16,24(sp)
  80e01c:	dfc00f15 	stw	ra,60(sp)
  80e020:	df000e15 	stw	fp,56(sp)
  80e024:	ddc00d15 	stw	r23,52(sp)
  80e028:	dd800c15 	stw	r22,48(sp)
  80e02c:	dd000a15 	stw	r20,40(sp)
  80e030:	dc800815 	stw	r18,32(sp)
  80e034:	dc400715 	stw	r17,28(sp)
  80e038:	2817883a 	mov	r11,r5
  80e03c:	d9800415 	stw	r6,16(sp)
  80e040:	4027883a 	mov	r19,r8
  80e044:	d9800515 	stw	r6,20(sp)
  80e048:	2021883a 	mov	r16,r4
  80e04c:	282b883a 	mov	r21,r5
  80e050:	38002c1e 	bne	r7,zero,80e104 <__umoddi3+0x100>
  80e054:	2a005636 	bltu	r5,r8,80e1b0 <__umoddi3+0x1ac>
  80e058:	40009a26 	beq	r8,zero,80e2c4 <__umoddi3+0x2c0>
  80e05c:	00bfffd4 	movui	r2,65535
  80e060:	14c09236 	bltu	r2,r19,80e2ac <__umoddi3+0x2a8>
  80e064:	00803fc4 	movi	r2,255
  80e068:	14c15c36 	bltu	r2,r19,80e5dc <__umoddi3+0x5d8>
  80e06c:	000b883a 	mov	r5,zero
  80e070:	0005883a 	mov	r2,zero
  80e074:	9884d83a 	srl	r2,r19,r2
  80e078:	010020b4 	movhi	r4,130
  80e07c:	2121d904 	addi	r4,r4,-30876
  80e080:	01800804 	movi	r6,32
  80e084:	1105883a 	add	r2,r2,r4
  80e088:	10c00003 	ldbu	r3,0(r2)
  80e08c:	28c7883a 	add	r3,r5,r3
  80e090:	30e5c83a 	sub	r18,r6,r3
  80e094:	9000a41e 	bne	r18,zero,80e328 <__umoddi3+0x324>
  80e098:	982ed43a 	srli	r23,r19,16
  80e09c:	acebc83a 	sub	r21,r21,r19
  80e0a0:	9d3fffcc 	andi	r20,r19,65535
  80e0a4:	002d883a 	mov	r22,zero
  80e0a8:	a809883a 	mov	r4,r21
  80e0ac:	b80b883a 	mov	r5,r23
  80e0b0:	08064740 	call	806474 <__udivsi3>
  80e0b4:	100b883a 	mov	r5,r2
  80e0b8:	a009883a 	mov	r4,r20
  80e0bc:	08064840 	call	806484 <__mulsi3>
  80e0c0:	a809883a 	mov	r4,r21
  80e0c4:	b80b883a 	mov	r5,r23
  80e0c8:	1023883a 	mov	r17,r2
  80e0cc:	080647c0 	call	80647c <__umodsi3>
  80e0d0:	1004943a 	slli	r2,r2,16
  80e0d4:	8006d43a 	srli	r3,r16,16
  80e0d8:	10c4b03a 	or	r2,r2,r3
  80e0dc:	1440032e 	bgeu	r2,r17,80e0ec <__umoddi3+0xe8>
  80e0e0:	14c5883a 	add	r2,r2,r19
  80e0e4:	14c00136 	bltu	r2,r19,80e0ec <__umoddi3+0xe8>
  80e0e8:	14415836 	bltu	r2,r17,80e64c <__umoddi3+0x648>
  80e0ec:	1463c83a 	sub	r17,r2,r17
  80e0f0:	8809883a 	mov	r4,r17
  80e0f4:	b80b883a 	mov	r5,r23
  80e0f8:	08064740 	call	806474 <__udivsi3>
  80e0fc:	a009883a 	mov	r4,r20
  80e100:	00005306 	br	80e250 <__umoddi3+0x24c>
  80e104:	380d883a 	mov	r6,r7
  80e108:	29c0132e 	bgeu	r5,r7,80e158 <__umoddi3+0x154>
  80e10c:	d9000415 	stw	r4,16(sp)
  80e110:	d9400515 	stw	r5,20(sp)
  80e114:	d9400417 	ldw	r5,16(sp)
  80e118:	5813883a 	mov	r9,r11
  80e11c:	2811883a 	mov	r8,r5
  80e120:	4005883a 	mov	r2,r8
  80e124:	4807883a 	mov	r3,r9
  80e128:	dfc00f17 	ldw	ra,60(sp)
  80e12c:	df000e17 	ldw	fp,56(sp)
  80e130:	ddc00d17 	ldw	r23,52(sp)
  80e134:	dd800c17 	ldw	r22,48(sp)
  80e138:	dd400b17 	ldw	r21,44(sp)
  80e13c:	dd000a17 	ldw	r20,40(sp)
  80e140:	dcc00917 	ldw	r19,36(sp)
  80e144:	dc800817 	ldw	r18,32(sp)
  80e148:	dc400717 	ldw	r17,28(sp)
  80e14c:	dc000617 	ldw	r16,24(sp)
  80e150:	dec01004 	addi	sp,sp,64
  80e154:	f800283a 	ret
  80e158:	00bfffd4 	movui	r2,65535
  80e15c:	11c06636 	bltu	r2,r7,80e2f8 <__umoddi3+0x2f4>
  80e160:	00803fc4 	movi	r2,255
  80e164:	11c12036 	bltu	r2,r7,80e5e8 <__umoddi3+0x5e4>
  80e168:	000b883a 	mov	r5,zero
  80e16c:	0005883a 	mov	r2,zero
  80e170:	3084d83a 	srl	r2,r6,r2
  80e174:	010020b4 	movhi	r4,130
  80e178:	2121d904 	addi	r4,r4,-30876
  80e17c:	01c00804 	movi	r7,32
  80e180:	1105883a 	add	r2,r2,r4
  80e184:	10c00003 	ldbu	r3,0(r2)
  80e188:	28c7883a 	add	r3,r5,r3
  80e18c:	38e5c83a 	sub	r18,r7,r3
  80e190:	9000941e 	bne	r18,zero,80e3e4 <__umoddi3+0x3e0>
  80e194:	35405e36 	bltu	r6,r21,80e310 <__umoddi3+0x30c>
  80e198:	84c05d2e 	bgeu	r16,r19,80e310 <__umoddi3+0x30c>
  80e19c:	8011883a 	mov	r8,r16
  80e1a0:	a813883a 	mov	r9,r21
  80e1a4:	dc000415 	stw	r16,16(sp)
  80e1a8:	dd400515 	stw	r21,20(sp)
  80e1ac:	003fdc06 	br	80e120 <__umoddi3+0x11c>
  80e1b0:	00bfffd4 	movui	r2,65535
  80e1b4:	12004a36 	bltu	r2,r8,80e2e0 <__umoddi3+0x2dc>
  80e1b8:	00803fc4 	movi	r2,255
  80e1bc:	12010d36 	bltu	r2,r8,80e5f4 <__umoddi3+0x5f0>
  80e1c0:	000b883a 	mov	r5,zero
  80e1c4:	0005883a 	mov	r2,zero
  80e1c8:	9884d83a 	srl	r2,r19,r2
  80e1cc:	010020b4 	movhi	r4,130
  80e1d0:	2121d904 	addi	r4,r4,-30876
  80e1d4:	01800804 	movi	r6,32
  80e1d8:	1105883a 	add	r2,r2,r4
  80e1dc:	10c00003 	ldbu	r3,0(r2)
  80e1e0:	28c7883a 	add	r3,r5,r3
  80e1e4:	30c7c83a 	sub	r3,r6,r3
  80e1e8:	1800dc1e 	bne	r3,zero,80e55c <__umoddi3+0x558>
  80e1ec:	002d883a 	mov	r22,zero
  80e1f0:	982ed43a 	srli	r23,r19,16
  80e1f4:	a809883a 	mov	r4,r21
  80e1f8:	9cbfffcc 	andi	r18,r19,65535
  80e1fc:	b80b883a 	mov	r5,r23
  80e200:	08064740 	call	806474 <__udivsi3>
  80e204:	100b883a 	mov	r5,r2
  80e208:	9009883a 	mov	r4,r18
  80e20c:	08064840 	call	806484 <__mulsi3>
  80e210:	a809883a 	mov	r4,r21
  80e214:	b80b883a 	mov	r5,r23
  80e218:	1023883a 	mov	r17,r2
  80e21c:	080647c0 	call	80647c <__umodsi3>
  80e220:	1004943a 	slli	r2,r2,16
  80e224:	8006d43a 	srli	r3,r16,16
  80e228:	10c4b03a 	or	r2,r2,r3
  80e22c:	1440032e 	bgeu	r2,r17,80e23c <__umoddi3+0x238>
  80e230:	14c5883a 	add	r2,r2,r19
  80e234:	14c00136 	bltu	r2,r19,80e23c <__umoddi3+0x238>
  80e238:	14410236 	bltu	r2,r17,80e644 <__umoddi3+0x640>
  80e23c:	1463c83a 	sub	r17,r2,r17
  80e240:	8809883a 	mov	r4,r17
  80e244:	b80b883a 	mov	r5,r23
  80e248:	08064740 	call	806474 <__udivsi3>
  80e24c:	9009883a 	mov	r4,r18
  80e250:	100b883a 	mov	r5,r2
  80e254:	08064840 	call	806484 <__mulsi3>
  80e258:	8809883a 	mov	r4,r17
  80e25c:	b80b883a 	mov	r5,r23
  80e260:	102b883a 	mov	r21,r2
  80e264:	080647c0 	call	80647c <__umodsi3>
  80e268:	1004943a 	slli	r2,r2,16
  80e26c:	80ffffcc 	andi	r3,r16,65535
  80e270:	10c4b03a 	or	r2,r2,r3
  80e274:	1540042e 	bgeu	r2,r21,80e288 <__umoddi3+0x284>
  80e278:	14c5883a 	add	r2,r2,r19
  80e27c:	14c00236 	bltu	r2,r19,80e288 <__umoddi3+0x284>
  80e280:	1540012e 	bgeu	r2,r21,80e288 <__umoddi3+0x284>
  80e284:	14c5883a 	add	r2,r2,r19
  80e288:	1545c83a 	sub	r2,r2,r21
  80e28c:	1584d83a 	srl	r2,r2,r22
  80e290:	0013883a 	mov	r9,zero
  80e294:	d8800415 	stw	r2,16(sp)
  80e298:	d8c00417 	ldw	r3,16(sp)
  80e29c:	0005883a 	mov	r2,zero
  80e2a0:	d8800515 	stw	r2,20(sp)
  80e2a4:	1811883a 	mov	r8,r3
  80e2a8:	003f9d06 	br	80e120 <__umoddi3+0x11c>
  80e2ac:	00804034 	movhi	r2,256
  80e2b0:	10bfffc4 	addi	r2,r2,-1
  80e2b4:	14c0c636 	bltu	r2,r19,80e5d0 <__umoddi3+0x5cc>
  80e2b8:	01400404 	movi	r5,16
  80e2bc:	2805883a 	mov	r2,r5
  80e2c0:	003f6c06 	br	80e074 <__umoddi3+0x70>
  80e2c4:	01000044 	movi	r4,1
  80e2c8:	000b883a 	mov	r5,zero
  80e2cc:	08064740 	call	806474 <__udivsi3>
  80e2d0:	1027883a 	mov	r19,r2
  80e2d4:	00bfffd4 	movui	r2,65535
  80e2d8:	14fff436 	bltu	r2,r19,80e2ac <__umoddi3+0x2a8>
  80e2dc:	003f6106 	br	80e064 <__umoddi3+0x60>
  80e2e0:	00804034 	movhi	r2,256
  80e2e4:	10bfffc4 	addi	r2,r2,-1
  80e2e8:	1200c536 	bltu	r2,r8,80e600 <__umoddi3+0x5fc>
  80e2ec:	01400404 	movi	r5,16
  80e2f0:	2805883a 	mov	r2,r5
  80e2f4:	003fb406 	br	80e1c8 <__umoddi3+0x1c4>
  80e2f8:	00804034 	movhi	r2,256
  80e2fc:	10bfffc4 	addi	r2,r2,-1
  80e300:	11c0c236 	bltu	r2,r7,80e60c <__umoddi3+0x608>
  80e304:	01400404 	movi	r5,16
  80e308:	2805883a 	mov	r2,r5
  80e30c:	003f9806 	br	80e170 <__umoddi3+0x16c>
  80e310:	84c9c83a 	sub	r4,r16,r19
  80e314:	8105803a 	cmpltu	r2,r16,r4
  80e318:	a987c83a 	sub	r3,r21,r6
  80e31c:	18abc83a 	sub	r21,r3,r2
  80e320:	2021883a 	mov	r16,r4
  80e324:	003f9d06 	br	80e19c <__umoddi3+0x198>
  80e328:	9ca6983a 	sll	r19,r19,r18
  80e32c:	3485c83a 	sub	r2,r6,r18
  80e330:	a8a2d83a 	srl	r17,r21,r2
  80e334:	982ed43a 	srli	r23,r19,16
  80e338:	ac86983a 	sll	r3,r21,r18
  80e33c:	8084d83a 	srl	r2,r16,r2
  80e340:	8809883a 	mov	r4,r17
  80e344:	b80b883a 	mov	r5,r23
  80e348:	18b8b03a 	or	fp,r3,r2
  80e34c:	9d3fffcc 	andi	r20,r19,65535
  80e350:	08064740 	call	806474 <__udivsi3>
  80e354:	100b883a 	mov	r5,r2
  80e358:	a009883a 	mov	r4,r20
  80e35c:	08064840 	call	806484 <__mulsi3>
  80e360:	8809883a 	mov	r4,r17
  80e364:	b80b883a 	mov	r5,r23
  80e368:	102b883a 	mov	r21,r2
  80e36c:	080647c0 	call	80647c <__umodsi3>
  80e370:	1004943a 	slli	r2,r2,16
  80e374:	e006d43a 	srli	r3,fp,16
  80e378:	902d883a 	mov	r22,r18
  80e37c:	10c4b03a 	or	r2,r2,r3
  80e380:	1540022e 	bgeu	r2,r21,80e38c <__umoddi3+0x388>
  80e384:	14c5883a 	add	r2,r2,r19
  80e388:	14c0ab2e 	bgeu	r2,r19,80e638 <__umoddi3+0x634>
  80e38c:	1563c83a 	sub	r17,r2,r21
  80e390:	8809883a 	mov	r4,r17
  80e394:	b80b883a 	mov	r5,r23
  80e398:	08064740 	call	806474 <__udivsi3>
  80e39c:	100b883a 	mov	r5,r2
  80e3a0:	a009883a 	mov	r4,r20
  80e3a4:	08064840 	call	806484 <__mulsi3>
  80e3a8:	8809883a 	mov	r4,r17
  80e3ac:	b80b883a 	mov	r5,r23
  80e3b0:	102b883a 	mov	r21,r2
  80e3b4:	080647c0 	call	80647c <__umodsi3>
  80e3b8:	1004943a 	slli	r2,r2,16
  80e3bc:	e0ffffcc 	andi	r3,fp,65535
  80e3c0:	10c4b03a 	or	r2,r2,r3
  80e3c4:	1540042e 	bgeu	r2,r21,80e3d8 <__umoddi3+0x3d4>
  80e3c8:	14c5883a 	add	r2,r2,r19
  80e3cc:	14c00236 	bltu	r2,r19,80e3d8 <__umoddi3+0x3d4>
  80e3d0:	1540012e 	bgeu	r2,r21,80e3d8 <__umoddi3+0x3d4>
  80e3d4:	14c5883a 	add	r2,r2,r19
  80e3d8:	84a0983a 	sll	r16,r16,r18
  80e3dc:	156bc83a 	sub	r21,r2,r21
  80e3e0:	003f3106 	br	80e0a8 <__umoddi3+0xa4>
  80e3e4:	3c8fc83a 	sub	r7,r7,r18
  80e3e8:	3486983a 	sll	r3,r6,r18
  80e3ec:	99c4d83a 	srl	r2,r19,r7
  80e3f0:	a9e2d83a 	srl	r17,r21,r7
  80e3f4:	ac8c983a 	sll	r6,r21,r18
  80e3f8:	18acb03a 	or	r22,r3,r2
  80e3fc:	b02ed43a 	srli	r23,r22,16
  80e400:	81c4d83a 	srl	r2,r16,r7
  80e404:	8809883a 	mov	r4,r17
  80e408:	b80b883a 	mov	r5,r23
  80e40c:	308cb03a 	or	r6,r6,r2
  80e410:	d9c00315 	stw	r7,12(sp)
  80e414:	d9800215 	stw	r6,8(sp)
  80e418:	b53fffcc 	andi	r20,r22,65535
  80e41c:	08064740 	call	806474 <__udivsi3>
  80e420:	100b883a 	mov	r5,r2
  80e424:	a009883a 	mov	r4,r20
  80e428:	1039883a 	mov	fp,r2
  80e42c:	08064840 	call	806484 <__mulsi3>
  80e430:	8809883a 	mov	r4,r17
  80e434:	b80b883a 	mov	r5,r23
  80e438:	102b883a 	mov	r21,r2
  80e43c:	080647c0 	call	80647c <__umodsi3>
  80e440:	d9000217 	ldw	r4,8(sp)
  80e444:	1004943a 	slli	r2,r2,16
  80e448:	9ca6983a 	sll	r19,r19,r18
  80e44c:	2006d43a 	srli	r3,r4,16
  80e450:	84a0983a 	sll	r16,r16,r18
  80e454:	dcc00015 	stw	r19,0(sp)
  80e458:	10c4b03a 	or	r2,r2,r3
  80e45c:	dc000115 	stw	r16,4(sp)
  80e460:	1540032e 	bgeu	r2,r21,80e470 <__umoddi3+0x46c>
  80e464:	1585883a 	add	r2,r2,r22
  80e468:	e73fffc4 	addi	fp,fp,-1
  80e46c:	15806e2e 	bgeu	r2,r22,80e628 <__umoddi3+0x624>
  80e470:	1563c83a 	sub	r17,r2,r21
  80e474:	8809883a 	mov	r4,r17
  80e478:	b80b883a 	mov	r5,r23
  80e47c:	08064740 	call	806474 <__udivsi3>
  80e480:	100b883a 	mov	r5,r2
  80e484:	a009883a 	mov	r4,r20
  80e488:	1021883a 	mov	r16,r2
  80e48c:	08064840 	call	806484 <__mulsi3>
  80e490:	b80b883a 	mov	r5,r23
  80e494:	8809883a 	mov	r4,r17
  80e498:	1029883a 	mov	r20,r2
  80e49c:	080647c0 	call	80647c <__umodsi3>
  80e4a0:	d9400217 	ldw	r5,8(sp)
  80e4a4:	1004943a 	slli	r2,r2,16
  80e4a8:	28ffffcc 	andi	r3,r5,65535
  80e4ac:	10c4b03a 	or	r2,r2,r3
  80e4b0:	1500032e 	bgeu	r2,r20,80e4c0 <__umoddi3+0x4bc>
  80e4b4:	1585883a 	add	r2,r2,r22
  80e4b8:	843fffc4 	addi	r16,r16,-1
  80e4bc:	1580562e 	bgeu	r2,r22,80e618 <__umoddi3+0x614>
  80e4c0:	d9800017 	ldw	r6,0(sp)
  80e4c4:	e022943a 	slli	r17,fp,16
  80e4c8:	302ed43a 	srli	r23,r6,16
  80e4cc:	8462b03a 	or	r17,r16,r17
  80e4d0:	34ffffcc 	andi	r19,r6,65535
  80e4d4:	882ad43a 	srli	r21,r17,16
  80e4d8:	8c7fffcc 	andi	r17,r17,65535
  80e4dc:	8809883a 	mov	r4,r17
  80e4e0:	980b883a 	mov	r5,r19
  80e4e4:	1521c83a 	sub	r16,r2,r20
  80e4e8:	08064840 	call	806484 <__mulsi3>
  80e4ec:	8809883a 	mov	r4,r17
  80e4f0:	b80b883a 	mov	r5,r23
  80e4f4:	1029883a 	mov	r20,r2
  80e4f8:	08064840 	call	806484 <__mulsi3>
  80e4fc:	980b883a 	mov	r5,r19
  80e500:	a809883a 	mov	r4,r21
  80e504:	1023883a 	mov	r17,r2
  80e508:	08064840 	call	806484 <__mulsi3>
  80e50c:	a809883a 	mov	r4,r21
  80e510:	b80b883a 	mov	r5,r23
  80e514:	1027883a 	mov	r19,r2
  80e518:	08064840 	call	806484 <__mulsi3>
  80e51c:	100b883a 	mov	r5,r2
  80e520:	a004d43a 	srli	r2,r20,16
  80e524:	8ce3883a 	add	r17,r17,r19
  80e528:	1449883a 	add	r4,r2,r17
  80e52c:	24c0022e 	bgeu	r4,r19,80e538 <__umoddi3+0x534>
  80e530:	00800074 	movhi	r2,1
  80e534:	288b883a 	add	r5,r5,r2
  80e538:	2004d43a 	srli	r2,r4,16
  80e53c:	2008943a 	slli	r4,r4,16
  80e540:	a0ffffcc 	andi	r3,r20,65535
  80e544:	288d883a 	add	r6,r5,r2
  80e548:	20c9883a 	add	r4,r4,r3
  80e54c:	81800b36 	bltu	r16,r6,80e57c <__umoddi3+0x578>
  80e550:	81804026 	beq	r16,r6,80e654 <__umoddi3+0x650>
  80e554:	818dc83a 	sub	r6,r16,r6
  80e558:	00000f06 	br	80e598 <__umoddi3+0x594>
  80e55c:	30c5c83a 	sub	r2,r6,r3
  80e560:	182d883a 	mov	r22,r3
  80e564:	8084d83a 	srl	r2,r16,r2
  80e568:	a8c6983a 	sll	r3,r21,r3
  80e56c:	9da6983a 	sll	r19,r19,r22
  80e570:	85a0983a 	sll	r16,r16,r22
  80e574:	18aab03a 	or	r21,r3,r2
  80e578:	003f1d06 	br	80e1f0 <__umoddi3+0x1ec>
  80e57c:	d8c00017 	ldw	r3,0(sp)
  80e580:	20c5c83a 	sub	r2,r4,r3
  80e584:	2089803a 	cmpltu	r4,r4,r2
  80e588:	3587c83a 	sub	r3,r6,r22
  80e58c:	1907c83a 	sub	r3,r3,r4
  80e590:	80cdc83a 	sub	r6,r16,r3
  80e594:	1009883a 	mov	r4,r2
  80e598:	d9400117 	ldw	r5,4(sp)
  80e59c:	2905c83a 	sub	r2,r5,r4
  80e5a0:	2887803a 	cmpltu	r3,r5,r2
  80e5a4:	30c7c83a 	sub	r3,r6,r3
  80e5a8:	d9800317 	ldw	r6,12(sp)
  80e5ac:	1484d83a 	srl	r2,r2,r18
  80e5b0:	1988983a 	sll	r4,r3,r6
  80e5b4:	1c86d83a 	srl	r3,r3,r18
  80e5b8:	2088b03a 	or	r4,r4,r2
  80e5bc:	2011883a 	mov	r8,r4
  80e5c0:	1813883a 	mov	r9,r3
  80e5c4:	d9000415 	stw	r4,16(sp)
  80e5c8:	d8c00515 	stw	r3,20(sp)
  80e5cc:	003ed406 	br	80e120 <__umoddi3+0x11c>
  80e5d0:	01400604 	movi	r5,24
  80e5d4:	2805883a 	mov	r2,r5
  80e5d8:	003ea606 	br	80e074 <__umoddi3+0x70>
  80e5dc:	01400204 	movi	r5,8
  80e5e0:	2805883a 	mov	r2,r5
  80e5e4:	003ea306 	br	80e074 <__umoddi3+0x70>
  80e5e8:	01400204 	movi	r5,8
  80e5ec:	2805883a 	mov	r2,r5
  80e5f0:	003edf06 	br	80e170 <__umoddi3+0x16c>
  80e5f4:	01400204 	movi	r5,8
  80e5f8:	2805883a 	mov	r2,r5
  80e5fc:	003ef206 	br	80e1c8 <__umoddi3+0x1c4>
  80e600:	01400604 	movi	r5,24
  80e604:	2805883a 	mov	r2,r5
  80e608:	003eef06 	br	80e1c8 <__umoddi3+0x1c4>
  80e60c:	01400604 	movi	r5,24
  80e610:	2805883a 	mov	r2,r5
  80e614:	003ed606 	br	80e170 <__umoddi3+0x16c>
  80e618:	153fa92e 	bgeu	r2,r20,80e4c0 <__umoddi3+0x4bc>
  80e61c:	843fffc4 	addi	r16,r16,-1
  80e620:	1585883a 	add	r2,r2,r22
  80e624:	003fa606 	br	80e4c0 <__umoddi3+0x4bc>
  80e628:	157f912e 	bgeu	r2,r21,80e470 <__umoddi3+0x46c>
  80e62c:	e73fffc4 	addi	fp,fp,-1
  80e630:	1585883a 	add	r2,r2,r22
  80e634:	003f8e06 	br	80e470 <__umoddi3+0x46c>
  80e638:	157f542e 	bgeu	r2,r21,80e38c <__umoddi3+0x388>
  80e63c:	14c5883a 	add	r2,r2,r19
  80e640:	003f5206 	br	80e38c <__umoddi3+0x388>
  80e644:	14c5883a 	add	r2,r2,r19
  80e648:	003efc06 	br	80e23c <__umoddi3+0x238>
  80e64c:	14c5883a 	add	r2,r2,r19
  80e650:	003ea606 	br	80e0ec <__umoddi3+0xe8>
  80e654:	d8800117 	ldw	r2,4(sp)
  80e658:	113fc836 	bltu	r2,r4,80e57c <__umoddi3+0x578>
  80e65c:	000d883a 	mov	r6,zero
  80e660:	003fcd06 	br	80e598 <__umoddi3+0x594>

0080e664 <_fpadd_parts>:
  80e664:	defff804 	addi	sp,sp,-32
  80e668:	dcc00315 	stw	r19,12(sp)
  80e66c:	2027883a 	mov	r19,r4
  80e670:	21000017 	ldw	r4,0(r4)
  80e674:	00c00044 	movi	r3,1
  80e678:	dd400515 	stw	r21,20(sp)
  80e67c:	dd000415 	stw	r20,16(sp)
  80e680:	ddc00715 	stw	r23,28(sp)
  80e684:	dd800615 	stw	r22,24(sp)
  80e688:	dc800215 	stw	r18,8(sp)
  80e68c:	dc400115 	stw	r17,4(sp)
  80e690:	dc000015 	stw	r16,0(sp)
  80e694:	282b883a 	mov	r21,r5
  80e698:	3029883a 	mov	r20,r6
  80e69c:	1900632e 	bgeu	r3,r4,80e82c <_fpadd_parts+0x1c8>
  80e6a0:	28800017 	ldw	r2,0(r5)
  80e6a4:	1880812e 	bgeu	r3,r2,80e8ac <_fpadd_parts+0x248>
  80e6a8:	00c00104 	movi	r3,4
  80e6ac:	20c0dc26 	beq	r4,r3,80ea20 <_fpadd_parts+0x3bc>
  80e6b0:	10c07e26 	beq	r2,r3,80e8ac <_fpadd_parts+0x248>
  80e6b4:	00c00084 	movi	r3,2
  80e6b8:	10c06726 	beq	r2,r3,80e858 <_fpadd_parts+0x1f4>
  80e6bc:	20c07b26 	beq	r4,r3,80e8ac <_fpadd_parts+0x248>
  80e6c0:	9dc00217 	ldw	r23,8(r19)
  80e6c4:	28c00217 	ldw	r3,8(r5)
  80e6c8:	9c400317 	ldw	r17,12(r19)
  80e6cc:	2bc00317 	ldw	r15,12(r5)
  80e6d0:	b8cdc83a 	sub	r6,r23,r3
  80e6d4:	9c800417 	ldw	r18,16(r19)
  80e6d8:	2c000417 	ldw	r16,16(r5)
  80e6dc:	3009883a 	mov	r4,r6
  80e6e0:	30009716 	blt	r6,zero,80e940 <_fpadd_parts+0x2dc>
  80e6e4:	00800fc4 	movi	r2,63
  80e6e8:	11806b16 	blt	r2,r6,80e898 <_fpadd_parts+0x234>
  80e6ec:	0100a40e 	bge	zero,r4,80e980 <_fpadd_parts+0x31c>
  80e6f0:	35bff804 	addi	r22,r6,-32
  80e6f4:	b000bc16 	blt	r22,zero,80e9e8 <_fpadd_parts+0x384>
  80e6f8:	8596d83a 	srl	r11,r16,r22
  80e6fc:	0019883a 	mov	r12,zero
  80e700:	0013883a 	mov	r9,zero
  80e704:	01000044 	movi	r4,1
  80e708:	0015883a 	mov	r10,zero
  80e70c:	b000be16 	blt	r22,zero,80ea08 <_fpadd_parts+0x3a4>
  80e710:	2590983a 	sll	r8,r4,r22
  80e714:	000f883a 	mov	r7,zero
  80e718:	00bfffc4 	movi	r2,-1
  80e71c:	3889883a 	add	r4,r7,r2
  80e720:	408b883a 	add	r5,r8,r2
  80e724:	21cd803a 	cmpltu	r6,r4,r7
  80e728:	314b883a 	add	r5,r6,r5
  80e72c:	7904703a 	and	r2,r15,r4
  80e730:	8146703a 	and	r3,r16,r5
  80e734:	10c4b03a 	or	r2,r2,r3
  80e738:	10000226 	beq	r2,zero,80e744 <_fpadd_parts+0xe0>
  80e73c:	02400044 	movi	r9,1
  80e740:	0015883a 	mov	r10,zero
  80e744:	5a5eb03a 	or	r15,r11,r9
  80e748:	62a0b03a 	or	r16,r12,r10
  80e74c:	99400117 	ldw	r5,4(r19)
  80e750:	a8800117 	ldw	r2,4(r21)
  80e754:	28806e26 	beq	r5,r2,80e910 <_fpadd_parts+0x2ac>
  80e758:	28006626 	beq	r5,zero,80e8f4 <_fpadd_parts+0x290>
  80e75c:	7c45c83a 	sub	r2,r15,r17
  80e760:	7889803a 	cmpltu	r4,r15,r2
  80e764:	8487c83a 	sub	r3,r16,r18
  80e768:	1909c83a 	sub	r4,r3,r4
  80e76c:	100d883a 	mov	r6,r2
  80e770:	200f883a 	mov	r7,r4
  80e774:	38007716 	blt	r7,zero,80e954 <_fpadd_parts+0x2f0>
  80e778:	a5c00215 	stw	r23,8(r20)
  80e77c:	a1c00415 	stw	r7,16(r20)
  80e780:	a0000115 	stw	zero,4(r20)
  80e784:	a1800315 	stw	r6,12(r20)
  80e788:	a2000317 	ldw	r8,12(r20)
  80e78c:	a2400417 	ldw	r9,16(r20)
  80e790:	00bfffc4 	movi	r2,-1
  80e794:	408b883a 	add	r5,r8,r2
  80e798:	2a09803a 	cmpltu	r4,r5,r8
  80e79c:	488d883a 	add	r6,r9,r2
  80e7a0:	01c40034 	movhi	r7,4096
  80e7a4:	39ffffc4 	addi	r7,r7,-1
  80e7a8:	218d883a 	add	r6,r4,r6
  80e7ac:	39801736 	bltu	r7,r6,80e80c <_fpadd_parts+0x1a8>
  80e7b0:	31c06526 	beq	r6,r7,80e948 <_fpadd_parts+0x2e4>
  80e7b4:	a3000217 	ldw	r12,8(r20)
  80e7b8:	4209883a 	add	r4,r8,r8
  80e7bc:	00bfffc4 	movi	r2,-1
  80e7c0:	220f803a 	cmpltu	r7,r4,r8
  80e7c4:	4a4b883a 	add	r5,r9,r9
  80e7c8:	394f883a 	add	r7,r7,r5
  80e7cc:	2095883a 	add	r10,r4,r2
  80e7d0:	3897883a 	add	r11,r7,r2
  80e7d4:	510d803a 	cmpltu	r6,r10,r4
  80e7d8:	6099883a 	add	r12,r12,r2
  80e7dc:	32d7883a 	add	r11,r6,r11
  80e7e0:	00840034 	movhi	r2,4096
  80e7e4:	10bfffc4 	addi	r2,r2,-1
  80e7e8:	2011883a 	mov	r8,r4
  80e7ec:	3813883a 	mov	r9,r7
  80e7f0:	a1000315 	stw	r4,12(r20)
  80e7f4:	a1c00415 	stw	r7,16(r20)
  80e7f8:	a3000215 	stw	r12,8(r20)
  80e7fc:	12c00336 	bltu	r2,r11,80e80c <_fpadd_parts+0x1a8>
  80e800:	58bfed1e 	bne	r11,r2,80e7b8 <_fpadd_parts+0x154>
  80e804:	00bfff84 	movi	r2,-2
  80e808:	12bfeb2e 	bgeu	r2,r10,80e7b8 <_fpadd_parts+0x154>
  80e80c:	a2800417 	ldw	r10,16(r20)
  80e810:	008000c4 	movi	r2,3
  80e814:	00c80034 	movhi	r3,8192
  80e818:	18ffffc4 	addi	r3,r3,-1
  80e81c:	a2400317 	ldw	r9,12(r20)
  80e820:	a0800015 	stw	r2,0(r20)
  80e824:	1a802336 	bltu	r3,r10,80e8b4 <_fpadd_parts+0x250>
  80e828:	a027883a 	mov	r19,r20
  80e82c:	9805883a 	mov	r2,r19
  80e830:	ddc00717 	ldw	r23,28(sp)
  80e834:	dd800617 	ldw	r22,24(sp)
  80e838:	dd400517 	ldw	r21,20(sp)
  80e83c:	dd000417 	ldw	r20,16(sp)
  80e840:	dcc00317 	ldw	r19,12(sp)
  80e844:	dc800217 	ldw	r18,8(sp)
  80e848:	dc400117 	ldw	r17,4(sp)
  80e84c:	dc000017 	ldw	r16,0(sp)
  80e850:	dec00804 	addi	sp,sp,32
  80e854:	f800283a 	ret
  80e858:	20fff41e 	bne	r4,r3,80e82c <_fpadd_parts+0x1c8>
  80e85c:	31000015 	stw	r4,0(r6)
  80e860:	98800117 	ldw	r2,4(r19)
  80e864:	30800115 	stw	r2,4(r6)
  80e868:	98c00217 	ldw	r3,8(r19)
  80e86c:	30c00215 	stw	r3,8(r6)
  80e870:	98800317 	ldw	r2,12(r19)
  80e874:	30800315 	stw	r2,12(r6)
  80e878:	98c00417 	ldw	r3,16(r19)
  80e87c:	30c00415 	stw	r3,16(r6)
  80e880:	98800117 	ldw	r2,4(r19)
  80e884:	28c00117 	ldw	r3,4(r5)
  80e888:	3027883a 	mov	r19,r6
  80e88c:	10c4703a 	and	r2,r2,r3
  80e890:	30800115 	stw	r2,4(r6)
  80e894:	003fe506 	br	80e82c <_fpadd_parts+0x1c8>
  80e898:	1dc02616 	blt	r3,r23,80e934 <_fpadd_parts+0x2d0>
  80e89c:	0023883a 	mov	r17,zero
  80e8a0:	182f883a 	mov	r23,r3
  80e8a4:	0025883a 	mov	r18,zero
  80e8a8:	003fa806 	br	80e74c <_fpadd_parts+0xe8>
  80e8ac:	a827883a 	mov	r19,r21
  80e8b0:	003fde06 	br	80e82c <_fpadd_parts+0x1c8>
  80e8b4:	01800044 	movi	r6,1
  80e8b8:	500497fa 	slli	r2,r10,31
  80e8bc:	4808d07a 	srli	r4,r9,1
  80e8c0:	518ad83a 	srl	r5,r10,r6
  80e8c4:	a2000217 	ldw	r8,8(r20)
  80e8c8:	1108b03a 	or	r4,r2,r4
  80e8cc:	0007883a 	mov	r3,zero
  80e8d0:	4984703a 	and	r2,r9,r6
  80e8d4:	208cb03a 	or	r6,r4,r2
  80e8d8:	28ceb03a 	or	r7,r5,r3
  80e8dc:	42000044 	addi	r8,r8,1
  80e8e0:	a027883a 	mov	r19,r20
  80e8e4:	a1c00415 	stw	r7,16(r20)
  80e8e8:	a2000215 	stw	r8,8(r20)
  80e8ec:	a1800315 	stw	r6,12(r20)
  80e8f0:	003fce06 	br	80e82c <_fpadd_parts+0x1c8>
  80e8f4:	8bc5c83a 	sub	r2,r17,r15
  80e8f8:	8889803a 	cmpltu	r4,r17,r2
  80e8fc:	9407c83a 	sub	r3,r18,r16
  80e900:	1909c83a 	sub	r4,r3,r4
  80e904:	100d883a 	mov	r6,r2
  80e908:	200f883a 	mov	r7,r4
  80e90c:	003f9906 	br	80e774 <_fpadd_parts+0x110>
  80e910:	7c45883a 	add	r2,r15,r17
  80e914:	13c9803a 	cmpltu	r4,r2,r15
  80e918:	8487883a 	add	r3,r16,r18
  80e91c:	20c9883a 	add	r4,r4,r3
  80e920:	a1400115 	stw	r5,4(r20)
  80e924:	a5c00215 	stw	r23,8(r20)
  80e928:	a0800315 	stw	r2,12(r20)
  80e92c:	a1000415 	stw	r4,16(r20)
  80e930:	003fb606 	br	80e80c <_fpadd_parts+0x1a8>
  80e934:	001f883a 	mov	r15,zero
  80e938:	0021883a 	mov	r16,zero
  80e93c:	003f8306 	br	80e74c <_fpadd_parts+0xe8>
  80e940:	018dc83a 	sub	r6,zero,r6
  80e944:	003f6706 	br	80e6e4 <_fpadd_parts+0x80>
  80e948:	00bfff84 	movi	r2,-2
  80e94c:	117faf36 	bltu	r2,r5,80e80c <_fpadd_parts+0x1a8>
  80e950:	003f9806 	br	80e7b4 <_fpadd_parts+0x150>
  80e954:	0005883a 	mov	r2,zero
  80e958:	1189c83a 	sub	r4,r2,r6
  80e95c:	1105803a 	cmpltu	r2,r2,r4
  80e960:	01cbc83a 	sub	r5,zero,r7
  80e964:	2885c83a 	sub	r2,r5,r2
  80e968:	01800044 	movi	r6,1
  80e96c:	a1800115 	stw	r6,4(r20)
  80e970:	a5c00215 	stw	r23,8(r20)
  80e974:	a1000315 	stw	r4,12(r20)
  80e978:	a0800415 	stw	r2,16(r20)
  80e97c:	003f8206 	br	80e788 <_fpadd_parts+0x124>
  80e980:	203f7226 	beq	r4,zero,80e74c <_fpadd_parts+0xe8>
  80e984:	35bff804 	addi	r22,r6,-32
  80e988:	b9af883a 	add	r23,r23,r6
  80e98c:	b0003116 	blt	r22,zero,80ea54 <_fpadd_parts+0x3f0>
  80e990:	959ad83a 	srl	r13,r18,r22
  80e994:	001d883a 	mov	r14,zero
  80e998:	000f883a 	mov	r7,zero
  80e99c:	01000044 	movi	r4,1
  80e9a0:	0011883a 	mov	r8,zero
  80e9a4:	b0002516 	blt	r22,zero,80ea3c <_fpadd_parts+0x3d8>
  80e9a8:	2594983a 	sll	r10,r4,r22
  80e9ac:	0013883a 	mov	r9,zero
  80e9b0:	00bfffc4 	movi	r2,-1
  80e9b4:	4889883a 	add	r4,r9,r2
  80e9b8:	508b883a 	add	r5,r10,r2
  80e9bc:	224d803a 	cmpltu	r6,r4,r9
  80e9c0:	314b883a 	add	r5,r6,r5
  80e9c4:	8904703a 	and	r2,r17,r4
  80e9c8:	9146703a 	and	r3,r18,r5
  80e9cc:	10c4b03a 	or	r2,r2,r3
  80e9d0:	10000226 	beq	r2,zero,80e9dc <_fpadd_parts+0x378>
  80e9d4:	01c00044 	movi	r7,1
  80e9d8:	0011883a 	mov	r8,zero
  80e9dc:	69e2b03a 	or	r17,r13,r7
  80e9e0:	7224b03a 	or	r18,r14,r8
  80e9e4:	003f5906 	br	80e74c <_fpadd_parts+0xe8>
  80e9e8:	8407883a 	add	r3,r16,r16
  80e9ec:	008007c4 	movi	r2,31
  80e9f0:	1185c83a 	sub	r2,r2,r6
  80e9f4:	1886983a 	sll	r3,r3,r2
  80e9f8:	7996d83a 	srl	r11,r15,r6
  80e9fc:	8198d83a 	srl	r12,r16,r6
  80ea00:	1ad6b03a 	or	r11,r3,r11
  80ea04:	003f3e06 	br	80e700 <_fpadd_parts+0x9c>
  80ea08:	2006d07a 	srli	r3,r4,1
  80ea0c:	008007c4 	movi	r2,31
  80ea10:	1185c83a 	sub	r2,r2,r6
  80ea14:	1890d83a 	srl	r8,r3,r2
  80ea18:	218e983a 	sll	r7,r4,r6
  80ea1c:	003f3e06 	br	80e718 <_fpadd_parts+0xb4>
  80ea20:	113f821e 	bne	r2,r4,80e82c <_fpadd_parts+0x1c8>
  80ea24:	28c00117 	ldw	r3,4(r5)
  80ea28:	98800117 	ldw	r2,4(r19)
  80ea2c:	10ff7f26 	beq	r2,r3,80e82c <_fpadd_parts+0x1c8>
  80ea30:	04c020b4 	movhi	r19,130
  80ea34:	9ce1d404 	addi	r19,r19,-30896
  80ea38:	003f7c06 	br	80e82c <_fpadd_parts+0x1c8>
  80ea3c:	2006d07a 	srli	r3,r4,1
  80ea40:	008007c4 	movi	r2,31
  80ea44:	1185c83a 	sub	r2,r2,r6
  80ea48:	1894d83a 	srl	r10,r3,r2
  80ea4c:	2192983a 	sll	r9,r4,r6
  80ea50:	003fd706 	br	80e9b0 <_fpadd_parts+0x34c>
  80ea54:	9487883a 	add	r3,r18,r18
  80ea58:	008007c4 	movi	r2,31
  80ea5c:	1185c83a 	sub	r2,r2,r6
  80ea60:	1886983a 	sll	r3,r3,r2
  80ea64:	899ad83a 	srl	r13,r17,r6
  80ea68:	919cd83a 	srl	r14,r18,r6
  80ea6c:	1b5ab03a 	or	r13,r3,r13
  80ea70:	003fc906 	br	80e998 <_fpadd_parts+0x334>

0080ea74 <__subdf3>:
  80ea74:	deffea04 	addi	sp,sp,-88
  80ea78:	dcc01415 	stw	r19,80(sp)
  80ea7c:	dcc00404 	addi	r19,sp,16
  80ea80:	2011883a 	mov	r8,r4
  80ea84:	2813883a 	mov	r9,r5
  80ea88:	dc401315 	stw	r17,76(sp)
  80ea8c:	d809883a 	mov	r4,sp
  80ea90:	980b883a 	mov	r5,r19
  80ea94:	dc400904 	addi	r17,sp,36
  80ea98:	dfc01515 	stw	ra,84(sp)
  80ea9c:	da400115 	stw	r9,4(sp)
  80eaa0:	d9c00315 	stw	r7,12(sp)
  80eaa4:	da000015 	stw	r8,0(sp)
  80eaa8:	d9800215 	stw	r6,8(sp)
  80eaac:	080fc480 	call	80fc48 <__unpack_d>
  80eab0:	d9000204 	addi	r4,sp,8
  80eab4:	880b883a 	mov	r5,r17
  80eab8:	080fc480 	call	80fc48 <__unpack_d>
  80eabc:	d8800a17 	ldw	r2,40(sp)
  80eac0:	880b883a 	mov	r5,r17
  80eac4:	9809883a 	mov	r4,r19
  80eac8:	d9800e04 	addi	r6,sp,56
  80eacc:	1080005c 	xori	r2,r2,1
  80ead0:	d8800a15 	stw	r2,40(sp)
  80ead4:	080e6640 	call	80e664 <_fpadd_parts>
  80ead8:	1009883a 	mov	r4,r2
  80eadc:	080f9340 	call	80f934 <__pack_d>
  80eae0:	dfc01517 	ldw	ra,84(sp)
  80eae4:	dcc01417 	ldw	r19,80(sp)
  80eae8:	dc401317 	ldw	r17,76(sp)
  80eaec:	dec01604 	addi	sp,sp,88
  80eaf0:	f800283a 	ret

0080eaf4 <__adddf3>:
  80eaf4:	deffea04 	addi	sp,sp,-88
  80eaf8:	dcc01415 	stw	r19,80(sp)
  80eafc:	dcc00404 	addi	r19,sp,16
  80eb00:	2011883a 	mov	r8,r4
  80eb04:	2813883a 	mov	r9,r5
  80eb08:	dc401315 	stw	r17,76(sp)
  80eb0c:	d809883a 	mov	r4,sp
  80eb10:	980b883a 	mov	r5,r19
  80eb14:	dc400904 	addi	r17,sp,36
  80eb18:	dfc01515 	stw	ra,84(sp)
  80eb1c:	da400115 	stw	r9,4(sp)
  80eb20:	d9c00315 	stw	r7,12(sp)
  80eb24:	da000015 	stw	r8,0(sp)
  80eb28:	d9800215 	stw	r6,8(sp)
  80eb2c:	080fc480 	call	80fc48 <__unpack_d>
  80eb30:	d9000204 	addi	r4,sp,8
  80eb34:	880b883a 	mov	r5,r17
  80eb38:	080fc480 	call	80fc48 <__unpack_d>
  80eb3c:	d9800e04 	addi	r6,sp,56
  80eb40:	9809883a 	mov	r4,r19
  80eb44:	880b883a 	mov	r5,r17
  80eb48:	080e6640 	call	80e664 <_fpadd_parts>
  80eb4c:	1009883a 	mov	r4,r2
  80eb50:	080f9340 	call	80f934 <__pack_d>
  80eb54:	dfc01517 	ldw	ra,84(sp)
  80eb58:	dcc01417 	ldw	r19,80(sp)
  80eb5c:	dc401317 	ldw	r17,76(sp)
  80eb60:	dec01604 	addi	sp,sp,88
  80eb64:	f800283a 	ret

0080eb68 <__muldf3>:
  80eb68:	deffe004 	addi	sp,sp,-128
  80eb6c:	dc401815 	stw	r17,96(sp)
  80eb70:	dc400404 	addi	r17,sp,16
  80eb74:	2011883a 	mov	r8,r4
  80eb78:	2813883a 	mov	r9,r5
  80eb7c:	dc001715 	stw	r16,92(sp)
  80eb80:	d809883a 	mov	r4,sp
  80eb84:	880b883a 	mov	r5,r17
  80eb88:	dc000904 	addi	r16,sp,36
  80eb8c:	dfc01f15 	stw	ra,124(sp)
  80eb90:	da400115 	stw	r9,4(sp)
  80eb94:	d9c00315 	stw	r7,12(sp)
  80eb98:	da000015 	stw	r8,0(sp)
  80eb9c:	d9800215 	stw	r6,8(sp)
  80eba0:	ddc01e15 	stw	r23,120(sp)
  80eba4:	dd801d15 	stw	r22,116(sp)
  80eba8:	dd401c15 	stw	r21,112(sp)
  80ebac:	dd001b15 	stw	r20,108(sp)
  80ebb0:	dcc01a15 	stw	r19,104(sp)
  80ebb4:	dc801915 	stw	r18,100(sp)
  80ebb8:	080fc480 	call	80fc48 <__unpack_d>
  80ebbc:	d9000204 	addi	r4,sp,8
  80ebc0:	800b883a 	mov	r5,r16
  80ebc4:	080fc480 	call	80fc48 <__unpack_d>
  80ebc8:	d9000417 	ldw	r4,16(sp)
  80ebcc:	00800044 	movi	r2,1
  80ebd0:	1100102e 	bgeu	r2,r4,80ec14 <__muldf3+0xac>
  80ebd4:	d8c00917 	ldw	r3,36(sp)
  80ebd8:	10c0062e 	bgeu	r2,r3,80ebf4 <__muldf3+0x8c>
  80ebdc:	00800104 	movi	r2,4
  80ebe0:	20800a26 	beq	r4,r2,80ec0c <__muldf3+0xa4>
  80ebe4:	1880cc26 	beq	r3,r2,80ef18 <__muldf3+0x3b0>
  80ebe8:	00800084 	movi	r2,2
  80ebec:	20800926 	beq	r4,r2,80ec14 <__muldf3+0xac>
  80ebf0:	1880191e 	bne	r3,r2,80ec58 <__muldf3+0xf0>
  80ebf4:	d8c00a17 	ldw	r3,40(sp)
  80ebf8:	d8800517 	ldw	r2,20(sp)
  80ebfc:	8009883a 	mov	r4,r16
  80ec00:	10c4c03a 	cmpne	r2,r2,r3
  80ec04:	d8800a15 	stw	r2,40(sp)
  80ec08:	00000706 	br	80ec28 <__muldf3+0xc0>
  80ec0c:	00800084 	movi	r2,2
  80ec10:	1880c326 	beq	r3,r2,80ef20 <__muldf3+0x3b8>
  80ec14:	d8800517 	ldw	r2,20(sp)
  80ec18:	d8c00a17 	ldw	r3,40(sp)
  80ec1c:	8809883a 	mov	r4,r17
  80ec20:	10c4c03a 	cmpne	r2,r2,r3
  80ec24:	d8800515 	stw	r2,20(sp)
  80ec28:	080f9340 	call	80f934 <__pack_d>
  80ec2c:	dfc01f17 	ldw	ra,124(sp)
  80ec30:	ddc01e17 	ldw	r23,120(sp)
  80ec34:	dd801d17 	ldw	r22,116(sp)
  80ec38:	dd401c17 	ldw	r21,112(sp)
  80ec3c:	dd001b17 	ldw	r20,108(sp)
  80ec40:	dcc01a17 	ldw	r19,104(sp)
  80ec44:	dc801917 	ldw	r18,100(sp)
  80ec48:	dc401817 	ldw	r17,96(sp)
  80ec4c:	dc001717 	ldw	r16,92(sp)
  80ec50:	dec02004 	addi	sp,sp,128
  80ec54:	f800283a 	ret
  80ec58:	dd800717 	ldw	r22,28(sp)
  80ec5c:	dc800c17 	ldw	r18,48(sp)
  80ec60:	002b883a 	mov	r21,zero
  80ec64:	0023883a 	mov	r17,zero
  80ec68:	a80b883a 	mov	r5,r21
  80ec6c:	b00d883a 	mov	r6,r22
  80ec70:	880f883a 	mov	r7,r17
  80ec74:	ddc00817 	ldw	r23,32(sp)
  80ec78:	dcc00d17 	ldw	r19,52(sp)
  80ec7c:	9009883a 	mov	r4,r18
  80ec80:	080f7900 	call	80f790 <__muldi3>
  80ec84:	001b883a 	mov	r13,zero
  80ec88:	680f883a 	mov	r7,r13
  80ec8c:	b009883a 	mov	r4,r22
  80ec90:	000b883a 	mov	r5,zero
  80ec94:	980d883a 	mov	r6,r19
  80ec98:	b82d883a 	mov	r22,r23
  80ec9c:	002f883a 	mov	r23,zero
  80eca0:	db401615 	stw	r13,88(sp)
  80eca4:	d8801315 	stw	r2,76(sp)
  80eca8:	d8c01415 	stw	r3,80(sp)
  80ecac:	dcc01515 	stw	r19,84(sp)
  80ecb0:	080f7900 	call	80f790 <__muldi3>
  80ecb4:	b00d883a 	mov	r6,r22
  80ecb8:	000b883a 	mov	r5,zero
  80ecbc:	9009883a 	mov	r4,r18
  80ecc0:	b80f883a 	mov	r7,r23
  80ecc4:	1021883a 	mov	r16,r2
  80ecc8:	1823883a 	mov	r17,r3
  80eccc:	080f7900 	call	80f790 <__muldi3>
  80ecd0:	8085883a 	add	r2,r16,r2
  80ecd4:	140d803a 	cmpltu	r6,r2,r16
  80ecd8:	88c7883a 	add	r3,r17,r3
  80ecdc:	30cd883a 	add	r6,r6,r3
  80ece0:	1029883a 	mov	r20,r2
  80ece4:	302b883a 	mov	r21,r6
  80ece8:	da801317 	ldw	r10,76(sp)
  80ecec:	dac01417 	ldw	r11,80(sp)
  80ecf0:	db001517 	ldw	r12,84(sp)
  80ecf4:	db401617 	ldw	r13,88(sp)
  80ecf8:	3440612e 	bgeu	r6,r17,80ee80 <__muldf3+0x318>
  80ecfc:	0009883a 	mov	r4,zero
  80ed00:	5105883a 	add	r2,r10,r4
  80ed04:	128d803a 	cmpltu	r6,r2,r10
  80ed08:	5d07883a 	add	r3,r11,r20
  80ed0c:	30cd883a 	add	r6,r6,r3
  80ed10:	0021883a 	mov	r16,zero
  80ed14:	04400044 	movi	r17,1
  80ed18:	1025883a 	mov	r18,r2
  80ed1c:	3027883a 	mov	r19,r6
  80ed20:	32c06236 	bltu	r6,r11,80eeac <__muldf3+0x344>
  80ed24:	59807a26 	beq	r11,r6,80ef10 <__muldf3+0x3a8>
  80ed28:	680b883a 	mov	r5,r13
  80ed2c:	b80f883a 	mov	r7,r23
  80ed30:	6009883a 	mov	r4,r12
  80ed34:	b00d883a 	mov	r6,r22
  80ed38:	080f7900 	call	80f790 <__muldi3>
  80ed3c:	1009883a 	mov	r4,r2
  80ed40:	000f883a 	mov	r7,zero
  80ed44:	1545883a 	add	r2,r2,r21
  80ed48:	1111803a 	cmpltu	r8,r2,r4
  80ed4c:	19c7883a 	add	r3,r3,r7
  80ed50:	40c7883a 	add	r3,r8,r3
  80ed54:	88cb883a 	add	r5,r17,r3
  80ed58:	d8c00617 	ldw	r3,24(sp)
  80ed5c:	8089883a 	add	r4,r16,r2
  80ed60:	d8800b17 	ldw	r2,44(sp)
  80ed64:	18c00104 	addi	r3,r3,4
  80ed68:	240d803a 	cmpltu	r6,r4,r16
  80ed6c:	10c7883a 	add	r3,r2,r3
  80ed70:	2013883a 	mov	r9,r4
  80ed74:	d8800a17 	ldw	r2,40(sp)
  80ed78:	d9000517 	ldw	r4,20(sp)
  80ed7c:	314d883a 	add	r6,r6,r5
  80ed80:	3015883a 	mov	r10,r6
  80ed84:	2088c03a 	cmpne	r4,r4,r2
  80ed88:	00880034 	movhi	r2,8192
  80ed8c:	10bfffc4 	addi	r2,r2,-1
  80ed90:	d9000f15 	stw	r4,60(sp)
  80ed94:	d8c01015 	stw	r3,64(sp)
  80ed98:	1180162e 	bgeu	r2,r6,80edf4 <__muldf3+0x28c>
  80ed9c:	1811883a 	mov	r8,r3
  80eda0:	101f883a 	mov	r15,r2
  80eda4:	980497fa 	slli	r2,r19,31
  80eda8:	9016d07a 	srli	r11,r18,1
  80edac:	500697fa 	slli	r3,r10,31
  80edb0:	480cd07a 	srli	r6,r9,1
  80edb4:	500ed07a 	srli	r7,r10,1
  80edb8:	12d6b03a 	or	r11,r2,r11
  80edbc:	00800044 	movi	r2,1
  80edc0:	198cb03a 	or	r6,r3,r6
  80edc4:	4888703a 	and	r4,r9,r2
  80edc8:	9818d07a 	srli	r12,r19,1
  80edcc:	001b883a 	mov	r13,zero
  80edd0:	03a00034 	movhi	r14,32768
  80edd4:	3013883a 	mov	r9,r6
  80edd8:	3815883a 	mov	r10,r7
  80eddc:	4091883a 	add	r8,r8,r2
  80ede0:	20000226 	beq	r4,zero,80edec <__muldf3+0x284>
  80ede4:	5b64b03a 	or	r18,r11,r13
  80ede8:	63a6b03a 	or	r19,r12,r14
  80edec:	7abfed36 	bltu	r15,r10,80eda4 <__muldf3+0x23c>
  80edf0:	da001015 	stw	r8,64(sp)
  80edf4:	00840034 	movhi	r2,4096
  80edf8:	10bfffc4 	addi	r2,r2,-1
  80edfc:	12801436 	bltu	r2,r10,80ee50 <__muldf3+0x2e8>
  80ee00:	da001017 	ldw	r8,64(sp)
  80ee04:	101f883a 	mov	r15,r2
  80ee08:	4a45883a 	add	r2,r9,r9
  80ee0c:	124d803a 	cmpltu	r6,r2,r9
  80ee10:	5287883a 	add	r3,r10,r10
  80ee14:	9497883a 	add	r11,r18,r18
  80ee18:	5c8f803a 	cmpltu	r7,r11,r18
  80ee1c:	9cd9883a 	add	r12,r19,r19
  80ee20:	01000044 	movi	r4,1
  80ee24:	30cd883a 	add	r6,r6,r3
  80ee28:	3b0f883a 	add	r7,r7,r12
  80ee2c:	423fffc4 	addi	r8,r8,-1
  80ee30:	1013883a 	mov	r9,r2
  80ee34:	3015883a 	mov	r10,r6
  80ee38:	111ab03a 	or	r13,r2,r4
  80ee3c:	98003016 	blt	r19,zero,80ef00 <__muldf3+0x398>
  80ee40:	5825883a 	mov	r18,r11
  80ee44:	3827883a 	mov	r19,r7
  80ee48:	7abfef2e 	bgeu	r15,r10,80ee08 <__muldf3+0x2a0>
  80ee4c:	da001015 	stw	r8,64(sp)
  80ee50:	00803fc4 	movi	r2,255
  80ee54:	488e703a 	and	r7,r9,r2
  80ee58:	00802004 	movi	r2,128
  80ee5c:	0007883a 	mov	r3,zero
  80ee60:	0011883a 	mov	r8,zero
  80ee64:	38801826 	beq	r7,r2,80eec8 <__muldf3+0x360>
  80ee68:	008000c4 	movi	r2,3
  80ee6c:	d9000e04 	addi	r4,sp,56
  80ee70:	da801215 	stw	r10,72(sp)
  80ee74:	d8800e15 	stw	r2,56(sp)
  80ee78:	da401115 	stw	r9,68(sp)
  80ee7c:	003f6a06 	br	80ec28 <__muldf3+0xc0>
  80ee80:	89802126 	beq	r17,r6,80ef08 <__muldf3+0x3a0>
  80ee84:	0009883a 	mov	r4,zero
  80ee88:	5105883a 	add	r2,r10,r4
  80ee8c:	128d803a 	cmpltu	r6,r2,r10
  80ee90:	5d07883a 	add	r3,r11,r20
  80ee94:	30cd883a 	add	r6,r6,r3
  80ee98:	0021883a 	mov	r16,zero
  80ee9c:	0023883a 	mov	r17,zero
  80eea0:	1025883a 	mov	r18,r2
  80eea4:	3027883a 	mov	r19,r6
  80eea8:	32ff9e2e 	bgeu	r6,r11,80ed24 <__muldf3+0x1bc>
  80eeac:	00800044 	movi	r2,1
  80eeb0:	8089883a 	add	r4,r16,r2
  80eeb4:	240d803a 	cmpltu	r6,r4,r16
  80eeb8:	344d883a 	add	r6,r6,r17
  80eebc:	2021883a 	mov	r16,r4
  80eec0:	3023883a 	mov	r17,r6
  80eec4:	003f9806 	br	80ed28 <__muldf3+0x1c0>
  80eec8:	403fe71e 	bne	r8,zero,80ee68 <__muldf3+0x300>
  80eecc:	01004004 	movi	r4,256
  80eed0:	4904703a 	and	r2,r9,r4
  80eed4:	10c4b03a 	or	r2,r2,r3
  80eed8:	103fe31e 	bne	r2,zero,80ee68 <__muldf3+0x300>
  80eedc:	94c4b03a 	or	r2,r18,r19
  80eee0:	103fe126 	beq	r2,zero,80ee68 <__muldf3+0x300>
  80eee4:	49c5883a 	add	r2,r9,r7
  80eee8:	1251803a 	cmpltu	r8,r2,r9
  80eeec:	4291883a 	add	r8,r8,r10
  80eef0:	013fc004 	movi	r4,-256
  80eef4:	1112703a 	and	r9,r2,r4
  80eef8:	4015883a 	mov	r10,r8
  80eefc:	003fda06 	br	80ee68 <__muldf3+0x300>
  80ef00:	6813883a 	mov	r9,r13
  80ef04:	003fce06 	br	80ee40 <__muldf3+0x2d8>
  80ef08:	143f7c36 	bltu	r2,r16,80ecfc <__muldf3+0x194>
  80ef0c:	003fdd06 	br	80ee84 <__muldf3+0x31c>
  80ef10:	12bf852e 	bgeu	r2,r10,80ed28 <__muldf3+0x1c0>
  80ef14:	003fe506 	br	80eeac <__muldf3+0x344>
  80ef18:	00800084 	movi	r2,2
  80ef1c:	20bf351e 	bne	r4,r2,80ebf4 <__muldf3+0x8c>
  80ef20:	010020b4 	movhi	r4,130
  80ef24:	2121d404 	addi	r4,r4,-30896
  80ef28:	003f3f06 	br	80ec28 <__muldf3+0xc0>

0080ef2c <__divdf3>:
  80ef2c:	deffed04 	addi	sp,sp,-76
  80ef30:	dcc01115 	stw	r19,68(sp)
  80ef34:	dcc00404 	addi	r19,sp,16
  80ef38:	2011883a 	mov	r8,r4
  80ef3c:	2813883a 	mov	r9,r5
  80ef40:	dc000e15 	stw	r16,56(sp)
  80ef44:	d809883a 	mov	r4,sp
  80ef48:	980b883a 	mov	r5,r19
  80ef4c:	dc000904 	addi	r16,sp,36
  80ef50:	dfc01215 	stw	ra,72(sp)
  80ef54:	da400115 	stw	r9,4(sp)
  80ef58:	d9c00315 	stw	r7,12(sp)
  80ef5c:	da000015 	stw	r8,0(sp)
  80ef60:	d9800215 	stw	r6,8(sp)
  80ef64:	dc801015 	stw	r18,64(sp)
  80ef68:	dc400f15 	stw	r17,60(sp)
  80ef6c:	080fc480 	call	80fc48 <__unpack_d>
  80ef70:	d9000204 	addi	r4,sp,8
  80ef74:	800b883a 	mov	r5,r16
  80ef78:	080fc480 	call	80fc48 <__unpack_d>
  80ef7c:	d9000417 	ldw	r4,16(sp)
  80ef80:	00800044 	movi	r2,1
  80ef84:	11000b2e 	bgeu	r2,r4,80efb4 <__divdf3+0x88>
  80ef88:	d9400917 	ldw	r5,36(sp)
  80ef8c:	1140762e 	bgeu	r2,r5,80f168 <__divdf3+0x23c>
  80ef90:	d8800517 	ldw	r2,20(sp)
  80ef94:	d8c00a17 	ldw	r3,40(sp)
  80ef98:	01800104 	movi	r6,4
  80ef9c:	10c4f03a 	xor	r2,r2,r3
  80efa0:	d8800515 	stw	r2,20(sp)
  80efa4:	21800226 	beq	r4,r6,80efb0 <__divdf3+0x84>
  80efa8:	00800084 	movi	r2,2
  80efac:	2080141e 	bne	r4,r2,80f000 <__divdf3+0xd4>
  80efb0:	29000926 	beq	r5,r4,80efd8 <__divdf3+0xac>
  80efb4:	9809883a 	mov	r4,r19
  80efb8:	080f9340 	call	80f934 <__pack_d>
  80efbc:	dfc01217 	ldw	ra,72(sp)
  80efc0:	dcc01117 	ldw	r19,68(sp)
  80efc4:	dc801017 	ldw	r18,64(sp)
  80efc8:	dc400f17 	ldw	r17,60(sp)
  80efcc:	dc000e17 	ldw	r16,56(sp)
  80efd0:	dec01304 	addi	sp,sp,76
  80efd4:	f800283a 	ret
  80efd8:	010020b4 	movhi	r4,130
  80efdc:	2121d404 	addi	r4,r4,-30896
  80efe0:	080f9340 	call	80f934 <__pack_d>
  80efe4:	dfc01217 	ldw	ra,72(sp)
  80efe8:	dcc01117 	ldw	r19,68(sp)
  80efec:	dc801017 	ldw	r18,64(sp)
  80eff0:	dc400f17 	ldw	r17,60(sp)
  80eff4:	dc000e17 	ldw	r16,56(sp)
  80eff8:	dec01304 	addi	sp,sp,76
  80effc:	f800283a 	ret
  80f000:	29805b26 	beq	r5,r6,80f170 <__divdf3+0x244>
  80f004:	28802d26 	beq	r5,r2,80f0bc <__divdf3+0x190>
  80f008:	d8c00617 	ldw	r3,24(sp)
  80f00c:	d8800b17 	ldw	r2,44(sp)
  80f010:	d9c00817 	ldw	r7,32(sp)
  80f014:	dc400d17 	ldw	r17,52(sp)
  80f018:	188bc83a 	sub	r5,r3,r2
  80f01c:	d9800717 	ldw	r6,28(sp)
  80f020:	dc000c17 	ldw	r16,48(sp)
  80f024:	d9400615 	stw	r5,24(sp)
  80f028:	3c403836 	bltu	r7,r17,80f10c <__divdf3+0x1e0>
  80f02c:	89c03626 	beq	r17,r7,80f108 <__divdf3+0x1dc>
  80f030:	0015883a 	mov	r10,zero
  80f034:	001d883a 	mov	r14,zero
  80f038:	02c40034 	movhi	r11,4096
  80f03c:	001f883a 	mov	r15,zero
  80f040:	003f883a 	mov	ra,zero
  80f044:	04800f44 	movi	r18,61
  80f048:	00000f06 	br	80f088 <__divdf3+0x15c>
  80f04c:	601d883a 	mov	r14,r12
  80f050:	681f883a 	mov	r15,r13
  80f054:	400d883a 	mov	r6,r8
  80f058:	100f883a 	mov	r7,r2
  80f05c:	3191883a 	add	r8,r6,r6
  80f060:	5808d07a 	srli	r4,r11,1
  80f064:	4185803a 	cmpltu	r2,r8,r6
  80f068:	39d3883a 	add	r9,r7,r7
  80f06c:	28c6b03a 	or	r3,r5,r3
  80f070:	1245883a 	add	r2,r2,r9
  80f074:	1815883a 	mov	r10,r3
  80f078:	2017883a 	mov	r11,r4
  80f07c:	400d883a 	mov	r6,r8
  80f080:	100f883a 	mov	r7,r2
  80f084:	fc801726 	beq	ra,r18,80f0e4 <__divdf3+0x1b8>
  80f088:	580a97fa 	slli	r5,r11,31
  80f08c:	5006d07a 	srli	r3,r10,1
  80f090:	ffc00044 	addi	ra,ra,1
  80f094:	3c7ff136 	bltu	r7,r17,80f05c <__divdf3+0x130>
  80f098:	3411c83a 	sub	r8,r6,r16
  80f09c:	3205803a 	cmpltu	r2,r6,r8
  80f0a0:	3c53c83a 	sub	r9,r7,r17
  80f0a4:	7298b03a 	or	r12,r14,r10
  80f0a8:	7adab03a 	or	r13,r15,r11
  80f0ac:	4885c83a 	sub	r2,r9,r2
  80f0b0:	89ffe61e 	bne	r17,r7,80f04c <__divdf3+0x120>
  80f0b4:	343fe936 	bltu	r6,r16,80f05c <__divdf3+0x130>
  80f0b8:	003fe406 	br	80f04c <__divdf3+0x120>
  80f0bc:	9809883a 	mov	r4,r19
  80f0c0:	d9800415 	stw	r6,16(sp)
  80f0c4:	080f9340 	call	80f934 <__pack_d>
  80f0c8:	dfc01217 	ldw	ra,72(sp)
  80f0cc:	dcc01117 	ldw	r19,68(sp)
  80f0d0:	dc801017 	ldw	r18,64(sp)
  80f0d4:	dc400f17 	ldw	r17,60(sp)
  80f0d8:	dc000e17 	ldw	r16,56(sp)
  80f0dc:	dec01304 	addi	sp,sp,76
  80f0e0:	f800283a 	ret
  80f0e4:	00803fc4 	movi	r2,255
  80f0e8:	7090703a 	and	r8,r14,r2
  80f0ec:	00802004 	movi	r2,128
  80f0f0:	0007883a 	mov	r3,zero
  80f0f4:	0013883a 	mov	r9,zero
  80f0f8:	40800d26 	beq	r8,r2,80f130 <__divdf3+0x204>
  80f0fc:	dbc00815 	stw	r15,32(sp)
  80f100:	db800715 	stw	r14,28(sp)
  80f104:	003fab06 	br	80efb4 <__divdf3+0x88>
  80f108:	343fc92e 	bgeu	r6,r16,80f030 <__divdf3+0x104>
  80f10c:	3185883a 	add	r2,r6,r6
  80f110:	1189803a 	cmpltu	r4,r2,r6
  80f114:	39c7883a 	add	r3,r7,r7
  80f118:	20c9883a 	add	r4,r4,r3
  80f11c:	297fffc4 	addi	r5,r5,-1
  80f120:	100d883a 	mov	r6,r2
  80f124:	200f883a 	mov	r7,r4
  80f128:	d9400615 	stw	r5,24(sp)
  80f12c:	003fc006 	br	80f030 <__divdf3+0x104>
  80f130:	483ff21e 	bne	r9,zero,80f0fc <__divdf3+0x1d0>
  80f134:	01004004 	movi	r4,256
  80f138:	7104703a 	and	r2,r14,r4
  80f13c:	10c4b03a 	or	r2,r2,r3
  80f140:	103fee1e 	bne	r2,zero,80f0fc <__divdf3+0x1d0>
  80f144:	31c4b03a 	or	r2,r6,r7
  80f148:	103fec26 	beq	r2,zero,80f0fc <__divdf3+0x1d0>
  80f14c:	7205883a 	add	r2,r14,r8
  80f150:	1391803a 	cmpltu	r8,r2,r14
  80f154:	43d1883a 	add	r8,r8,r15
  80f158:	013fc004 	movi	r4,-256
  80f15c:	111c703a 	and	r14,r2,r4
  80f160:	401f883a 	mov	r15,r8
  80f164:	003fe506 	br	80f0fc <__divdf3+0x1d0>
  80f168:	8009883a 	mov	r4,r16
  80f16c:	003f9206 	br	80efb8 <__divdf3+0x8c>
  80f170:	9809883a 	mov	r4,r19
  80f174:	d8000715 	stw	zero,28(sp)
  80f178:	d8000815 	stw	zero,32(sp)
  80f17c:	d8000615 	stw	zero,24(sp)
  80f180:	003f8d06 	br	80efb8 <__divdf3+0x8c>

0080f184 <__eqdf2>:
  80f184:	deffef04 	addi	sp,sp,-68
  80f188:	dc400f15 	stw	r17,60(sp)
  80f18c:	dc400404 	addi	r17,sp,16
  80f190:	2005883a 	mov	r2,r4
  80f194:	2807883a 	mov	r3,r5
  80f198:	dc000e15 	stw	r16,56(sp)
  80f19c:	d809883a 	mov	r4,sp
  80f1a0:	880b883a 	mov	r5,r17
  80f1a4:	dc000904 	addi	r16,sp,36
  80f1a8:	d8c00115 	stw	r3,4(sp)
  80f1ac:	d8800015 	stw	r2,0(sp)
  80f1b0:	d9800215 	stw	r6,8(sp)
  80f1b4:	dfc01015 	stw	ra,64(sp)
  80f1b8:	d9c00315 	stw	r7,12(sp)
  80f1bc:	080fc480 	call	80fc48 <__unpack_d>
  80f1c0:	d9000204 	addi	r4,sp,8
  80f1c4:	800b883a 	mov	r5,r16
  80f1c8:	080fc480 	call	80fc48 <__unpack_d>
  80f1cc:	d8800417 	ldw	r2,16(sp)
  80f1d0:	00c00044 	movi	r3,1
  80f1d4:	180d883a 	mov	r6,r3
  80f1d8:	1880062e 	bgeu	r3,r2,80f1f4 <__eqdf2+0x70>
  80f1dc:	d8800917 	ldw	r2,36(sp)
  80f1e0:	8809883a 	mov	r4,r17
  80f1e4:	800b883a 	mov	r5,r16
  80f1e8:	1880022e 	bgeu	r3,r2,80f1f4 <__eqdf2+0x70>
  80f1ec:	080fd800 	call	80fd80 <__fpcmp_parts_d>
  80f1f0:	100d883a 	mov	r6,r2
  80f1f4:	3005883a 	mov	r2,r6
  80f1f8:	dfc01017 	ldw	ra,64(sp)
  80f1fc:	dc400f17 	ldw	r17,60(sp)
  80f200:	dc000e17 	ldw	r16,56(sp)
  80f204:	dec01104 	addi	sp,sp,68
  80f208:	f800283a 	ret

0080f20c <__nedf2>:
  80f20c:	deffef04 	addi	sp,sp,-68
  80f210:	dc400f15 	stw	r17,60(sp)
  80f214:	dc400404 	addi	r17,sp,16
  80f218:	2005883a 	mov	r2,r4
  80f21c:	2807883a 	mov	r3,r5
  80f220:	dc000e15 	stw	r16,56(sp)
  80f224:	d809883a 	mov	r4,sp
  80f228:	880b883a 	mov	r5,r17
  80f22c:	dc000904 	addi	r16,sp,36
  80f230:	d8c00115 	stw	r3,4(sp)
  80f234:	d8800015 	stw	r2,0(sp)
  80f238:	d9800215 	stw	r6,8(sp)
  80f23c:	dfc01015 	stw	ra,64(sp)
  80f240:	d9c00315 	stw	r7,12(sp)
  80f244:	080fc480 	call	80fc48 <__unpack_d>
  80f248:	d9000204 	addi	r4,sp,8
  80f24c:	800b883a 	mov	r5,r16
  80f250:	080fc480 	call	80fc48 <__unpack_d>
  80f254:	d8800417 	ldw	r2,16(sp)
  80f258:	00c00044 	movi	r3,1
  80f25c:	180d883a 	mov	r6,r3
  80f260:	1880062e 	bgeu	r3,r2,80f27c <__nedf2+0x70>
  80f264:	d8800917 	ldw	r2,36(sp)
  80f268:	8809883a 	mov	r4,r17
  80f26c:	800b883a 	mov	r5,r16
  80f270:	1880022e 	bgeu	r3,r2,80f27c <__nedf2+0x70>
  80f274:	080fd800 	call	80fd80 <__fpcmp_parts_d>
  80f278:	100d883a 	mov	r6,r2
  80f27c:	3005883a 	mov	r2,r6
  80f280:	dfc01017 	ldw	ra,64(sp)
  80f284:	dc400f17 	ldw	r17,60(sp)
  80f288:	dc000e17 	ldw	r16,56(sp)
  80f28c:	dec01104 	addi	sp,sp,68
  80f290:	f800283a 	ret

0080f294 <__gtdf2>:
  80f294:	deffef04 	addi	sp,sp,-68
  80f298:	dc400f15 	stw	r17,60(sp)
  80f29c:	dc400404 	addi	r17,sp,16
  80f2a0:	2005883a 	mov	r2,r4
  80f2a4:	2807883a 	mov	r3,r5
  80f2a8:	dc000e15 	stw	r16,56(sp)
  80f2ac:	d809883a 	mov	r4,sp
  80f2b0:	880b883a 	mov	r5,r17
  80f2b4:	dc000904 	addi	r16,sp,36
  80f2b8:	d8c00115 	stw	r3,4(sp)
  80f2bc:	d8800015 	stw	r2,0(sp)
  80f2c0:	d9800215 	stw	r6,8(sp)
  80f2c4:	dfc01015 	stw	ra,64(sp)
  80f2c8:	d9c00315 	stw	r7,12(sp)
  80f2cc:	080fc480 	call	80fc48 <__unpack_d>
  80f2d0:	d9000204 	addi	r4,sp,8
  80f2d4:	800b883a 	mov	r5,r16
  80f2d8:	080fc480 	call	80fc48 <__unpack_d>
  80f2dc:	d8800417 	ldw	r2,16(sp)
  80f2e0:	00c00044 	movi	r3,1
  80f2e4:	01bfffc4 	movi	r6,-1
  80f2e8:	1880062e 	bgeu	r3,r2,80f304 <__gtdf2+0x70>
  80f2ec:	d8800917 	ldw	r2,36(sp)
  80f2f0:	8809883a 	mov	r4,r17
  80f2f4:	800b883a 	mov	r5,r16
  80f2f8:	1880022e 	bgeu	r3,r2,80f304 <__gtdf2+0x70>
  80f2fc:	080fd800 	call	80fd80 <__fpcmp_parts_d>
  80f300:	100d883a 	mov	r6,r2
  80f304:	3005883a 	mov	r2,r6
  80f308:	dfc01017 	ldw	ra,64(sp)
  80f30c:	dc400f17 	ldw	r17,60(sp)
  80f310:	dc000e17 	ldw	r16,56(sp)
  80f314:	dec01104 	addi	sp,sp,68
  80f318:	f800283a 	ret

0080f31c <__gedf2>:
  80f31c:	deffef04 	addi	sp,sp,-68
  80f320:	dc400f15 	stw	r17,60(sp)
  80f324:	dc400404 	addi	r17,sp,16
  80f328:	2005883a 	mov	r2,r4
  80f32c:	2807883a 	mov	r3,r5
  80f330:	dc000e15 	stw	r16,56(sp)
  80f334:	d809883a 	mov	r4,sp
  80f338:	880b883a 	mov	r5,r17
  80f33c:	dc000904 	addi	r16,sp,36
  80f340:	d8c00115 	stw	r3,4(sp)
  80f344:	d8800015 	stw	r2,0(sp)
  80f348:	d9800215 	stw	r6,8(sp)
  80f34c:	dfc01015 	stw	ra,64(sp)
  80f350:	d9c00315 	stw	r7,12(sp)
  80f354:	080fc480 	call	80fc48 <__unpack_d>
  80f358:	d9000204 	addi	r4,sp,8
  80f35c:	800b883a 	mov	r5,r16
  80f360:	080fc480 	call	80fc48 <__unpack_d>
  80f364:	d8800417 	ldw	r2,16(sp)
  80f368:	00c00044 	movi	r3,1
  80f36c:	01bfffc4 	movi	r6,-1
  80f370:	1880062e 	bgeu	r3,r2,80f38c <__gedf2+0x70>
  80f374:	d8800917 	ldw	r2,36(sp)
  80f378:	8809883a 	mov	r4,r17
  80f37c:	800b883a 	mov	r5,r16
  80f380:	1880022e 	bgeu	r3,r2,80f38c <__gedf2+0x70>
  80f384:	080fd800 	call	80fd80 <__fpcmp_parts_d>
  80f388:	100d883a 	mov	r6,r2
  80f38c:	3005883a 	mov	r2,r6
  80f390:	dfc01017 	ldw	ra,64(sp)
  80f394:	dc400f17 	ldw	r17,60(sp)
  80f398:	dc000e17 	ldw	r16,56(sp)
  80f39c:	dec01104 	addi	sp,sp,68
  80f3a0:	f800283a 	ret

0080f3a4 <__ltdf2>:
  80f3a4:	deffef04 	addi	sp,sp,-68
  80f3a8:	dc400f15 	stw	r17,60(sp)
  80f3ac:	dc400404 	addi	r17,sp,16
  80f3b0:	2005883a 	mov	r2,r4
  80f3b4:	2807883a 	mov	r3,r5
  80f3b8:	dc000e15 	stw	r16,56(sp)
  80f3bc:	d809883a 	mov	r4,sp
  80f3c0:	880b883a 	mov	r5,r17
  80f3c4:	dc000904 	addi	r16,sp,36
  80f3c8:	d8c00115 	stw	r3,4(sp)
  80f3cc:	d8800015 	stw	r2,0(sp)
  80f3d0:	d9800215 	stw	r6,8(sp)
  80f3d4:	dfc01015 	stw	ra,64(sp)
  80f3d8:	d9c00315 	stw	r7,12(sp)
  80f3dc:	080fc480 	call	80fc48 <__unpack_d>
  80f3e0:	d9000204 	addi	r4,sp,8
  80f3e4:	800b883a 	mov	r5,r16
  80f3e8:	080fc480 	call	80fc48 <__unpack_d>
  80f3ec:	d8800417 	ldw	r2,16(sp)
  80f3f0:	00c00044 	movi	r3,1
  80f3f4:	180d883a 	mov	r6,r3
  80f3f8:	1880062e 	bgeu	r3,r2,80f414 <__ltdf2+0x70>
  80f3fc:	d8800917 	ldw	r2,36(sp)
  80f400:	8809883a 	mov	r4,r17
  80f404:	800b883a 	mov	r5,r16
  80f408:	1880022e 	bgeu	r3,r2,80f414 <__ltdf2+0x70>
  80f40c:	080fd800 	call	80fd80 <__fpcmp_parts_d>
  80f410:	100d883a 	mov	r6,r2
  80f414:	3005883a 	mov	r2,r6
  80f418:	dfc01017 	ldw	ra,64(sp)
  80f41c:	dc400f17 	ldw	r17,60(sp)
  80f420:	dc000e17 	ldw	r16,56(sp)
  80f424:	dec01104 	addi	sp,sp,68
  80f428:	f800283a 	ret

0080f42c <__floatsidf>:
  80f42c:	2006d7fa 	srli	r3,r4,31
  80f430:	defff604 	addi	sp,sp,-40
  80f434:	008000c4 	movi	r2,3
  80f438:	dfc00915 	stw	ra,36(sp)
  80f43c:	dcc00815 	stw	r19,32(sp)
  80f440:	dc800715 	stw	r18,28(sp)
  80f444:	dc400615 	stw	r17,24(sp)
  80f448:	dc000515 	stw	r16,20(sp)
  80f44c:	d8800015 	stw	r2,0(sp)
  80f450:	d8c00115 	stw	r3,4(sp)
  80f454:	20000f1e 	bne	r4,zero,80f494 <__floatsidf+0x68>
  80f458:	00800084 	movi	r2,2
  80f45c:	d8800015 	stw	r2,0(sp)
  80f460:	d809883a 	mov	r4,sp
  80f464:	080f9340 	call	80f934 <__pack_d>
  80f468:	1009883a 	mov	r4,r2
  80f46c:	180b883a 	mov	r5,r3
  80f470:	2005883a 	mov	r2,r4
  80f474:	2807883a 	mov	r3,r5
  80f478:	dfc00917 	ldw	ra,36(sp)
  80f47c:	dcc00817 	ldw	r19,32(sp)
  80f480:	dc800717 	ldw	r18,28(sp)
  80f484:	dc400617 	ldw	r17,24(sp)
  80f488:	dc000517 	ldw	r16,20(sp)
  80f48c:	dec00a04 	addi	sp,sp,40
  80f490:	f800283a 	ret
  80f494:	00800f04 	movi	r2,60
  80f498:	1807003a 	cmpeq	r3,r3,zero
  80f49c:	d8800215 	stw	r2,8(sp)
  80f4a0:	18001126 	beq	r3,zero,80f4e8 <__floatsidf+0xbc>
  80f4a4:	0027883a 	mov	r19,zero
  80f4a8:	2025883a 	mov	r18,r4
  80f4ac:	d9000315 	stw	r4,12(sp)
  80f4b0:	dcc00415 	stw	r19,16(sp)
  80f4b4:	080f8b40 	call	80f8b4 <__clzsi2>
  80f4b8:	11000744 	addi	r4,r2,29
  80f4bc:	013fe80e 	bge	zero,r4,80f460 <__floatsidf+0x34>
  80f4c0:	10bfff44 	addi	r2,r2,-3
  80f4c4:	10000c16 	blt	r2,zero,80f4f8 <__floatsidf+0xcc>
  80f4c8:	90a2983a 	sll	r17,r18,r2
  80f4cc:	0021883a 	mov	r16,zero
  80f4d0:	d8800217 	ldw	r2,8(sp)
  80f4d4:	dc400415 	stw	r17,16(sp)
  80f4d8:	dc000315 	stw	r16,12(sp)
  80f4dc:	1105c83a 	sub	r2,r2,r4
  80f4e0:	d8800215 	stw	r2,8(sp)
  80f4e4:	003fde06 	br	80f460 <__floatsidf+0x34>
  80f4e8:	00a00034 	movhi	r2,32768
  80f4ec:	20800a26 	beq	r4,r2,80f518 <__floatsidf+0xec>
  80f4f0:	0109c83a 	sub	r4,zero,r4
  80f4f4:	003feb06 	br	80f4a4 <__floatsidf+0x78>
  80f4f8:	9006d07a 	srli	r3,r18,1
  80f4fc:	008007c4 	movi	r2,31
  80f500:	1105c83a 	sub	r2,r2,r4
  80f504:	1886d83a 	srl	r3,r3,r2
  80f508:	9922983a 	sll	r17,r19,r4
  80f50c:	9120983a 	sll	r16,r18,r4
  80f510:	1c62b03a 	or	r17,r3,r17
  80f514:	003fee06 	br	80f4d0 <__floatsidf+0xa4>
  80f518:	0009883a 	mov	r4,zero
  80f51c:	01707834 	movhi	r5,49632
  80f520:	003fd306 	br	80f470 <__floatsidf+0x44>

0080f524 <__fixdfsi>:
  80f524:	defff804 	addi	sp,sp,-32
  80f528:	2005883a 	mov	r2,r4
  80f52c:	2807883a 	mov	r3,r5
  80f530:	d809883a 	mov	r4,sp
  80f534:	d9400204 	addi	r5,sp,8
  80f538:	d8c00115 	stw	r3,4(sp)
  80f53c:	d8800015 	stw	r2,0(sp)
  80f540:	dfc00715 	stw	ra,28(sp)
  80f544:	080fc480 	call	80fc48 <__unpack_d>
  80f548:	d8c00217 	ldw	r3,8(sp)
  80f54c:	00800084 	movi	r2,2
  80f550:	1880051e 	bne	r3,r2,80f568 <__fixdfsi+0x44>
  80f554:	0007883a 	mov	r3,zero
  80f558:	1805883a 	mov	r2,r3
  80f55c:	dfc00717 	ldw	ra,28(sp)
  80f560:	dec00804 	addi	sp,sp,32
  80f564:	f800283a 	ret
  80f568:	00800044 	movi	r2,1
  80f56c:	10fff92e 	bgeu	r2,r3,80f554 <__fixdfsi+0x30>
  80f570:	00800104 	movi	r2,4
  80f574:	18800426 	beq	r3,r2,80f588 <__fixdfsi+0x64>
  80f578:	d8c00417 	ldw	r3,16(sp)
  80f57c:	183ff516 	blt	r3,zero,80f554 <__fixdfsi+0x30>
  80f580:	00800784 	movi	r2,30
  80f584:	10c0080e 	bge	r2,r3,80f5a8 <__fixdfsi+0x84>
  80f588:	d8800317 	ldw	r2,12(sp)
  80f58c:	1000121e 	bne	r2,zero,80f5d8 <__fixdfsi+0xb4>
  80f590:	00e00034 	movhi	r3,32768
  80f594:	18ffffc4 	addi	r3,r3,-1
  80f598:	1805883a 	mov	r2,r3
  80f59c:	dfc00717 	ldw	ra,28(sp)
  80f5a0:	dec00804 	addi	sp,sp,32
  80f5a4:	f800283a 	ret
  80f5a8:	00800f04 	movi	r2,60
  80f5ac:	10d1c83a 	sub	r8,r2,r3
  80f5b0:	40bff804 	addi	r2,r8,-32
  80f5b4:	d9800517 	ldw	r6,20(sp)
  80f5b8:	d9c00617 	ldw	r7,24(sp)
  80f5bc:	10000816 	blt	r2,zero,80f5e0 <__fixdfsi+0xbc>
  80f5c0:	3888d83a 	srl	r4,r7,r2
  80f5c4:	d8800317 	ldw	r2,12(sp)
  80f5c8:	2007883a 	mov	r3,r4
  80f5cc:	103fe226 	beq	r2,zero,80f558 <__fixdfsi+0x34>
  80f5d0:	0107c83a 	sub	r3,zero,r4
  80f5d4:	003fe006 	br	80f558 <__fixdfsi+0x34>
  80f5d8:	00e00034 	movhi	r3,32768
  80f5dc:	003fde06 	br	80f558 <__fixdfsi+0x34>
  80f5e0:	39c7883a 	add	r3,r7,r7
  80f5e4:	008007c4 	movi	r2,31
  80f5e8:	1205c83a 	sub	r2,r2,r8
  80f5ec:	1886983a 	sll	r3,r3,r2
  80f5f0:	3208d83a 	srl	r4,r6,r8
  80f5f4:	1908b03a 	or	r4,r3,r4
  80f5f8:	003ff206 	br	80f5c4 <__fixdfsi+0xa0>

0080f5fc <__floatunsidf>:
  80f5fc:	defff204 	addi	sp,sp,-56
  80f600:	dfc00d15 	stw	ra,52(sp)
  80f604:	ddc00c15 	stw	r23,48(sp)
  80f608:	dd800b15 	stw	r22,44(sp)
  80f60c:	dd400a15 	stw	r21,40(sp)
  80f610:	dd000915 	stw	r20,36(sp)
  80f614:	dcc00815 	stw	r19,32(sp)
  80f618:	dc800715 	stw	r18,28(sp)
  80f61c:	dc400615 	stw	r17,24(sp)
  80f620:	dc000515 	stw	r16,20(sp)
  80f624:	d8000115 	stw	zero,4(sp)
  80f628:	20000f1e 	bne	r4,zero,80f668 <__floatunsidf+0x6c>
  80f62c:	00800084 	movi	r2,2
  80f630:	d8800015 	stw	r2,0(sp)
  80f634:	d809883a 	mov	r4,sp
  80f638:	080f9340 	call	80f934 <__pack_d>
  80f63c:	dfc00d17 	ldw	ra,52(sp)
  80f640:	ddc00c17 	ldw	r23,48(sp)
  80f644:	dd800b17 	ldw	r22,44(sp)
  80f648:	dd400a17 	ldw	r21,40(sp)
  80f64c:	dd000917 	ldw	r20,36(sp)
  80f650:	dcc00817 	ldw	r19,32(sp)
  80f654:	dc800717 	ldw	r18,28(sp)
  80f658:	dc400617 	ldw	r17,24(sp)
  80f65c:	dc000517 	ldw	r16,20(sp)
  80f660:	dec00e04 	addi	sp,sp,56
  80f664:	f800283a 	ret
  80f668:	008000c4 	movi	r2,3
  80f66c:	00c00f04 	movi	r3,60
  80f670:	002f883a 	mov	r23,zero
  80f674:	202d883a 	mov	r22,r4
  80f678:	d8800015 	stw	r2,0(sp)
  80f67c:	d8c00215 	stw	r3,8(sp)
  80f680:	d9000315 	stw	r4,12(sp)
  80f684:	ddc00415 	stw	r23,16(sp)
  80f688:	080f8b40 	call	80f8b4 <__clzsi2>
  80f68c:	12400744 	addi	r9,r2,29
  80f690:	48000b16 	blt	r9,zero,80f6c0 <__floatunsidf+0xc4>
  80f694:	483fe726 	beq	r9,zero,80f634 <__floatunsidf+0x38>
  80f698:	10bfff44 	addi	r2,r2,-3
  80f69c:	10002e16 	blt	r2,zero,80f758 <__floatunsidf+0x15c>
  80f6a0:	b0a2983a 	sll	r17,r22,r2
  80f6a4:	0021883a 	mov	r16,zero
  80f6a8:	d8800217 	ldw	r2,8(sp)
  80f6ac:	dc400415 	stw	r17,16(sp)
  80f6b0:	dc000315 	stw	r16,12(sp)
  80f6b4:	1245c83a 	sub	r2,r2,r9
  80f6b8:	d8800215 	stw	r2,8(sp)
  80f6bc:	003fdd06 	br	80f634 <__floatunsidf+0x38>
  80f6c0:	0255c83a 	sub	r10,zero,r9
  80f6c4:	51bff804 	addi	r6,r10,-32
  80f6c8:	30001b16 	blt	r6,zero,80f738 <__floatunsidf+0x13c>
  80f6cc:	b9a8d83a 	srl	r20,r23,r6
  80f6d0:	002b883a 	mov	r21,zero
  80f6d4:	000f883a 	mov	r7,zero
  80f6d8:	01000044 	movi	r4,1
  80f6dc:	0011883a 	mov	r8,zero
  80f6e0:	30002516 	blt	r6,zero,80f778 <__floatunsidf+0x17c>
  80f6e4:	21a6983a 	sll	r19,r4,r6
  80f6e8:	0025883a 	mov	r18,zero
  80f6ec:	00bfffc4 	movi	r2,-1
  80f6f0:	9089883a 	add	r4,r18,r2
  80f6f4:	988b883a 	add	r5,r19,r2
  80f6f8:	248d803a 	cmpltu	r6,r4,r18
  80f6fc:	314b883a 	add	r5,r6,r5
  80f700:	b104703a 	and	r2,r22,r4
  80f704:	b946703a 	and	r3,r23,r5
  80f708:	10c4b03a 	or	r2,r2,r3
  80f70c:	10000226 	beq	r2,zero,80f718 <__floatunsidf+0x11c>
  80f710:	01c00044 	movi	r7,1
  80f714:	0011883a 	mov	r8,zero
  80f718:	d9000217 	ldw	r4,8(sp)
  80f71c:	a1c4b03a 	or	r2,r20,r7
  80f720:	aa06b03a 	or	r3,r21,r8
  80f724:	2249c83a 	sub	r4,r4,r9
  80f728:	d8c00415 	stw	r3,16(sp)
  80f72c:	d9000215 	stw	r4,8(sp)
  80f730:	d8800315 	stw	r2,12(sp)
  80f734:	003fbf06 	br	80f634 <__floatunsidf+0x38>
  80f738:	bdc7883a 	add	r3,r23,r23
  80f73c:	008007c4 	movi	r2,31
  80f740:	1285c83a 	sub	r2,r2,r10
  80f744:	1886983a 	sll	r3,r3,r2
  80f748:	b2a8d83a 	srl	r20,r22,r10
  80f74c:	baaad83a 	srl	r21,r23,r10
  80f750:	1d28b03a 	or	r20,r3,r20
  80f754:	003fdf06 	br	80f6d4 <__floatunsidf+0xd8>
  80f758:	b006d07a 	srli	r3,r22,1
  80f75c:	008007c4 	movi	r2,31
  80f760:	1245c83a 	sub	r2,r2,r9
  80f764:	1886d83a 	srl	r3,r3,r2
  80f768:	ba62983a 	sll	r17,r23,r9
  80f76c:	b260983a 	sll	r16,r22,r9
  80f770:	1c62b03a 	or	r17,r3,r17
  80f774:	003fcc06 	br	80f6a8 <__floatunsidf+0xac>
  80f778:	2006d07a 	srli	r3,r4,1
  80f77c:	008007c4 	movi	r2,31
  80f780:	1285c83a 	sub	r2,r2,r10
  80f784:	18a6d83a 	srl	r19,r3,r2
  80f788:	22a4983a 	sll	r18,r4,r10
  80f78c:	003fd706 	br	80f6ec <__floatunsidf+0xf0>

0080f790 <__muldi3>:
  80f790:	defff204 	addi	sp,sp,-56
  80f794:	df000c15 	stw	fp,48(sp)
  80f798:	3038d43a 	srli	fp,r6,16
  80f79c:	dd000815 	stw	r20,32(sp)
  80f7a0:	dc400515 	stw	r17,20(sp)
  80f7a4:	2028d43a 	srli	r20,r4,16
  80f7a8:	247fffcc 	andi	r17,r4,65535
  80f7ac:	dc000415 	stw	r16,16(sp)
  80f7b0:	343fffcc 	andi	r16,r6,65535
  80f7b4:	dcc00715 	stw	r19,28(sp)
  80f7b8:	d9000015 	stw	r4,0(sp)
  80f7bc:	2827883a 	mov	r19,r5
  80f7c0:	8809883a 	mov	r4,r17
  80f7c4:	d9400115 	stw	r5,4(sp)
  80f7c8:	800b883a 	mov	r5,r16
  80f7cc:	d9800215 	stw	r6,8(sp)
  80f7d0:	dfc00d15 	stw	ra,52(sp)
  80f7d4:	d9c00315 	stw	r7,12(sp)
  80f7d8:	dd800a15 	stw	r22,40(sp)
  80f7dc:	dd400915 	stw	r21,36(sp)
  80f7e0:	302d883a 	mov	r22,r6
  80f7e4:	ddc00b15 	stw	r23,44(sp)
  80f7e8:	dc800615 	stw	r18,24(sp)
  80f7ec:	08064840 	call	806484 <__mulsi3>
  80f7f0:	8809883a 	mov	r4,r17
  80f7f4:	e00b883a 	mov	r5,fp
  80f7f8:	102b883a 	mov	r21,r2
  80f7fc:	08064840 	call	806484 <__mulsi3>
  80f800:	800b883a 	mov	r5,r16
  80f804:	a009883a 	mov	r4,r20
  80f808:	1023883a 	mov	r17,r2
  80f80c:	08064840 	call	806484 <__mulsi3>
  80f810:	a009883a 	mov	r4,r20
  80f814:	e00b883a 	mov	r5,fp
  80f818:	1021883a 	mov	r16,r2
  80f81c:	08064840 	call	806484 <__mulsi3>
  80f820:	a8ffffcc 	andi	r3,r21,65535
  80f824:	a82ad43a 	srli	r21,r21,16
  80f828:	8c23883a 	add	r17,r17,r16
  80f82c:	1011883a 	mov	r8,r2
  80f830:	ac6b883a 	add	r21,r21,r17
  80f834:	a804943a 	slli	r2,r21,16
  80f838:	b009883a 	mov	r4,r22
  80f83c:	980b883a 	mov	r5,r19
  80f840:	10c7883a 	add	r3,r2,r3
  80f844:	a812d43a 	srli	r9,r21,16
  80f848:	180d883a 	mov	r6,r3
  80f84c:	ac00022e 	bgeu	r21,r16,80f858 <__muldi3+0xc8>
  80f850:	00800074 	movhi	r2,1
  80f854:	4091883a 	add	r8,r8,r2
  80f858:	4267883a 	add	r19,r8,r9
  80f85c:	302d883a 	mov	r22,r6
  80f860:	08064840 	call	806484 <__mulsi3>
  80f864:	d9400317 	ldw	r5,12(sp)
  80f868:	d9000017 	ldw	r4,0(sp)
  80f86c:	1023883a 	mov	r17,r2
  80f870:	08064840 	call	806484 <__mulsi3>
  80f874:	14cb883a 	add	r5,r2,r19
  80f878:	894b883a 	add	r5,r17,r5
  80f87c:	b005883a 	mov	r2,r22
  80f880:	2807883a 	mov	r3,r5
  80f884:	dfc00d17 	ldw	ra,52(sp)
  80f888:	df000c17 	ldw	fp,48(sp)
  80f88c:	ddc00b17 	ldw	r23,44(sp)
  80f890:	dd800a17 	ldw	r22,40(sp)
  80f894:	dd400917 	ldw	r21,36(sp)
  80f898:	dd000817 	ldw	r20,32(sp)
  80f89c:	dcc00717 	ldw	r19,28(sp)
  80f8a0:	dc800617 	ldw	r18,24(sp)
  80f8a4:	dc400517 	ldw	r17,20(sp)
  80f8a8:	dc000417 	ldw	r16,16(sp)
  80f8ac:	dec00e04 	addi	sp,sp,56
  80f8b0:	f800283a 	ret

0080f8b4 <__clzsi2>:
  80f8b4:	00bfffd4 	movui	r2,65535
  80f8b8:	11000e36 	bltu	r2,r4,80f8f4 <__clzsi2+0x40>
  80f8bc:	00803fc4 	movi	r2,255
  80f8c0:	01400204 	movi	r5,8
  80f8c4:	0007883a 	mov	r3,zero
  80f8c8:	11001036 	bltu	r2,r4,80f90c <__clzsi2+0x58>
  80f8cc:	000b883a 	mov	r5,zero
  80f8d0:	20c6d83a 	srl	r3,r4,r3
  80f8d4:	008020b4 	movhi	r2,130
  80f8d8:	10a1d904 	addi	r2,r2,-30876
  80f8dc:	1887883a 	add	r3,r3,r2
  80f8e0:	18800003 	ldbu	r2,0(r3)
  80f8e4:	00c00804 	movi	r3,32
  80f8e8:	2885883a 	add	r2,r5,r2
  80f8ec:	1885c83a 	sub	r2,r3,r2
  80f8f0:	f800283a 	ret
  80f8f4:	01400404 	movi	r5,16
  80f8f8:	00804034 	movhi	r2,256
  80f8fc:	10bfffc4 	addi	r2,r2,-1
  80f900:	2807883a 	mov	r3,r5
  80f904:	113ff22e 	bgeu	r2,r4,80f8d0 <__clzsi2+0x1c>
  80f908:	01400604 	movi	r5,24
  80f90c:	2807883a 	mov	r3,r5
  80f910:	20c6d83a 	srl	r3,r4,r3
  80f914:	008020b4 	movhi	r2,130
  80f918:	10a1d904 	addi	r2,r2,-30876
  80f91c:	1887883a 	add	r3,r3,r2
  80f920:	18800003 	ldbu	r2,0(r3)
  80f924:	00c00804 	movi	r3,32
  80f928:	2885883a 	add	r2,r5,r2
  80f92c:	1885c83a 	sub	r2,r3,r2
  80f930:	f800283a 	ret

0080f934 <__pack_d>:
  80f934:	20c00017 	ldw	r3,0(r4)
  80f938:	defffd04 	addi	sp,sp,-12
  80f93c:	dc000015 	stw	r16,0(sp)
  80f940:	dc800215 	stw	r18,8(sp)
  80f944:	dc400115 	stw	r17,4(sp)
  80f948:	00800044 	movi	r2,1
  80f94c:	22000317 	ldw	r8,12(r4)
  80f950:	001f883a 	mov	r15,zero
  80f954:	22400417 	ldw	r9,16(r4)
  80f958:	24000117 	ldw	r16,4(r4)
  80f95c:	10c0552e 	bgeu	r2,r3,80fab4 <__pack_d+0x180>
  80f960:	00800104 	movi	r2,4
  80f964:	18804f26 	beq	r3,r2,80faa4 <__pack_d+0x170>
  80f968:	00800084 	movi	r2,2
  80f96c:	18800226 	beq	r3,r2,80f978 <__pack_d+0x44>
  80f970:	4244b03a 	or	r2,r8,r9
  80f974:	10001a1e 	bne	r2,zero,80f9e0 <__pack_d+0xac>
  80f978:	000d883a 	mov	r6,zero
  80f97c:	000f883a 	mov	r7,zero
  80f980:	0011883a 	mov	r8,zero
  80f984:	00800434 	movhi	r2,16
  80f988:	10bfffc4 	addi	r2,r2,-1
  80f98c:	301d883a 	mov	r14,r6
  80f990:	3884703a 	and	r2,r7,r2
  80f994:	400a953a 	slli	r5,r8,20
  80f998:	79bffc2c 	andhi	r6,r15,65520
  80f99c:	308cb03a 	or	r6,r6,r2
  80f9a0:	00e00434 	movhi	r3,32784
  80f9a4:	18ffffc4 	addi	r3,r3,-1
  80f9a8:	800497fa 	slli	r2,r16,31
  80f9ac:	30c6703a 	and	r3,r6,r3
  80f9b0:	1946b03a 	or	r3,r3,r5
  80f9b4:	01600034 	movhi	r5,32768
  80f9b8:	297fffc4 	addi	r5,r5,-1
  80f9bc:	194a703a 	and	r5,r3,r5
  80f9c0:	288ab03a 	or	r5,r5,r2
  80f9c4:	2807883a 	mov	r3,r5
  80f9c8:	7005883a 	mov	r2,r14
  80f9cc:	dc800217 	ldw	r18,8(sp)
  80f9d0:	dc400117 	ldw	r17,4(sp)
  80f9d4:	dc000017 	ldw	r16,0(sp)
  80f9d8:	dec00304 	addi	sp,sp,12
  80f9dc:	f800283a 	ret
  80f9e0:	21000217 	ldw	r4,8(r4)
  80f9e4:	00bf0084 	movi	r2,-1022
  80f9e8:	20803f16 	blt	r4,r2,80fae8 <__pack_d+0x1b4>
  80f9ec:	0080ffc4 	movi	r2,1023
  80f9f0:	11002c16 	blt	r2,r4,80faa4 <__pack_d+0x170>
  80f9f4:	00803fc4 	movi	r2,255
  80f9f8:	408c703a 	and	r6,r8,r2
  80f9fc:	00802004 	movi	r2,128
  80fa00:	0007883a 	mov	r3,zero
  80fa04:	000f883a 	mov	r7,zero
  80fa08:	2280ffc4 	addi	r10,r4,1023
  80fa0c:	30801e26 	beq	r6,r2,80fa88 <__pack_d+0x154>
  80fa10:	00801fc4 	movi	r2,127
  80fa14:	4089883a 	add	r4,r8,r2
  80fa18:	220d803a 	cmpltu	r6,r4,r8
  80fa1c:	324d883a 	add	r6,r6,r9
  80fa20:	2011883a 	mov	r8,r4
  80fa24:	3013883a 	mov	r9,r6
  80fa28:	00880034 	movhi	r2,8192
  80fa2c:	10bfffc4 	addi	r2,r2,-1
  80fa30:	12400d36 	bltu	r2,r9,80fa68 <__pack_d+0x134>
  80fa34:	4804963a 	slli	r2,r9,24
  80fa38:	400cd23a 	srli	r6,r8,8
  80fa3c:	480ed23a 	srli	r7,r9,8
  80fa40:	013fffc4 	movi	r4,-1
  80fa44:	118cb03a 	or	r6,r2,r6
  80fa48:	01400434 	movhi	r5,16
  80fa4c:	297fffc4 	addi	r5,r5,-1
  80fa50:	3104703a 	and	r2,r6,r4
  80fa54:	3946703a 	and	r3,r7,r5
  80fa58:	5201ffcc 	andi	r8,r10,2047
  80fa5c:	100d883a 	mov	r6,r2
  80fa60:	180f883a 	mov	r7,r3
  80fa64:	003fc706 	br	80f984 <__pack_d+0x50>
  80fa68:	480897fa 	slli	r4,r9,31
  80fa6c:	4004d07a 	srli	r2,r8,1
  80fa70:	4806d07a 	srli	r3,r9,1
  80fa74:	52800044 	addi	r10,r10,1
  80fa78:	2084b03a 	or	r2,r4,r2
  80fa7c:	1011883a 	mov	r8,r2
  80fa80:	1813883a 	mov	r9,r3
  80fa84:	003feb06 	br	80fa34 <__pack_d+0x100>
  80fa88:	383fe11e 	bne	r7,zero,80fa10 <__pack_d+0xdc>
  80fa8c:	01004004 	movi	r4,256
  80fa90:	4104703a 	and	r2,r8,r4
  80fa94:	10c4b03a 	or	r2,r2,r3
  80fa98:	103fe326 	beq	r2,zero,80fa28 <__pack_d+0xf4>
  80fa9c:	3005883a 	mov	r2,r6
  80faa0:	003fdc06 	br	80fa14 <__pack_d+0xe0>
  80faa4:	000d883a 	mov	r6,zero
  80faa8:	000f883a 	mov	r7,zero
  80faac:	0201ffc4 	movi	r8,2047
  80fab0:	003fb406 	br	80f984 <__pack_d+0x50>
  80fab4:	0005883a 	mov	r2,zero
  80fab8:	00c00234 	movhi	r3,8
  80fabc:	408cb03a 	or	r6,r8,r2
  80fac0:	48ceb03a 	or	r7,r9,r3
  80fac4:	013fffc4 	movi	r4,-1
  80fac8:	01400434 	movhi	r5,16
  80facc:	297fffc4 	addi	r5,r5,-1
  80fad0:	3104703a 	and	r2,r6,r4
  80fad4:	3946703a 	and	r3,r7,r5
  80fad8:	100d883a 	mov	r6,r2
  80fadc:	180f883a 	mov	r7,r3
  80fae0:	0201ffc4 	movi	r8,2047
  80fae4:	003fa706 	br	80f984 <__pack_d+0x50>
  80fae8:	1109c83a 	sub	r4,r2,r4
  80faec:	00800e04 	movi	r2,56
  80faf0:	11004316 	blt	r2,r4,80fc00 <__pack_d+0x2cc>
  80faf4:	21fff804 	addi	r7,r4,-32
  80faf8:	38004516 	blt	r7,zero,80fc10 <__pack_d+0x2dc>
  80fafc:	49d8d83a 	srl	r12,r9,r7
  80fb00:	001b883a 	mov	r13,zero
  80fb04:	0023883a 	mov	r17,zero
  80fb08:	01400044 	movi	r5,1
  80fb0c:	0025883a 	mov	r18,zero
  80fb10:	38004716 	blt	r7,zero,80fc30 <__pack_d+0x2fc>
  80fb14:	29d6983a 	sll	r11,r5,r7
  80fb18:	0015883a 	mov	r10,zero
  80fb1c:	00bfffc4 	movi	r2,-1
  80fb20:	5089883a 	add	r4,r10,r2
  80fb24:	588b883a 	add	r5,r11,r2
  80fb28:	228d803a 	cmpltu	r6,r4,r10
  80fb2c:	314b883a 	add	r5,r6,r5
  80fb30:	4104703a 	and	r2,r8,r4
  80fb34:	4946703a 	and	r3,r9,r5
  80fb38:	10c4b03a 	or	r2,r2,r3
  80fb3c:	10000226 	beq	r2,zero,80fb48 <__pack_d+0x214>
  80fb40:	04400044 	movi	r17,1
  80fb44:	0025883a 	mov	r18,zero
  80fb48:	00803fc4 	movi	r2,255
  80fb4c:	644eb03a 	or	r7,r12,r17
  80fb50:	3892703a 	and	r9,r7,r2
  80fb54:	00802004 	movi	r2,128
  80fb58:	6c90b03a 	or	r8,r13,r18
  80fb5c:	0015883a 	mov	r10,zero
  80fb60:	48801626 	beq	r9,r2,80fbbc <__pack_d+0x288>
  80fb64:	01001fc4 	movi	r4,127
  80fb68:	3905883a 	add	r2,r7,r4
  80fb6c:	11cd803a 	cmpltu	r6,r2,r7
  80fb70:	320d883a 	add	r6,r6,r8
  80fb74:	100f883a 	mov	r7,r2
  80fb78:	00840034 	movhi	r2,4096
  80fb7c:	10bfffc4 	addi	r2,r2,-1
  80fb80:	3011883a 	mov	r8,r6
  80fb84:	0007883a 	mov	r3,zero
  80fb88:	11801b36 	bltu	r2,r6,80fbf8 <__pack_d+0x2c4>
  80fb8c:	4004963a 	slli	r2,r8,24
  80fb90:	3808d23a 	srli	r4,r7,8
  80fb94:	400ad23a 	srli	r5,r8,8
  80fb98:	1813883a 	mov	r9,r3
  80fb9c:	1108b03a 	or	r4,r2,r4
  80fba0:	00bfffc4 	movi	r2,-1
  80fba4:	00c00434 	movhi	r3,16
  80fba8:	18ffffc4 	addi	r3,r3,-1
  80fbac:	208c703a 	and	r6,r4,r2
  80fbb0:	28ce703a 	and	r7,r5,r3
  80fbb4:	4a01ffcc 	andi	r8,r9,2047
  80fbb8:	003f7206 	br	80f984 <__pack_d+0x50>
  80fbbc:	503fe91e 	bne	r10,zero,80fb64 <__pack_d+0x230>
  80fbc0:	01004004 	movi	r4,256
  80fbc4:	3904703a 	and	r2,r7,r4
  80fbc8:	0007883a 	mov	r3,zero
  80fbcc:	10c4b03a 	or	r2,r2,r3
  80fbd0:	10000626 	beq	r2,zero,80fbec <__pack_d+0x2b8>
  80fbd4:	3a45883a 	add	r2,r7,r9
  80fbd8:	11cd803a 	cmpltu	r6,r2,r7
  80fbdc:	320d883a 	add	r6,r6,r8
  80fbe0:	100f883a 	mov	r7,r2
  80fbe4:	3011883a 	mov	r8,r6
  80fbe8:	0007883a 	mov	r3,zero
  80fbec:	00840034 	movhi	r2,4096
  80fbf0:	10bfffc4 	addi	r2,r2,-1
  80fbf4:	123fe52e 	bgeu	r2,r8,80fb8c <__pack_d+0x258>
  80fbf8:	00c00044 	movi	r3,1
  80fbfc:	003fe306 	br	80fb8c <__pack_d+0x258>
  80fc00:	0009883a 	mov	r4,zero
  80fc04:	0013883a 	mov	r9,zero
  80fc08:	000b883a 	mov	r5,zero
  80fc0c:	003fe406 	br	80fba0 <__pack_d+0x26c>
  80fc10:	4a47883a 	add	r3,r9,r9
  80fc14:	008007c4 	movi	r2,31
  80fc18:	1105c83a 	sub	r2,r2,r4
  80fc1c:	1886983a 	sll	r3,r3,r2
  80fc20:	4118d83a 	srl	r12,r8,r4
  80fc24:	491ad83a 	srl	r13,r9,r4
  80fc28:	1b18b03a 	or	r12,r3,r12
  80fc2c:	003fb506 	br	80fb04 <__pack_d+0x1d0>
  80fc30:	2806d07a 	srli	r3,r5,1
  80fc34:	008007c4 	movi	r2,31
  80fc38:	1105c83a 	sub	r2,r2,r4
  80fc3c:	1896d83a 	srl	r11,r3,r2
  80fc40:	2914983a 	sll	r10,r5,r4
  80fc44:	003fb506 	br	80fb1c <__pack_d+0x1e8>

0080fc48 <__unpack_d>:
  80fc48:	20c00117 	ldw	r3,4(r4)
  80fc4c:	22400017 	ldw	r9,0(r4)
  80fc50:	00800434 	movhi	r2,16
  80fc54:	10bfffc4 	addi	r2,r2,-1
  80fc58:	1808d53a 	srli	r4,r3,20
  80fc5c:	180cd7fa 	srli	r6,r3,31
  80fc60:	1894703a 	and	r10,r3,r2
  80fc64:	2201ffcc 	andi	r8,r4,2047
  80fc68:	281b883a 	mov	r13,r5
  80fc6c:	4817883a 	mov	r11,r9
  80fc70:	29800115 	stw	r6,4(r5)
  80fc74:	5019883a 	mov	r12,r10
  80fc78:	40001e1e 	bne	r8,zero,80fcf4 <__unpack_d+0xac>
  80fc7c:	4a84b03a 	or	r2,r9,r10
  80fc80:	10001926 	beq	r2,zero,80fce8 <__unpack_d+0xa0>
  80fc84:	4804d63a 	srli	r2,r9,24
  80fc88:	500c923a 	slli	r6,r10,8
  80fc8c:	013f0084 	movi	r4,-1022
  80fc90:	00c40034 	movhi	r3,4096
  80fc94:	18ffffc4 	addi	r3,r3,-1
  80fc98:	118cb03a 	or	r6,r2,r6
  80fc9c:	008000c4 	movi	r2,3
  80fca0:	480a923a 	slli	r5,r9,8
  80fca4:	68800015 	stw	r2,0(r13)
  80fca8:	69000215 	stw	r4,8(r13)
  80fcac:	19800b36 	bltu	r3,r6,80fcdc <__unpack_d+0x94>
  80fcb0:	200f883a 	mov	r7,r4
  80fcb4:	1811883a 	mov	r8,r3
  80fcb8:	2945883a 	add	r2,r5,r5
  80fcbc:	1149803a 	cmpltu	r4,r2,r5
  80fcc0:	3187883a 	add	r3,r6,r6
  80fcc4:	20c9883a 	add	r4,r4,r3
  80fcc8:	100b883a 	mov	r5,r2
  80fccc:	200d883a 	mov	r6,r4
  80fcd0:	39ffffc4 	addi	r7,r7,-1
  80fcd4:	413ff82e 	bgeu	r8,r4,80fcb8 <__unpack_d+0x70>
  80fcd8:	69c00215 	stw	r7,8(r13)
  80fcdc:	69800415 	stw	r6,16(r13)
  80fce0:	69400315 	stw	r5,12(r13)
  80fce4:	f800283a 	ret
  80fce8:	00800084 	movi	r2,2
  80fcec:	28800015 	stw	r2,0(r5)
  80fcf0:	f800283a 	ret
  80fcf4:	0081ffc4 	movi	r2,2047
  80fcf8:	40800f26 	beq	r8,r2,80fd38 <__unpack_d+0xf0>
  80fcfc:	480cd63a 	srli	r6,r9,24
  80fd00:	5006923a 	slli	r3,r10,8
  80fd04:	4804923a 	slli	r2,r9,8
  80fd08:	0009883a 	mov	r4,zero
  80fd0c:	30c6b03a 	or	r3,r6,r3
  80fd10:	01440034 	movhi	r5,4096
  80fd14:	110cb03a 	or	r6,r2,r4
  80fd18:	423f0044 	addi	r8,r8,-1023
  80fd1c:	194eb03a 	or	r7,r3,r5
  80fd20:	008000c4 	movi	r2,3
  80fd24:	69c00415 	stw	r7,16(r13)
  80fd28:	6a000215 	stw	r8,8(r13)
  80fd2c:	68800015 	stw	r2,0(r13)
  80fd30:	69800315 	stw	r6,12(r13)
  80fd34:	f800283a 	ret
  80fd38:	4a84b03a 	or	r2,r9,r10
  80fd3c:	1000031e 	bne	r2,zero,80fd4c <__unpack_d+0x104>
  80fd40:	00800104 	movi	r2,4
  80fd44:	28800015 	stw	r2,0(r5)
  80fd48:	f800283a 	ret
  80fd4c:	0009883a 	mov	r4,zero
  80fd50:	01400234 	movhi	r5,8
  80fd54:	4904703a 	and	r2,r9,r4
  80fd58:	5146703a 	and	r3,r10,r5
  80fd5c:	10c4b03a 	or	r2,r2,r3
  80fd60:	10000526 	beq	r2,zero,80fd78 <__unpack_d+0x130>
  80fd64:	00800044 	movi	r2,1
  80fd68:	68800015 	stw	r2,0(r13)
  80fd6c:	6b000415 	stw	r12,16(r13)
  80fd70:	6ac00315 	stw	r11,12(r13)
  80fd74:	f800283a 	ret
  80fd78:	68000015 	stw	zero,0(r13)
  80fd7c:	003ffb06 	br	80fd6c <__unpack_d+0x124>

0080fd80 <__fpcmp_parts_d>:
  80fd80:	21800017 	ldw	r6,0(r4)
  80fd84:	00c00044 	movi	r3,1
  80fd88:	19800a2e 	bgeu	r3,r6,80fdb4 <__fpcmp_parts_d+0x34>
  80fd8c:	28800017 	ldw	r2,0(r5)
  80fd90:	1880082e 	bgeu	r3,r2,80fdb4 <__fpcmp_parts_d+0x34>
  80fd94:	00c00104 	movi	r3,4
  80fd98:	30c02626 	beq	r6,r3,80fe34 <__fpcmp_parts_d+0xb4>
  80fd9c:	10c02226 	beq	r2,r3,80fe28 <__fpcmp_parts_d+0xa8>
  80fda0:	00c00084 	movi	r3,2
  80fda4:	30c00526 	beq	r6,r3,80fdbc <__fpcmp_parts_d+0x3c>
  80fda8:	10c0071e 	bne	r2,r3,80fdc8 <__fpcmp_parts_d+0x48>
  80fdac:	20800117 	ldw	r2,4(r4)
  80fdb0:	1000091e 	bne	r2,zero,80fdd8 <__fpcmp_parts_d+0x58>
  80fdb4:	00800044 	movi	r2,1
  80fdb8:	f800283a 	ret
  80fdbc:	10c01a1e 	bne	r2,r3,80fe28 <__fpcmp_parts_d+0xa8>
  80fdc0:	0005883a 	mov	r2,zero
  80fdc4:	f800283a 	ret
  80fdc8:	22000117 	ldw	r8,4(r4)
  80fdcc:	28800117 	ldw	r2,4(r5)
  80fdd0:	40800326 	beq	r8,r2,80fde0 <__fpcmp_parts_d+0x60>
  80fdd4:	403ff726 	beq	r8,zero,80fdb4 <__fpcmp_parts_d+0x34>
  80fdd8:	00bfffc4 	movi	r2,-1
  80fddc:	f800283a 	ret
  80fde0:	20c00217 	ldw	r3,8(r4)
  80fde4:	28800217 	ldw	r2,8(r5)
  80fde8:	10fffa16 	blt	r2,r3,80fdd4 <__fpcmp_parts_d+0x54>
  80fdec:	18800916 	blt	r3,r2,80fe14 <__fpcmp_parts_d+0x94>
  80fdf0:	21c00417 	ldw	r7,16(r4)
  80fdf4:	28c00417 	ldw	r3,16(r5)
  80fdf8:	21800317 	ldw	r6,12(r4)
  80fdfc:	28800317 	ldw	r2,12(r5)
  80fe00:	19fff436 	bltu	r3,r7,80fdd4 <__fpcmp_parts_d+0x54>
  80fe04:	38c00526 	beq	r7,r3,80fe1c <__fpcmp_parts_d+0x9c>
  80fe08:	38c00236 	bltu	r7,r3,80fe14 <__fpcmp_parts_d+0x94>
  80fe0c:	19ffec1e 	bne	r3,r7,80fdc0 <__fpcmp_parts_d+0x40>
  80fe10:	30bfeb2e 	bgeu	r6,r2,80fdc0 <__fpcmp_parts_d+0x40>
  80fe14:	403fe71e 	bne	r8,zero,80fdb4 <__fpcmp_parts_d+0x34>
  80fe18:	003fef06 	br	80fdd8 <__fpcmp_parts_d+0x58>
  80fe1c:	11bffa2e 	bgeu	r2,r6,80fe08 <__fpcmp_parts_d+0x88>
  80fe20:	403fe426 	beq	r8,zero,80fdb4 <__fpcmp_parts_d+0x34>
  80fe24:	003fec06 	br	80fdd8 <__fpcmp_parts_d+0x58>
  80fe28:	28800117 	ldw	r2,4(r5)
  80fe2c:	103fe11e 	bne	r2,zero,80fdb4 <__fpcmp_parts_d+0x34>
  80fe30:	003fe906 	br	80fdd8 <__fpcmp_parts_d+0x58>
  80fe34:	11bfdd1e 	bne	r2,r6,80fdac <__fpcmp_parts_d+0x2c>
  80fe38:	28c00117 	ldw	r3,4(r5)
  80fe3c:	20800117 	ldw	r2,4(r4)
  80fe40:	1885c83a 	sub	r2,r3,r2
  80fe44:	f800283a 	ret

0080fe48 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
Thread *chThdAddRef(Thread *tp) {
  80fe48:	defffc04 	addi	sp,sp,-16
  80fe4c:	df000315 	stw	fp,12(sp)
  80fe50:	df000304 	addi	fp,sp,12
  80fe54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80fe58:	0005303a 	rdctl	r2,status
  80fe5c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80fe60:	e0fffe17 	ldw	r3,-8(fp)
  80fe64:	00bfff84 	movi	r2,-2
  80fe68:	1884703a 	and	r2,r3,r2
  80fe6c:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_refs < 255, "chThdAddRef(), #1", "too many references");
  tp->p_refs++;
  80fe70:	e0bfff17 	ldw	r2,-4(fp)
  80fe74:	10800783 	ldbu	r2,30(r2)
  80fe78:	10800044 	addi	r2,r2,1
  80fe7c:	1007883a 	mov	r3,r2
  80fe80:	e0bfff17 	ldw	r2,-4(fp)
  80fe84:	10c00785 	stb	r3,30(r2)
  80fe88:	00800044 	movi	r2,1
  80fe8c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80fe90:	e0bffd17 	ldw	r2,-12(fp)
  80fe94:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  80fe98:	e0bfff17 	ldw	r2,-4(fp)
}
  80fe9c:	e037883a 	mov	sp,fp
  80fea0:	df000017 	ldw	fp,0(sp)
  80fea4:	dec00104 	addi	sp,sp,4
  80fea8:	f800283a 	ret

0080feac <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(Thread *tp) {
  80feac:	defff904 	addi	sp,sp,-28
  80feb0:	dfc00615 	stw	ra,24(sp)
  80feb4:	df000515 	stw	fp,20(sp)
  80feb8:	df000504 	addi	fp,sp,20
  80febc:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80fec0:	0005303a 	rdctl	r2,status
  80fec4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80fec8:	e0fffc17 	ldw	r3,-16(fp)
  80fecc:	00bfff84 	movi	r2,-2
  80fed0:	1884703a 	and	r2,r3,r2
  80fed4:	1001703a 	wrctl	status,r2
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > 0, "chThdRelease(), #1", "not referenced");
  refs = --tp->p_refs;
  80fed8:	e0bffe17 	ldw	r2,-8(fp)
  80fedc:	10800783 	ldbu	r2,30(r2)
  80fee0:	10bfffc4 	addi	r2,r2,-1
  80fee4:	1007883a 	mov	r3,r2
  80fee8:	e0bffe17 	ldw	r2,-8(fp)
  80feec:	10c00785 	stb	r3,30(r2)
  80fef0:	e0bffe17 	ldw	r2,-8(fp)
  80fef4:	10800783 	ldbu	r2,30(r2)
  80fef8:	e0bffd05 	stb	r2,-12(fp)
  80fefc:	00800044 	movi	r2,1
  80ff00:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80ff04:	e0bffb17 	ldw	r2,-20(fp)
  80ff08:	1001703a 	wrctl	status,r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == THD_STATE_FINAL)) {
  80ff0c:	e0bffd03 	ldbu	r2,-12(fp)
  80ff10:	1004c03a 	cmpne	r2,r2,zero
  80ff14:	10002d1e 	bne	r2,zero,80ffcc <chThdRelease+0x120>
  80ff18:	e0bffe17 	ldw	r2,-8(fp)
  80ff1c:	10800703 	ldbu	r2,28(r2)
  80ff20:	10803fcc 	andi	r2,r2,255
  80ff24:	10800398 	cmpnei	r2,r2,14
  80ff28:	1000281e 	bne	r2,zero,80ffcc <chThdRelease+0x120>
    switch (tp->p_flags & THD_MEM_MODE_MASK) {
  80ff2c:	e0bffe17 	ldw	r2,-8(fp)
  80ff30:	10800743 	ldbu	r2,29(r2)
  80ff34:	10803fcc 	andi	r2,r2,255
  80ff38:	108000cc 	andi	r2,r2,3
  80ff3c:	e0bfff15 	stw	r2,-4(fp)
  80ff40:	e0ffff17 	ldw	r3,-4(fp)
  80ff44:	18800060 	cmpeqi	r2,r3,1
  80ff48:	1000041e 	bne	r2,zero,80ff5c <chThdRelease+0xb0>
  80ff4c:	e0ffff17 	ldw	r3,-4(fp)
  80ff50:	188000a0 	cmpeqi	r2,r3,2
  80ff54:	10000e1e 	bne	r2,zero,80ff90 <chThdRelease+0xe4>
  80ff58:	00001c06 	br	80ffcc <chThdRelease+0x120>
#if CH_USE_HEAP
    case THD_MEM_MODE_HEAP:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
  80ff5c:	e0bffe17 	ldw	r2,-8(fp)
  80ff60:	10c00517 	ldw	r3,20(r2)
  80ff64:	e0bffe17 	ldw	r2,-8(fp)
  80ff68:	10800417 	ldw	r2,16(r2)
  80ff6c:	18800415 	stw	r2,16(r3)
  80ff70:	e0bffe17 	ldw	r2,-8(fp)
  80ff74:	10c00417 	ldw	r3,16(r2)
  80ff78:	e0bffe17 	ldw	r2,-8(fp)
  80ff7c:	10800517 	ldw	r2,20(r2)
  80ff80:	18800515 	stw	r2,20(r3)
#endif
      chHeapFree(tp);
  80ff84:	e13ffe17 	ldw	r4,-8(fp)
  80ff88:	0810e900 	call	810e90 <chHeapFree>
      break;
  80ff8c:	00000f06 	br	80ffcc <chThdRelease+0x120>
#endif
#if CH_USE_MEMPOOLS
    case THD_MEM_MODE_MEMPOOL:
#if CH_USE_REGISTRY
      REG_REMOVE(tp);
  80ff90:	e0bffe17 	ldw	r2,-8(fp)
  80ff94:	10c00517 	ldw	r3,20(r2)
  80ff98:	e0bffe17 	ldw	r2,-8(fp)
  80ff9c:	10800417 	ldw	r2,16(r2)
  80ffa0:	18800415 	stw	r2,16(r3)
  80ffa4:	e0bffe17 	ldw	r2,-8(fp)
  80ffa8:	10c00417 	ldw	r3,16(r2)
  80ffac:	e0bffe17 	ldw	r2,-8(fp)
  80ffb0:	10800517 	ldw	r2,20(r2)
  80ffb4:	18800515 	stw	r2,20(r3)
#endif
      chPoolFree(tp->p_mpool, tp);
  80ffb8:	e0bffe17 	ldw	r2,-8(fp)
  80ffbc:	10801117 	ldw	r2,68(r2)
  80ffc0:	1009883a 	mov	r4,r2
  80ffc4:	e17ffe17 	ldw	r5,-8(fp)
  80ffc8:	08113d80 	call	8113d8 <chPoolFree>
      break;
#endif
    }
  }
}
  80ffcc:	e037883a 	mov	sp,fp
  80ffd0:	dfc00117 	ldw	ra,4(sp)
  80ffd4:	df000017 	ldw	fp,0(sp)
  80ffd8:	dec00204 	addi	sp,sp,8
  80ffdc:	f800283a 	ret

0080ffe0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
Thread *chThdCreateFromHeap(MemoryHeap *heapp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
  80ffe0:	defff404 	addi	sp,sp,-48
  80ffe4:	dfc00b15 	stw	ra,44(sp)
  80ffe8:	df000a15 	stw	fp,40(sp)
  80ffec:	df000a04 	addi	fp,sp,40
  80fff0:	e13ffb15 	stw	r4,-20(fp)
  80fff4:	e17ffc15 	stw	r5,-16(fp)
  80fff8:	e1bffd15 	stw	r6,-12(fp)
  80fffc:	e1fffe15 	stw	r7,-8(fp)
  void *wsp;
  Thread *tp;

  wsp = chHeapAlloc(heapp, size);
  810000:	e13ffb17 	ldw	r4,-20(fp)
  810004:	e17ffc17 	ldw	r5,-16(fp)
  810008:	0810cd80 	call	810cd8 <chHeapAlloc>
  81000c:	e0bffa15 	stw	r2,-24(fp)
  if (wsp == NULL)
  810010:	e0bffa17 	ldw	r2,-24(fp)
  810014:	1004c03a 	cmpne	r2,r2,zero
  810018:	1000021e 	bne	r2,zero,810024 <chThdCreateFromHeap+0x44>
    return NULL;
  81001c:	e03fff15 	stw	zero,-4(fp)
  810020:	00001a06 	br	81008c <chThdCreateFromHeap+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810024:	0005303a 	rdctl	r2,status
  810028:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81002c:	e0fff817 	ldw	r3,-32(fp)
  810030:	00bfff84 	movi	r2,-2
  810034:	1884703a 	and	r2,r3,r2
  810038:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  81003c:	e0800217 	ldw	r2,8(fp)
  810040:	d8800015 	stw	r2,0(sp)
  810044:	e13ffa17 	ldw	r4,-24(fp)
  810048:	e17ffc17 	ldw	r5,-16(fp)
  81004c:	e1bffd17 	ldw	r6,-12(fp)
  810050:	e1fffe17 	ldw	r7,-8(fp)
  810054:	08124f40 	call	8124f4 <chThdCreateI>
  810058:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_HEAP;
  81005c:	e0fff917 	ldw	r3,-28(fp)
  810060:	00800044 	movi	r2,1
  810064:	18800745 	stb	r2,29(r3)
  chSchWakeupS(tp, RDY_OK);
  810068:	e13ff917 	ldw	r4,-28(fp)
  81006c:	000b883a 	mov	r5,zero
  810070:	08121e80 	call	8121e8 <chSchWakeupS>
  810074:	00800044 	movi	r2,1
  810078:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81007c:	e0bff717 	ldw	r2,-36(fp)
  810080:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  810084:	e0bff917 	ldw	r2,-28(fp)
  810088:	e0bfff15 	stw	r2,-4(fp)
  81008c:	e0bfff17 	ldw	r2,-4(fp)
}
  810090:	e037883a 	mov	sp,fp
  810094:	dfc00117 	ldw	ra,4(sp)
  810098:	df000017 	ldw	fp,0(sp)
  81009c:	dec00204 	addi	sp,sp,8
  8100a0:	f800283a 	ret

008100a4 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
Thread *chThdCreateFromMemoryPool(MemoryPool *mp, tprio_t prio,
                                  tfunc_t pf, void *arg) {
  8100a4:	defff404 	addi	sp,sp,-48
  8100a8:	dfc00b15 	stw	ra,44(sp)
  8100ac:	df000a15 	stw	fp,40(sp)
  8100b0:	df000a04 	addi	fp,sp,40
  8100b4:	e13ffb15 	stw	r4,-20(fp)
  8100b8:	e17ffc15 	stw	r5,-16(fp)
  8100bc:	e1bffd15 	stw	r6,-12(fp)
  8100c0:	e1fffe15 	stw	r7,-8(fp)
  void *wsp;
  Thread *tp;

  chDbgCheck(mp != NULL, "chThdCreateFromMemoryPool");

  wsp = chPoolAlloc(mp);
  8100c4:	e13ffb17 	ldw	r4,-20(fp)
  8100c8:	08113180 	call	811318 <chPoolAlloc>
  8100cc:	e0bffa15 	stw	r2,-24(fp)
  if (wsp == NULL)
  8100d0:	e0bffa17 	ldw	r2,-24(fp)
  8100d4:	1004c03a 	cmpne	r2,r2,zero
  8100d8:	1000021e 	bne	r2,zero,8100e4 <chThdCreateFromMemoryPool+0x40>
    return NULL;
  8100dc:	e03fff15 	stw	zero,-4(fp)
  8100e0:	00001e06 	br	81015c <chThdCreateFromMemoryPool+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8100e4:	0005303a 	rdctl	r2,status
  8100e8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8100ec:	e0fff817 	ldw	r3,-32(fp)
  8100f0:	00bfff84 	movi	r2,-2
  8100f4:	1884703a 	and	r2,r3,r2
  8100f8:	1001703a 	wrctl	status,r2
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  8100fc:	e0bffb17 	ldw	r2,-20(fp)
  810100:	11400117 	ldw	r5,4(r2)
  810104:	e0bffe17 	ldw	r2,-8(fp)
  810108:	d8800015 	stw	r2,0(sp)
  81010c:	e13ffa17 	ldw	r4,-24(fp)
  810110:	e1bffc17 	ldw	r6,-16(fp)
  810114:	e1fffd17 	ldw	r7,-12(fp)
  810118:	08124f40 	call	8124f4 <chThdCreateI>
  81011c:	e0bff915 	stw	r2,-28(fp)
  tp->p_flags = THD_MEM_MODE_MEMPOOL;
  810120:	e0fff917 	ldw	r3,-28(fp)
  810124:	00800084 	movi	r2,2
  810128:	18800745 	stb	r2,29(r3)
  tp->p_mpool = mp;
  81012c:	e0fff917 	ldw	r3,-28(fp)
  810130:	e0bffb17 	ldw	r2,-20(fp)
  810134:	18801115 	stw	r2,68(r3)
  chSchWakeupS(tp, RDY_OK);
  810138:	e13ff917 	ldw	r4,-28(fp)
  81013c:	000b883a 	mov	r5,zero
  810140:	08121e80 	call	8121e8 <chSchWakeupS>
  810144:	00800044 	movi	r2,1
  810148:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81014c:	e0bff717 	ldw	r2,-36(fp)
  810150:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  810154:	e0bff917 	ldw	r2,-28(fp)
  810158:	e0bfff15 	stw	r2,-4(fp)
  81015c:	e0bfff17 	ldw	r2,-4(fp)
}
  810160:	e037883a 	mov	sp,fp
  810164:	dfc00117 	ldw	ra,4(sp)
  810168:	df000017 	ldw	fp,0(sp)
  81016c:	dec00204 	addi	sp,sp,8
  810170:	f800283a 	ret

00810174 <chEvtRegisterMask>:
 * @param[in] mask      the mask of event flags to be ORed to the thread when
 *                      the event source is broadcasted
 *
 * @api
 */
void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
  810174:	defffa04 	addi	sp,sp,-24
  810178:	df000515 	stw	fp,20(sp)
  81017c:	df000504 	addi	fp,sp,20
  810180:	e13ffd15 	stw	r4,-12(fp)
  810184:	e17ffe15 	stw	r5,-8(fp)
  810188:	e1bfff15 	stw	r6,-4(fp)

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");
  81018c:	e0bffd17 	ldw	r2,-12(fp)
  810190:	1005003a 	cmpeq	r2,r2,zero
  810194:	1000001e 	bne	r2,zero,810198 <chEvtRegisterMask+0x24>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810198:	0005303a 	rdctl	r2,status
  81019c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8101a0:	e0fffc17 	ldw	r3,-16(fp)
  8101a4:	00bfff84 	movi	r2,-2
  8101a8:	1884703a 	and	r2,r3,r2
  8101ac:	1001703a 	wrctl	status,r2

  chSysLock();
  elp->el_next = esp->es_next;
  8101b0:	e0bffd17 	ldw	r2,-12(fp)
  8101b4:	10c00017 	ldw	r3,0(r2)
  8101b8:	e0bffe17 	ldw	r2,-8(fp)
  8101bc:	10c00015 	stw	r3,0(r2)
  esp->es_next = elp;
  8101c0:	e0fffd17 	ldw	r3,-12(fp)
  8101c4:	e0bffe17 	ldw	r2,-8(fp)
  8101c8:	18800015 	stw	r2,0(r3)
  elp->el_listener = currp;
  8101cc:	00802134 	movhi	r2,132
  8101d0:	10ba9c04 	addi	r2,r2,-5520
  8101d4:	10c00717 	ldw	r3,28(r2)
  8101d8:	e0bffe17 	ldw	r2,-8(fp)
  8101dc:	10c00115 	stw	r3,4(r2)
  elp->el_mask = mask;
  8101e0:	e0fffe17 	ldw	r3,-8(fp)
  8101e4:	e0bfff17 	ldw	r2,-4(fp)
  8101e8:	18800215 	stw	r2,8(r3)
  8101ec:	00800044 	movi	r2,1
  8101f0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8101f4:	e0bffb17 	ldw	r2,-20(fp)
  8101f8:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  8101fc:	e037883a 	mov	sp,fp
  810200:	df000017 	ldw	fp,0(sp)
  810204:	dec00104 	addi	sp,sp,4
  810208:	f800283a 	ret

0081020c <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p EventSource structure
 * @param[in] elp       pointer to the @p EventListener structure
 *
 * @api
 */
void chEvtUnregister(EventSource *esp, EventListener *elp) {
  81020c:	defffa04 	addi	sp,sp,-24
  810210:	df000515 	stw	fp,20(sp)
  810214:	df000504 	addi	fp,sp,20
  810218:	e13ffe15 	stw	r4,-8(fp)
  81021c:	e17fff15 	stw	r5,-4(fp)
  EventListener *p;

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");
  810220:	e0bffe17 	ldw	r2,-8(fp)
  810224:	1005003a 	cmpeq	r2,r2,zero
  810228:	1000001e 	bne	r2,zero,81022c <chEvtUnregister+0x20>

  p = (EventListener *)esp;
  81022c:	e0bffe17 	ldw	r2,-8(fp)
  810230:	e0bffd15 	stw	r2,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810234:	0005303a 	rdctl	r2,status
  810238:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81023c:	e0fffc17 	ldw	r3,-16(fp)
  810240:	00bfff84 	movi	r2,-2
  810244:	1884703a 	and	r2,r3,r2
  810248:	1001703a 	wrctl	status,r2
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
  81024c:	00000c06 	br	810280 <chEvtUnregister+0x74>
    if (p->el_next == elp) {
  810250:	e0bffd17 	ldw	r2,-12(fp)
  810254:	10c00017 	ldw	r3,0(r2)
  810258:	e0bfff17 	ldw	r2,-4(fp)
  81025c:	1880051e 	bne	r3,r2,810274 <chEvtUnregister+0x68>
      p->el_next = elp->el_next;
  810260:	e0bfff17 	ldw	r2,-4(fp)
  810264:	10c00017 	ldw	r3,0(r2)
  810268:	e0bffd17 	ldw	r2,-12(fp)
  81026c:	10c00015 	stw	r3,0(r2)
      break;
  810270:	00000706 	br	810290 <chEvtUnregister+0x84>
    }
    p = p->el_next;
  810274:	e0bffd17 	ldw	r2,-12(fp)
  810278:	10800017 	ldw	r2,0(r2)
  81027c:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");

  p = (EventListener *)esp;
  chSysLock();
  while (p->el_next != (EventListener *)esp) {
  810280:	e0bffd17 	ldw	r2,-12(fp)
  810284:	10c00017 	ldw	r3,0(r2)
  810288:	e0bffe17 	ldw	r2,-8(fp)
  81028c:	18bff01e 	bne	r3,r2,810250 <chEvtUnregister+0x44>
  810290:	00800044 	movi	r2,1
  810294:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810298:	e0bffb17 	ldw	r2,-20(fp)
  81029c:	1001703a 	wrctl	status,r2
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
}
  8102a0:	e037883a 	mov	sp,fp
  8102a4:	df000017 	ldw	fp,0(sp)
  8102a8:	dec00104 	addi	sp,sp,4
  8102ac:	f800283a 	ret

008102b0 <chEvtClearFlags>:
 * @param[in] mask      the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtClearFlags(eventmask_t mask) {
  8102b0:	defffb04 	addi	sp,sp,-20
  8102b4:	df000415 	stw	fp,16(sp)
  8102b8:	df000404 	addi	fp,sp,16
  8102bc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8102c0:	0005303a 	rdctl	r2,status
  8102c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8102c8:	e0fffd17 	ldw	r3,-12(fp)
  8102cc:	00bfff84 	movi	r2,-2
  8102d0:	1884703a 	and	r2,r3,r2
  8102d4:	1001703a 	wrctl	status,r2
  eventmask_t m;

  chSysLock();

  m = currp->p_epending & mask;
  8102d8:	00802134 	movhi	r2,132
  8102dc:	10ba9c04 	addi	r2,r2,-5520
  8102e0:	10800717 	ldw	r2,28(r2)
  8102e4:	10c00e17 	ldw	r3,56(r2)
  8102e8:	e0bfff17 	ldw	r2,-4(fp)
  8102ec:	1884703a 	and	r2,r3,r2
  8102f0:	e0bffe15 	stw	r2,-8(fp)
  currp->p_epending &= ~mask;
  8102f4:	00802134 	movhi	r2,132
  8102f8:	10ba9c04 	addi	r2,r2,-5520
  8102fc:	11000717 	ldw	r4,28(r2)
  810300:	00802134 	movhi	r2,132
  810304:	10ba9c04 	addi	r2,r2,-5520
  810308:	10800717 	ldw	r2,28(r2)
  81030c:	10c00e17 	ldw	r3,56(r2)
  810310:	e0bfff17 	ldw	r2,-4(fp)
  810314:	0084303a 	nor	r2,zero,r2
  810318:	1884703a 	and	r2,r3,r2
  81031c:	20800e15 	stw	r2,56(r4)
  810320:	00800044 	movi	r2,1
  810324:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810328:	e0bffc17 	ldw	r2,-16(fp)
  81032c:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return m;
  810330:	e0bffe17 	ldw	r2,-8(fp)
}
  810334:	e037883a 	mov	sp,fp
  810338:	df000017 	ldw	fp,0(sp)
  81033c:	dec00104 	addi	sp,sp,4
  810340:	f800283a 	ret

00810344 <chEvtAddFlags>:
 * @param[in] mask      the event flags to be ORed
 * @return              The current pending events mask.
 *
 * @api
 */
eventmask_t chEvtAddFlags(eventmask_t mask) {
  810344:	defffc04 	addi	sp,sp,-16
  810348:	df000315 	stw	fp,12(sp)
  81034c:	df000304 	addi	fp,sp,12
  810350:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810354:	0005303a 	rdctl	r2,status
  810358:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81035c:	e0fffe17 	ldw	r3,-8(fp)
  810360:	00bfff84 	movi	r2,-2
  810364:	1884703a 	and	r2,r3,r2
  810368:	1001703a 	wrctl	status,r2

  chSysLock();

  mask = (currp->p_epending |= mask);
  81036c:	00802134 	movhi	r2,132
  810370:	10ba9c04 	addi	r2,r2,-5520
  810374:	11000717 	ldw	r4,28(r2)
  810378:	00802134 	movhi	r2,132
  81037c:	10ba9c04 	addi	r2,r2,-5520
  810380:	10800717 	ldw	r2,28(r2)
  810384:	10c00e17 	ldw	r3,56(r2)
  810388:	e0bfff17 	ldw	r2,-4(fp)
  81038c:	1884b03a 	or	r2,r3,r2
  810390:	20800e15 	stw	r2,56(r4)
  810394:	20800e17 	ldw	r2,56(r4)
  810398:	e0bfff15 	stw	r2,-4(fp)
  81039c:	00800044 	movi	r2,1
  8103a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8103a4:	e0bffd17 	ldw	r2,-12(fp)
  8103a8:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return mask;
  8103ac:	e0bfff17 	ldw	r2,-4(fp)
}
  8103b0:	e037883a 	mov	sp,fp
  8103b4:	df000017 	ldw	fp,0(sp)
  8103b8:	dec00104 	addi	sp,sp,4
  8103bc:	f800283a 	ret

008103c0 <chEvtSignalFlags>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtSignalFlags(Thread *tp, eventmask_t mask) {
  8103c0:	defffa04 	addi	sp,sp,-24
  8103c4:	dfc00515 	stw	ra,20(sp)
  8103c8:	df000415 	stw	fp,16(sp)
  8103cc:	df000404 	addi	fp,sp,16
  8103d0:	e13ffe15 	stw	r4,-8(fp)
  8103d4:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8103d8:	0005303a 	rdctl	r2,status
  8103dc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8103e0:	e0fffd17 	ldw	r3,-12(fp)
  8103e4:	00bfff84 	movi	r2,-2
  8103e8:	1884703a 	and	r2,r3,r2
  8103ec:	1001703a 	wrctl	status,r2

  chDbgCheck(tp != NULL, "chEvtSignal");

  chSysLock();
  chEvtSignalFlagsI(tp, mask);
  8103f0:	e13ffe17 	ldw	r4,-8(fp)
  8103f4:	e17fff17 	ldw	r5,-4(fp)
  8103f8:	08104240 	call	810424 <chEvtSignalFlagsI>
  chSchRescheduleS();
  8103fc:	08122940 	call	812294 <chSchRescheduleS>
  810400:	00800044 	movi	r2,1
  810404:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810408:	e0bffc17 	ldw	r2,-16(fp)
  81040c:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  810410:	e037883a 	mov	sp,fp
  810414:	dfc00117 	ldw	ra,4(sp)
  810418:	df000017 	ldw	fp,0(sp)
  81041c:	dec00204 	addi	sp,sp,8
  810420:	f800283a 	ret

00810424 <chEvtSignalFlagsI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalFlagsI(Thread *tp, eventmask_t mask) {
  810424:	defffc04 	addi	sp,sp,-16
  810428:	dfc00315 	stw	ra,12(sp)
  81042c:	df000215 	stw	fp,8(sp)
  810430:	df000204 	addi	fp,sp,8
  810434:	e13ffe15 	stw	r4,-8(fp)
  810438:	e17fff15 	stw	r5,-4(fp)

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  81043c:	e0bffe17 	ldw	r2,-8(fp)
  810440:	10c00e17 	ldw	r3,56(r2)
  810444:	e0bfff17 	ldw	r2,-4(fp)
  810448:	1886b03a 	or	r3,r3,r2
  81044c:	e0bffe17 	ldw	r2,-8(fp)
  810450:	10c00e15 	stw	r3,56(r2)
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
  810454:	e0bffe17 	ldw	r2,-8(fp)
  810458:	10800703 	ldbu	r2,28(r2)
  81045c:	10803fcc 	andi	r2,r2,255
  810460:	10800218 	cmpnei	r2,r2,8
  810464:	1000071e 	bne	r2,zero,810484 <chEvtSignalFlagsI+0x60>
  810468:	e0bffe17 	ldw	r2,-8(fp)
  81046c:	10c00e17 	ldw	r3,56(r2)
  810470:	e0bffe17 	ldw	r2,-8(fp)
  810474:	10800917 	ldw	r2,36(r2)
  810478:	1884703a 	and	r2,r3,r2
  81047c:	1004c03a 	cmpne	r2,r2,zero
  810480:	10000d1e 	bne	r2,zero,8104b8 <chEvtSignalFlagsI+0x94>
  810484:	e0bffe17 	ldw	r2,-8(fp)
  810488:	10800703 	ldbu	r2,28(r2)
  81048c:	10803fcc 	andi	r2,r2,255
  810490:	10800258 	cmpnei	r2,r2,9
  810494:	10000b1e 	bne	r2,zero,8104c4 <chEvtSignalFlagsI+0xa0>
  810498:	e0bffe17 	ldw	r2,-8(fp)
  81049c:	10c00e17 	ldw	r3,56(r2)
  8104a0:	e0bffe17 	ldw	r2,-8(fp)
  8104a4:	10800917 	ldw	r2,36(r2)
  8104a8:	1886703a 	and	r3,r3,r2
  8104ac:	e0bffe17 	ldw	r2,-8(fp)
  8104b0:	10800917 	ldw	r2,36(r2)
  8104b4:	1880031e 	bne	r3,r2,8104c4 <chEvtSignalFlagsI+0xa0>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
  8104b8:	e13ffe17 	ldw	r4,-8(fp)
  8104bc:	0811ec40 	call	811ec4 <chSchReadyI>
  8104c0:	10000915 	stw	zero,36(r2)
}
  8104c4:	e037883a 	mov	sp,fp
  8104c8:	dfc00117 	ldw	ra,4(sp)
  8104cc:	df000017 	ldw	fp,0(sp)
  8104d0:	dec00204 	addi	sp,sp,8
  8104d4:	f800283a 	ret

008104d8 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] mask      the event flags set to be ORed
 *
 * @api
 */
void chEvtBroadcastFlags(EventSource *esp, eventmask_t mask) {
  8104d8:	defffa04 	addi	sp,sp,-24
  8104dc:	dfc00515 	stw	ra,20(sp)
  8104e0:	df000415 	stw	fp,16(sp)
  8104e4:	df000404 	addi	fp,sp,16
  8104e8:	e13ffe15 	stw	r4,-8(fp)
  8104ec:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8104f0:	0005303a 	rdctl	r2,status
  8104f4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8104f8:	e0fffd17 	ldw	r3,-12(fp)
  8104fc:	00bfff84 	movi	r2,-2
  810500:	1884703a 	and	r2,r3,r2
  810504:	1001703a 	wrctl	status,r2

  chSysLock();
  chEvtBroadcastFlagsI(esp, mask);
  810508:	e13ffe17 	ldw	r4,-8(fp)
  81050c:	e17fff17 	ldw	r5,-4(fp)
  810510:	081053c0 	call	81053c <chEvtBroadcastFlagsI>
  chSchRescheduleS();
  810514:	08122940 	call	812294 <chSchRescheduleS>
  810518:	00800044 	movi	r2,1
  81051c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810520:	e0bffc17 	ldw	r2,-16(fp)
  810524:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  810528:	e037883a 	mov	sp,fp
  81052c:	dfc00117 	ldw	ra,4(sp)
  810530:	df000017 	ldw	fp,0(sp)
  810534:	dec00204 	addi	sp,sp,8
  810538:	f800283a 	ret

0081053c <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, eventmask_t mask) {
  81053c:	defffb04 	addi	sp,sp,-20
  810540:	dfc00415 	stw	ra,16(sp)
  810544:	df000315 	stw	fp,12(sp)
  810548:	df000304 	addi	fp,sp,12
  81054c:	e13ffe15 	stw	r4,-8(fp)
  810550:	e17fff15 	stw	r5,-4(fp)
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  810554:	e0bffe17 	ldw	r2,-8(fp)
  810558:	10800017 	ldw	r2,0(r2)
  81055c:	e0bffd15 	stw	r2,-12(fp)
  while (elp != (EventListener *)esp) {
  810560:	00000a06 	br	81058c <chEvtBroadcastFlagsI+0x50>
    chEvtSignalFlagsI(elp->el_listener, elp->el_mask | mask);
  810564:	e0bffd17 	ldw	r2,-12(fp)
  810568:	11000117 	ldw	r4,4(r2)
  81056c:	e0bffd17 	ldw	r2,-12(fp)
  810570:	10c00217 	ldw	r3,8(r2)
  810574:	e0bfff17 	ldw	r2,-4(fp)
  810578:	188ab03a 	or	r5,r3,r2
  81057c:	08104240 	call	810424 <chEvtSignalFlagsI>
    elp = elp->el_next;
  810580:	e0bffd17 	ldw	r2,-12(fp)
  810584:	10800017 	ldw	r2,0(r2)
  810588:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
  81058c:	e0fffe17 	ldw	r3,-8(fp)
  810590:	e0bffd17 	ldw	r2,-12(fp)
  810594:	10fff31e 	bne	r2,r3,810564 <chEvtBroadcastFlagsI+0x28>
    chEvtSignalFlagsI(elp->el_listener, elp->el_mask | mask);
    elp = elp->el_next;
  }
}
  810598:	e037883a 	mov	sp,fp
  81059c:	dfc00117 	ldw	ra,4(sp)
  8105a0:	df000017 	ldw	fp,0(sp)
  8105a4:	dec00204 	addi	sp,sp,8
  8105a8:	f800283a 	ret

008105ac <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
  8105ac:	defffb04 	addi	sp,sp,-20
  8105b0:	dfc00415 	stw	ra,16(sp)
  8105b4:	df000315 	stw	fp,12(sp)
  8105b8:	df000304 	addi	fp,sp,12
  8105bc:	e13ffe15 	stw	r4,-8(fp)
  8105c0:	e17fff15 	stw	r5,-4(fp)
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  8105c4:	e03ffd15 	stw	zero,-12(fp)
  while (mask) {
  8105c8:	00001b06 	br	810638 <chEvtDispatch+0x8c>
    if (mask & EVENT_MASK(eid)) {
  8105cc:	00c00044 	movi	r3,1
  8105d0:	e0bffd17 	ldw	r2,-12(fp)
  8105d4:	1884983a 	sll	r2,r3,r2
  8105d8:	1007883a 	mov	r3,r2
  8105dc:	e0bfff17 	ldw	r2,-4(fp)
  8105e0:	1884703a 	and	r2,r3,r2
  8105e4:	1005003a 	cmpeq	r2,r2,zero
  8105e8:	1000101e 	bne	r2,zero,81062c <chEvtDispatch+0x80>
      chDbgAssert(handlers[eid] != NULL,
                  "chEvtDispatch(), #1",
                  "null handler");
      mask &= ~EVENT_MASK(eid);
  8105ec:	00c00044 	movi	r3,1
  8105f0:	e0bffd17 	ldw	r2,-12(fp)
  8105f4:	1884983a 	sll	r2,r3,r2
  8105f8:	0086303a 	nor	r3,zero,r2
  8105fc:	e0bfff17 	ldw	r2,-4(fp)
  810600:	10c4703a 	and	r2,r2,r3
  810604:	e0bfff15 	stw	r2,-4(fp)
      handlers[eid](eid);
  810608:	e0bffd17 	ldw	r2,-12(fp)
  81060c:	1085883a 	add	r2,r2,r2
  810610:	1085883a 	add	r2,r2,r2
  810614:	1007883a 	mov	r3,r2
  810618:	e0bffe17 	ldw	r2,-8(fp)
  81061c:	1885883a 	add	r2,r3,r2
  810620:	10800017 	ldw	r2,0(r2)
  810624:	e13ffd17 	ldw	r4,-12(fp)
  810628:	103ee83a 	callr	r2
    }
    eid++;
  81062c:	e0bffd17 	ldw	r2,-12(fp)
  810630:	10800044 	addi	r2,r2,1
  810634:	e0bffd15 	stw	r2,-12(fp)
  eventid_t eid;

  chDbgCheck(handlers != NULL, "chEvtDispatch");

  eid = 0;
  while (mask) {
  810638:	e0bfff17 	ldw	r2,-4(fp)
  81063c:	1004c03a 	cmpne	r2,r2,zero
  810640:	103fe21e 	bne	r2,zero,8105cc <chEvtDispatch+0x20>
      mask &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
  810644:	e037883a 	mov	sp,fp
  810648:	dfc00117 	ldw	ra,4(sp)
  81064c:	df000017 	ldw	fp,0(sp)
  810650:	dec00204 	addi	sp,sp,8
  810654:	f800283a 	ret

00810658 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest id served and cleared event.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t mask) {
  810658:	defff904 	addi	sp,sp,-28
  81065c:	dfc00615 	stw	ra,24(sp)
  810660:	df000515 	stw	fp,20(sp)
  810664:	df000504 	addi	fp,sp,20
  810668:	e13fff15 	stw	r4,-4(fp)
  Thread *ctp = currp;
  81066c:	00802134 	movhi	r2,132
  810670:	10ba9c04 	addi	r2,r2,-5520
  810674:	10800717 	ldw	r2,28(r2)
  810678:	e0bffe15 	stw	r2,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81067c:	0005303a 	rdctl	r2,status
  810680:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810684:	e0fffc17 	ldw	r3,-16(fp)
  810688:	00bfff84 	movi	r2,-2
  81068c:	1884703a 	and	r2,r3,r2
  810690:	1001703a 	wrctl	status,r2
  eventmask_t m;

  chSysLock();

  if ((m = (ctp->p_epending & mask)) == 0) {
  810694:	e0bffe17 	ldw	r2,-8(fp)
  810698:	10c00e17 	ldw	r3,56(r2)
  81069c:	e0bfff17 	ldw	r2,-4(fp)
  8106a0:	1884703a 	and	r2,r3,r2
  8106a4:	e0bffd15 	stw	r2,-12(fp)
  8106a8:	e0bffd17 	ldw	r2,-12(fp)
  8106ac:	1004c03a 	cmpne	r2,r2,zero
  8106b0:	10000a1e 	bne	r2,zero,8106dc <chEvtWaitOne+0x84>
    ctp->p_u.ewmask = mask;
  8106b4:	e0fffe17 	ldw	r3,-8(fp)
  8106b8:	e0bfff17 	ldw	r2,-4(fp)
  8106bc:	18800915 	stw	r2,36(r3)
    chSchGoSleepS(THD_STATE_WTOREVT);
  8106c0:	01000204 	movi	r4,8
  8106c4:	0811f6c0 	call	811f6c <chSchGoSleepS>
    m = ctp->p_epending & mask;
  8106c8:	e0bffe17 	ldw	r2,-8(fp)
  8106cc:	10c00e17 	ldw	r3,56(r2)
  8106d0:	e0bfff17 	ldw	r2,-4(fp)
  8106d4:	1884703a 	and	r2,r3,r2
  8106d8:	e0bffd15 	stw	r2,-12(fp)
  }
  m &= -m;
  8106dc:	e0bffd17 	ldw	r2,-12(fp)
  8106e0:	0087c83a 	sub	r3,zero,r2
  8106e4:	e0bffd17 	ldw	r2,-12(fp)
  8106e8:	10c4703a 	and	r2,r2,r3
  8106ec:	e0bffd15 	stw	r2,-12(fp)
  ctp->p_epending &= ~m;
  8106f0:	e0bffe17 	ldw	r2,-8(fp)
  8106f4:	10c00e17 	ldw	r3,56(r2)
  8106f8:	e0bffd17 	ldw	r2,-12(fp)
  8106fc:	0084303a 	nor	r2,zero,r2
  810700:	1886703a 	and	r3,r3,r2
  810704:	e0bffe17 	ldw	r2,-8(fp)
  810708:	10c00e15 	stw	r3,56(r2)
  81070c:	00800044 	movi	r2,1
  810710:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810714:	e0bffb17 	ldw	r2,-20(fp)
  810718:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return m;
  81071c:	e0bffd17 	ldw	r2,-12(fp)
}
  810720:	e037883a 	mov	sp,fp
  810724:	dfc00117 	ldw	ra,4(sp)
  810728:	df000017 	ldw	fp,0(sp)
  81072c:	dec00204 	addi	sp,sp,8
  810730:	f800283a 	ret

00810734 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
  810734:	defff904 	addi	sp,sp,-28
  810738:	dfc00615 	stw	ra,24(sp)
  81073c:	df000515 	stw	fp,20(sp)
  810740:	df000504 	addi	fp,sp,20
  810744:	e13fff15 	stw	r4,-4(fp)
  Thread *ctp = currp;
  810748:	00802134 	movhi	r2,132
  81074c:	10ba9c04 	addi	r2,r2,-5520
  810750:	10800717 	ldw	r2,28(r2)
  810754:	e0bffe15 	stw	r2,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810758:	0005303a 	rdctl	r2,status
  81075c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810760:	e0fffc17 	ldw	r3,-16(fp)
  810764:	00bfff84 	movi	r2,-2
  810768:	1884703a 	and	r2,r3,r2
  81076c:	1001703a 	wrctl	status,r2
  eventmask_t m;

  chSysLock();

  if ((m = (ctp->p_epending & mask)) == 0) {
  810770:	e0bffe17 	ldw	r2,-8(fp)
  810774:	10c00e17 	ldw	r3,56(r2)
  810778:	e0bfff17 	ldw	r2,-4(fp)
  81077c:	1884703a 	and	r2,r3,r2
  810780:	e0bffd15 	stw	r2,-12(fp)
  810784:	e0bffd17 	ldw	r2,-12(fp)
  810788:	1004c03a 	cmpne	r2,r2,zero
  81078c:	10000a1e 	bne	r2,zero,8107b8 <chEvtWaitAny+0x84>
    ctp->p_u.ewmask = mask;
  810790:	e0fffe17 	ldw	r3,-8(fp)
  810794:	e0bfff17 	ldw	r2,-4(fp)
  810798:	18800915 	stw	r2,36(r3)
    chSchGoSleepS(THD_STATE_WTOREVT);
  81079c:	01000204 	movi	r4,8
  8107a0:	0811f6c0 	call	811f6c <chSchGoSleepS>
    m = ctp->p_epending & mask;
  8107a4:	e0bffe17 	ldw	r2,-8(fp)
  8107a8:	10c00e17 	ldw	r3,56(r2)
  8107ac:	e0bfff17 	ldw	r2,-4(fp)
  8107b0:	1884703a 	and	r2,r3,r2
  8107b4:	e0bffd15 	stw	r2,-12(fp)
  }
  ctp->p_epending &= ~m;
  8107b8:	e0bffe17 	ldw	r2,-8(fp)
  8107bc:	10c00e17 	ldw	r3,56(r2)
  8107c0:	e0bffd17 	ldw	r2,-12(fp)
  8107c4:	0084303a 	nor	r2,zero,r2
  8107c8:	1886703a 	and	r3,r3,r2
  8107cc:	e0bffe17 	ldw	r2,-8(fp)
  8107d0:	10c00e15 	stw	r3,56(r2)
  8107d4:	00800044 	movi	r2,1
  8107d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8107dc:	e0bffb17 	ldw	r2,-20(fp)
  8107e0:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return m;
  8107e4:	e0bffd17 	ldw	r2,-12(fp)
}
  8107e8:	e037883a 	mov	sp,fp
  8107ec:	dfc00117 	ldw	ra,4(sp)
  8107f0:	df000017 	ldw	fp,0(sp)
  8107f4:	dec00204 	addi	sp,sp,8
  8107f8:	f800283a 	ret

008107fc <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t mask) {
  8107fc:	defffa04 	addi	sp,sp,-24
  810800:	dfc00515 	stw	ra,20(sp)
  810804:	df000415 	stw	fp,16(sp)
  810808:	df000404 	addi	fp,sp,16
  81080c:	e13fff15 	stw	r4,-4(fp)
  Thread *ctp = currp;
  810810:	00802134 	movhi	r2,132
  810814:	10ba9c04 	addi	r2,r2,-5520
  810818:	10800717 	ldw	r2,28(r2)
  81081c:	e0bffe15 	stw	r2,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810820:	0005303a 	rdctl	r2,status
  810824:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810828:	e0fffd17 	ldw	r3,-12(fp)
  81082c:	00bfff84 	movi	r2,-2
  810830:	1884703a 	and	r2,r3,r2
  810834:	1001703a 	wrctl	status,r2

  chSysLock();

  if ((ctp->p_epending & mask) != mask) {
  810838:	e0bffe17 	ldw	r2,-8(fp)
  81083c:	10c00e17 	ldw	r3,56(r2)
  810840:	e0bfff17 	ldw	r2,-4(fp)
  810844:	1886703a 	and	r3,r3,r2
  810848:	e0bfff17 	ldw	r2,-4(fp)
  81084c:	18800526 	beq	r3,r2,810864 <chEvtWaitAll+0x68>
    ctp->p_u.ewmask = mask;
  810850:	e0fffe17 	ldw	r3,-8(fp)
  810854:	e0bfff17 	ldw	r2,-4(fp)
  810858:	18800915 	stw	r2,36(r3)
    chSchGoSleepS(THD_STATE_WTANDEVT);
  81085c:	01000244 	movi	r4,9
  810860:	0811f6c0 	call	811f6c <chSchGoSleepS>
  }
  ctp->p_epending &= ~mask;
  810864:	e0bffe17 	ldw	r2,-8(fp)
  810868:	10c00e17 	ldw	r3,56(r2)
  81086c:	e0bfff17 	ldw	r2,-4(fp)
  810870:	0084303a 	nor	r2,zero,r2
  810874:	1886703a 	and	r3,r3,r2
  810878:	e0bffe17 	ldw	r2,-8(fp)
  81087c:	10c00e15 	stw	r3,56(r2)
  810880:	00800044 	movi	r2,1
  810884:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810888:	e0bffc17 	ldw	r2,-16(fp)
  81088c:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return mask;
  810890:	e0bfff17 	ldw	r2,-4(fp)
}
  810894:	e037883a 	mov	sp,fp
  810898:	dfc00117 	ldw	ra,4(sp)
  81089c:	df000017 	ldw	fp,0(sp)
  8108a0:	dec00204 	addi	sp,sp,8
  8108a4:	f800283a 	ret

008108a8 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest id served and cleared event.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
  8108a8:	defff504 	addi	sp,sp,-44
  8108ac:	dfc00a15 	stw	ra,40(sp)
  8108b0:	df000915 	stw	fp,36(sp)
  8108b4:	df000904 	addi	fp,sp,36
  8108b8:	e13ffd15 	stw	r4,-12(fp)
  8108bc:	e17ffe15 	stw	r5,-8(fp)
  Thread *ctp = currp;
  8108c0:	00802134 	movhi	r2,132
  8108c4:	10ba9c04 	addi	r2,r2,-5520
  8108c8:	10800717 	ldw	r2,28(r2)
  8108cc:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8108d0:	0005303a 	rdctl	r2,status
  8108d4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8108d8:	e0fffa17 	ldw	r3,-24(fp)
  8108dc:	00bfff84 	movi	r2,-2
  8108e0:	1884703a 	and	r2,r3,r2
  8108e4:	1001703a 	wrctl	status,r2
  eventmask_t m;

  chSysLock();

  if ((m = (ctp->p_epending & mask)) == 0) {
  8108e8:	e0bffc17 	ldw	r2,-16(fp)
  8108ec:	10c00e17 	ldw	r3,56(r2)
  8108f0:	e0bffd17 	ldw	r2,-12(fp)
  8108f4:	1884703a 	and	r2,r3,r2
  8108f8:	e0bffb15 	stw	r2,-20(fp)
  8108fc:	e0bffb17 	ldw	r2,-20(fp)
  810900:	1004c03a 	cmpne	r2,r2,zero
  810904:	10001c1e 	bne	r2,zero,810978 <chEvtWaitOneTimeout+0xd0>
    if (TIME_IMMEDIATE == time) {
  810908:	e0bffe17 	ldw	r2,-8(fp)
  81090c:	1004c03a 	cmpne	r2,r2,zero
  810910:	1000061e 	bne	r2,zero,81092c <chEvtWaitOneTimeout+0x84>
  810914:	00800044 	movi	r2,1
  810918:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81091c:	e0bff917 	ldw	r2,-28(fp)
  810920:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  810924:	e03fff15 	stw	zero,-4(fp)
  810928:	00002506 	br	8109c0 <chEvtWaitOneTimeout+0x118>
    }
    ctp->p_u.ewmask = mask;
  81092c:	e0fffc17 	ldw	r3,-16(fp)
  810930:	e0bffd17 	ldw	r2,-12(fp)
  810934:	18800915 	stw	r2,36(r3)
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
  810938:	01000204 	movi	r4,8
  81093c:	e17ffe17 	ldw	r5,-8(fp)
  810940:	08121580 	call	812158 <chSchGoSleepTimeoutS>
  810944:	1004403a 	cmpge	r2,r2,zero
  810948:	1000061e 	bne	r2,zero,810964 <chEvtWaitOneTimeout+0xbc>
  81094c:	00800044 	movi	r2,1
  810950:	e0bff815 	stw	r2,-32(fp)
  810954:	e0bff817 	ldw	r2,-32(fp)
  810958:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  81095c:	e03fff15 	stw	zero,-4(fp)
  810960:	00001706 	br	8109c0 <chEvtWaitOneTimeout+0x118>
    }
    m = ctp->p_epending & mask;
  810964:	e0bffc17 	ldw	r2,-16(fp)
  810968:	10c00e17 	ldw	r3,56(r2)
  81096c:	e0bffd17 	ldw	r2,-12(fp)
  810970:	1884703a 	and	r2,r3,r2
  810974:	e0bffb15 	stw	r2,-20(fp)
  }
  m &= -m;
  810978:	e0bffb17 	ldw	r2,-20(fp)
  81097c:	0087c83a 	sub	r3,zero,r2
  810980:	e0bffb17 	ldw	r2,-20(fp)
  810984:	10c4703a 	and	r2,r2,r3
  810988:	e0bffb15 	stw	r2,-20(fp)
  ctp->p_epending &= ~m;
  81098c:	e0bffc17 	ldw	r2,-16(fp)
  810990:	10c00e17 	ldw	r3,56(r2)
  810994:	e0bffb17 	ldw	r2,-20(fp)
  810998:	0084303a 	nor	r2,zero,r2
  81099c:	1886703a 	and	r3,r3,r2
  8109a0:	e0bffc17 	ldw	r2,-16(fp)
  8109a4:	10c00e15 	stw	r3,56(r2)
  8109a8:	00800044 	movi	r2,1
  8109ac:	e0bff715 	stw	r2,-36(fp)
  8109b0:	e0bff717 	ldw	r2,-36(fp)
  8109b4:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return m;
  8109b8:	e0bffb17 	ldw	r2,-20(fp)
  8109bc:	e0bfff15 	stw	r2,-4(fp)
  8109c0:	e0bfff17 	ldw	r2,-4(fp)
}
  8109c4:	e037883a 	mov	sp,fp
  8109c8:	dfc00117 	ldw	ra,4(sp)
  8109cc:	df000017 	ldw	fp,0(sp)
  8109d0:	dec00204 	addi	sp,sp,8
  8109d4:	f800283a 	ret

008109d8 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
  8109d8:	defff504 	addi	sp,sp,-44
  8109dc:	dfc00a15 	stw	ra,40(sp)
  8109e0:	df000915 	stw	fp,36(sp)
  8109e4:	df000904 	addi	fp,sp,36
  8109e8:	e13ffd15 	stw	r4,-12(fp)
  8109ec:	e17ffe15 	stw	r5,-8(fp)
  Thread *ctp = currp;
  8109f0:	00802134 	movhi	r2,132
  8109f4:	10ba9c04 	addi	r2,r2,-5520
  8109f8:	10800717 	ldw	r2,28(r2)
  8109fc:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810a00:	0005303a 	rdctl	r2,status
  810a04:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810a08:	e0fffa17 	ldw	r3,-24(fp)
  810a0c:	00bfff84 	movi	r2,-2
  810a10:	1884703a 	and	r2,r3,r2
  810a14:	1001703a 	wrctl	status,r2
  eventmask_t m;

  chSysLock();

  if ((m = (ctp->p_epending & mask)) == 0) {
  810a18:	e0bffc17 	ldw	r2,-16(fp)
  810a1c:	10c00e17 	ldw	r3,56(r2)
  810a20:	e0bffd17 	ldw	r2,-12(fp)
  810a24:	1884703a 	and	r2,r3,r2
  810a28:	e0bffb15 	stw	r2,-20(fp)
  810a2c:	e0bffb17 	ldw	r2,-20(fp)
  810a30:	1004c03a 	cmpne	r2,r2,zero
  810a34:	10001c1e 	bne	r2,zero,810aa8 <chEvtWaitAnyTimeout+0xd0>
    if (TIME_IMMEDIATE == time) {
  810a38:	e0bffe17 	ldw	r2,-8(fp)
  810a3c:	1004c03a 	cmpne	r2,r2,zero
  810a40:	1000061e 	bne	r2,zero,810a5c <chEvtWaitAnyTimeout+0x84>
  810a44:	00800044 	movi	r2,1
  810a48:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810a4c:	e0bff917 	ldw	r2,-28(fp)
  810a50:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  810a54:	e03fff15 	stw	zero,-4(fp)
  810a58:	00002006 	br	810adc <chEvtWaitAnyTimeout+0x104>
    }
    ctp->p_u.ewmask = mask;
  810a5c:	e0fffc17 	ldw	r3,-16(fp)
  810a60:	e0bffd17 	ldw	r2,-12(fp)
  810a64:	18800915 	stw	r2,36(r3)
    if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
  810a68:	01000204 	movi	r4,8
  810a6c:	e17ffe17 	ldw	r5,-8(fp)
  810a70:	08121580 	call	812158 <chSchGoSleepTimeoutS>
  810a74:	1004403a 	cmpge	r2,r2,zero
  810a78:	1000061e 	bne	r2,zero,810a94 <chEvtWaitAnyTimeout+0xbc>
  810a7c:	00800044 	movi	r2,1
  810a80:	e0bff815 	stw	r2,-32(fp)
  810a84:	e0bff817 	ldw	r2,-32(fp)
  810a88:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  810a8c:	e03fff15 	stw	zero,-4(fp)
  810a90:	00001206 	br	810adc <chEvtWaitAnyTimeout+0x104>
    }
    m = ctp->p_epending & mask;
  810a94:	e0bffc17 	ldw	r2,-16(fp)
  810a98:	10c00e17 	ldw	r3,56(r2)
  810a9c:	e0bffd17 	ldw	r2,-12(fp)
  810aa0:	1884703a 	and	r2,r3,r2
  810aa4:	e0bffb15 	stw	r2,-20(fp)
  }
  ctp->p_epending &= ~m;
  810aa8:	e0bffc17 	ldw	r2,-16(fp)
  810aac:	10c00e17 	ldw	r3,56(r2)
  810ab0:	e0bffb17 	ldw	r2,-20(fp)
  810ab4:	0084303a 	nor	r2,zero,r2
  810ab8:	1886703a 	and	r3,r3,r2
  810abc:	e0bffc17 	ldw	r2,-16(fp)
  810ac0:	10c00e15 	stw	r3,56(r2)
  810ac4:	00800044 	movi	r2,1
  810ac8:	e0bff715 	stw	r2,-36(fp)
  810acc:	e0bff717 	ldw	r2,-36(fp)
  810ad0:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return m;
  810ad4:	e0bffb17 	ldw	r2,-20(fp)
  810ad8:	e0bfff15 	stw	r2,-4(fp)
  810adc:	e0bfff17 	ldw	r2,-4(fp)
}
  810ae0:	e037883a 	mov	sp,fp
  810ae4:	dfc00117 	ldw	ra,4(sp)
  810ae8:	df000017 	ldw	fp,0(sp)
  810aec:	dec00204 	addi	sp,sp,8
  810af0:	f800283a 	ret

00810af4 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
  810af4:	defff604 	addi	sp,sp,-40
  810af8:	dfc00915 	stw	ra,36(sp)
  810afc:	df000815 	stw	fp,32(sp)
  810b00:	df000804 	addi	fp,sp,32
  810b04:	e13ffd15 	stw	r4,-12(fp)
  810b08:	e17ffe15 	stw	r5,-8(fp)
  Thread *ctp = currp;
  810b0c:	00802134 	movhi	r2,132
  810b10:	10ba9c04 	addi	r2,r2,-5520
  810b14:	10800717 	ldw	r2,28(r2)
  810b18:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  810b1c:	0005303a 	rdctl	r2,status
  810b20:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  810b24:	e0fffb17 	ldw	r3,-20(fp)
  810b28:	00bfff84 	movi	r2,-2
  810b2c:	1884703a 	and	r2,r3,r2
  810b30:	1001703a 	wrctl	status,r2

  chSysLock();

  if ((ctp->p_epending & mask) != mask) {
  810b34:	e0bffc17 	ldw	r2,-16(fp)
  810b38:	10c00e17 	ldw	r3,56(r2)
  810b3c:	e0bffd17 	ldw	r2,-12(fp)
  810b40:	1886703a 	and	r3,r3,r2
  810b44:	e0bffd17 	ldw	r2,-12(fp)
  810b48:	18801726 	beq	r3,r2,810ba8 <chEvtWaitAllTimeout+0xb4>
    if (TIME_IMMEDIATE == time) {
  810b4c:	e0bffe17 	ldw	r2,-8(fp)
  810b50:	1004c03a 	cmpne	r2,r2,zero
  810b54:	1000061e 	bne	r2,zero,810b70 <chEvtWaitAllTimeout+0x7c>
  810b58:	00800044 	movi	r2,1
  810b5c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  810b60:	e0bffa17 	ldw	r2,-24(fp)
  810b64:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  810b68:	e03fff15 	stw	zero,-4(fp)
  810b6c:	00001b06 	br	810bdc <chEvtWaitAllTimeout+0xe8>
    }
    ctp->p_u.ewmask = mask;
  810b70:	e0fffc17 	ldw	r3,-16(fp)
  810b74:	e0bffd17 	ldw	r2,-12(fp)
  810b78:	18800915 	stw	r2,36(r3)
    if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
  810b7c:	01000244 	movi	r4,9
  810b80:	e17ffe17 	ldw	r5,-8(fp)
  810b84:	08121580 	call	812158 <chSchGoSleepTimeoutS>
  810b88:	1004403a 	cmpge	r2,r2,zero
  810b8c:	1000061e 	bne	r2,zero,810ba8 <chEvtWaitAllTimeout+0xb4>
  810b90:	00800044 	movi	r2,1
  810b94:	e0bff915 	stw	r2,-28(fp)
  810b98:	e0bff917 	ldw	r2,-28(fp)
  810b9c:	1001703a 	wrctl	status,r2
      chSysUnlock();
      return (eventmask_t)0;
  810ba0:	e03fff15 	stw	zero,-4(fp)
  810ba4:	00000d06 	br	810bdc <chEvtWaitAllTimeout+0xe8>
    }
  }
  ctp->p_epending &= ~mask;
  810ba8:	e0bffc17 	ldw	r2,-16(fp)
  810bac:	10c00e17 	ldw	r3,56(r2)
  810bb0:	e0bffd17 	ldw	r2,-12(fp)
  810bb4:	0084303a 	nor	r2,zero,r2
  810bb8:	1886703a 	and	r3,r3,r2
  810bbc:	e0bffc17 	ldw	r2,-16(fp)
  810bc0:	10c00e15 	stw	r3,56(r2)
  810bc4:	00800044 	movi	r2,1
  810bc8:	e0bff815 	stw	r2,-32(fp)
  810bcc:	e0bff817 	ldw	r2,-32(fp)
  810bd0:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return mask;
  810bd4:	e0bffd17 	ldw	r2,-12(fp)
  810bd8:	e0bfff15 	stw	r2,-4(fp)
  810bdc:	e0bfff17 	ldw	r2,-4(fp)
}
  810be0:	e037883a 	mov	sp,fp
  810be4:	dfc00117 	ldw	ra,4(sp)
  810be8:	df000017 	ldw	fp,0(sp)
  810bec:	dec00204 	addi	sp,sp,8
  810bf0:	f800283a 	ret

00810bf4 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
  810bf4:	defffe04 	addi	sp,sp,-8
  810bf8:	dfc00115 	stw	ra,4(sp)
  810bfc:	df000015 	stw	fp,0(sp)
  810c00:	d839883a 	mov	fp,sp
  default_heap.h_provider = chCoreAlloc;
  810c04:	00c020f4 	movhi	r3,131
  810c08:	18f9dd04 	addi	r3,r3,-6284
  810c0c:	00802074 	movhi	r2,129
  810c10:	10844b04 	addi	r2,r2,4396
  810c14:	18800015 	stw	r2,0(r3)
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  810c18:	008020f4 	movhi	r2,131
  810c1c:	10b9dd04 	addi	r2,r2,-6284
  810c20:	10000115 	stw	zero,4(r2)
  default_heap.h_free.h.size = 0;
  810c24:	008020f4 	movhi	r2,131
  810c28:	10b9dd04 	addi	r2,r2,-6284
  810c2c:	10000215 	stw	zero,8(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
  810c30:	010020f4 	movhi	r4,131
  810c34:	2139e004 	addi	r4,r4,-6272
  810c38:	08116ac0 	call	8116ac <chMtxInit>
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
  810c3c:	e037883a 	mov	sp,fp
  810c40:	dfc00117 	ldw	ra,4(sp)
  810c44:	df000017 	ldw	fp,0(sp)
  810c48:	dec00204 	addi	sp,sp,8
  810c4c:	f800283a 	ret

00810c50 <chHeapInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
  810c50:	defffa04 	addi	sp,sp,-24
  810c54:	dfc00515 	stw	ra,20(sp)
  810c58:	df000415 	stw	fp,16(sp)
  810c5c:	df000404 	addi	fp,sp,16
  810c60:	e13ffd15 	stw	r4,-12(fp)
  810c64:	e17ffe15 	stw	r5,-8(fp)
  810c68:	e1bfff15 	stw	r6,-4(fp)
  union heap_header *hp;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
  810c6c:	e0bffe17 	ldw	r2,-8(fp)
  810c70:	108000cc 	andi	r2,r2,3
  810c74:	1004c03a 	cmpne	r2,r2,zero
  810c78:	1000001e 	bne	r2,zero,810c7c <chHeapInit+0x2c>

  heapp->h_provider = (memgetfunc_t)NULL;
  810c7c:	e0bffd17 	ldw	r2,-12(fp)
  810c80:	10000015 	stw	zero,0(r2)
  heapp->h_free.h.u.next = hp = buf;
  810c84:	e0bffe17 	ldw	r2,-8(fp)
  810c88:	e0bffc15 	stw	r2,-16(fp)
  810c8c:	e0fffd17 	ldw	r3,-12(fp)
  810c90:	e0bffc17 	ldw	r2,-16(fp)
  810c94:	18800115 	stw	r2,4(r3)
  heapp->h_free.h.size = 0;
  810c98:	e0bffd17 	ldw	r2,-12(fp)
  810c9c:	10000215 	stw	zero,8(r2)
  hp->h.u.next = NULL;
  810ca0:	e0bffc17 	ldw	r2,-16(fp)
  810ca4:	10000015 	stw	zero,0(r2)
  hp->h.size = size - sizeof(union heap_header);
  810ca8:	e0bfff17 	ldw	r2,-4(fp)
  810cac:	10fffe04 	addi	r3,r2,-8
  810cb0:	e0bffc17 	ldw	r2,-16(fp)
  810cb4:	10c00115 	stw	r3,4(r2)
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&heapp->h_mtx);
  810cb8:	e0bffd17 	ldw	r2,-12(fp)
  810cbc:	11000304 	addi	r4,r2,12
  810cc0:	08116ac0 	call	8116ac <chMtxInit>
#else
  chSemInit(&heapp->h_sem, 1);
#endif
}
  810cc4:	e037883a 	mov	sp,fp
  810cc8:	dfc00117 	ldw	ra,4(sp)
  810ccc:	df000017 	ldw	fp,0(sp)
  810cd0:	dec00204 	addi	sp,sp,8
  810cd4:	f800283a 	ret

00810cd8 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
  810cd8:	defff804 	addi	sp,sp,-32
  810cdc:	dfc00715 	stw	ra,28(sp)
  810ce0:	df000615 	stw	fp,24(sp)
  810ce4:	df000604 	addi	fp,sp,24
  810ce8:	e13ffd15 	stw	r4,-12(fp)
  810cec:	e17ffe15 	stw	r5,-8(fp)
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
  810cf0:	e0bffd17 	ldw	r2,-12(fp)
  810cf4:	1004c03a 	cmpne	r2,r2,zero
  810cf8:	1000031e 	bne	r2,zero,810d08 <chHeapAlloc+0x30>
    heapp = &default_heap;
  810cfc:	008020f4 	movhi	r2,131
  810d00:	10b9dd04 	addi	r2,r2,-6284
  810d04:	e0bffd15 	stw	r2,-12(fp)

  size = MEM_ALIGN_NEXT(size);
  810d08:	e0bffe17 	ldw	r2,-8(fp)
  810d0c:	10c000c4 	addi	r3,r2,3
  810d10:	00bfff04 	movi	r2,-4
  810d14:	1884703a 	and	r2,r3,r2
  810d18:	e0bffe15 	stw	r2,-8(fp)
  qp = &heapp->h_free;
  810d1c:	e0bffd17 	ldw	r2,-12(fp)
  810d20:	10800104 	addi	r2,r2,4
  810d24:	e0bffc15 	stw	r2,-16(fp)
  H_LOCK(heapp);
  810d28:	e0bffd17 	ldw	r2,-12(fp)
  810d2c:	11000304 	addi	r4,r2,12
  810d30:	08116f40 	call	8116f4 <chMtxLock>

  while (qp->h.u.next != NULL) {
  810d34:	00003106 	br	810dfc <chHeapAlloc+0x124>
    hp = qp->h.u.next;
  810d38:	e0bffc17 	ldw	r2,-16(fp)
  810d3c:	10800017 	ldw	r2,0(r2)
  810d40:	e0bffb15 	stw	r2,-20(fp)
    if (hp->h.size >= size) {
  810d44:	e0bffb17 	ldw	r2,-20(fp)
  810d48:	10c00117 	ldw	r3,4(r2)
  810d4c:	e0bffe17 	ldw	r2,-8(fp)
  810d50:	18802836 	bltu	r3,r2,810df4 <chHeapAlloc+0x11c>
      if (hp->h.size < size + sizeof(union heap_header)) {
  810d54:	e0bffb17 	ldw	r2,-20(fp)
  810d58:	10c00117 	ldw	r3,4(r2)
  810d5c:	e0bffe17 	ldw	r2,-8(fp)
  810d60:	10800204 	addi	r2,r2,8
  810d64:	1880052e 	bgeu	r3,r2,810d7c <chHeapAlloc+0xa4>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
  810d68:	e0bffb17 	ldw	r2,-20(fp)
  810d6c:	10c00017 	ldw	r3,0(r2)
  810d70:	e0bffc17 	ldw	r2,-16(fp)
  810d74:	10c00015 	stw	r3,0(r2)
  810d78:	00001606 	br	810dd4 <chHeapAlloc+0xfc>
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
  810d7c:	e0fffb17 	ldw	r3,-20(fp)
  810d80:	e0bffe17 	ldw	r2,-8(fp)
  810d84:	1885883a 	add	r2,r3,r2
  810d88:	10800204 	addi	r2,r2,8
  810d8c:	e0bffa15 	stw	r2,-24(fp)
        fp->h.u.next = hp->h.u.next;
  810d90:	e0bffb17 	ldw	r2,-20(fp)
  810d94:	10c00017 	ldw	r3,0(r2)
  810d98:	e0bffa17 	ldw	r2,-24(fp)
  810d9c:	10c00015 	stw	r3,0(r2)
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
  810da0:	e0bffb17 	ldw	r2,-20(fp)
  810da4:	10c00117 	ldw	r3,4(r2)
  810da8:	e0bffe17 	ldw	r2,-8(fp)
  810dac:	1885c83a 	sub	r2,r3,r2
  810db0:	10fffe04 	addi	r3,r2,-8
  810db4:	e0bffa17 	ldw	r2,-24(fp)
  810db8:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = fp;
  810dbc:	e0fffc17 	ldw	r3,-16(fp)
  810dc0:	e0bffa17 	ldw	r2,-24(fp)
  810dc4:	18800015 	stw	r2,0(r3)
        hp->h.size = size;
  810dc8:	e0fffb17 	ldw	r3,-20(fp)
  810dcc:	e0bffe17 	ldw	r2,-8(fp)
  810dd0:	18800115 	stw	r2,4(r3)
      }
      hp->h.u.heap = heapp;
  810dd4:	e0bffb17 	ldw	r2,-20(fp)
  810dd8:	e0fffd17 	ldw	r3,-12(fp)
  810ddc:	10c00015 	stw	r3,0(r2)

      H_UNLOCK(heapp);
  810de0:	0811a740 	call	811a74 <chMtxUnlock>
      return (void *)(hp + 1);
  810de4:	e0bffb17 	ldw	r2,-20(fp)
  810de8:	10800204 	addi	r2,r2,8
  810dec:	e0bfff15 	stw	r2,-4(fp)
  810df0:	00002106 	br	810e78 <chHeapAlloc+0x1a0>
    }
    qp = hp;
  810df4:	e0bffb17 	ldw	r2,-20(fp)
  810df8:	e0bffc15 	stw	r2,-16(fp)

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
  H_LOCK(heapp);

  while (qp->h.u.next != NULL) {
  810dfc:	e0bffc17 	ldw	r2,-16(fp)
  810e00:	10800017 	ldw	r2,0(r2)
  810e04:	1004c03a 	cmpne	r2,r2,zero
  810e08:	103fcb1e 	bne	r2,zero,810d38 <chHeapAlloc+0x60>
      return (void *)(hp + 1);
    }
    qp = hp;
  }

  H_UNLOCK(heapp);
  810e0c:	0811a740 	call	811a74 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
  810e10:	e0bffd17 	ldw	r2,-12(fp)
  810e14:	10800017 	ldw	r2,0(r2)
  810e18:	1005003a 	cmpeq	r2,r2,zero
  810e1c:	1000151e 	bne	r2,zero,810e74 <chHeapAlloc+0x19c>
    hp = heapp->h_provider(size + sizeof(union heap_header));
  810e20:	e0bffd17 	ldw	r2,-12(fp)
  810e24:	10c00017 	ldw	r3,0(r2)
  810e28:	e0bffe17 	ldw	r2,-8(fp)
  810e2c:	11000204 	addi	r4,r2,8
  810e30:	183ee83a 	callr	r3
  810e34:	e0bffb15 	stw	r2,-20(fp)
    if (hp != NULL) {
  810e38:	e0bffb17 	ldw	r2,-20(fp)
  810e3c:	1005003a 	cmpeq	r2,r2,zero
  810e40:	10000c1e 	bne	r2,zero,810e74 <chHeapAlloc+0x19c>
      hp->h.u.heap = heapp;
  810e44:	e0fffb17 	ldw	r3,-20(fp)
  810e48:	e0bffd17 	ldw	r2,-12(fp)
  810e4c:	18800015 	stw	r2,0(r3)
      hp->h.size = size;
  810e50:	e0fffb17 	ldw	r3,-20(fp)
  810e54:	e0bffe17 	ldw	r2,-8(fp)
  810e58:	18800115 	stw	r2,4(r3)
      hp++;
  810e5c:	e0bffb17 	ldw	r2,-20(fp)
  810e60:	10800204 	addi	r2,r2,8
  810e64:	e0bffb15 	stw	r2,-20(fp)
      return (void *)hp;
  810e68:	e0bffb17 	ldw	r2,-20(fp)
  810e6c:	e0bfff15 	stw	r2,-4(fp)
  810e70:	00000106 	br	810e78 <chHeapAlloc+0x1a0>
    }
  }
  return NULL;
  810e74:	e03fff15 	stw	zero,-4(fp)
  810e78:	e0bfff17 	ldw	r2,-4(fp)
}
  810e7c:	e037883a 	mov	sp,fp
  810e80:	dfc00117 	ldw	ra,4(sp)
  810e84:	df000017 	ldw	fp,0(sp)
  810e88:	dec00204 	addi	sp,sp,8
  810e8c:	f800283a 	ret

00810e90 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
  810e90:	defffa04 	addi	sp,sp,-24
  810e94:	dfc00515 	stw	ra,20(sp)
  810e98:	df000415 	stw	fp,16(sp)
  810e9c:	df000404 	addi	fp,sp,16
  810ea0:	e13fff15 	stw	r4,-4(fp)
  union heap_header *qp, *hp;
  MemoryHeap *heapp;

  chDbgCheck(p != NULL, "chHeapFree");

  hp = (union heap_header *)p - 1;
  810ea4:	e0bfff17 	ldw	r2,-4(fp)
  810ea8:	10bffe04 	addi	r2,r2,-8
  810eac:	e0bffd15 	stw	r2,-12(fp)
  heapp = hp->h.u.heap;
  810eb0:	e0bffd17 	ldw	r2,-12(fp)
  810eb4:	10800017 	ldw	r2,0(r2)
  810eb8:	e0bffc15 	stw	r2,-16(fp)
  qp = &heapp->h_free;
  810ebc:	e0bffc17 	ldw	r2,-16(fp)
  810ec0:	10800104 	addi	r2,r2,4
  810ec4:	e0bffe15 	stw	r2,-8(fp)
  H_LOCK(heapp);
  810ec8:	e0bffc17 	ldw	r2,-16(fp)
  810ecc:	11000304 	addi	r4,r2,12
  810ed0:	08116f40 	call	8116f4 <chMtxLock>

  while (TRUE) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
  810ed4:	e0fffd17 	ldw	r3,-12(fp)
  810ed8:	e0bffe17 	ldw	r2,-8(fp)
  810edc:	18800036 	bltu	r3,r2,810ee0 <chHeapFree+0x50>
                "chHeapFree(), #1",
                "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
  810ee0:	e0bffc17 	ldw	r2,-16(fp)
  810ee4:	10c00104 	addi	r3,r2,4
  810ee8:	e0bffe17 	ldw	r2,-8(fp)
  810eec:	18800326 	beq	r3,r2,810efc <chHeapFree+0x6c>
  810ef0:	e0fffd17 	ldw	r3,-12(fp)
  810ef4:	e0bffe17 	ldw	r2,-8(fp)
  810ef8:	10c03e2e 	bgeu	r2,r3,810ff4 <chHeapFree+0x164>
  810efc:	e0bffe17 	ldw	r2,-8(fp)
  810f00:	10800017 	ldw	r2,0(r2)
  810f04:	1005003a 	cmpeq	r2,r2,zero
  810f08:	1000041e 	bne	r2,zero,810f1c <chHeapFree+0x8c>
  810f0c:	e0bffe17 	ldw	r2,-8(fp)
  810f10:	10c00017 	ldw	r3,0(r2)
  810f14:	e0bffd17 	ldw	r2,-12(fp)
  810f18:	10c0362e 	bgeu	r2,r3,810ff4 <chHeapFree+0x164>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
  810f1c:	e0bffe17 	ldw	r2,-8(fp)
  810f20:	10c00017 	ldw	r3,0(r2)
  810f24:	e0bffd17 	ldw	r2,-12(fp)
  810f28:	10c00015 	stw	r3,0(r2)
      qp->h.u.next = hp;
  810f2c:	e0fffe17 	ldw	r3,-8(fp)
  810f30:	e0bffd17 	ldw	r2,-12(fp)
  810f34:	18800015 	stw	r2,0(r3)
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
  810f38:	e0bffd17 	ldw	r2,-12(fp)
  810f3c:	10800117 	ldw	r2,4(r2)
  810f40:	1007883a 	mov	r3,r2
  810f44:	e0bffd17 	ldw	r2,-12(fp)
  810f48:	1885883a 	add	r2,r3,r2
  810f4c:	10800204 	addi	r2,r2,8
  810f50:	1007883a 	mov	r3,r2
  810f54:	e0bffd17 	ldw	r2,-12(fp)
  810f58:	10800017 	ldw	r2,0(r2)
  810f5c:	18800e1e 	bne	r3,r2,810f98 <chHeapFree+0x108>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
  810f60:	e0bffd17 	ldw	r2,-12(fp)
  810f64:	10c00117 	ldw	r3,4(r2)
  810f68:	e0bffd17 	ldw	r2,-12(fp)
  810f6c:	10800017 	ldw	r2,0(r2)
  810f70:	10800117 	ldw	r2,4(r2)
  810f74:	1885883a 	add	r2,r3,r2
  810f78:	10c00204 	addi	r3,r2,8
  810f7c:	e0bffd17 	ldw	r2,-12(fp)
  810f80:	10c00115 	stw	r3,4(r2)
        hp->h.u.next = hp->h.u.next->h.u.next;
  810f84:	e0bffd17 	ldw	r2,-12(fp)
  810f88:	10800017 	ldw	r2,0(r2)
  810f8c:	10c00017 	ldw	r3,0(r2)
  810f90:	e0bffd17 	ldw	r2,-12(fp)
  810f94:	10c00015 	stw	r3,0(r2)
      }
      if ((LIMIT(qp) == hp)) {
  810f98:	e0bffe17 	ldw	r2,-8(fp)
  810f9c:	10800117 	ldw	r2,4(r2)
  810fa0:	1007883a 	mov	r3,r2
  810fa4:	e0bffe17 	ldw	r2,-8(fp)
  810fa8:	1885883a 	add	r2,r3,r2
  810fac:	10800204 	addi	r2,r2,8
  810fb0:	1007883a 	mov	r3,r2
  810fb4:	e0bffd17 	ldw	r2,-12(fp)
  810fb8:	18800c1e 	bne	r3,r2,810fec <chHeapFree+0x15c>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
  810fbc:	e0bffe17 	ldw	r2,-8(fp)
  810fc0:	10c00117 	ldw	r3,4(r2)
  810fc4:	e0bffd17 	ldw	r2,-12(fp)
  810fc8:	10800117 	ldw	r2,4(r2)
  810fcc:	1885883a 	add	r2,r3,r2
  810fd0:	10c00204 	addi	r3,r2,8
  810fd4:	e0bffe17 	ldw	r2,-8(fp)
  810fd8:	10c00115 	stw	r3,4(r2)
        qp->h.u.next = hp->h.u.next;
  810fdc:	e0bffd17 	ldw	r2,-12(fp)
  810fe0:	10c00017 	ldw	r3,0(r2)
  810fe4:	e0bffe17 	ldw	r2,-8(fp)
  810fe8:	10c00015 	stw	r3,0(r2)
      break;
    }
    qp = qp->h.u.next;
  }

  H_UNLOCK(heapp);
  810fec:	0811a740 	call	811a74 <chMtxUnlock>
  810ff0:	00000406 	br	811004 <chHeapFree+0x174>
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
  810ff4:	e0bffe17 	ldw	r2,-8(fp)
  810ff8:	10800017 	ldw	r2,0(r2)
  810ffc:	e0bffe15 	stw	r2,-8(fp)
  }
  811000:	003fb406 	br	810ed4 <chHeapFree+0x44>

  H_UNLOCK(heapp);
  return;
}
  811004:	e037883a 	mov	sp,fp
  811008:	dfc00117 	ldw	ra,4(sp)
  81100c:	df000017 	ldw	fp,0(sp)
  811010:	dec00204 	addi	sp,sp,8
  811014:	f800283a 	ret

00811018 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
  811018:	defff904 	addi	sp,sp,-28
  81101c:	dfc00615 	stw	ra,24(sp)
  811020:	df000515 	stw	fp,20(sp)
  811024:	df000504 	addi	fp,sp,20
  811028:	e13ffe15 	stw	r4,-8(fp)
  81102c:	e17fff15 	stw	r5,-4(fp)
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL)
  811030:	e0bffe17 	ldw	r2,-8(fp)
  811034:	1004c03a 	cmpne	r2,r2,zero
  811038:	1000031e 	bne	r2,zero,811048 <chHeapStatus+0x30>
    heapp = &default_heap;
  81103c:	008020f4 	movhi	r2,131
  811040:	10b9dd04 	addi	r2,r2,-6284
  811044:	e0bffe15 	stw	r2,-8(fp)

  H_LOCK(heapp);
  811048:	e0bffe17 	ldw	r2,-8(fp)
  81104c:	11000304 	addi	r4,r2,12
  811050:	08116f40 	call	8116f4 <chMtxLock>

  sz = 0;
  811054:	e03ffb15 	stw	zero,-20(fp)
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
  811058:	e03ffc15 	stw	zero,-16(fp)
  81105c:	e0bffe17 	ldw	r2,-8(fp)
  811060:	10800104 	addi	r2,r2,4
  811064:	e0bffd15 	stw	r2,-12(fp)
  811068:	00000c06 	br	81109c <chHeapStatus+0x84>
    sz += qp->h.u.next->h.size;
  81106c:	e0bffd17 	ldw	r2,-12(fp)
  811070:	10800017 	ldw	r2,0(r2)
  811074:	10c00117 	ldw	r3,4(r2)
  811078:	e0bffb17 	ldw	r2,-20(fp)
  81107c:	10c5883a 	add	r2,r2,r3
  811080:	e0bffb15 	stw	r2,-20(fp)
    heapp = &default_heap;

  H_LOCK(heapp);

  sz = 0;
  for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
  811084:	e0bffc17 	ldw	r2,-16(fp)
  811088:	10800044 	addi	r2,r2,1
  81108c:	e0bffc15 	stw	r2,-16(fp)
  811090:	e0bffd17 	ldw	r2,-12(fp)
  811094:	10800017 	ldw	r2,0(r2)
  811098:	e0bffd15 	stw	r2,-12(fp)
  81109c:	e0bffd17 	ldw	r2,-12(fp)
  8110a0:	10800017 	ldw	r2,0(r2)
  8110a4:	1004c03a 	cmpne	r2,r2,zero
  8110a8:	103ff01e 	bne	r2,zero,81106c <chHeapStatus+0x54>
    sz += qp->h.u.next->h.size;
  if (sizep)
  8110ac:	e0bfff17 	ldw	r2,-4(fp)
  8110b0:	1005003a 	cmpeq	r2,r2,zero
  8110b4:	1000031e 	bne	r2,zero,8110c4 <chHeapStatus+0xac>
    *sizep = sz;
  8110b8:	e0ffff17 	ldw	r3,-4(fp)
  8110bc:	e0bffb17 	ldw	r2,-20(fp)
  8110c0:	18800015 	stw	r2,0(r3)

  H_UNLOCK(heapp);
  8110c4:	0811a740 	call	811a74 <chMtxUnlock>
  return n;
  8110c8:	e0bffc17 	ldw	r2,-16(fp)
}
  8110cc:	e037883a 	mov	sp,fp
  8110d0:	dfc00117 	ldw	ra,4(sp)
  8110d4:	df000017 	ldw	fp,0(sp)
  8110d8:	dec00204 	addi	sp,sp,8
  8110dc:	f800283a 	ret

008110e0 <_core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void _core_init(void) {
  8110e0:	deffff04 	addi	sp,sp,-4
  8110e4:	df000015 	stw	fp,0(sp)
  8110e8:	d839883a 	mov	fp,sp
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
  8110ec:	00802134 	movhi	r2,132
  8110f0:	10bbbc04 	addi	r2,r2,-4368
  8110f4:	10c000c4 	addi	r3,r2,3
  8110f8:	00bfff04 	movi	r2,-4
  8110fc:	1884703a 	and	r2,r3,r2
  811100:	d0a6f915 	stw	r2,-25628(gp)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
  811104:	00804034 	movhi	r2,256
  811108:	10800004 	addi	r2,r2,0
  81110c:	1007883a 	mov	r3,r2
  811110:	00bfff04 	movi	r2,-4
  811114:	1884703a 	and	r2,r3,r2
  811118:	d0a6fa15 	stw	r2,-25624(gp)
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
  81111c:	e037883a 	mov	sp,fp
  811120:	df000017 	ldw	fp,0(sp)
  811124:	dec00104 	addi	sp,sp,4
  811128:	f800283a 	ret

0081112c <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
  81112c:	defffa04 	addi	sp,sp,-24
  811130:	dfc00515 	stw	ra,20(sp)
  811134:	df000415 	stw	fp,16(sp)
  811138:	df000404 	addi	fp,sp,16
  81113c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811140:	0005303a 	rdctl	r2,status
  811144:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811148:	e0fffd17 	ldw	r3,-12(fp)
  81114c:	00bfff84 	movi	r2,-2
  811150:	1884703a 	and	r2,r3,r2
  811154:	1001703a 	wrctl	status,r2
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
  811158:	e13fff17 	ldw	r4,-4(fp)
  81115c:	081118c0 	call	81118c <chCoreAllocI>
  811160:	e0bffe15 	stw	r2,-8(fp)
  811164:	00800044 	movi	r2,1
  811168:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81116c:	e0bffc17 	ldw	r2,-16(fp)
  811170:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return p;
  811174:	e0bffe17 	ldw	r2,-8(fp)
}
  811178:	e037883a 	mov	sp,fp
  81117c:	dfc00117 	ldw	ra,4(sp)
  811180:	df000017 	ldw	fp,0(sp)
  811184:	dec00204 	addi	sp,sp,8
  811188:	f800283a 	ret

0081118c <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  81118c:	defffc04 	addi	sp,sp,-16
  811190:	df000315 	stw	fp,12(sp)
  811194:	df000304 	addi	fp,sp,12
  811198:	e13ffe15 	stw	r4,-8(fp)
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  81119c:	e0bffe17 	ldw	r2,-8(fp)
  8111a0:	10c000c4 	addi	r3,r2,3
  8111a4:	00bfff04 	movi	r2,-4
  8111a8:	1884703a 	and	r2,r3,r2
  8111ac:	e0bffe15 	stw	r2,-8(fp)
  if ((size_t)(endmem - nextmem) < size)
  8111b0:	d0a6fa17 	ldw	r2,-25624(gp)
  8111b4:	1007883a 	mov	r3,r2
  8111b8:	d0a6f917 	ldw	r2,-25628(gp)
  8111bc:	1885c83a 	sub	r2,r3,r2
  8111c0:	1007883a 	mov	r3,r2
  8111c4:	e0bffe17 	ldw	r2,-8(fp)
  8111c8:	1880022e 	bgeu	r3,r2,8111d4 <chCoreAllocI+0x48>
    return NULL;
  8111cc:	e03fff15 	stw	zero,-4(fp)
  8111d0:	00000806 	br	8111f4 <chCoreAllocI+0x68>
  p = nextmem;
  8111d4:	d0a6f917 	ldw	r2,-25628(gp)
  8111d8:	e0bffd15 	stw	r2,-12(fp)
  nextmem += size;
  8111dc:	d0e6f917 	ldw	r3,-25628(gp)
  8111e0:	e0bffe17 	ldw	r2,-8(fp)
  8111e4:	1885883a 	add	r2,r3,r2
  8111e8:	d0a6f915 	stw	r2,-25628(gp)
  return p;
  8111ec:	e0bffd17 	ldw	r2,-12(fp)
  8111f0:	e0bfff15 	stw	r2,-4(fp)
  8111f4:	e0bfff17 	ldw	r2,-4(fp)
}
  8111f8:	e037883a 	mov	sp,fp
  8111fc:	df000017 	ldw	fp,0(sp)
  811200:	dec00104 	addi	sp,sp,4
  811204:	f800283a 	ret

00811208 <chCoreStatus>:
 *
 * @return              The size, in bytes, of the free core memory.
 *
 * @api
 */
size_t chCoreStatus(void) {
  811208:	deffff04 	addi	sp,sp,-4
  81120c:	df000015 	stw	fp,0(sp)
  811210:	d839883a 	mov	fp,sp

  return (size_t)(endmem - nextmem);
  811214:	d0a6fa17 	ldw	r2,-25624(gp)
  811218:	1007883a 	mov	r3,r2
  81121c:	d0a6f917 	ldw	r2,-25628(gp)
  811220:	1885c83a 	sub	r2,r3,r2
}
  811224:	e037883a 	mov	sp,fp
  811228:	df000017 	ldw	fp,0(sp)
  81122c:	dec00104 	addi	sp,sp,4
  811230:	f800283a 	ret

00811234 <chPoolInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolInit(MemoryPool *mp, size_t size, memgetfunc_t provider) {
  811234:	defffc04 	addi	sp,sp,-16
  811238:	df000315 	stw	fp,12(sp)
  81123c:	df000304 	addi	fp,sp,12
  811240:	e13ffd15 	stw	r4,-12(fp)
  811244:	e17ffe15 	stw	r5,-8(fp)
  811248:	e1bfff15 	stw	r6,-4(fp)

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)), "chPoolInit");
  81124c:	e0bffd17 	ldw	r2,-12(fp)
  811250:	1005003a 	cmpeq	r2,r2,zero
  811254:	1000001e 	bne	r2,zero,811258 <chPoolInit+0x24>

  mp->mp_next = NULL;
  811258:	e0bffd17 	ldw	r2,-12(fp)
  81125c:	10000015 	stw	zero,0(r2)
  mp->mp_object_size = MEM_ALIGN_NEXT(size);
  811260:	e0bffe17 	ldw	r2,-8(fp)
  811264:	10c000c4 	addi	r3,r2,3
  811268:	00bfff04 	movi	r2,-4
  81126c:	1886703a 	and	r3,r3,r2
  811270:	e0bffd17 	ldw	r2,-12(fp)
  811274:	10c00115 	stw	r3,4(r2)
  mp->mp_provider = provider;
  811278:	e0fffd17 	ldw	r3,-12(fp)
  81127c:	e0bfff17 	ldw	r2,-4(fp)
  811280:	18800215 	stw	r2,8(r3)
}
  811284:	e037883a 	mov	sp,fp
  811288:	df000017 	ldw	fp,0(sp)
  81128c:	dec00104 	addi	sp,sp,4
  811290:	f800283a 	ret

00811294 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(MemoryPool *mp) {
  811294:	defffc04 	addi	sp,sp,-16
  811298:	dfc00315 	stw	ra,12(sp)
  81129c:	df000215 	stw	fp,8(sp)
  8112a0:	df000204 	addi	fp,sp,8
  8112a4:	e13fff15 	stw	r4,-4(fp)
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL, "chPoolAllocI");

  if ((objp = mp->mp_next) != NULL)
  8112a8:	e0bfff17 	ldw	r2,-4(fp)
  8112ac:	10800017 	ldw	r2,0(r2)
  8112b0:	e0bffe15 	stw	r2,-8(fp)
  8112b4:	e0bffe17 	ldw	r2,-8(fp)
  8112b8:	1005003a 	cmpeq	r2,r2,zero
  8112bc:	1000061e 	bne	r2,zero,8112d8 <chPoolAllocI+0x44>
    mp->mp_next = mp->mp_next->ph_next;
  8112c0:	e0bfff17 	ldw	r2,-4(fp)
  8112c4:	10800017 	ldw	r2,0(r2)
  8112c8:	10c00017 	ldw	r3,0(r2)
  8112cc:	e0bfff17 	ldw	r2,-4(fp)
  8112d0:	10c00015 	stw	r3,0(r2)
  8112d4:	00000a06 	br	811300 <chPoolAllocI+0x6c>
  else if (mp->mp_provider != NULL)
  8112d8:	e0bfff17 	ldw	r2,-4(fp)
  8112dc:	10800217 	ldw	r2,8(r2)
  8112e0:	1005003a 	cmpeq	r2,r2,zero
  8112e4:	1000061e 	bne	r2,zero,811300 <chPoolAllocI+0x6c>
    objp = mp->mp_provider(mp->mp_object_size);
  8112e8:	e0bfff17 	ldw	r2,-4(fp)
  8112ec:	10c00217 	ldw	r3,8(r2)
  8112f0:	e0bfff17 	ldw	r2,-4(fp)
  8112f4:	11000117 	ldw	r4,4(r2)
  8112f8:	183ee83a 	callr	r3
  8112fc:	e0bffe15 	stw	r2,-8(fp)
  return objp;
  811300:	e0bffe17 	ldw	r2,-8(fp)
}
  811304:	e037883a 	mov	sp,fp
  811308:	dfc00117 	ldw	ra,4(sp)
  81130c:	df000017 	ldw	fp,0(sp)
  811310:	dec00204 	addi	sp,sp,8
  811314:	f800283a 	ret

00811318 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(MemoryPool *mp) {
  811318:	defffa04 	addi	sp,sp,-24
  81131c:	dfc00515 	stw	ra,20(sp)
  811320:	df000415 	stw	fp,16(sp)
  811324:	df000404 	addi	fp,sp,16
  811328:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81132c:	0005303a 	rdctl	r2,status
  811330:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811334:	e0fffd17 	ldw	r3,-12(fp)
  811338:	00bfff84 	movi	r2,-2
  81133c:	1884703a 	and	r2,r3,r2
  811340:	1001703a 	wrctl	status,r2
  void *objp;

  chSysLock();
  objp = chPoolAllocI(mp);
  811344:	e13fff17 	ldw	r4,-4(fp)
  811348:	08112940 	call	811294 <chPoolAllocI>
  81134c:	e0bffe15 	stw	r2,-8(fp)
  811350:	00800044 	movi	r2,1
  811354:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811358:	e0bffc17 	ldw	r2,-16(fp)
  81135c:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return objp;
  811360:	e0bffe17 	ldw	r2,-8(fp)
}
  811364:	e037883a 	mov	sp,fp
  811368:	dfc00117 	ldw	ra,4(sp)
  81136c:	df000017 	ldw	fp,0(sp)
  811370:	dec00204 	addi	sp,sp,8
  811374:	f800283a 	ret

00811378 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @iclass
 */
void chPoolFreeI(MemoryPool *mp, void *objp) {
  811378:	defffc04 	addi	sp,sp,-16
  81137c:	df000315 	stw	fp,12(sp)
  811380:	df000304 	addi	fp,sp,12
  811384:	e13ffe15 	stw	r4,-8(fp)
  811388:	e17fff15 	stw	r5,-4(fp)
  struct pool_header *php = objp;
  81138c:	e0bfff17 	ldw	r2,-4(fp)
  811390:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL) && MEM_IS_ALIGNED(objp),
  811394:	e0bffe17 	ldw	r2,-8(fp)
  811398:	1005003a 	cmpeq	r2,r2,zero
  81139c:	1000031e 	bne	r2,zero,8113ac <chPoolFreeI+0x34>
  8113a0:	e0bfff17 	ldw	r2,-4(fp)
  8113a4:	1005003a 	cmpeq	r2,r2,zero
  8113a8:	1000001e 	bne	r2,zero,8113ac <chPoolFreeI+0x34>
             "chPoolFreeI");

  php->ph_next = mp->mp_next;
  8113ac:	e0bffe17 	ldw	r2,-8(fp)
  8113b0:	10c00017 	ldw	r3,0(r2)
  8113b4:	e0bffd17 	ldw	r2,-12(fp)
  8113b8:	10c00015 	stw	r3,0(r2)
  mp->mp_next = php;
  8113bc:	e0fffe17 	ldw	r3,-8(fp)
  8113c0:	e0bffd17 	ldw	r2,-12(fp)
  8113c4:	18800015 	stw	r2,0(r3)
}
  8113c8:	e037883a 	mov	sp,fp
  8113cc:	df000017 	ldw	fp,0(sp)
  8113d0:	dec00104 	addi	sp,sp,4
  8113d4:	f800283a 	ret

008113d8 <chPoolFree>:
 * @param[in] mp        pointer to a @p MemoryPool structure
 * @param[in] objp      the pointer to the object to be released or added
 *
 * @api
 */
void chPoolFree(MemoryPool *mp, void *objp) {
  8113d8:	defffa04 	addi	sp,sp,-24
  8113dc:	dfc00515 	stw	ra,20(sp)
  8113e0:	df000415 	stw	fp,16(sp)
  8113e4:	df000404 	addi	fp,sp,16
  8113e8:	e13ffe15 	stw	r4,-8(fp)
  8113ec:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8113f0:	0005303a 	rdctl	r2,status
  8113f4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8113f8:	e0fffd17 	ldw	r3,-12(fp)
  8113fc:	00bfff84 	movi	r2,-2
  811400:	1884703a 	and	r2,r3,r2
  811404:	1001703a 	wrctl	status,r2

  chSysLock();
  chPoolFreeI(mp, objp);
  811408:	e13ffe17 	ldw	r4,-8(fp)
  81140c:	e17fff17 	ldw	r5,-4(fp)
  811410:	08113780 	call	811378 <chPoolFreeI>
  811414:	00800044 	movi	r2,1
  811418:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81141c:	e0bffc17 	ldw	r2,-16(fp)
  811420:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  811424:	e037883a 	mov	sp,fp
  811428:	dfc00117 	ldw	ra,4(sp)
  81142c:	df000017 	ldw	fp,0(sp)
  811430:	dec00204 	addi	sp,sp,8
  811434:	f800283a 	ret

00811438 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(Thread *tp, msg_t msg) {
  811438:	defff904 	addi	sp,sp,-28
  81143c:	dfc00615 	stw	ra,24(sp)
  811440:	df000515 	stw	fp,20(sp)
  811444:	df000504 	addi	fp,sp,20
  811448:	e13ffe15 	stw	r4,-8(fp)
  81144c:	e17fff15 	stw	r5,-4(fp)
  Thread *ctp = currp;
  811450:	00802134 	movhi	r2,132
  811454:	10ba9c04 	addi	r2,r2,-5520
  811458:	10800717 	ldw	r2,28(r2)
  81145c:	e0bffd15 	stw	r2,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811460:	0005303a 	rdctl	r2,status
  811464:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811468:	e0fffc17 	ldw	r3,-16(fp)
  81146c:	00bfff84 	movi	r2,-2
  811470:	1884703a 	and	r2,r3,r2
  811474:	1001703a 	wrctl	status,r2

  chDbgCheck(tp != NULL, "chMsgSend");

  chSysLock();
  ctp->p_msg = msg;
  811478:	e0fffd17 	ldw	r3,-12(fp)
  81147c:	e0bfff17 	ldw	r2,-4(fp)
  811480:	18800d15 	stw	r2,52(r3)
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  811484:	e0bffe17 	ldw	r2,-8(fp)
  811488:	10c00b04 	addi	r3,r2,44
  81148c:	e0bffd17 	ldw	r2,-12(fp)
  811490:	10c00915 	stw	r3,36(r2)
  msg_insert(ctp, &tp->p_msgqueue);
  811494:	e0bffe17 	ldw	r2,-8(fp)
  811498:	11400b04 	addi	r5,r2,44
  81149c:	e13ffd17 	ldw	r4,-12(fp)
  8114a0:	08114fc0 	call	8114fc <queue_insert>
  if (tp->p_state == THD_STATE_WTMSG)
  8114a4:	e0bffe17 	ldw	r2,-8(fp)
  8114a8:	10800703 	ldbu	r2,28(r2)
  8114ac:	10803fcc 	andi	r2,r2,255
  8114b0:	10800318 	cmpnei	r2,r2,12
  8114b4:	1000021e 	bne	r2,zero,8114c0 <chMsgSend+0x88>
    chSchReadyI(tp);
  8114b8:	e13ffe17 	ldw	r4,-8(fp)
  8114bc:	0811ec40 	call	811ec4 <chSchReadyI>
  chSchGoSleepS(THD_STATE_SNDMSGQ);
  8114c0:	01000284 	movi	r4,10
  8114c4:	0811f6c0 	call	811f6c <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
  8114c8:	e0bffd17 	ldw	r2,-12(fp)
  8114cc:	10800917 	ldw	r2,36(r2)
  8114d0:	e0bfff15 	stw	r2,-4(fp)
  8114d4:	00800044 	movi	r2,1
  8114d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8114dc:	e0bffb17 	ldw	r2,-20(fp)
  8114e0:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return msg;
  8114e4:	e0bfff17 	ldw	r2,-4(fp)
}
  8114e8:	e037883a 	mov	sp,fp
  8114ec:	dfc00117 	ldw	ra,4(sp)
  8114f0:	df000017 	ldw	fp,0(sp)
  8114f4:	dec00204 	addi	sp,sp,8
  8114f8:	f800283a 	ret

008114fc <queue_insert>:
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
}

static INLINE void queue_insert(Thread *tp, ThreadsQueue *tqp) {
  8114fc:	defffd04 	addi	sp,sp,-12
  811500:	df000215 	stw	fp,8(sp)
  811504:	df000204 	addi	fp,sp,8
  811508:	e13ffe15 	stw	r4,-8(fp)
  81150c:	e17fff15 	stw	r5,-4(fp)

  tp->p_next = (Thread *)tqp;
  811510:	e0ffff17 	ldw	r3,-4(fp)
  811514:	e0bffe17 	ldw	r2,-8(fp)
  811518:	10c00015 	stw	r3,0(r2)
  tp->p_prev = tqp->p_prev;
  81151c:	e0bfff17 	ldw	r2,-4(fp)
  811520:	10c00117 	ldw	r3,4(r2)
  811524:	e0bffe17 	ldw	r2,-8(fp)
  811528:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = tqp->p_prev = tp;
  81152c:	e0bffe17 	ldw	r2,-8(fp)
  811530:	11000117 	ldw	r4,4(r2)
  811534:	e0ffff17 	ldw	r3,-4(fp)
  811538:	e0bffe17 	ldw	r2,-8(fp)
  81153c:	18800115 	stw	r2,4(r3)
  811540:	e0bfff17 	ldw	r2,-4(fp)
  811544:	10800117 	ldw	r2,4(r2)
  811548:	20800015 	stw	r2,0(r4)
}
  81154c:	e037883a 	mov	sp,fp
  811550:	df000017 	ldw	fp,0(sp)
  811554:	dec00104 	addi	sp,sp,4
  811558:	f800283a 	ret

0081155c <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
Thread *chMsgWait(void) {
  81155c:	defffb04 	addi	sp,sp,-20
  811560:	dfc00415 	stw	ra,16(sp)
  811564:	df000315 	stw	fp,12(sp)
  811568:	df000304 	addi	fp,sp,12
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81156c:	0005303a 	rdctl	r2,status
  811570:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811574:	e0fffe17 	ldw	r3,-8(fp)
  811578:	00bfff84 	movi	r2,-2
  81157c:	1884703a 	and	r2,r3,r2
  811580:	1001703a 	wrctl	status,r2
  Thread *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp))
  811584:	00802134 	movhi	r2,132
  811588:	10ba9c04 	addi	r2,r2,-5520
  81158c:	10800717 	ldw	r2,28(r2)
  811590:	10c00b17 	ldw	r3,44(r2)
  811594:	00802134 	movhi	r2,132
  811598:	10ba9c04 	addi	r2,r2,-5520
  81159c:	10800717 	ldw	r2,28(r2)
  8115a0:	10800b04 	addi	r2,r2,44
  8115a4:	1880021e 	bne	r3,r2,8115b0 <chMsgWait+0x54>
    chSchGoSleepS(THD_STATE_WTMSG);
  8115a8:	01000304 	movi	r4,12
  8115ac:	0811f6c0 	call	811f6c <chSchGoSleepS>
  tp = fifo_remove(&currp->p_msgqueue);
  8115b0:	00802134 	movhi	r2,132
  8115b4:	10ba9c04 	addi	r2,r2,-5520
  8115b8:	10800717 	ldw	r2,28(r2)
  8115bc:	11000b04 	addi	r4,r2,44
  8115c0:	08115fc0 	call	8115fc <fifo_remove>
  8115c4:	e0bfff15 	stw	r2,-4(fp)
  tp->p_state = THD_STATE_SNDMSG;
  8115c8:	e0ffff17 	ldw	r3,-4(fp)
  8115cc:	008002c4 	movi	r2,11
  8115d0:	18800705 	stb	r2,28(r3)
  8115d4:	00800044 	movi	r2,1
  8115d8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8115dc:	e0bffd17 	ldw	r2,-12(fp)
  8115e0:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  8115e4:	e0bfff17 	ldw	r2,-4(fp)
}
  8115e8:	e037883a 	mov	sp,fp
  8115ec:	dfc00117 	ldw	ra,4(sp)
  8115f0:	df000017 	ldw	fp,0(sp)
  8115f4:	dec00204 	addi	sp,sp,8
  8115f8:	f800283a 	ret

008115fc <fifo_remove>:

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  8115fc:	defffd04 	addi	sp,sp,-12
  811600:	df000215 	stw	fp,8(sp)
  811604:	df000204 	addi	fp,sp,8
  811608:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
  81160c:	e0bfff17 	ldw	r2,-4(fp)
  811610:	10800017 	ldw	r2,0(r2)
  811614:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  811618:	e0bffe17 	ldw	r2,-8(fp)
  81161c:	10c00017 	ldw	r3,0(r2)
  811620:	e0bfff17 	ldw	r2,-4(fp)
  811624:	10c00015 	stw	r3,0(r2)
  811628:	e0bfff17 	ldw	r2,-4(fp)
  81162c:	10c00017 	ldw	r3,0(r2)
  811630:	e0bfff17 	ldw	r2,-4(fp)
  811634:	18800115 	stw	r2,4(r3)
  return tp;
  811638:	e0bffe17 	ldw	r2,-8(fp)
}
  81163c:	e037883a 	mov	sp,fp
  811640:	df000017 	ldw	fp,0(sp)
  811644:	dec00104 	addi	sp,sp,4
  811648:	f800283a 	ret

0081164c <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(Thread *tp, msg_t msg) {
  81164c:	defffa04 	addi	sp,sp,-24
  811650:	dfc00515 	stw	ra,20(sp)
  811654:	df000415 	stw	fp,16(sp)
  811658:	df000404 	addi	fp,sp,16
  81165c:	e13ffe15 	stw	r4,-8(fp)
  811660:	e17fff15 	stw	r5,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811664:	0005303a 	rdctl	r2,status
  811668:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81166c:	e0fffd17 	ldw	r3,-12(fp)
  811670:	00bfff84 	movi	r2,-2
  811674:	1884703a 	and	r2,r3,r2
  811678:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_state == THD_STATE_SNDMSG,
              "chMsgRelease(), #1", "invalid state");
  chMsgReleaseS(tp, msg);
  81167c:	e13ffe17 	ldw	r4,-8(fp)
  811680:	e17fff17 	ldw	r5,-4(fp)
  811684:	08121e80 	call	8121e8 <chSchWakeupS>
  811688:	00800044 	movi	r2,1
  81168c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811690:	e0bffc17 	ldw	r2,-16(fp)
  811694:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  811698:	e037883a 	mov	sp,fp
  81169c:	dfc00117 	ldw	ra,4(sp)
  8116a0:	df000017 	ldw	fp,0(sp)
  8116a4:	dec00204 	addi	sp,sp,8
  8116a8:	f800283a 	ret

008116ac <chMtxInit>:
 *
 * @param[out] mp       pointer to a @p Mutex structure
 *
 * @init
 */
void chMtxInit(Mutex *mp) {
  8116ac:	defffe04 	addi	sp,sp,-8
  8116b0:	df000115 	stw	fp,4(sp)
  8116b4:	df000104 	addi	fp,sp,4
  8116b8:	e13fff15 	stw	r4,-4(fp)

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
  8116bc:	e0bfff17 	ldw	r2,-4(fp)
  8116c0:	1007883a 	mov	r3,r2
  8116c4:	e0bfff17 	ldw	r2,-4(fp)
  8116c8:	10c00115 	stw	r3,4(r2)
  8116cc:	e0bfff17 	ldw	r2,-4(fp)
  8116d0:	10c00117 	ldw	r3,4(r2)
  8116d4:	e0bfff17 	ldw	r2,-4(fp)
  8116d8:	10c00015 	stw	r3,0(r2)
  mp->m_owner = NULL;
  8116dc:	e0bfff17 	ldw	r2,-4(fp)
  8116e0:	10000215 	stw	zero,8(r2)
}
  8116e4:	e037883a 	mov	sp,fp
  8116e8:	df000017 	ldw	fp,0(sp)
  8116ec:	dec00104 	addi	sp,sp,4
  8116f0:	f800283a 	ret

008116f4 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @api
 */
void chMtxLock(Mutex *mp) {
  8116f4:	defffb04 	addi	sp,sp,-20
  8116f8:	dfc00415 	stw	ra,16(sp)
  8116fc:	df000315 	stw	fp,12(sp)
  811700:	df000304 	addi	fp,sp,12
  811704:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811708:	0005303a 	rdctl	r2,status
  81170c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811710:	e0fffe17 	ldw	r3,-8(fp)
  811714:	00bfff84 	movi	r2,-2
  811718:	1884703a 	and	r2,r3,r2
  81171c:	1001703a 	wrctl	status,r2

  chSysLock();

  chMtxLockS(mp);
  811720:	e13fff17 	ldw	r4,-4(fp)
  811724:	081174c0 	call	81174c <chMtxLockS>
  811728:	00800044 	movi	r2,1
  81172c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811730:	e0bffd17 	ldw	r2,-12(fp)
  811734:	1001703a 	wrctl	status,r2

  chSysUnlock();
}
  811738:	e037883a 	mov	sp,fp
  81173c:	dfc00117 	ldw	ra,4(sp)
  811740:	df000017 	ldw	fp,0(sp)
  811744:	dec00204 	addi	sp,sp,8
  811748:	f800283a 	ret

0081174c <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p Mutex structure
 *
 * @sclass
 */
void chMtxLockS(Mutex *mp) {
  81174c:	defffa04 	addi	sp,sp,-24
  811750:	dfc00515 	stw	ra,20(sp)
  811754:	df000415 	stw	fp,16(sp)
  811758:	df000404 	addi	fp,sp,16
  81175c:	e13ffe15 	stw	r4,-8(fp)
  Thread *ctp = currp;
  811760:	00802134 	movhi	r2,132
  811764:	10ba9c04 	addi	r2,r2,-5520
  811768:	10800717 	ldw	r2,28(r2)
  81176c:	e0bffd15 	stw	r2,-12(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxLockS");

  /* Ia the mutex already locked? */
  if (mp->m_owner != NULL) {
  811770:	e0bffe17 	ldw	r2,-8(fp)
  811774:	10800217 	ldw	r2,8(r2)
  811778:	1005003a 	cmpeq	r2,r2,zero
  81177c:	10003d1e 	bne	r2,zero,811874 <chMtxLockS+0x128>
    /* Priority inheritance protocol; explores the thread-mutex dependencies
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
  811780:	e0bffe17 	ldw	r2,-8(fp)
  811784:	10800217 	ldw	r2,8(r2)
  811788:	e0bffc15 	stw	r2,-16(fp)
    /* Does the running thread have higher priority than the mutex
       ownning thread? */
    while (tp->p_prio < ctp->p_prio) {
  81178c:	00002b06 	br	81183c <chMtxLockS+0xf0>
      /* Make priority of thread tp match the running thread's priority.*/
      tp->p_prio = ctp->p_prio;
  811790:	e0bffd17 	ldw	r2,-12(fp)
  811794:	10c00217 	ldw	r3,8(r2)
  811798:	e0bffc17 	ldw	r2,-16(fp)
  81179c:	10c00215 	stw	r3,8(r2)
      /* The following states need priority queues reordering.*/
      switch (tp->p_state) {
  8117a0:	e0bffc17 	ldw	r2,-16(fp)
  8117a4:	10800703 	ldbu	r2,28(r2)
  8117a8:	10803fcc 	andi	r2,r2,255
  8117ac:	e0bfff15 	stw	r2,-4(fp)
  8117b0:	e0ffff17 	ldw	r3,-4(fp)
  8117b4:	18800120 	cmpeqi	r2,r3,4
  8117b8:	1000071e 	bne	r2,zero,8117d8 <chMtxLockS+0x8c>
  8117bc:	e0ffff17 	ldw	r3,-4(fp)
  8117c0:	18800160 	cmpeqi	r2,r3,5
  8117c4:	1000101e 	bne	r2,zero,811808 <chMtxLockS+0xbc>
  8117c8:	e0ffff17 	ldw	r3,-4(fp)
  8117cc:	1805003a 	cmpeq	r2,r3,zero
  8117d0:	1000151e 	bne	r2,zero,811828 <chMtxLockS+0xdc>
  8117d4:	00001e06 	br	811850 <chMtxLockS+0x104>
      case THD_STATE_WTMTX:
        /* Re-enqueues the mutex owner with its new priority.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
  8117d8:	e13ffc17 	ldw	r4,-16(fp)
  8117dc:	08118b00 	call	8118b0 <dequeue>
  8117e0:	1009883a 	mov	r4,r2
  8117e4:	e0bffc17 	ldw	r2,-16(fp)
  8117e8:	10800917 	ldw	r2,36(r2)
  8117ec:	100b883a 	mov	r5,r2
  8117f0:	08118fc0 	call	8118fc <prio_insert>
        tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
  8117f4:	e0bffc17 	ldw	r2,-16(fp)
  8117f8:	10800917 	ldw	r2,36(r2)
  8117fc:	10800217 	ldw	r2,8(r2)
  811800:	e0bffc15 	stw	r2,-16(fp)
        continue;
  811804:	00000d06 	br	81183c <chMtxLockS+0xf0>
#endif
#if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
      case THD_STATE_SNDMSGQ:
#endif
        /* Re-enqueues tp with its new priority on the queue.*/
        prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
  811808:	e13ffc17 	ldw	r4,-16(fp)
  81180c:	08118b00 	call	8118b0 <dequeue>
  811810:	1009883a 	mov	r4,r2
  811814:	e0bffc17 	ldw	r2,-16(fp)
  811818:	10800917 	ldw	r2,36(r2)
  81181c:	100b883a 	mov	r5,r2
  811820:	08118fc0 	call	8118fc <prio_insert>
        break;
  811824:	00000a06 	br	811850 <chMtxLockS+0x104>
#if CH_DBG_ENABLE_ASSERTS
        /* Prevents an assertion in chSchReadyI().*/
        tp->p_state = THD_STATE_CURRENT;
#endif
        /* Re-enqueues tp with its new priority on the ready list.*/
        chSchReadyI(dequeue(tp));
  811828:	e13ffc17 	ldw	r4,-16(fp)
  81182c:	08118b00 	call	8118b0 <dequeue>
  811830:	1009883a 	mov	r4,r2
  811834:	0811ec40 	call	811ec4 <chSchReadyI>
        break;
      }
      break;
  811838:	00000506 	br	811850 <chMtxLockS+0x104>
       boosting the priority of all the affected threads to equal the priority
       of the running thread requesting the mutex.*/
    Thread *tp = mp->m_owner;
    /* Does the running thread have higher priority than the mutex
       ownning thread? */
    while (tp->p_prio < ctp->p_prio) {
  81183c:	e0bffc17 	ldw	r2,-16(fp)
  811840:	10c00217 	ldw	r3,8(r2)
  811844:	e0bffd17 	ldw	r2,-12(fp)
  811848:	10800217 	ldw	r2,8(r2)
  81184c:	18bfd036 	bltu	r3,r2,811790 <chMtxLockS+0x44>
        break;
      }
      break;
    }
    /* Sleep on the mutex.*/
    prio_insert(ctp, &mp->m_queue);
  811850:	e17ffe17 	ldw	r5,-8(fp)
  811854:	e13ffd17 	ldw	r4,-12(fp)
  811858:	08118fc0 	call	8118fc <prio_insert>
    ctp->p_u.wtobjp = mp;
  81185c:	e0fffd17 	ldw	r3,-12(fp)
  811860:	e0bffe17 	ldw	r2,-8(fp)
  811864:	18800915 	stw	r2,36(r3)
    chSchGoSleepS(THD_STATE_WTMTX);
  811868:	01000104 	movi	r4,4
  81186c:	0811f6c0 	call	811f6c <chSchGoSleepS>
    /* It is assumed that the thread performing the unlock operation assigns
       the mutex to this thread.*/
    chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
    chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
  811870:	00000a06 	br	81189c <chMtxLockS+0x150>
  }
  else {
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
  811874:	e0fffe17 	ldw	r3,-8(fp)
  811878:	e0bffd17 	ldw	r2,-12(fp)
  81187c:	18800215 	stw	r2,8(r3)
    mp->m_next = ctp->p_mtxlist;
  811880:	e0bffd17 	ldw	r2,-12(fp)
  811884:	10c00f17 	ldw	r3,60(r2)
  811888:	e0bffe17 	ldw	r2,-8(fp)
  81188c:	10c00315 	stw	r3,12(r2)
    ctp->p_mtxlist = mp;
  811890:	e0fffd17 	ldw	r3,-12(fp)
  811894:	e0bffe17 	ldw	r2,-8(fp)
  811898:	18800f15 	stw	r2,60(r3)
  }
}
  81189c:	e037883a 	mov	sp,fp
  8118a0:	dfc00117 	ldw	ra,4(sp)
  8118a4:	df000017 	ldw	fp,0(sp)
  8118a8:	dec00204 	addi	sp,sp,8
  8118ac:	f800283a 	ret

008118b0 <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
  8118b0:	defffe04 	addi	sp,sp,-8
  8118b4:	df000115 	stw	fp,4(sp)
  8118b8:	df000104 	addi	fp,sp,4
  8118bc:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
  8118c0:	e0bfff17 	ldw	r2,-4(fp)
  8118c4:	10c00117 	ldw	r3,4(r2)
  8118c8:	e0bfff17 	ldw	r2,-4(fp)
  8118cc:	10800017 	ldw	r2,0(r2)
  8118d0:	18800015 	stw	r2,0(r3)
  tp->p_next->p_prev = tp->p_prev;
  8118d4:	e0bfff17 	ldw	r2,-4(fp)
  8118d8:	10c00017 	ldw	r3,0(r2)
  8118dc:	e0bfff17 	ldw	r2,-4(fp)
  8118e0:	10800117 	ldw	r2,4(r2)
  8118e4:	18800115 	stw	r2,4(r3)
  return tp;
  8118e8:	e0bfff17 	ldw	r2,-4(fp)
}
  8118ec:	e037883a 	mov	sp,fp
  8118f0:	df000017 	ldw	fp,0(sp)
  8118f4:	dec00104 	addi	sp,sp,4
  8118f8:	f800283a 	ret

008118fc <prio_insert>:
#define _CHINLINE_H_

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_OPTIMIZE_SPEED
static INLINE void prio_insert(Thread *tp, ThreadsQueue *tqp) {
  8118fc:	defffc04 	addi	sp,sp,-16
  811900:	df000315 	stw	fp,12(sp)
  811904:	df000304 	addi	fp,sp,12
  811908:	e13ffe15 	stw	r4,-8(fp)
  81190c:	e17fff15 	stw	r5,-4(fp)

  Thread *cp = (Thread *)tqp;
  811910:	e0bfff17 	ldw	r2,-4(fp)
  811914:	e0bffd15 	stw	r2,-12(fp)
  do {
    cp = cp->p_next;
  811918:	e0bffd17 	ldw	r2,-12(fp)
  81191c:	10800017 	ldw	r2,0(r2)
  811920:	e0bffd15 	stw	r2,-12(fp)
  } while ((cp != (Thread *)tqp) && (cp->p_prio >= tp->p_prio));
  811924:	e0ffff17 	ldw	r3,-4(fp)
  811928:	e0bffd17 	ldw	r2,-12(fp)
  81192c:	10c00526 	beq	r2,r3,811944 <prio_insert+0x48>
  811930:	e0bffd17 	ldw	r2,-12(fp)
  811934:	10c00217 	ldw	r3,8(r2)
  811938:	e0bffe17 	ldw	r2,-8(fp)
  81193c:	10800217 	ldw	r2,8(r2)
  811940:	18bff52e 	bgeu	r3,r2,811918 <prio_insert+0x1c>
  tp->p_next = cp;
  811944:	e0fffe17 	ldw	r3,-8(fp)
  811948:	e0bffd17 	ldw	r2,-12(fp)
  81194c:	18800015 	stw	r2,0(r3)
  tp->p_prev = cp->p_prev;
  811950:	e0bffd17 	ldw	r2,-12(fp)
  811954:	10c00117 	ldw	r3,4(r2)
  811958:	e0bffe17 	ldw	r2,-8(fp)
  81195c:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
  811960:	e0bffe17 	ldw	r2,-8(fp)
  811964:	11000117 	ldw	r4,4(r2)
  811968:	e0fffd17 	ldw	r3,-12(fp)
  81196c:	e0bffe17 	ldw	r2,-8(fp)
  811970:	18800115 	stw	r2,4(r3)
  811974:	e0bffd17 	ldw	r2,-12(fp)
  811978:	10800117 	ldw	r2,4(r2)
  81197c:	20800015 	stw	r2,0(r4)
}
  811980:	e037883a 	mov	sp,fp
  811984:	df000017 	ldw	fp,0(sp)
  811988:	dec00104 	addi	sp,sp,4
  81198c:	f800283a 	ret

00811990 <chMtxTryLock>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @api
 */
bool_t chMtxTryLock(Mutex *mp) {
  811990:	defffa04 	addi	sp,sp,-24
  811994:	dfc00515 	stw	ra,20(sp)
  811998:	df000415 	stw	fp,16(sp)
  81199c:	df000404 	addi	fp,sp,16
  8119a0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8119a4:	0005303a 	rdctl	r2,status
  8119a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8119ac:	e0fffd17 	ldw	r3,-12(fp)
  8119b0:	00bfff84 	movi	r2,-2
  8119b4:	1884703a 	and	r2,r3,r2
  8119b8:	1001703a 	wrctl	status,r2
  bool_t b;

  chSysLock();

  b = chMtxTryLockS(mp);
  8119bc:	e13fff17 	ldw	r4,-4(fp)
  8119c0:	08119f00 	call	8119f0 <chMtxTryLockS>
  8119c4:	e0bffe15 	stw	r2,-8(fp)
  8119c8:	00800044 	movi	r2,1
  8119cc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8119d0:	e0bffc17 	ldw	r2,-16(fp)
  8119d4:	1001703a 	wrctl	status,r2

  chSysUnlock();
  return b;
  8119d8:	e0bffe17 	ldw	r2,-8(fp)
}
  8119dc:	e037883a 	mov	sp,fp
  8119e0:	dfc00117 	ldw	ra,4(sp)
  8119e4:	df000017 	ldw	fp,0(sp)
  8119e8:	dec00204 	addi	sp,sp,8
  8119ec:	f800283a 	ret

008119f0 <chMtxTryLockS>:
 * @retval TRUE         if the mutex has been successfully acquired
 * @retval FALSE        if the lock attempt failed.
 *
 * @sclass
 */
bool_t chMtxTryLockS(Mutex *mp) {
  8119f0:	defffd04 	addi	sp,sp,-12
  8119f4:	df000215 	stw	fp,8(sp)
  8119f8:	df000204 	addi	fp,sp,8
  8119fc:	e13ffe15 	stw	r4,-8(fp)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL, "chMtxTryLockS");

  if (mp->m_owner != NULL)
  811a00:	e0bffe17 	ldw	r2,-8(fp)
  811a04:	10800217 	ldw	r2,8(r2)
  811a08:	1005003a 	cmpeq	r2,r2,zero
  811a0c:	1000021e 	bne	r2,zero,811a18 <chMtxTryLockS+0x28>
    return FALSE;
  811a10:	e03fff15 	stw	zero,-4(fp)
  811a14:	00001206 	br	811a60 <chMtxTryLockS+0x70>
  mp->m_owner = currp;
  811a18:	00802134 	movhi	r2,132
  811a1c:	10ba9c04 	addi	r2,r2,-5520
  811a20:	10c00717 	ldw	r3,28(r2)
  811a24:	e0bffe17 	ldw	r2,-8(fp)
  811a28:	10c00215 	stw	r3,8(r2)
  mp->m_next = currp->p_mtxlist;
  811a2c:	00802134 	movhi	r2,132
  811a30:	10ba9c04 	addi	r2,r2,-5520
  811a34:	10800717 	ldw	r2,28(r2)
  811a38:	10c00f17 	ldw	r3,60(r2)
  811a3c:	e0bffe17 	ldw	r2,-8(fp)
  811a40:	10c00315 	stw	r3,12(r2)
  currp->p_mtxlist = mp;
  811a44:	00802134 	movhi	r2,132
  811a48:	10ba9c04 	addi	r2,r2,-5520
  811a4c:	10c00717 	ldw	r3,28(r2)
  811a50:	e0bffe17 	ldw	r2,-8(fp)
  811a54:	18800f15 	stw	r2,60(r3)
  return TRUE;
  811a58:	00800044 	movi	r2,1
  811a5c:	e0bfff15 	stw	r2,-4(fp)
  811a60:	e0bfff17 	ldw	r2,-4(fp)
}
  811a64:	e037883a 	mov	sp,fp
  811a68:	df000017 	ldw	fp,0(sp)
  811a6c:	dec00104 	addi	sp,sp,4
  811a70:	f800283a 	ret

00811a74 <chMtxUnlock>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @api
 */
Mutex *chMtxUnlock(void) {
  811a74:	defff704 	addi	sp,sp,-36
  811a78:	dfc00815 	stw	ra,32(sp)
  811a7c:	df000715 	stw	fp,28(sp)
  811a80:	df000704 	addi	fp,sp,28
  Thread *ctp = currp;
  811a84:	00802134 	movhi	r2,132
  811a88:	10ba9c04 	addi	r2,r2,-5520
  811a8c:	10800717 	ldw	r2,28(r2)
  811a90:	e0bfff15 	stw	r2,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811a94:	0005303a 	rdctl	r2,status
  811a98:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811a9c:	e0fffa17 	ldw	r3,-24(fp)
  811aa0:	00bfff84 	movi	r2,-2
  811aa4:	1884703a 	and	r2,r3,r2
  811aa8:	1001703a 	wrctl	status,r2
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
              "chMtxUnlock(), #2",
              "ownership failure");
  /* Removes the top Mutex from the Threads's owned mutexes list and matk it
     as not owned.*/
  ump = ctp->p_mtxlist;
  811aac:	e0bfff17 	ldw	r2,-4(fp)
  811ab0:	10800f17 	ldw	r2,60(r2)
  811ab4:	e0bffe15 	stw	r2,-8(fp)
  ctp->p_mtxlist = ump->m_next;
  811ab8:	e0bffe17 	ldw	r2,-8(fp)
  811abc:	10c00317 	ldw	r3,12(r2)
  811ac0:	e0bfff17 	ldw	r2,-4(fp)
  811ac4:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
  811ac8:	e0bffe17 	ldw	r2,-8(fp)
  811acc:	10c00017 	ldw	r3,0(r2)
  811ad0:	e0bffe17 	ldw	r2,-8(fp)
  811ad4:	18802e26 	beq	r3,r2,811b90 <chMtxUnlock+0x11c>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
  811ad8:	e0bfff17 	ldw	r2,-4(fp)
  811adc:	10801017 	ldw	r2,64(r2)
  811ae0:	e0bffb15 	stw	r2,-20(fp)
    mp = ctp->p_mtxlist;
  811ae4:	e0bfff17 	ldw	r2,-4(fp)
  811ae8:	10800f17 	ldw	r2,60(r2)
  811aec:	e0bffd15 	stw	r2,-12(fp)
    while (mp != NULL) {
  811af0:	00001006 	br	811b34 <chMtxUnlock+0xc0>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
  811af4:	e0bffd17 	ldw	r2,-12(fp)
  811af8:	10c00017 	ldw	r3,0(r2)
  811afc:	e0bffd17 	ldw	r2,-12(fp)
  811b00:	18800926 	beq	r3,r2,811b28 <chMtxUnlock+0xb4>
  811b04:	e0bffd17 	ldw	r2,-12(fp)
  811b08:	10800017 	ldw	r2,0(r2)
  811b0c:	10c00217 	ldw	r3,8(r2)
  811b10:	e0bffb17 	ldw	r2,-20(fp)
  811b14:	10c0042e 	bgeu	r2,r3,811b28 <chMtxUnlock+0xb4>
        newprio = mp->m_queue.p_next->p_prio;
  811b18:	e0bffd17 	ldw	r2,-12(fp)
  811b1c:	10800017 	ldw	r2,0(r2)
  811b20:	10800217 	ldw	r2,8(r2)
  811b24:	e0bffb15 	stw	r2,-20(fp)
      mp = mp->m_next;
  811b28:	e0bffd17 	ldw	r2,-12(fp)
  811b2c:	10800317 	ldw	r2,12(r2)
  811b30:	e0bffd15 	stw	r2,-12(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
  811b34:	e0bffd17 	ldw	r2,-12(fp)
  811b38:	1004c03a 	cmpne	r2,r2,zero
  811b3c:	103fed1e 	bne	r2,zero,811af4 <chMtxUnlock+0x80>
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    /* Assigns to the current thread the highest priority among all the
       waiting threads.*/
    ctp->p_prio = newprio;
  811b40:	e0ffff17 	ldw	r3,-4(fp)
  811b44:	e0bffb17 	ldw	r2,-20(fp)
  811b48:	18800215 	stw	r2,8(r3)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
  811b4c:	e13ffe17 	ldw	r4,-8(fp)
  811b50:	0811bc00 	call	811bc0 <fifo_remove>
  811b54:	e0bffc15 	stw	r2,-16(fp)
    ump->m_owner = tp;
  811b58:	e0fffe17 	ldw	r3,-8(fp)
  811b5c:	e0bffc17 	ldw	r2,-16(fp)
  811b60:	18800215 	stw	r2,8(r3)
    ump->m_next = tp->p_mtxlist;
  811b64:	e0bffc17 	ldw	r2,-16(fp)
  811b68:	10c00f17 	ldw	r3,60(r2)
  811b6c:	e0bffe17 	ldw	r2,-8(fp)
  811b70:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
  811b74:	e0fffc17 	ldw	r3,-16(fp)
  811b78:	e0bffe17 	ldw	r2,-8(fp)
  811b7c:	18800f15 	stw	r2,60(r3)
    chSchWakeupS(tp, RDY_OK);
  811b80:	e13ffc17 	ldw	r4,-16(fp)
  811b84:	000b883a 	mov	r5,zero
  811b88:	08121e80 	call	8121e8 <chSchWakeupS>
  811b8c:	00000206 	br	811b98 <chMtxUnlock+0x124>
  }
  else
    ump->m_owner = NULL;
  811b90:	e0bffe17 	ldw	r2,-8(fp)
  811b94:	10000215 	stw	zero,8(r2)
  811b98:	00800044 	movi	r2,1
  811b9c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811ba0:	e0bff917 	ldw	r2,-28(fp)
  811ba4:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return ump;
  811ba8:	e0bffe17 	ldw	r2,-8(fp)
}
  811bac:	e037883a 	mov	sp,fp
  811bb0:	dfc00117 	ldw	ra,4(sp)
  811bb4:	df000017 	ldw	fp,0(sp)
  811bb8:	dec00204 	addi	sp,sp,8
  811bbc:	f800283a 	ret

00811bc0 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  811bc0:	defffd04 	addi	sp,sp,-12
  811bc4:	df000215 	stw	fp,8(sp)
  811bc8:	df000204 	addi	fp,sp,8
  811bcc:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
  811bd0:	e0bfff17 	ldw	r2,-4(fp)
  811bd4:	10800017 	ldw	r2,0(r2)
  811bd8:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  811bdc:	e0bffe17 	ldw	r2,-8(fp)
  811be0:	10c00017 	ldw	r3,0(r2)
  811be4:	e0bfff17 	ldw	r2,-4(fp)
  811be8:	10c00015 	stw	r3,0(r2)
  811bec:	e0bfff17 	ldw	r2,-4(fp)
  811bf0:	10c00017 	ldw	r3,0(r2)
  811bf4:	e0bfff17 	ldw	r2,-4(fp)
  811bf8:	18800115 	stw	r2,4(r3)
  return tp;
  811bfc:	e0bffe17 	ldw	r2,-8(fp)
}
  811c00:	e037883a 	mov	sp,fp
  811c04:	df000017 	ldw	fp,0(sp)
  811c08:	dec00104 	addi	sp,sp,4
  811c0c:	f800283a 	ret

00811c10 <chMtxUnlockS>:
 *
 * @return              A pointer to the unlocked mutex.
 *
 * @sclass
 */
Mutex *chMtxUnlockS(void) {
  811c10:	defff904 	addi	sp,sp,-28
  811c14:	dfc00615 	stw	ra,24(sp)
  811c18:	df000515 	stw	fp,20(sp)
  811c1c:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
  811c20:	00802134 	movhi	r2,132
  811c24:	10ba9c04 	addi	r2,r2,-5520
  811c28:	10800717 	ldw	r2,28(r2)
  811c2c:	e0bfff15 	stw	r2,-4(fp)
              "chMtxUnlockS(), #2",
              "ownership failure");

  /* Removes the top Mutex from the owned mutexes list and marks it as not
     owned.*/
  ump = ctp->p_mtxlist;
  811c30:	e0bfff17 	ldw	r2,-4(fp)
  811c34:	10800f17 	ldw	r2,60(r2)
  811c38:	e0bffe15 	stw	r2,-8(fp)
  ctp->p_mtxlist = ump->m_next;
  811c3c:	e0bffe17 	ldw	r2,-8(fp)
  811c40:	10c00317 	ldw	r3,12(r2)
  811c44:	e0bfff17 	ldw	r2,-4(fp)
  811c48:	10c00f15 	stw	r3,60(r2)
  /* If a thread is waiting on the mutex then the fun part begins.*/
  if (chMtxQueueNotEmptyS(ump)) {
  811c4c:	e0bffe17 	ldw	r2,-8(fp)
  811c50:	10c00017 	ldw	r3,0(r2)
  811c54:	e0bffe17 	ldw	r2,-8(fp)
  811c58:	18802d26 	beq	r3,r2,811d10 <chMtxUnlockS+0x100>
    Thread *tp;

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
  811c5c:	e0bfff17 	ldw	r2,-4(fp)
  811c60:	10801017 	ldw	r2,64(r2)
  811c64:	e0bffb15 	stw	r2,-20(fp)
    mp = ctp->p_mtxlist;
  811c68:	e0bfff17 	ldw	r2,-4(fp)
  811c6c:	10800f17 	ldw	r2,60(r2)
  811c70:	e0bffd15 	stw	r2,-12(fp)
    while (mp != NULL) {
  811c74:	00001006 	br	811cb8 <chMtxUnlockS+0xa8>
      /* If the highest priority thread waiting in the mutexes list has a
         greater priority than the current thread base priority then the final
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
  811c78:	e0bffd17 	ldw	r2,-12(fp)
  811c7c:	10c00017 	ldw	r3,0(r2)
  811c80:	e0bffd17 	ldw	r2,-12(fp)
  811c84:	18800926 	beq	r3,r2,811cac <chMtxUnlockS+0x9c>
  811c88:	e0bffd17 	ldw	r2,-12(fp)
  811c8c:	10800017 	ldw	r2,0(r2)
  811c90:	10c00217 	ldw	r3,8(r2)
  811c94:	e0bffb17 	ldw	r2,-20(fp)
  811c98:	10c0042e 	bgeu	r2,r3,811cac <chMtxUnlockS+0x9c>
        newprio = mp->m_queue.p_next->p_prio;
  811c9c:	e0bffd17 	ldw	r2,-12(fp)
  811ca0:	10800017 	ldw	r2,0(r2)
  811ca4:	10800217 	ldw	r2,8(r2)
  811ca8:	e0bffb15 	stw	r2,-20(fp)
      mp = mp->m_next;
  811cac:	e0bffd17 	ldw	r2,-12(fp)
  811cb0:	10800317 	ldw	r2,12(r2)
  811cb4:	e0bffd15 	stw	r2,-12(fp)

    /* Recalculates the optimal thread priority by scanning the owned
       mutexes list.*/
    tprio_t newprio = ctp->p_realprio;
    mp = ctp->p_mtxlist;
    while (mp != NULL) {
  811cb8:	e0bffd17 	ldw	r2,-12(fp)
  811cbc:	1004c03a 	cmpne	r2,r2,zero
  811cc0:	103fed1e 	bne	r2,zero,811c78 <chMtxUnlockS+0x68>
         priority will have at least that priority.*/
      if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
        newprio = mp->m_queue.p_next->p_prio;
      mp = mp->m_next;
    }
    ctp->p_prio = newprio;
  811cc4:	e0ffff17 	ldw	r3,-4(fp)
  811cc8:	e0bffb17 	ldw	r2,-20(fp)
  811ccc:	18800215 	stw	r2,8(r3)
    /* Awakens the highest priority thread waiting for the unlocked mutex and
       assigns the mutex to it.*/
    tp = fifo_remove(&ump->m_queue);
  811cd0:	e13ffe17 	ldw	r4,-8(fp)
  811cd4:	0811bc00 	call	811bc0 <fifo_remove>
  811cd8:	e0bffc15 	stw	r2,-16(fp)
    ump->m_owner = tp;
  811cdc:	e0fffe17 	ldw	r3,-8(fp)
  811ce0:	e0bffc17 	ldw	r2,-16(fp)
  811ce4:	18800215 	stw	r2,8(r3)
    ump->m_next = tp->p_mtxlist;
  811ce8:	e0bffc17 	ldw	r2,-16(fp)
  811cec:	10c00f17 	ldw	r3,60(r2)
  811cf0:	e0bffe17 	ldw	r2,-8(fp)
  811cf4:	10c00315 	stw	r3,12(r2)
    tp->p_mtxlist = ump;
  811cf8:	e0fffc17 	ldw	r3,-16(fp)
  811cfc:	e0bffe17 	ldw	r2,-8(fp)
  811d00:	18800f15 	stw	r2,60(r3)
    chSchReadyI(tp);
  811d04:	e13ffc17 	ldw	r4,-16(fp)
  811d08:	0811ec40 	call	811ec4 <chSchReadyI>
  811d0c:	00000206 	br	811d18 <chMtxUnlockS+0x108>
  }
  else
    ump->m_owner = NULL;
  811d10:	e0bffe17 	ldw	r2,-8(fp)
  811d14:	10000215 	stw	zero,8(r2)
  return ump;
  811d18:	e0bffe17 	ldw	r2,-8(fp)
}
  811d1c:	e037883a 	mov	sp,fp
  811d20:	dfc00117 	ldw	ra,4(sp)
  811d24:	df000017 	ldw	fp,0(sp)
  811d28:	dec00204 	addi	sp,sp,8
  811d2c:	f800283a 	ret

00811d30 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  811d30:	defff904 	addi	sp,sp,-28
  811d34:	dfc00615 	stw	ra,24(sp)
  811d38:	df000515 	stw	fp,20(sp)
  811d3c:	df000504 	addi	fp,sp,20
  Thread *ctp = currp;
  811d40:	00802134 	movhi	r2,132
  811d44:	10ba9c04 	addi	r2,r2,-5520
  811d48:	10800717 	ldw	r2,28(r2)
  811d4c:	e0bfff15 	stw	r2,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  811d50:	0005303a 	rdctl	r2,status
  811d54:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  811d58:	e0fffc17 	ldw	r3,-16(fp)
  811d5c:	00bfff84 	movi	r2,-2
  811d60:	1884703a 	and	r2,r3,r2
  811d64:	1001703a 	wrctl	status,r2

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
  811d68:	e0bfff17 	ldw	r2,-4(fp)
  811d6c:	10800f17 	ldw	r2,60(r2)
  811d70:	1005003a 	cmpeq	r2,r2,zero
  811d74:	1000261e 	bne	r2,zero,811e10 <chMtxUnlockAll+0xe0>
    do {
      Mutex *ump = ctp->p_mtxlist;
  811d78:	e0bfff17 	ldw	r2,-4(fp)
  811d7c:	10800f17 	ldw	r2,60(r2)
  811d80:	e0bffe15 	stw	r2,-8(fp)
      ctp->p_mtxlist = ump->m_next;
  811d84:	e0bffe17 	ldw	r2,-8(fp)
  811d88:	10c00317 	ldw	r3,12(r2)
  811d8c:	e0bfff17 	ldw	r2,-4(fp)
  811d90:	10c00f15 	stw	r3,60(r2)
      if (chMtxQueueNotEmptyS(ump)) {
  811d94:	e0bffe17 	ldw	r2,-8(fp)
  811d98:	10c00017 	ldw	r3,0(r2)
  811d9c:	e0bffe17 	ldw	r2,-8(fp)
  811da0:	18801026 	beq	r3,r2,811de4 <chMtxUnlockAll+0xb4>
        Thread *tp = fifo_remove(&ump->m_queue);
  811da4:	e13ffe17 	ldw	r4,-8(fp)
  811da8:	0811bc00 	call	811bc0 <fifo_remove>
  811dac:	e0bffd15 	stw	r2,-12(fp)
        ump->m_owner = tp;
  811db0:	e0fffe17 	ldw	r3,-8(fp)
  811db4:	e0bffd17 	ldw	r2,-12(fp)
  811db8:	18800215 	stw	r2,8(r3)
        ump->m_next = tp->p_mtxlist;
  811dbc:	e0bffd17 	ldw	r2,-12(fp)
  811dc0:	10c00f17 	ldw	r3,60(r2)
  811dc4:	e0bffe17 	ldw	r2,-8(fp)
  811dc8:	10c00315 	stw	r3,12(r2)
        tp->p_mtxlist = ump;
  811dcc:	e0fffd17 	ldw	r3,-12(fp)
  811dd0:	e0bffe17 	ldw	r2,-8(fp)
  811dd4:	18800f15 	stw	r2,60(r3)
        chSchReadyI(tp);
  811dd8:	e13ffd17 	ldw	r4,-12(fp)
  811ddc:	0811ec40 	call	811ec4 <chSchReadyI>
  811de0:	00000206 	br	811dec <chMtxUnlockAll+0xbc>
      }
      else
        ump->m_owner = NULL;
  811de4:	e0bffe17 	ldw	r2,-8(fp)
  811de8:	10000215 	stw	zero,8(r2)
    } while (ctp->p_mtxlist != NULL);
  811dec:	e0bfff17 	ldw	r2,-4(fp)
  811df0:	10800f17 	ldw	r2,60(r2)
  811df4:	1004c03a 	cmpne	r2,r2,zero
  811df8:	103fdf1e 	bne	r2,zero,811d78 <chMtxUnlockAll+0x48>
    ctp->p_prio = ctp->p_realprio;
  811dfc:	e0bfff17 	ldw	r2,-4(fp)
  811e00:	10c01017 	ldw	r3,64(r2)
  811e04:	e0bfff17 	ldw	r2,-4(fp)
  811e08:	10c00215 	stw	r3,8(r2)
    chSchRescheduleS();
  811e0c:	08122940 	call	812294 <chSchRescheduleS>
  811e10:	00800044 	movi	r2,1
  811e14:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  811e18:	e0bffb17 	ldw	r2,-20(fp)
  811e1c:	1001703a 	wrctl	status,r2
  }
  chSysUnlock();
}
  811e20:	e037883a 	mov	sp,fp
  811e24:	dfc00117 	ldw	ra,4(sp)
  811e28:	df000017 	ldw	fp,0(sp)
  811e2c:	dec00204 	addi	sp,sp,8
  811e30:	f800283a 	ret

00811e34 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
  811e34:	deffff04 	addi	sp,sp,-4
  811e38:	df000015 	stw	fp,0(sp)
  811e3c:	d839883a 	mov	fp,sp

  queue_init(&rlist.r_queue);
  811e40:	00c02134 	movhi	r3,132
  811e44:	18fa9c04 	addi	r3,r3,-5520
  811e48:	00802134 	movhi	r2,132
  811e4c:	10ba9c04 	addi	r2,r2,-5520
  811e50:	10c00115 	stw	r3,4(r2)
  811e54:	00802134 	movhi	r2,132
  811e58:	10ba9c04 	addi	r2,r2,-5520
  811e5c:	10c00117 	ldw	r3,4(r2)
  811e60:	00802134 	movhi	r2,132
  811e64:	10ba9c04 	addi	r2,r2,-5520
  811e68:	10c00015 	stw	r3,0(r2)
  rlist.r_prio = NOPRIO;
  811e6c:	00802134 	movhi	r2,132
  811e70:	10ba9c04 	addi	r2,r2,-5520
  811e74:	10000215 	stw	zero,8(r2)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  811e78:	00c02134 	movhi	r3,132
  811e7c:	18fa9c04 	addi	r3,r3,-5520
  811e80:	00800504 	movi	r2,20
  811e84:	18800615 	stw	r2,24(r3)
#endif
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
  811e88:	00c02134 	movhi	r3,132
  811e8c:	18fa9c04 	addi	r3,r3,-5520
  811e90:	00802134 	movhi	r2,132
  811e94:	10ba9c04 	addi	r2,r2,-5520
  811e98:	10c00515 	stw	r3,20(r2)
  811e9c:	00802134 	movhi	r2,132
  811ea0:	10ba9c04 	addi	r2,r2,-5520
  811ea4:	10c00517 	ldw	r3,20(r2)
  811ea8:	00802134 	movhi	r2,132
  811eac:	10ba9c04 	addi	r2,r2,-5520
  811eb0:	10c00415 	stw	r3,16(r2)
#endif
}
  811eb4:	e037883a 	mov	sp,fp
  811eb8:	df000017 	ldw	fp,0(sp)
  811ebc:	dec00104 	addi	sp,sp,4
  811ec0:	f800283a 	ret

00811ec4 <chSchReadyI>:
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
  811ec4:	defffd04 	addi	sp,sp,-12
  811ec8:	df000215 	stw	fp,8(sp)
  811ecc:	df000204 	addi	fp,sp,8
  811ed0:	e13fff15 	stw	r4,-4(fp)
  Thread *cp;

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
  811ed4:	e0bfff17 	ldw	r2,-4(fp)
  811ed8:	10800703 	ldbu	r2,28(r2)
  811edc:	10803fcc 	andi	r2,r2,255
  811ee0:	1005003a 	cmpeq	r2,r2,zero
  811ee4:	1000001e 	bne	r2,zero,811ee8 <chSchReadyI+0x24>
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  811ee8:	e0bfff17 	ldw	r2,-4(fp)
  811eec:	10000705 	stb	zero,28(r2)
  cp = (Thread *)&rlist.r_queue;
  811ef0:	00802134 	movhi	r2,132
  811ef4:	10ba9c04 	addi	r2,r2,-5520
  811ef8:	e0bffe15 	stw	r2,-8(fp)
  do {
    cp = cp->p_next;
  811efc:	e0bffe17 	ldw	r2,-8(fp)
  811f00:	10800017 	ldw	r2,0(r2)
  811f04:	e0bffe15 	stw	r2,-8(fp)
  } while (cp->p_prio >= tp->p_prio);
  811f08:	e0bffe17 	ldw	r2,-8(fp)
  811f0c:	10c00217 	ldw	r3,8(r2)
  811f10:	e0bfff17 	ldw	r2,-4(fp)
  811f14:	10800217 	ldw	r2,8(r2)
  811f18:	18bff82e 	bgeu	r3,r2,811efc <chSchReadyI+0x38>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  811f1c:	e0ffff17 	ldw	r3,-4(fp)
  811f20:	e0bffe17 	ldw	r2,-8(fp)
  811f24:	18800015 	stw	r2,0(r3)
  tp->p_prev = cp->p_prev;
  811f28:	e0bffe17 	ldw	r2,-8(fp)
  811f2c:	10c00117 	ldw	r3,4(r2)
  811f30:	e0bfff17 	ldw	r2,-4(fp)
  811f34:	10c00115 	stw	r3,4(r2)
  tp->p_prev->p_next = cp->p_prev = tp;
  811f38:	e0bfff17 	ldw	r2,-4(fp)
  811f3c:	11000117 	ldw	r4,4(r2)
  811f40:	e0fffe17 	ldw	r3,-8(fp)
  811f44:	e0bfff17 	ldw	r2,-4(fp)
  811f48:	18800115 	stw	r2,4(r3)
  811f4c:	e0bffe17 	ldw	r2,-8(fp)
  811f50:	10800117 	ldw	r2,4(r2)
  811f54:	20800015 	stw	r2,0(r4)
  return tp;
  811f58:	e0bfff17 	ldw	r2,-4(fp)
}
  811f5c:	e037883a 	mov	sp,fp
  811f60:	df000017 	ldw	fp,0(sp)
  811f64:	dec00104 	addi	sp,sp,4
  811f68:	f800283a 	ret

00811f6c <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
  811f6c:	defffc04 	addi	sp,sp,-16
  811f70:	dfc00315 	stw	ra,12(sp)
  811f74:	df000215 	stw	fp,8(sp)
  811f78:	df000204 	addi	fp,sp,8
  811f7c:	e13fff05 	stb	r4,-4(fp)
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
  811f80:	00802134 	movhi	r2,132
  811f84:	10ba9c04 	addi	r2,r2,-5520
  811f88:	10800717 	ldw	r2,28(r2)
  811f8c:	e0bffe15 	stw	r2,-8(fp)
  811f90:	e0fffe17 	ldw	r3,-8(fp)
  811f94:	e0bfff03 	ldbu	r2,-4(fp)
  811f98:	18800705 	stb	r2,28(r3)
#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  811f9c:	00c02134 	movhi	r3,132
  811fa0:	18fa9c04 	addi	r3,r3,-5520
  811fa4:	00800504 	movi	r2,20
  811fa8:	18800615 	stw	r2,24(r3)
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
  811fac:	01002134 	movhi	r4,132
  811fb0:	213a9c04 	addi	r4,r4,-5520
  811fb4:	08120040 	call	812004 <fifo_remove>
  811fb8:	1007883a 	mov	r3,r2
  811fbc:	00802134 	movhi	r2,132
  811fc0:	10ba9c04 	addi	r2,r2,-5520
  811fc4:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
  811fc8:	00802134 	movhi	r2,132
  811fcc:	10ba9c04 	addi	r2,r2,-5520
  811fd0:	10c00717 	ldw	r3,28(r2)
  811fd4:	00800044 	movi	r2,1
  811fd8:	18800705 	stb	r2,28(r3)
  chSysSwitch(currp, otp);
  811fdc:	00802134 	movhi	r2,132
  811fe0:	10ba9c04 	addi	r2,r2,-5520
  811fe4:	11000717 	ldw	r4,28(r2)
  811fe8:	e17ffe17 	ldw	r5,-8(fp)
  811fec:	0812e900 	call	812e90 <port_switch>
}
  811ff0:	e037883a 	mov	sp,fp
  811ff4:	dfc00117 	ldw	ra,4(sp)
  811ff8:	df000017 	ldw	fp,0(sp)
  811ffc:	dec00204 	addi	sp,sp,8
  812000:	f800283a 	ret

00812004 <fifo_remove>:
  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  812004:	defffd04 	addi	sp,sp,-12
  812008:	df000215 	stw	fp,8(sp)
  81200c:	df000204 	addi	fp,sp,8
  812010:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = tqp->p_next;
  812014:	e0bfff17 	ldw	r2,-4(fp)
  812018:	10800017 	ldw	r2,0(r2)
  81201c:	e0bffe15 	stw	r2,-8(fp)

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
  812020:	e0bffe17 	ldw	r2,-8(fp)
  812024:	10c00017 	ldw	r3,0(r2)
  812028:	e0bfff17 	ldw	r2,-4(fp)
  81202c:	10c00015 	stw	r3,0(r2)
  812030:	e0bfff17 	ldw	r2,-4(fp)
  812034:	10c00017 	ldw	r3,0(r2)
  812038:	e0bfff17 	ldw	r2,-4(fp)
  81203c:	18800115 	stw	r2,4(r3)
  return tp;
  812040:	e0bffe17 	ldw	r2,-8(fp)
}
  812044:	e037883a 	mov	sp,fp
  812048:	df000017 	ldw	fp,0(sp)
  81204c:	dec00104 	addi	sp,sp,4
  812050:	f800283a 	ret

00812054 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
  812054:	defffb04 	addi	sp,sp,-20
  812058:	dfc00415 	stw	ra,16(sp)
  81205c:	df000315 	stw	fp,12(sp)
  812060:	df000304 	addi	fp,sp,12
  812064:	e13ffe15 	stw	r4,-8(fp)
  Thread *tp = (Thread *)p;
  812068:	e0bffe17 	ldw	r2,-8(fp)
  81206c:	e0bffd15 	stw	r2,-12(fp)

  switch (tp->p_state) {
  812070:	e0bffd17 	ldw	r2,-12(fp)
  812074:	10800703 	ldbu	r2,28(r2)
  812078:	10803fcc 	andi	r2,r2,255
  81207c:	e0bfff15 	stw	r2,-4(fp)
  812080:	e0ffff17 	ldw	r3,-4(fp)
  812084:	188000e0 	cmpeqi	r2,r3,3
  812088:	10000e1e 	bne	r2,zero,8120c4 <wakeup+0x70>
  81208c:	e0ffff17 	ldw	r3,-4(fp)
  812090:	18800108 	cmpgei	r2,r3,4
  812094:	1000041e 	bne	r2,zero,8120a8 <wakeup+0x54>
  812098:	e0ffff17 	ldw	r3,-4(fp)
  81209c:	1805003a 	cmpeq	r2,r3,zero
  8120a0:	1000151e 	bne	r2,zero,8120f8 <wakeup+0xa4>
  8120a4:	00000f06 	br	8120e4 <wakeup+0x90>
  8120a8:	e0ffff17 	ldw	r3,-4(fp)
  8120ac:	18800160 	cmpeqi	r2,r3,5
  8120b0:	10000a1e 	bne	r2,zero,8120dc <wakeup+0x88>
  8120b4:	e0ffff17 	ldw	r3,-4(fp)
  8120b8:	18800360 	cmpeqi	r2,r3,13
  8120bc:	1000071e 	bne	r2,zero,8120dc <wakeup+0x88>
  8120c0:	00000806 	br	8120e4 <wakeup+0x90>
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
  8120c4:	e0bffd17 	ldw	r2,-12(fp)
  8120c8:	10800917 	ldw	r2,36(r2)
  8120cc:	1007883a 	mov	r3,r2
  8120d0:	18800217 	ldw	r2,8(r3)
  8120d4:	10800044 	addi	r2,r2,1
  8120d8:	18800215 	stw	r2,8(r3)
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
  8120dc:	e13ffd17 	ldw	r4,-12(fp)
  8120e0:	081210c0 	call	81210c <dequeue>
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  8120e4:	e0fffd17 	ldw	r3,-12(fp)
  8120e8:	00bfffc4 	movi	r2,-1
  8120ec:	18800915 	stw	r2,36(r3)
  chSchReadyI(tp);
  8120f0:	e13ffd17 	ldw	r4,-12(fp)
  8120f4:	0811ec40 	call	811ec4 <chSchReadyI>
}
  8120f8:	e037883a 	mov	sp,fp
  8120fc:	dfc00117 	ldw	ra,4(sp)
  812100:	df000017 	ldw	fp,0(sp)
  812104:	dec00204 	addi	sp,sp,8
  812108:	f800283a 	ret

0081210c <dequeue>:

  (tqp->p_prev = tp->p_prev)->p_next = (Thread *)tqp;
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {
  81210c:	defffe04 	addi	sp,sp,-8
  812110:	df000115 	stw	fp,4(sp)
  812114:	df000104 	addi	fp,sp,4
  812118:	e13fff15 	stw	r4,-4(fp)

  tp->p_prev->p_next = tp->p_next;
  81211c:	e0bfff17 	ldw	r2,-4(fp)
  812120:	10c00117 	ldw	r3,4(r2)
  812124:	e0bfff17 	ldw	r2,-4(fp)
  812128:	10800017 	ldw	r2,0(r2)
  81212c:	18800015 	stw	r2,0(r3)
  tp->p_next->p_prev = tp->p_prev;
  812130:	e0bfff17 	ldw	r2,-4(fp)
  812134:	10c00017 	ldw	r3,0(r2)
  812138:	e0bfff17 	ldw	r2,-4(fp)
  81213c:	10800117 	ldw	r2,4(r2)
  812140:	18800115 	stw	r2,4(r3)
  return tp;
  812144:	e0bfff17 	ldw	r2,-4(fp)
}
  812148:	e037883a 	mov	sp,fp
  81214c:	df000017 	ldw	fp,0(sp)
  812150:	dec00104 	addi	sp,sp,4
  812154:	f800283a 	ret

00812158 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  812158:	defff704 	addi	sp,sp,-36
  81215c:	dfc00815 	stw	ra,32(sp)
  812160:	df000715 	stw	fp,28(sp)
  812164:	df000704 	addi	fp,sp,28
  812168:	e17fff15 	stw	r5,-4(fp)
  81216c:	e13ffe05 	stb	r4,-8(fp)

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
  812170:	e0bfff17 	ldw	r2,-4(fp)
  812174:	10bfffe0 	cmpeqi	r2,r2,-1
  812178:	1000101e 	bne	r2,zero,8121bc <chSchGoSleepTimeoutS+0x64>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
  81217c:	00802134 	movhi	r2,132
  812180:	10ba9c04 	addi	r2,r2,-5520
  812184:	11c00717 	ldw	r7,28(r2)
  812188:	e13ff904 	addi	r4,fp,-28
  81218c:	e17fff17 	ldw	r5,-4(fp)
  812190:	01802074 	movhi	r6,129
  812194:	31881504 	addi	r6,r6,8276
  812198:	0812c380 	call	812c38 <chVTSetI>
    chSchGoSleepS(newstate);
  81219c:	e13ffe03 	ldbu	r4,-8(fp)
  8121a0:	0811f6c0 	call	811f6c <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
  8121a4:	e0bffc17 	ldw	r2,-16(fp)
  8121a8:	1005003a 	cmpeq	r2,r2,zero
  8121ac:	1000051e 	bne	r2,zero,8121c4 <chSchGoSleepTimeoutS+0x6c>
      chVTResetI(&vt);
  8121b0:	e13ff904 	addi	r4,fp,-28
  8121b4:	0812d4c0 	call	812d4c <chVTResetI>
  8121b8:	00000206 	br	8121c4 <chSchGoSleepTimeoutS+0x6c>
  }
  else
    chSchGoSleepS(newstate);
  8121bc:	e13ffe03 	ldbu	r4,-8(fp)
  8121c0:	0811f6c0 	call	811f6c <chSchGoSleepS>
  return currp->p_u.rdymsg;
  8121c4:	00802134 	movhi	r2,132
  8121c8:	10ba9c04 	addi	r2,r2,-5520
  8121cc:	10800717 	ldw	r2,28(r2)
  8121d0:	10800917 	ldw	r2,36(r2)
}
  8121d4:	e037883a 	mov	sp,fp
  8121d8:	dfc00117 	ldw	ra,4(sp)
  8121dc:	df000017 	ldw	fp,0(sp)
  8121e0:	dec00204 	addi	sp,sp,8
  8121e4:	f800283a 	ret

008121e8 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
  8121e8:	defffb04 	addi	sp,sp,-20
  8121ec:	dfc00415 	stw	ra,16(sp)
  8121f0:	df000315 	stw	fp,12(sp)
  8121f4:	df000304 	addi	fp,sp,12
  8121f8:	e13ffe15 	stw	r4,-8(fp)
  8121fc:	e17fff15 	stw	r5,-4(fp)

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
  812200:	e0fffe17 	ldw	r3,-8(fp)
  812204:	e0bfff17 	ldw	r2,-4(fp)
  812208:	18800915 	stw	r2,36(r3)
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
  81220c:	e0bffe17 	ldw	r2,-8(fp)
  812210:	10c00217 	ldw	r3,8(r2)
  812214:	00802134 	movhi	r2,132
  812218:	10ba9c04 	addi	r2,r2,-5520
  81221c:	10800717 	ldw	r2,28(r2)
  812220:	10800217 	ldw	r2,8(r2)
  812224:	10c00336 	bltu	r2,r3,812234 <chSchWakeupS+0x4c>
    chSchReadyI(ntp);
  812228:	e13ffe17 	ldw	r4,-8(fp)
  81222c:	0811ec40 	call	811ec4 <chSchReadyI>
  812230:	00001306 	br	812280 <chSchWakeupS+0x98>
  else {
    Thread *otp = chSchReadyI(currp);
  812234:	00802134 	movhi	r2,132
  812238:	10ba9c04 	addi	r2,r2,-5520
  81223c:	11000717 	ldw	r4,28(r2)
  812240:	0811ec40 	call	811ec4 <chSchReadyI>
  812244:	e0bffd15 	stw	r2,-12(fp)
#if CH_TIME_QUANTUM > 0
    rlist.r_preempt = CH_TIME_QUANTUM;
  812248:	00c02134 	movhi	r3,132
  81224c:	18fa9c04 	addi	r3,r3,-5520
  812250:	00800504 	movi	r2,20
  812254:	18800615 	stw	r2,24(r3)
#endif
    setcurrp(ntp);
  812258:	00c02134 	movhi	r3,132
  81225c:	18fa9c04 	addi	r3,r3,-5520
  812260:	e0bffe17 	ldw	r2,-8(fp)
  812264:	18800715 	stw	r2,28(r3)
    ntp->p_state = THD_STATE_CURRENT;
  812268:	e0fffe17 	ldw	r3,-8(fp)
  81226c:	00800044 	movi	r2,1
  812270:	18800705 	stb	r2,28(r3)
    chSysSwitch(ntp, otp);
  812274:	e13ffe17 	ldw	r4,-8(fp)
  812278:	e17ffd17 	ldw	r5,-12(fp)
  81227c:	0812e900 	call	812e90 <port_switch>
  }
}
  812280:	e037883a 	mov	sp,fp
  812284:	dfc00117 	ldw	ra,4(sp)
  812288:	df000017 	ldw	fp,0(sp)
  81228c:	dec00204 	addi	sp,sp,8
  812290:	f800283a 	ret

00812294 <chSchRescheduleS>:
 *          the ready list then make the higher priority thread running.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)
void chSchRescheduleS(void) {
  812294:	defffe04 	addi	sp,sp,-8
  812298:	dfc00115 	stw	ra,4(sp)
  81229c:	df000015 	stw	fp,0(sp)
  8122a0:	d839883a 	mov	fp,sp

  chDbgCheckClassS();

  if (chSchIsRescRequiredI())
  8122a4:	00802134 	movhi	r2,132
  8122a8:	10ba9c04 	addi	r2,r2,-5520
  8122ac:	10800017 	ldw	r2,0(r2)
  8122b0:	10c00217 	ldw	r3,8(r2)
  8122b4:	00802134 	movhi	r2,132
  8122b8:	10ba9c04 	addi	r2,r2,-5520
  8122bc:	10800717 	ldw	r2,28(r2)
  8122c0:	10800217 	ldw	r2,8(r2)
  8122c4:	10c0012e 	bgeu	r2,r3,8122cc <chSchRescheduleS+0x38>
    chSchDoReschedule();
  8122c8:	08123600 	call	812360 <chSchDoReschedule>
}
  8122cc:	e037883a 	mov	sp,fp
  8122d0:	dfc00117 	ldw	ra,4(sp)
  8122d4:	df000017 	ldw	fp,0(sp)
  8122d8:	dec00204 	addi	sp,sp,8
  8122dc:	f800283a 	ret

008122e0 <chSchIsPreemptionRequired>:
 * @retval FALSE        if preemption is not required.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
bool_t chSchIsPreemptionRequired(void) {
  8122e0:	defffc04 	addi	sp,sp,-16
  8122e4:	df000315 	stw	fp,12(sp)
  8122e8:	df000304 	addi	fp,sp,12
  tprio_t p1 = firstprio(&rlist.r_queue);
  8122ec:	00802134 	movhi	r2,132
  8122f0:	10ba9c04 	addi	r2,r2,-5520
  8122f4:	10800017 	ldw	r2,0(r2)
  8122f8:	10800217 	ldw	r2,8(r2)
  8122fc:	e0bffe15 	stw	r2,-8(fp)
  tprio_t p2 = currp->p_prio;
  812300:	00802134 	movhi	r2,132
  812304:	10ba9c04 	addi	r2,r2,-5520
  812308:	10800717 	ldw	r2,28(r2)
  81230c:	10800217 	ldw	r2,8(r2)
  812310:	e0bffd15 	stw	r2,-12(fp)
#if CH_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return rlist.r_preempt ? p1 > p2 : p1 >= p2;
  812314:	00802134 	movhi	r2,132
  812318:	10ba9c04 	addi	r2,r2,-5520
  81231c:	10800617 	ldw	r2,24(r2)
  812320:	1005003a 	cmpeq	r2,r2,zero
  812324:	1000051e 	bne	r2,zero,81233c <chSchIsPreemptionRequired+0x5c>
  812328:	e0fffe17 	ldw	r3,-8(fp)
  81232c:	e0bffd17 	ldw	r2,-12(fp)
  812330:	10c5803a 	cmpltu	r2,r2,r3
  812334:	e0bfff15 	stw	r2,-4(fp)
  812338:	00000406 	br	81234c <chSchIsPreemptionRequired+0x6c>
  81233c:	e0fffe17 	ldw	r3,-8(fp)
  812340:	e0bffd17 	ldw	r2,-12(fp)
  812344:	1887403a 	cmpgeu	r3,r3,r2
  812348:	e0ffff15 	stw	r3,-4(fp)
  81234c:	e0bfff17 	ldw	r2,-4(fp)
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
  812350:	e037883a 	mov	sp,fp
  812354:	df000017 	ldw	fp,0(sp)
  812358:	dec00104 	addi	sp,sp,4
  81235c:	f800283a 	ret

00812360 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
  812360:	defffd04 	addi	sp,sp,-12
  812364:	dfc00215 	stw	ra,8(sp)
  812368:	df000115 	stw	fp,4(sp)
  81236c:	df000104 	addi	fp,sp,4
  Thread *otp;

#if CH_TIME_QUANTUM > 0
  rlist.r_preempt = CH_TIME_QUANTUM;
  812370:	00c02134 	movhi	r3,132
  812374:	18fa9c04 	addi	r3,r3,-5520
  812378:	00800504 	movi	r2,20
  81237c:	18800615 	stw	r2,24(r3)
#endif
  otp = currp;
  812380:	00802134 	movhi	r2,132
  812384:	10ba9c04 	addi	r2,r2,-5520
  812388:	10800717 	ldw	r2,28(r2)
  81238c:	e0bfff15 	stw	r2,-4(fp)
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  812390:	01002134 	movhi	r4,132
  812394:	213a9c04 	addi	r4,r4,-5520
  812398:	08120040 	call	812004 <fifo_remove>
  81239c:	1007883a 	mov	r3,r2
  8123a0:	00802134 	movhi	r2,132
  8123a4:	10ba9c04 	addi	r2,r2,-5520
  8123a8:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
  8123ac:	00802134 	movhi	r2,132
  8123b0:	10ba9c04 	addi	r2,r2,-5520
  8123b4:	10c00717 	ldw	r3,28(r2)
  8123b8:	00800044 	movi	r2,1
  8123bc:	18800705 	stb	r2,28(r3)
  chSchReadyI(otp);
  8123c0:	e13fff17 	ldw	r4,-4(fp)
  8123c4:	0811ec40 	call	811ec4 <chSchReadyI>
  chSysSwitch(currp, otp);
  8123c8:	00802134 	movhi	r2,132
  8123cc:	10ba9c04 	addi	r2,r2,-5520
  8123d0:	11000717 	ldw	r4,28(r2)
  8123d4:	e17fff17 	ldw	r5,-4(fp)
  8123d8:	0812e900 	call	812e90 <port_switch>
}
  8123dc:	e037883a 	mov	sp,fp
  8123e0:	dfc00117 	ldw	ra,4(sp)
  8123e4:	df000017 	ldw	fp,0(sp)
  8123e8:	dec00204 	addi	sp,sp,8
  8123ec:	f800283a 	ret

008123f0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {
  8123f0:	defffd04 	addi	sp,sp,-12
  8123f4:	df000215 	stw	fp,8(sp)
  8123f8:	df000204 	addi	fp,sp,8
  8123fc:	e13ffe15 	stw	r4,-8(fp)
  812400:	e17fff15 	stw	r5,-4(fp)

  tp->p_prio = prio;
  812404:	e0fffe17 	ldw	r3,-8(fp)
  812408:	e0bfff17 	ldw	r2,-4(fp)
  81240c:	18800215 	stw	r2,8(r3)
  tp->p_state = THD_STATE_SUSPENDED;
  812410:	e0fffe17 	ldw	r3,-8(fp)
  812414:	00800084 	movi	r2,2
  812418:	18800705 	stb	r2,28(r3)
  tp->p_flags = THD_MEM_MODE_STATIC;
  81241c:	e0bffe17 	ldw	r2,-8(fp)
  812420:	10000745 	stb	zero,29(r2)
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  812424:	e0fffe17 	ldw	r3,-8(fp)
  812428:	e0bfff17 	ldw	r2,-4(fp)
  81242c:	18801015 	stw	r2,64(r3)
  tp->p_mtxlist = NULL;
  812430:	e0bffe17 	ldw	r2,-8(fp)
  812434:	10000f15 	stw	zero,60(r2)
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
  812438:	e0bffe17 	ldw	r2,-8(fp)
  81243c:	10000e15 	stw	zero,56(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
  812440:	e0bffe17 	ldw	r2,-8(fp)
  812444:	10000815 	stw	zero,32(r2)
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
  812448:	e0fffe17 	ldw	r3,-8(fp)
  81244c:	00800044 	movi	r2,1
  812450:	18800785 	stb	r2,30(r3)
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  812454:	e0bffe17 	ldw	r2,-8(fp)
  812458:	10000615 	stw	zero,24(r2)
  REG_INSERT(tp);
  81245c:	00c02134 	movhi	r3,132
  812460:	18fa9c04 	addi	r3,r3,-5520
  812464:	e0bffe17 	ldw	r2,-8(fp)
  812468:	10c00415 	stw	r3,16(r2)
  81246c:	00802134 	movhi	r2,132
  812470:	10ba9c04 	addi	r2,r2,-5520
  812474:	10c00517 	ldw	r3,20(r2)
  812478:	e0bffe17 	ldw	r2,-8(fp)
  81247c:	10c00515 	stw	r3,20(r2)
  812480:	e0bffe17 	ldw	r2,-8(fp)
  812484:	11000517 	ldw	r4,20(r2)
  812488:	00c02134 	movhi	r3,132
  81248c:	18fa9c04 	addi	r3,r3,-5520
  812490:	e0bffe17 	ldw	r2,-8(fp)
  812494:	18800515 	stw	r2,20(r3)
  812498:	00802134 	movhi	r2,132
  81249c:	10ba9c04 	addi	r2,r2,-5520
  8124a0:	10800517 	ldw	r2,20(r2)
  8124a4:	20800415 	stw	r2,16(r4)
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
  8124a8:	e0bffe17 	ldw	r2,-8(fp)
  8124ac:	10800a04 	addi	r2,r2,40
  8124b0:	1007883a 	mov	r3,r2
  8124b4:	e0bffe17 	ldw	r2,-8(fp)
  8124b8:	10c00a15 	stw	r3,40(r2)
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
  8124bc:	e0bffe17 	ldw	r2,-8(fp)
  8124c0:	10800b04 	addi	r2,r2,44
  8124c4:	1007883a 	mov	r3,r2
  8124c8:	e0bffe17 	ldw	r2,-8(fp)
  8124cc:	10c00c15 	stw	r3,48(r2)
  8124d0:	e0bffe17 	ldw	r2,-8(fp)
  8124d4:	10c00c17 	ldw	r3,48(r2)
  8124d8:	e0bffe17 	ldw	r2,-8(fp)
  8124dc:	10c00b15 	stw	r3,44(r2)
  tp->p_stklimit = (stkalign_t *)(tp + 1);
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
  8124e0:	e0bffe17 	ldw	r2,-8(fp)
}
  8124e4:	e037883a 	mov	sp,fp
  8124e8:	df000017 	ldw	fp,0(sp)
  8124ec:	dec00104 	addi	sp,sp,4
  8124f0:	f800283a 	ret

008124f4 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
  8124f4:	defff904 	addi	sp,sp,-28
  8124f8:	dfc00615 	stw	ra,24(sp)
  8124fc:	df000515 	stw	fp,20(sp)
  812500:	df000504 	addi	fp,sp,20
  812504:	e13ffc15 	stw	r4,-16(fp)
  812508:	e17ffd15 	stw	r5,-12(fp)
  81250c:	e1bffe15 	stw	r6,-8(fp)
  812510:	e1ffff15 	stw	r7,-4(fp)
  /* Thread structure is layed out in the lower part of the thread workspace */
  Thread *tp = wsp;
  812514:	e0bffc17 	ldw	r2,-16(fp)
  812518:	e0bffb15 	stw	r2,-20(fp)

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
  81251c:	e0bffc17 	ldw	r2,-16(fp)
  812520:	1005003a 	cmpeq	r2,r2,zero
  812524:	1000061e 	bne	r2,zero,812540 <chThdCreateI+0x4c>
  812528:	e0bffd17 	ldw	r2,-12(fp)
  81252c:	10805030 	cmpltui	r2,r2,320
  812530:	1000031e 	bne	r2,zero,812540 <chThdCreateI+0x4c>
  812534:	e0bffe17 	ldw	r2,-8(fp)
  812538:	10802028 	cmpgeui	r2,r2,128
  81253c:	1000001e 	bne	r2,zero,812540 <chThdCreateI+0x4c>
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  812540:	e0fffc17 	ldw	r3,-16(fp)
  812544:	e0bffd17 	ldw	r2,-12(fp)
  812548:	1885883a 	add	r2,r3,r2
  81254c:	10bff504 	addi	r2,r2,-44
  812550:	1007883a 	mov	r3,r2
  812554:	e0bffb17 	ldw	r2,-20(fp)
  812558:	10c00315 	stw	r3,12(r2)
  81255c:	e0bffb17 	ldw	r2,-20(fp)
  812560:	10c00317 	ldw	r3,12(r2)
  812564:	e0bfff17 	ldw	r2,-4(fp)
  812568:	18800215 	stw	r2,8(r3)
  81256c:	e0bffb17 	ldw	r2,-20(fp)
  812570:	10c00317 	ldw	r3,12(r2)
  812574:	e0800217 	ldw	r2,8(fp)
  812578:	18800315 	stw	r2,12(r3)
  81257c:	e0bffb17 	ldw	r2,-20(fp)
  812580:	10c00317 	ldw	r3,12(r2)
  812584:	00860634 	movhi	r2,6168
  812588:	10860604 	addi	r2,r2,6168
  81258c:	18800415 	stw	r2,16(r3)
  812590:	e0bffb17 	ldw	r2,-20(fp)
  812594:	10c00317 	ldw	r3,12(r2)
  812598:	00864674 	movhi	r2,6425
  81259c:	10864644 	addi	r2,r2,6425
  8125a0:	18800515 	stw	r2,20(r3)
  8125a4:	e0bffb17 	ldw	r2,-20(fp)
  8125a8:	10c00317 	ldw	r3,12(r2)
  8125ac:	00880834 	movhi	r2,8224
  8125b0:	10880804 	addi	r2,r2,8224
  8125b4:	18800615 	stw	r2,24(r3)
  8125b8:	e0bffb17 	ldw	r2,-20(fp)
  8125bc:	10c00317 	ldw	r3,12(r2)
  8125c0:	00884874 	movhi	r2,8481
  8125c4:	10884844 	addi	r2,r2,8481
  8125c8:	18800715 	stw	r2,28(r3)
  8125cc:	e0bffb17 	ldw	r2,-20(fp)
  8125d0:	10c00317 	ldw	r3,12(r2)
  8125d4:	008888b4 	movhi	r2,8738
  8125d8:	10888884 	addi	r2,r2,8738
  8125dc:	18800815 	stw	r2,32(r3)
  8125e0:	e0bffb17 	ldw	r2,-20(fp)
  8125e4:	10c00317 	ldw	r3,12(r2)
  8125e8:	0088c8f4 	movhi	r2,8995
  8125ec:	1088c8c4 	addi	r2,r2,8995
  8125f0:	18800915 	stw	r2,36(r3)
  8125f4:	e0bffb17 	ldw	r2,-20(fp)
  8125f8:	10c00317 	ldw	r3,12(r2)
  8125fc:	00800044 	movi	r2,1
  812600:	18800a15 	stw	r2,40(r3)
  812604:	e0bffb17 	ldw	r2,-20(fp)
  812608:	10c00317 	ldw	r3,12(r2)
  81260c:	008a0a34 	movhi	r2,10280
  812610:	108a0a04 	addi	r2,r2,10280
  812614:	18800115 	stw	r2,4(r3)
  812618:	e0bffb17 	ldw	r2,-20(fp)
  81261c:	10c00317 	ldw	r3,12(r2)
  812620:	00802074 	movhi	r2,129
  812624:	108b9f04 	addi	r2,r2,11900
  812628:	18800015 	stw	r2,0(r3)
  return _thread_init(tp, prio);
  81262c:	e13ffb17 	ldw	r4,-20(fp)
  812630:	e17ffe17 	ldw	r5,-8(fp)
  812634:	08123f00 	call	8123f0 <_thread_init>
}
  812638:	e037883a 	mov	sp,fp
  81263c:	dfc00117 	ldw	ra,4(sp)
  812640:	df000017 	ldw	fp,0(sp)
  812644:	dec00204 	addi	sp,sp,8
  812648:	f800283a 	ret

0081264c <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
  81264c:	defff604 	addi	sp,sp,-40
  812650:	dfc00915 	stw	ra,36(sp)
  812654:	df000815 	stw	fp,32(sp)
  812658:	df000804 	addi	fp,sp,32
  81265c:	e13ffc15 	stw	r4,-16(fp)
  812660:	e17ffd15 	stw	r5,-12(fp)
  812664:	e1bffe15 	stw	r6,-8(fp)
  812668:	e1ffff15 	stw	r7,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81266c:	0005303a 	rdctl	r2,status
  812670:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  812674:	e0fffa17 	ldw	r3,-24(fp)
  812678:	00bfff84 	movi	r2,-2
  81267c:	1884703a 	and	r2,r3,r2
  812680:	1001703a 	wrctl	status,r2
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
  812684:	e0800217 	ldw	r2,8(fp)
  812688:	d8800015 	stw	r2,0(sp)
  81268c:	e13ffc17 	ldw	r4,-16(fp)
  812690:	e17ffd17 	ldw	r5,-12(fp)
  812694:	e1bffe17 	ldw	r6,-8(fp)
  812698:	e1ffff17 	ldw	r7,-4(fp)
  81269c:	08124f40 	call	8124f4 <chThdCreateI>
  8126a0:	e0bffb15 	stw	r2,-20(fp)
  8126a4:	e13ffb17 	ldw	r4,-20(fp)
  8126a8:	000b883a 	mov	r5,zero
  8126ac:	08121e80 	call	8121e8 <chSchWakeupS>
  8126b0:	00800044 	movi	r2,1
  8126b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8126b8:	e0bff917 	ldw	r2,-28(fp)
  8126bc:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  8126c0:	e0bffb17 	ldw	r2,-20(fp)
}
  8126c4:	e037883a 	mov	sp,fp
  8126c8:	dfc00117 	ldw	ra,4(sp)
  8126cc:	df000017 	ldw	fp,0(sp)
  8126d0:	dec00204 	addi	sp,sp,8
  8126d4:	f800283a 	ret

008126d8 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
  8126d8:	defffa04 	addi	sp,sp,-24
  8126dc:	dfc00515 	stw	ra,20(sp)
  8126e0:	df000415 	stw	fp,16(sp)
  8126e4:	df000404 	addi	fp,sp,16
  8126e8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8126ec:	0005303a 	rdctl	r2,status
  8126f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8126f4:	e0fffd17 	ldw	r3,-12(fp)
  8126f8:	00bfff84 	movi	r2,-2
  8126fc:	1884703a 	and	r2,r3,r2
  812700:	1001703a 	wrctl	status,r2

  chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");

  chSysLock();
#if CH_USE_MUTEXES
  oldprio = currp->p_realprio;
  812704:	00802134 	movhi	r2,132
  812708:	10ba9c04 	addi	r2,r2,-5520
  81270c:	10800717 	ldw	r2,28(r2)
  812710:	10801017 	ldw	r2,64(r2)
  812714:	e0bffe15 	stw	r2,-8(fp)
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
  812718:	00802134 	movhi	r2,132
  81271c:	10ba9c04 	addi	r2,r2,-5520
  812720:	10800717 	ldw	r2,28(r2)
  812724:	10c00217 	ldw	r3,8(r2)
  812728:	00802134 	movhi	r2,132
  81272c:	10ba9c04 	addi	r2,r2,-5520
  812730:	10800717 	ldw	r2,28(r2)
  812734:	10801017 	ldw	r2,64(r2)
  812738:	18800626 	beq	r3,r2,812754 <chThdSetPriority+0x7c>
  81273c:	00802134 	movhi	r2,132
  812740:	10ba9c04 	addi	r2,r2,-5520
  812744:	10800717 	ldw	r2,28(r2)
  812748:	10c00217 	ldw	r3,8(r2)
  81274c:	e0bfff17 	ldw	r2,-4(fp)
  812750:	1880052e 	bgeu	r3,r2,812768 <chThdSetPriority+0x90>
    currp->p_prio = newprio;
  812754:	00802134 	movhi	r2,132
  812758:	10ba9c04 	addi	r2,r2,-5520
  81275c:	10c00717 	ldw	r3,28(r2)
  812760:	e0bfff17 	ldw	r2,-4(fp)
  812764:	18800215 	stw	r2,8(r3)
  currp->p_realprio = newprio;
  812768:	00802134 	movhi	r2,132
  81276c:	10ba9c04 	addi	r2,r2,-5520
  812770:	10c00717 	ldw	r3,28(r2)
  812774:	e0bfff17 	ldw	r2,-4(fp)
  812778:	18801015 	stw	r2,64(r3)
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
  81277c:	08122940 	call	812294 <chSchRescheduleS>
  812780:	00800044 	movi	r2,1
  812784:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  812788:	e0bffc17 	ldw	r2,-16(fp)
  81278c:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return oldprio;
  812790:	e0bffe17 	ldw	r2,-8(fp)
}
  812794:	e037883a 	mov	sp,fp
  812798:	dfc00117 	ldw	ra,4(sp)
  81279c:	df000017 	ldw	fp,0(sp)
  8127a0:	dec00204 	addi	sp,sp,8
  8127a4:	f800283a 	ret

008127a8 <chThdResume>:
 * @param[in] tp        pointer to the thread
 * @return              The pointer to the thread.
 *
 * @api
 */
Thread *chThdResume(Thread *tp) {
  8127a8:	defffb04 	addi	sp,sp,-20
  8127ac:	dfc00415 	stw	ra,16(sp)
  8127b0:	df000315 	stw	fp,12(sp)
  8127b4:	df000304 	addi	fp,sp,12
  8127b8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8127bc:	0005303a 	rdctl	r2,status
  8127c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8127c4:	e0fffe17 	ldw	r3,-8(fp)
  8127c8:	00bfff84 	movi	r2,-2
  8127cc:	1884703a 	and	r2,r3,r2
  8127d0:	1001703a 	wrctl	status,r2

  chSysLock();
  chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
              "chThdResume(), #1",
              "thread not in THD_STATE_SUSPENDED state");
  chSchWakeupS(tp, RDY_OK);
  8127d4:	e13fff17 	ldw	r4,-4(fp)
  8127d8:	000b883a 	mov	r5,zero
  8127dc:	08121e80 	call	8121e8 <chSchWakeupS>
  8127e0:	00800044 	movi	r2,1
  8127e4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8127e8:	e0bffd17 	ldw	r2,-12(fp)
  8127ec:	1001703a 	wrctl	status,r2
  chSysUnlock();
  return tp;
  8127f0:	e0bfff17 	ldw	r2,-4(fp)
}
  8127f4:	e037883a 	mov	sp,fp
  8127f8:	dfc00117 	ldw	ra,4(sp)
  8127fc:	df000017 	ldw	fp,0(sp)
  812800:	dec00204 	addi	sp,sp,8
  812804:	f800283a 	ret

00812808 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(Thread *tp) {
  812808:	defffc04 	addi	sp,sp,-16
  81280c:	df000315 	stw	fp,12(sp)
  812810:	df000304 	addi	fp,sp,12
  812814:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  812818:	0005303a 	rdctl	r2,status
  81281c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  812820:	e0fffe17 	ldw	r3,-8(fp)
  812824:	00bfff84 	movi	r2,-2
  812828:	1884703a 	and	r2,r3,r2
  81282c:	1001703a 	wrctl	status,r2

  chSysLock();
  tp->p_flags |= THD_TERMINATE;
  812830:	e0bfff17 	ldw	r2,-4(fp)
  812834:	10800743 	ldbu	r2,29(r2)
  812838:	10800114 	ori	r2,r2,4
  81283c:	1007883a 	mov	r3,r2
  812840:	e0bfff17 	ldw	r2,-4(fp)
  812844:	10c00745 	stb	r3,29(r2)
  812848:	00800044 	movi	r2,1
  81284c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  812850:	e0bffd17 	ldw	r2,-12(fp)
  812854:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  812858:	e037883a 	mov	sp,fp
  81285c:	df000017 	ldw	fp,0(sp)
  812860:	dec00104 	addi	sp,sp,4
  812864:	f800283a 	ret

00812868 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
  812868:	defffb04 	addi	sp,sp,-20
  81286c:	dfc00415 	stw	ra,16(sp)
  812870:	df000315 	stw	fp,12(sp)
  812874:	df000304 	addi	fp,sp,12
  812878:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81287c:	0005303a 	rdctl	r2,status
  812880:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  812884:	e0fffe17 	ldw	r3,-8(fp)
  812888:	00bfff84 	movi	r2,-2
  81288c:	1884703a 	and	r2,r3,r2
  812890:	1001703a 	wrctl	status,r2

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
  chThdSleepS(time);
  812894:	01000184 	movi	r4,6
  812898:	e17fff17 	ldw	r5,-4(fp)
  81289c:	08121580 	call	812158 <chSchGoSleepTimeoutS>
  8128a0:	00800044 	movi	r2,1
  8128a4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8128a8:	e0bffd17 	ldw	r2,-12(fp)
  8128ac:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  8128b0:	e037883a 	mov	sp,fp
  8128b4:	dfc00117 	ldw	ra,4(sp)
  8128b8:	df000017 	ldw	fp,0(sp)
  8128bc:	dec00204 	addi	sp,sp,8
  8128c0:	f800283a 	ret

008128c4 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
  8128c4:	defffb04 	addi	sp,sp,-20
  8128c8:	dfc00415 	stw	ra,16(sp)
  8128cc:	df000315 	stw	fp,12(sp)
  8128d0:	df000304 	addi	fp,sp,12
  8128d4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8128d8:	0005303a 	rdctl	r2,status
  8128dc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8128e0:	e0fffe17 	ldw	r3,-8(fp)
  8128e4:	00bfff84 	movi	r2,-2
  8128e8:	1884703a 	and	r2,r3,r2
  8128ec:	1001703a 	wrctl	status,r2

  chSysLock();
  if ((time -= chTimeNow()) > 0)
  8128f0:	00802134 	movhi	r2,132
  8128f4:	10baa404 	addi	r2,r2,-5488
  8128f8:	10c00317 	ldw	r3,12(r2)
  8128fc:	e0bfff17 	ldw	r2,-4(fp)
  812900:	10c5c83a 	sub	r2,r2,r3
  812904:	e0bfff15 	stw	r2,-4(fp)
  812908:	e0bfff17 	ldw	r2,-4(fp)
  81290c:	1005003a 	cmpeq	r2,r2,zero
  812910:	1000031e 	bne	r2,zero,812920 <chThdSleepUntil+0x5c>
    chThdSleepS(time);
  812914:	01000184 	movi	r4,6
  812918:	e17fff17 	ldw	r5,-4(fp)
  81291c:	08121580 	call	812158 <chSchGoSleepTimeoutS>
  812920:	00800044 	movi	r2,1
  812924:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  812928:	e0bffd17 	ldw	r2,-12(fp)
  81292c:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  812930:	e037883a 	mov	sp,fp
  812934:	dfc00117 	ldw	ra,4(sp)
  812938:	df000017 	ldw	fp,0(sp)
  81293c:	dec00204 	addi	sp,sp,8
  812940:	f800283a 	ret

00812944 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
  812944:	defffc04 	addi	sp,sp,-16
  812948:	dfc00315 	stw	ra,12(sp)
  81294c:	df000215 	stw	fp,8(sp)
  812950:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  812954:	0005303a 	rdctl	r2,status
  812958:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81295c:	e0ffff17 	ldw	r3,-4(fp)
  812960:	00bfff84 	movi	r2,-2
  812964:	1884703a 	and	r2,r3,r2
  812968:	1001703a 	wrctl	status,r2

  chSysLock();
  chSchDoYieldS();
  81296c:	00802134 	movhi	r2,132
  812970:	10ba9c04 	addi	r2,r2,-5520
  812974:	10800017 	ldw	r2,0(r2)
  812978:	10c00217 	ldw	r3,8(r2)
  81297c:	00802134 	movhi	r2,132
  812980:	10ba9c04 	addi	r2,r2,-5520
  812984:	10800717 	ldw	r2,28(r2)
  812988:	10800217 	ldw	r2,8(r2)
  81298c:	18800136 	bltu	r3,r2,812994 <chThdYield+0x50>
  812990:	08123600 	call	812360 <chSchDoReschedule>
  812994:	00800044 	movi	r2,1
  812998:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81299c:	e0bffe17 	ldw	r2,-8(fp)
  8129a0:	1001703a 	wrctl	status,r2
  chSysUnlock();
}
  8129a4:	e037883a 	mov	sp,fp
  8129a8:	dfc00117 	ldw	ra,4(sp)
  8129ac:	df000017 	ldw	fp,0(sp)
  8129b0:	dec00204 	addi	sp,sp,8
  8129b4:	f800283a 	ret

008129b8 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
  8129b8:	defffc04 	addi	sp,sp,-16
  8129bc:	dfc00315 	stw	ra,12(sp)
  8129c0:	df000215 	stw	fp,8(sp)
  8129c4:	df000204 	addi	fp,sp,8
  8129c8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8129cc:	0005303a 	rdctl	r2,status
  8129d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8129d4:	e0fffe17 	ldw	r3,-8(fp)
  8129d8:	00bfff84 	movi	r2,-2
  8129dc:	1884703a 	and	r2,r3,r2
  8129e0:	1001703a 	wrctl	status,r2

  chSysLock();
  chThdExitS(msg);
  8129e4:	e13fff17 	ldw	r4,-4(fp)
  8129e8:	0812a000 	call	812a00 <chThdExitS>
  /* The thread never returns here.*/
}
  8129ec:	e037883a 	mov	sp,fp
  8129f0:	dfc00117 	ldw	ra,4(sp)
  8129f4:	df000017 	ldw	fp,0(sp)
  8129f8:	dec00204 	addi	sp,sp,8
  8129fc:	f800283a 	ret

00812a00 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  812a00:	defffc04 	addi	sp,sp,-16
  812a04:	dfc00315 	stw	ra,12(sp)
  812a08:	df000215 	stw	fp,8(sp)
  812a0c:	df000204 	addi	fp,sp,8
  812a10:	e13fff15 	stw	r4,-4(fp)
  Thread *tp = currp;
  812a14:	00802134 	movhi	r2,132
  812a18:	10ba9c04 	addi	r2,r2,-5520
  812a1c:	10800717 	ldw	r2,28(r2)
  812a20:	e0bffe15 	stw	r2,-8(fp)

  tp->p_u.exitcode = msg;
  812a24:	e0fffe17 	ldw	r3,-8(fp)
  812a28:	e0bfff17 	ldw	r2,-4(fp)
  812a2c:	18800915 	stw	r2,36(r3)
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
  812a30:	00000506 	br	812a48 <chThdExitS+0x48>
    chSchReadyI(list_remove(&tp->p_waiting));
  812a34:	e0bffe17 	ldw	r2,-8(fp)
  812a38:	11000a04 	addi	r4,r2,40
  812a3c:	0812ab80 	call	812ab8 <list_remove>
  812a40:	1009883a 	mov	r4,r2
  812a44:	0811ec40 	call	811ec4 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
  812a48:	e0bffe17 	ldw	r2,-8(fp)
  812a4c:	10c00a17 	ldw	r3,40(r2)
  812a50:	e0bffe17 	ldw	r2,-8(fp)
  812a54:	10800a04 	addi	r2,r2,40
  812a58:	18bff61e 	bne	r3,r2,812a34 <chThdExitS+0x34>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
  812a5c:	e0bffe17 	ldw	r2,-8(fp)
  812a60:	10800743 	ldbu	r2,29(r2)
  812a64:	10803fcc 	andi	r2,r2,255
  812a68:	108000cc 	andi	r2,r2,3
  812a6c:	1004c03a 	cmpne	r2,r2,zero
  812a70:	10000a1e 	bne	r2,zero,812a9c <chThdExitS+0x9c>
    REG_REMOVE(tp);
  812a74:	e0bffe17 	ldw	r2,-8(fp)
  812a78:	10c00517 	ldw	r3,20(r2)
  812a7c:	e0bffe17 	ldw	r2,-8(fp)
  812a80:	10800417 	ldw	r2,16(r2)
  812a84:	18800415 	stw	r2,16(r3)
  812a88:	e0bffe17 	ldw	r2,-8(fp)
  812a8c:	10c00417 	ldw	r3,16(r2)
  812a90:	e0bffe17 	ldw	r2,-8(fp)
  812a94:	10800517 	ldw	r2,20(r2)
  812a98:	18800515 	stw	r2,20(r3)
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  812a9c:	01000384 	movi	r4,14
  812aa0:	0811f6c0 	call	811f6c <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
  812aa4:	e037883a 	mov	sp,fp
  812aa8:	dfc00117 	ldw	ra,4(sp)
  812aac:	df000017 	ldw	fp,0(sp)
  812ab0:	dec00204 	addi	sp,sp,8
  812ab4:	f800283a 	ret

00812ab8 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static INLINE Thread *list_remove(ThreadsList *tlp) {
  812ab8:	defffd04 	addi	sp,sp,-12
  812abc:	df000215 	stw	fp,8(sp)
  812ac0:	df000204 	addi	fp,sp,8
  812ac4:	e13fff15 	stw	r4,-4(fp)

  Thread *tp = tlp->p_next;
  812ac8:	e0bfff17 	ldw	r2,-4(fp)
  812acc:	10800017 	ldw	r2,0(r2)
  812ad0:	e0bffe15 	stw	r2,-8(fp)
  tlp->p_next = tp->p_next;
  812ad4:	e0bffe17 	ldw	r2,-8(fp)
  812ad8:	10c00017 	ldw	r3,0(r2)
  812adc:	e0bfff17 	ldw	r2,-4(fp)
  812ae0:	10c00015 	stw	r3,0(r2)
  return tp;
  812ae4:	e0bffe17 	ldw	r2,-8(fp)
}
  812ae8:	e037883a 	mov	sp,fp
  812aec:	df000017 	ldw	fp,0(sp)
  812af0:	dec00104 	addi	sp,sp,4
  812af4:	f800283a 	ret

00812af8 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(Thread *tp) {
  812af8:	defffa04 	addi	sp,sp,-24
  812afc:	dfc00515 	stw	ra,20(sp)
  812b00:	df000415 	stw	fp,16(sp)
  812b04:	df000404 	addi	fp,sp,16
  812b08:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  812b0c:	0005303a 	rdctl	r2,status
  812b10:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  812b14:	e0fffd17 	ldw	r3,-12(fp)
  812b18:	00bfff84 	movi	r2,-2
  812b1c:	1884703a 	and	r2,r3,r2
  812b20:	1001703a 	wrctl	status,r2
  chSysLock();
  chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
#if CH_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
#endif
  if (tp->p_state != THD_STATE_FINAL) {
  812b24:	e0bfff17 	ldw	r2,-4(fp)
  812b28:	10800703 	ldbu	r2,28(r2)
  812b2c:	10803fcc 	andi	r2,r2,255
  812b30:	108003a0 	cmpeqi	r2,r2,14
  812b34:	1000081e 	bne	r2,zero,812b58 <chThdWait+0x60>
    list_insert(currp, &tp->p_waiting);
  812b38:	00802134 	movhi	r2,132
  812b3c:	10ba9c04 	addi	r2,r2,-5520
  812b40:	11000717 	ldw	r4,28(r2)
  812b44:	e0bfff17 	ldw	r2,-4(fp)
  812b48:	11400a04 	addi	r5,r2,40
  812b4c:	0812b940 	call	812b94 <list_insert>
    chSchGoSleepS(THD_STATE_WTEXIT);
  812b50:	010001c4 	movi	r4,7
  812b54:	0811f6c0 	call	811f6c <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
  812b58:	e0bfff17 	ldw	r2,-4(fp)
  812b5c:	10800917 	ldw	r2,36(r2)
  812b60:	e0bffe15 	stw	r2,-8(fp)
  812b64:	00800044 	movi	r2,1
  812b68:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  812b6c:	e0bffc17 	ldw	r2,-16(fp)
  812b70:	1001703a 	wrctl	status,r2
  chSysUnlock();
#if CH_USE_DYNAMIC
  chThdRelease(tp);
  812b74:	e13fff17 	ldw	r4,-4(fp)
  812b78:	080feac0 	call	80feac <chThdRelease>
#endif
  return msg;
  812b7c:	e0bffe17 	ldw	r2,-8(fp)
}
  812b80:	e037883a 	mov	sp,fp
  812b84:	dfc00117 	ldw	ra,4(sp)
  812b88:	df000017 	ldw	fp,0(sp)
  812b8c:	dec00204 	addi	sp,sp,8
  812b90:	f800283a 	ret

00812b94 <list_insert>:
  tp->p_prev->p_next = tp->p_next;
  tp->p_next->p_prev = tp->p_prev;
  return tp;
}

static INLINE void list_insert(Thread *tp, ThreadsList *tlp) {
  812b94:	defffd04 	addi	sp,sp,-12
  812b98:	df000215 	stw	fp,8(sp)
  812b9c:	df000204 	addi	fp,sp,8
  812ba0:	e13ffe15 	stw	r4,-8(fp)
  812ba4:	e17fff15 	stw	r5,-4(fp)

  tp->p_next = tlp->p_next;
  812ba8:	e0bfff17 	ldw	r2,-4(fp)
  812bac:	10c00017 	ldw	r3,0(r2)
  812bb0:	e0bffe17 	ldw	r2,-8(fp)
  812bb4:	10c00015 	stw	r3,0(r2)
  tlp->p_next = tp;
  812bb8:	e0ffff17 	ldw	r3,-4(fp)
  812bbc:	e0bffe17 	ldw	r2,-8(fp)
  812bc0:	18800015 	stw	r2,0(r3)
}
  812bc4:	e037883a 	mov	sp,fp
  812bc8:	df000017 	ldw	fp,0(sp)
  812bcc:	dec00104 	addi	sp,sp,4
  812bd0:	f800283a 	ret

00812bd4 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
  812bd4:	deffff04 	addi	sp,sp,-4
  812bd8:	df000015 	stw	fp,0(sp)
  812bdc:	d839883a 	mov	fp,sp

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
  812be0:	00c02134 	movhi	r3,132
  812be4:	18faa404 	addi	r3,r3,-5488
  812be8:	00802134 	movhi	r2,132
  812bec:	10baa404 	addi	r2,r2,-5488
  812bf0:	10c00115 	stw	r3,4(r2)
  812bf4:	00802134 	movhi	r2,132
  812bf8:	10baa404 	addi	r2,r2,-5488
  812bfc:	10c00117 	ldw	r3,4(r2)
  812c00:	00802134 	movhi	r2,132
  812c04:	10baa404 	addi	r2,r2,-5488
  812c08:	10c00015 	stw	r3,0(r2)
  vtlist.vt_time = (systime_t)-1;
  812c0c:	00c02134 	movhi	r3,132
  812c10:	18faa404 	addi	r3,r3,-5488
  812c14:	00bfffc4 	movi	r2,-1
  812c18:	18800215 	stw	r2,8(r3)
  vtlist.vt_systime = 0;
  812c1c:	00802134 	movhi	r2,132
  812c20:	10baa404 	addi	r2,r2,-5488
  812c24:	10000315 	stw	zero,12(r2)
}
  812c28:	e037883a 	mov	sp,fp
  812c2c:	df000017 	ldw	fp,0(sp)
  812c30:	dec00104 	addi	sp,sp,4
  812c34:	f800283a 	ret

00812c38 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
  812c38:	defffa04 	addi	sp,sp,-24
  812c3c:	df000515 	stw	fp,20(sp)
  812c40:	df000504 	addi	fp,sp,20
  812c44:	e13ffc15 	stw	r4,-16(fp)
  812c48:	e17ffd15 	stw	r5,-12(fp)
  812c4c:	e1bffe15 	stw	r6,-8(fp)
  812c50:	e1ffff15 	stw	r7,-4(fp)
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
  812c54:	e0bffc17 	ldw	r2,-16(fp)
  812c58:	1005003a 	cmpeq	r2,r2,zero
  812c5c:	1000031e 	bne	r2,zero,812c6c <chVTSetI+0x34>
  812c60:	e0bffe17 	ldw	r2,-8(fp)
  812c64:	1005003a 	cmpeq	r2,r2,zero
  812c68:	1000001e 	bne	r2,zero,812c6c <chVTSetI+0x34>
             "chVTSetI");

  vtp->vt_par = par;
  812c6c:	e0fffc17 	ldw	r3,-16(fp)
  812c70:	e0bfff17 	ldw	r2,-4(fp)
  812c74:	18800415 	stw	r2,16(r3)
  vtp->vt_func = vtfunc;
  812c78:	e0fffc17 	ldw	r3,-16(fp)
  812c7c:	e0bffe17 	ldw	r2,-8(fp)
  812c80:	18800315 	stw	r2,12(r3)
  p = vtlist.vt_next;
  812c84:	00802134 	movhi	r2,132
  812c88:	10baa404 	addi	r2,r2,-5488
  812c8c:	10800017 	ldw	r2,0(r2)
  812c90:	e0bffb15 	stw	r2,-20(fp)
  while (p->vt_time < time) {
  812c94:	00000806 	br	812cb8 <chVTSetI+0x80>
    time -= p->vt_time;
  812c98:	e0bffb17 	ldw	r2,-20(fp)
  812c9c:	10c00217 	ldw	r3,8(r2)
  812ca0:	e0bffd17 	ldw	r2,-12(fp)
  812ca4:	10c5c83a 	sub	r2,r2,r3
  812ca8:	e0bffd15 	stw	r2,-12(fp)
    p = p->vt_next;
  812cac:	e0bffb17 	ldw	r2,-20(fp)
  812cb0:	10800017 	ldw	r2,0(r2)
  812cb4:	e0bffb15 	stw	r2,-20(fp)
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
  812cb8:	e0bffb17 	ldw	r2,-20(fp)
  812cbc:	10c00217 	ldw	r3,8(r2)
  812cc0:	e0bffd17 	ldw	r2,-12(fp)
  812cc4:	18bff436 	bltu	r3,r2,812c98 <chVTSetI+0x60>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
  812cc8:	e0fffc17 	ldw	r3,-16(fp)
  812ccc:	e0bffb17 	ldw	r2,-20(fp)
  812cd0:	18800015 	stw	r2,0(r3)
  812cd4:	e0bffc17 	ldw	r2,-16(fp)
  812cd8:	10800017 	ldw	r2,0(r2)
  812cdc:	10c00117 	ldw	r3,4(r2)
  812ce0:	e0bffc17 	ldw	r2,-16(fp)
  812ce4:	10c00115 	stw	r3,4(r2)
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  812ce8:	e0bffc17 	ldw	r2,-16(fp)
  812cec:	11000117 	ldw	r4,4(r2)
  812cf0:	e0fffb17 	ldw	r3,-20(fp)
  812cf4:	e0bffc17 	ldw	r2,-16(fp)
  812cf8:	18800115 	stw	r2,4(r3)
  812cfc:	e0bffb17 	ldw	r2,-20(fp)
  812d00:	10800117 	ldw	r2,4(r2)
  812d04:	20800015 	stw	r2,0(r4)
  vtp->vt_time = time;
  812d08:	e0fffc17 	ldw	r3,-16(fp)
  812d0c:	e0bffd17 	ldw	r2,-12(fp)
  812d10:	18800215 	stw	r2,8(r3)
  if (p != (void *)&vtlist)
  812d14:	e0fffb17 	ldw	r3,-20(fp)
  812d18:	00802134 	movhi	r2,132
  812d1c:	10baa404 	addi	r2,r2,-5488
  812d20:	18800626 	beq	r3,r2,812d3c <chVTSetI+0x104>
    p->vt_time -= time;
  812d24:	e0bffb17 	ldw	r2,-20(fp)
  812d28:	10c00217 	ldw	r3,8(r2)
  812d2c:	e0bffd17 	ldw	r2,-12(fp)
  812d30:	1887c83a 	sub	r3,r3,r2
  812d34:	e0bffb17 	ldw	r2,-20(fp)
  812d38:	10c00215 	stw	r3,8(r2)
}
  812d3c:	e037883a 	mov	sp,fp
  812d40:	df000017 	ldw	fp,0(sp)
  812d44:	dec00104 	addi	sp,sp,4
  812d48:	f800283a 	ret

00812d4c <chVTResetI>:
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
  812d4c:	defffe04 	addi	sp,sp,-8
  812d50:	df000115 	stw	fp,4(sp)
  812d54:	df000104 	addi	fp,sp,4
  812d58:	e13fff15 	stw	r4,-4(fp)
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
  812d5c:	e0bfff17 	ldw	r2,-4(fp)
  812d60:	10c00017 	ldw	r3,0(r2)
  812d64:	00802134 	movhi	r2,132
  812d68:	10baa404 	addi	r2,r2,-5488
  812d6c:	18800926 	beq	r3,r2,812d94 <chVTResetI+0x48>
    vtp->vt_next->vt_time += vtp->vt_time;
  812d70:	e0bfff17 	ldw	r2,-4(fp)
  812d74:	11000017 	ldw	r4,0(r2)
  812d78:	e0bfff17 	ldw	r2,-4(fp)
  812d7c:	10800017 	ldw	r2,0(r2)
  812d80:	10c00217 	ldw	r3,8(r2)
  812d84:	e0bfff17 	ldw	r2,-4(fp)
  812d88:	10800217 	ldw	r2,8(r2)
  812d8c:	1885883a 	add	r2,r3,r2
  812d90:	20800215 	stw	r2,8(r4)
  vtp->vt_prev->vt_next = vtp->vt_next;
  812d94:	e0bfff17 	ldw	r2,-4(fp)
  812d98:	10c00117 	ldw	r3,4(r2)
  812d9c:	e0bfff17 	ldw	r2,-4(fp)
  812da0:	10800017 	ldw	r2,0(r2)
  812da4:	18800015 	stw	r2,0(r3)
  vtp->vt_next->vt_prev = vtp->vt_prev;
  812da8:	e0bfff17 	ldw	r2,-4(fp)
  812dac:	10c00017 	ldw	r3,0(r2)
  812db0:	e0bfff17 	ldw	r2,-4(fp)
  812db4:	10800117 	ldw	r2,4(r2)
  812db8:	18800115 	stw	r2,4(r3)
  vtp->vt_func = (vtfunc_t)NULL;
  812dbc:	e0bfff17 	ldw	r2,-4(fp)
  812dc0:	10000315 	stw	zero,12(r2)
}
  812dc4:	e037883a 	mov	sp,fp
  812dc8:	df000017 	ldw	fp,0(sp)
  812dcc:	dec00104 	addi	sp,sp,4
  812dd0:	f800283a 	ret

00812dd4 <chTimeIsWithin>:
 * @retval TRUE         current time within the specified time window.
 * @retval FALSE        current time not within the specified time window.
 *
 * @api
 */
bool_t chTimeIsWithin(systime_t start, systime_t end) {
  812dd4:	defff904 	addi	sp,sp,-28
  812dd8:	df000615 	stw	fp,24(sp)
  812ddc:	df000604 	addi	fp,sp,24
  812de0:	e13ffb15 	stw	r4,-20(fp)
  812de4:	e17ffc15 	stw	r5,-16(fp)

  systime_t time = chTimeNow();
  812de8:	00802134 	movhi	r2,132
  812dec:	10baa404 	addi	r2,r2,-5488
  812df0:	10800317 	ldw	r2,12(r2)
  812df4:	e0bffa15 	stw	r2,-24(fp)
  return end > start ? (time >= start) && (time < end) :
  812df8:	e0fffc17 	ldw	r3,-16(fp)
  812dfc:	e0bffb17 	ldw	r2,-20(fp)
  812e00:	10c00d2e 	bgeu	r2,r3,812e38 <chTimeIsWithin+0x64>
  812e04:	e0fffa17 	ldw	r3,-24(fp)
  812e08:	e0bffb17 	ldw	r2,-20(fp)
  812e0c:	18800636 	bltu	r3,r2,812e28 <chTimeIsWithin+0x54>
  812e10:	e0fffa17 	ldw	r3,-24(fp)
  812e14:	e0bffc17 	ldw	r2,-16(fp)
  812e18:	1880032e 	bgeu	r3,r2,812e28 <chTimeIsWithin+0x54>
  812e1c:	00800044 	movi	r2,1
  812e20:	e0bffe15 	stw	r2,-8(fp)
  812e24:	00000106 	br	812e2c <chTimeIsWithin+0x58>
  812e28:	e03ffe15 	stw	zero,-8(fp)
  812e2c:	e0bffe17 	ldw	r2,-8(fp)
  812e30:	e0bfff15 	stw	r2,-4(fp)
  812e34:	00000c06 	br	812e68 <chTimeIsWithin+0x94>
  812e38:	e0fffa17 	ldw	r3,-24(fp)
  812e3c:	e0bffb17 	ldw	r2,-20(fp)
  812e40:	1880032e 	bgeu	r3,r2,812e50 <chTimeIsWithin+0x7c>
  812e44:	e0fffa17 	ldw	r3,-24(fp)
  812e48:	e0bffc17 	ldw	r2,-16(fp)
  812e4c:	1880032e 	bgeu	r3,r2,812e5c <chTimeIsWithin+0x88>
  812e50:	00800044 	movi	r2,1
  812e54:	e0bffd15 	stw	r2,-12(fp)
  812e58:	00000106 	br	812e60 <chTimeIsWithin+0x8c>
  812e5c:	e03ffd15 	stw	zero,-12(fp)
  812e60:	e0bffd17 	ldw	r2,-12(fp)
  812e64:	e0bfff15 	stw	r2,-4(fp)
  812e68:	e0bfff17 	ldw	r2,-4(fp)
                       (time >= start) || (time < end);
}
  812e6c:	e037883a 	mov	sp,fp
  812e70:	df000017 	ldw	fp,0(sp)
  812e74:	dec00104 	addi	sp,sp,4
  812e78:	f800283a 	ret

00812e7c <_port_thread_start>:
/*                                                                         */
/*  Start a thread by invoking its work function.                          */
/***************************************************************************/
_port_thread_start:

      mov   r4, r17        /* r4 = Register Arguments (First 32 bits) */
  812e7c:	8809883a 	mov	r4,r17
      mov   r5, r16        /* Store thread pointer for the callr,     */
  812e80:	800b883a 	mov	r5,r16
      callr r5             /* and call the thread */
  812e84:	283ee83a 	callr	r5
      call  chThdExit      /* This is the thread exit function. */
  812e88:	08129b80 	call	8129b8 <chThdExit>

00812e8c <_port_thread_start_loop>:
      
_port_thread_start_loop:      
      br    _port_thread_start_loop
  812e8c:	003fff06 	br	812e8c <_port_thread_start_loop>

00812e90 <port_switch>:
/***************************************************************************/
port_switch:

      /* r4 = ntp, r5 = otp */

      addi  sp, sp, -44    /* Size of the intctx structure */
  812e90:	defff504 	addi	sp,sp,-44
      
      stw   ra,   0(sp)
  812e94:	dfc00015 	stw	ra,0(sp)
      stw   fp,   4(sp)
  812e98:	df000115 	stw	fp,4(sp)
      stw   r16,  8(sp)
  812e9c:	dc000215 	stw	r16,8(sp)
      stw   r17, 12(sp)
  812ea0:	dc400315 	stw	r17,12(sp)
      stw   r18, 16(sp)
  812ea4:	dc800415 	stw	r18,16(sp)
      stw   r19, 20(sp)
  812ea8:	dcc00515 	stw	r19,20(sp)
      stw   r20, 24(sp)
  812eac:	dd000615 	stw	r20,24(sp)
      stw   r21, 28(sp)
  812eb0:	dd400715 	stw	r21,28(sp)
      stw   r22, 32(sp)
  812eb4:	dd800815 	stw	r22,32(sp)
      stw   r23, 36(sp)
  812eb8:	ddc00915 	stw	r23,36(sp)
      
      rdctl r23, status    /* r23 is not more needed and can */
  812ebc:	002f303a 	rdctl	r23,status
      stw   r23, 40(sp)    /* be used here to store the status */
  812ec0:	ddc00a15 	stw	r23,40(sp)
      
      stw   sp, 12(r5)     /* Save old stack: otp->p_ctx.sp = sp */
  812ec4:	2ec00315 	stw	sp,12(r5)
      
      ldw   sp, 12(r4)     /* Get new stack: sp = ntp->p_ctx.sp */
  812ec8:	26c00317 	ldw	sp,12(r4)
      
      ldw   ra,   0(sp)
  812ecc:	dfc00017 	ldw	ra,0(sp)
      ldw   fp,   4(sp)
  812ed0:	df000117 	ldw	fp,4(sp)
      ldw   r16,  8(sp)
  812ed4:	dc000217 	ldw	r16,8(sp)
      ldw   r17, 12(sp)
  812ed8:	dc400317 	ldw	r17,12(sp)
      ldw   r18, 16(sp)
  812edc:	dc800417 	ldw	r18,16(sp)
      ldw   r19, 20(sp)
  812ee0:	dcc00517 	ldw	r19,20(sp)
      ldw   r20, 24(sp)
  812ee4:	dd000617 	ldw	r20,24(sp)
      ldw   r21, 28(sp)
  812ee8:	dd400717 	ldw	r21,28(sp)
      ldw   r22, 32(sp)
  812eec:	dd800817 	ldw	r22,32(sp)
      ldw   r23, 36(sp)
  812ef0:	ddc00917 	ldw	r23,36(sp)
      
      ldw   r4,  40(sp)    /* r4 is not more needed and can */
  812ef4:	d9000a17 	ldw	r4,40(sp)
      wrctl status, r4     /* be used here to store the status */
  812ef8:	2001703a 	wrctl	status,r4
      
      addi  sp, sp, 44     /* Size of the intctx structure */
  812efc:	dec00b04 	addi	sp,sp,44
      
      ret
  812f00:	f800283a 	ret
   
      nop
  812f04:	0001883a 	nop

00812f08 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  812f08:	defff804 	addi	sp,sp,-32
  812f0c:	dfc00715 	stw	ra,28(sp)
  812f10:	df000615 	stw	fp,24(sp)
  812f14:	df000604 	addi	fp,sp,24
  812f18:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  812f1c:	e0bffc17 	ldw	r2,-16(fp)
  812f20:	1004803a 	cmplt	r2,r2,zero
  812f24:	1000091e 	bne	r2,zero,812f4c <close+0x44>
  812f28:	e13ffc17 	ldw	r4,-16(fp)
  812f2c:	01400304 	movi	r5,12
  812f30:	08064840 	call	806484 <__mulsi3>
  812f34:	1007883a 	mov	r3,r2
  812f38:	008020b4 	movhi	r2,130
  812f3c:	10a48304 	addi	r2,r2,-28148
  812f40:	1887883a 	add	r3,r3,r2
  812f44:	e0ffff15 	stw	r3,-4(fp)
  812f48:	00000106 	br	812f50 <close+0x48>
  812f4c:	e03fff15 	stw	zero,-4(fp)
  812f50:	e0bfff17 	ldw	r2,-4(fp)
  812f54:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
  812f58:	e0bffb17 	ldw	r2,-20(fp)
  812f5c:	1005003a 	cmpeq	r2,r2,zero
  812f60:	10001d1e 	bne	r2,zero,812fd8 <close+0xd0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  812f64:	e0bffb17 	ldw	r2,-20(fp)
  812f68:	10800017 	ldw	r2,0(r2)
  812f6c:	10800417 	ldw	r2,16(r2)
  812f70:	1005003a 	cmpeq	r2,r2,zero
  812f74:	1000071e 	bne	r2,zero,812f94 <close+0x8c>
  812f78:	e0bffb17 	ldw	r2,-20(fp)
  812f7c:	10800017 	ldw	r2,0(r2)
  812f80:	10800417 	ldw	r2,16(r2)
  812f84:	e13ffb17 	ldw	r4,-20(fp)
  812f88:	103ee83a 	callr	r2
  812f8c:	e0bffe15 	stw	r2,-8(fp)
  812f90:	00000106 	br	812f98 <close+0x90>
  812f94:	e03ffe15 	stw	zero,-8(fp)
  812f98:	e0bffe17 	ldw	r2,-8(fp)
  812f9c:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  812fa0:	e13ffc17 	ldw	r4,-16(fp)
  812fa4:	0813a4c0 	call	813a4c <alt_release_fd>
    if (rval < 0)
  812fa8:	e0bffa17 	ldw	r2,-24(fp)
  812fac:	1004403a 	cmpge	r2,r2,zero
  812fb0:	1000071e 	bne	r2,zero,812fd0 <close+0xc8>
    {
      ALT_ERRNO = -rval;
  812fb4:	08130080 	call	813008 <alt_get_errno>
  812fb8:	e0fffa17 	ldw	r3,-24(fp)
  812fbc:	00c7c83a 	sub	r3,zero,r3
  812fc0:	10c00015 	stw	r3,0(r2)
      return -1;
  812fc4:	00bfffc4 	movi	r2,-1
  812fc8:	e0bffd15 	stw	r2,-12(fp)
  812fcc:	00000806 	br	812ff0 <close+0xe8>
    }
    return 0;
  812fd0:	e03ffd15 	stw	zero,-12(fp)
  812fd4:	00000606 	br	812ff0 <close+0xe8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  812fd8:	08130080 	call	813008 <alt_get_errno>
  812fdc:	1007883a 	mov	r3,r2
  812fe0:	00801444 	movi	r2,81
  812fe4:	18800015 	stw	r2,0(r3)
    return -1;
  812fe8:	00bfffc4 	movi	r2,-1
  812fec:	e0bffd15 	stw	r2,-12(fp)
  812ff0:	e0bffd17 	ldw	r2,-12(fp)
  }
}
  812ff4:	e037883a 	mov	sp,fp
  812ff8:	dfc00117 	ldw	ra,4(sp)
  812ffc:	df000017 	ldw	fp,0(sp)
  813000:	dec00204 	addi	sp,sp,8
  813004:	f800283a 	ret

00813008 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  813008:	defffd04 	addi	sp,sp,-12
  81300c:	dfc00215 	stw	ra,8(sp)
  813010:	df000115 	stw	fp,4(sp)
  813014:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  813018:	008020b4 	movhi	r2,130
  81301c:	10a93c04 	addi	r2,r2,-23312
  813020:	10800017 	ldw	r2,0(r2)
  813024:	1005003a 	cmpeq	r2,r2,zero
  813028:	1000061e 	bne	r2,zero,813044 <alt_get_errno+0x3c>
  81302c:	008020b4 	movhi	r2,130
  813030:	10a93c04 	addi	r2,r2,-23312
  813034:	10800017 	ldw	r2,0(r2)
  813038:	103ee83a 	callr	r2
  81303c:	e0bfff15 	stw	r2,-4(fp)
  813040:	00000306 	br	813050 <alt_get_errno+0x48>
  813044:	008020b4 	movhi	r2,130
  813048:	10b02404 	addi	r2,r2,-16240
  81304c:	e0bfff15 	stw	r2,-4(fp)
  813050:	e0bfff17 	ldw	r2,-4(fp)
}
  813054:	e037883a 	mov	sp,fp
  813058:	dfc00117 	ldw	ra,4(sp)
  81305c:	df000017 	ldw	fp,0(sp)
  813060:	dec00204 	addi	sp,sp,8
  813064:	f800283a 	ret

00813068 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  813068:	defffc04 	addi	sp,sp,-16
  81306c:	df000315 	stw	fp,12(sp)
  813070:	df000304 	addi	fp,sp,12
  813074:	e13ffd15 	stw	r4,-12(fp)
  813078:	e17ffe15 	stw	r5,-8(fp)
  81307c:	e1bfff15 	stw	r6,-4(fp)
  return len;
  813080:	e0bfff17 	ldw	r2,-4(fp)
}
  813084:	e037883a 	mov	sp,fp
  813088:	df000017 	ldw	fp,0(sp)
  81308c:	dec00104 	addi	sp,sp,4
  813090:	f800283a 	ret

00813094 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  813094:	defff904 	addi	sp,sp,-28
  813098:	dfc00615 	stw	ra,24(sp)
  81309c:	df000515 	stw	fp,20(sp)
  8130a0:	df000504 	addi	fp,sp,20
  8130a4:	e13ffc15 	stw	r4,-16(fp)
  8130a8:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  8130ac:	e0bffc17 	ldw	r2,-16(fp)
  8130b0:	1004803a 	cmplt	r2,r2,zero
  8130b4:	1000091e 	bne	r2,zero,8130dc <fstat+0x48>
  8130b8:	e13ffc17 	ldw	r4,-16(fp)
  8130bc:	01400304 	movi	r5,12
  8130c0:	08064840 	call	806484 <__mulsi3>
  8130c4:	1007883a 	mov	r3,r2
  8130c8:	008020b4 	movhi	r2,130
  8130cc:	10a48304 	addi	r2,r2,-28148
  8130d0:	1887883a 	add	r3,r3,r2
  8130d4:	e0ffff15 	stw	r3,-4(fp)
  8130d8:	00000106 	br	8130e0 <fstat+0x4c>
  8130dc:	e03fff15 	stw	zero,-4(fp)
  8130e0:	e0bfff17 	ldw	r2,-4(fp)
  8130e4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  8130e8:	e0bffb17 	ldw	r2,-20(fp)
  8130ec:	1005003a 	cmpeq	r2,r2,zero
  8130f0:	1000121e 	bne	r2,zero,81313c <fstat+0xa8>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  8130f4:	e0bffb17 	ldw	r2,-20(fp)
  8130f8:	10800017 	ldw	r2,0(r2)
  8130fc:	10800817 	ldw	r2,32(r2)
  813100:	1005003a 	cmpeq	r2,r2,zero
  813104:	1000081e 	bne	r2,zero,813128 <fstat+0x94>
    {
      return fd->dev->fstat(fd, st);
  813108:	e0bffb17 	ldw	r2,-20(fp)
  81310c:	10800017 	ldw	r2,0(r2)
  813110:	10800817 	ldw	r2,32(r2)
  813114:	e13ffb17 	ldw	r4,-20(fp)
  813118:	e17ffd17 	ldw	r5,-12(fp)
  81311c:	103ee83a 	callr	r2
  813120:	e0bffe15 	stw	r2,-8(fp)
  813124:	00000b06 	br	813154 <fstat+0xc0>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  813128:	e0fffd17 	ldw	r3,-12(fp)
  81312c:	00880004 	movi	r2,8192
  813130:	18800115 	stw	r2,4(r3)
      return 0;
  813134:	e03ffe15 	stw	zero,-8(fp)
  813138:	00000606 	br	813154 <fstat+0xc0>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  81313c:	081316c0 	call	81316c <alt_get_errno>
  813140:	1007883a 	mov	r3,r2
  813144:	00801444 	movi	r2,81
  813148:	18800015 	stw	r2,0(r3)
    return -1;
  81314c:	00bfffc4 	movi	r2,-1
  813150:	e0bffe15 	stw	r2,-8(fp)
  813154:	e0bffe17 	ldw	r2,-8(fp)
  }
}
  813158:	e037883a 	mov	sp,fp
  81315c:	dfc00117 	ldw	ra,4(sp)
  813160:	df000017 	ldw	fp,0(sp)
  813164:	dec00204 	addi	sp,sp,8
  813168:	f800283a 	ret

0081316c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  81316c:	defffd04 	addi	sp,sp,-12
  813170:	dfc00215 	stw	ra,8(sp)
  813174:	df000115 	stw	fp,4(sp)
  813178:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  81317c:	008020b4 	movhi	r2,130
  813180:	10a93c04 	addi	r2,r2,-23312
  813184:	10800017 	ldw	r2,0(r2)
  813188:	1005003a 	cmpeq	r2,r2,zero
  81318c:	1000061e 	bne	r2,zero,8131a8 <alt_get_errno+0x3c>
  813190:	008020b4 	movhi	r2,130
  813194:	10a93c04 	addi	r2,r2,-23312
  813198:	10800017 	ldw	r2,0(r2)
  81319c:	103ee83a 	callr	r2
  8131a0:	e0bfff15 	stw	r2,-4(fp)
  8131a4:	00000306 	br	8131b4 <alt_get_errno+0x48>
  8131a8:	008020b4 	movhi	r2,130
  8131ac:	10b02404 	addi	r2,r2,-16240
  8131b0:	e0bfff15 	stw	r2,-4(fp)
  8131b4:	e0bfff17 	ldw	r2,-4(fp)
}
  8131b8:	e037883a 	mov	sp,fp
  8131bc:	dfc00117 	ldw	ra,4(sp)
  8131c0:	df000017 	ldw	fp,0(sp)
  8131c4:	dec00204 	addi	sp,sp,8
  8131c8:	f800283a 	ret

008131cc <alt_getchar>:
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
  8131cc:	defffe04 	addi	sp,sp,-8
  8131d0:	dfc00115 	stw	ra,4(sp)
  8131d4:	df000015 	stw	fp,0(sp)
  8131d8:	d839883a 	mov	fp,sp
    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
        return -1;
    }
    return c;
#else
    return getchar();
  8131dc:	008020b4 	movhi	r2,130
  8131e0:	10a93104 	addi	r2,r2,-23356
  8131e4:	10800017 	ldw	r2,0(r2)
  8131e8:	11000117 	ldw	r4,4(r2)
  8131ec:	08168d00 	call	8168d0 <getc>
#endif
}
  8131f0:	e037883a 	mov	sp,fp
  8131f4:	dfc00117 	ldw	ra,4(sp)
  8131f8:	df000017 	ldw	fp,0(sp)
  8131fc:	dec00204 	addi	sp,sp,8
  813200:	f800283a 	ret

00813204 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
  813204:	deffeb04 	addi	sp,sp,-84
  813208:	dfc01415 	stw	ra,80(sp)
  81320c:	df001315 	stw	fp,76(sp)
  813210:	df001304 	addi	fp,sp,76
  813214:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  813218:	e0bffd17 	ldw	r2,-12(fp)
  81321c:	1004803a 	cmplt	r2,r2,zero
  813220:	1000091e 	bne	r2,zero,813248 <isatty+0x44>
  813224:	e13ffd17 	ldw	r4,-12(fp)
  813228:	01400304 	movi	r5,12
  81322c:	08064840 	call	806484 <__mulsi3>
  813230:	1007883a 	mov	r3,r2
  813234:	008020b4 	movhi	r2,130
  813238:	10a48304 	addi	r2,r2,-28148
  81323c:	1887883a 	add	r3,r3,r2
  813240:	e0ffff15 	stw	r3,-4(fp)
  813244:	00000106 	br	81324c <isatty+0x48>
  813248:	e03fff15 	stw	zero,-4(fp)
  81324c:	e0bfff17 	ldw	r2,-4(fp)
  813250:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
  813254:	e0bfed17 	ldw	r2,-76(fp)
  813258:	1005003a 	cmpeq	r2,r2,zero
  81325c:	10000f1e 	bne	r2,zero,81329c <isatty+0x98>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  813260:	e0bfed17 	ldw	r2,-76(fp)
  813264:	10800017 	ldw	r2,0(r2)
  813268:	10800817 	ldw	r2,32(r2)
  81326c:	1004c03a 	cmpne	r2,r2,zero
  813270:	1000031e 	bne	r2,zero,813280 <isatty+0x7c>
    {
      return 1;
  813274:	00800044 	movi	r2,1
  813278:	e0bffe15 	stw	r2,-8(fp)
  81327c:	00000c06 	br	8132b0 <isatty+0xac>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  813280:	e17fee04 	addi	r5,fp,-72
  813284:	e13ffd17 	ldw	r4,-12(fp)
  813288:	08130940 	call	813094 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  81328c:	e0bfef17 	ldw	r2,-68(fp)
  813290:	10880020 	cmpeqi	r2,r2,8192
  813294:	e0bffe15 	stw	r2,-8(fp)
  813298:	00000506 	br	8132b0 <isatty+0xac>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  81329c:	08132c80 	call	8132c8 <alt_get_errno>
  8132a0:	1007883a 	mov	r3,r2
  8132a4:	00801444 	movi	r2,81
  8132a8:	18800015 	stw	r2,0(r3)
    return 0;
  8132ac:	e03ffe15 	stw	zero,-8(fp)
  8132b0:	e0bffe17 	ldw	r2,-8(fp)
  }
}
  8132b4:	e037883a 	mov	sp,fp
  8132b8:	dfc00117 	ldw	ra,4(sp)
  8132bc:	df000017 	ldw	fp,0(sp)
  8132c0:	dec00204 	addi	sp,sp,8
  8132c4:	f800283a 	ret

008132c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  8132c8:	defffd04 	addi	sp,sp,-12
  8132cc:	dfc00215 	stw	ra,8(sp)
  8132d0:	df000115 	stw	fp,4(sp)
  8132d4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  8132d8:	008020b4 	movhi	r2,130
  8132dc:	10a93c04 	addi	r2,r2,-23312
  8132e0:	10800017 	ldw	r2,0(r2)
  8132e4:	1005003a 	cmpeq	r2,r2,zero
  8132e8:	1000061e 	bne	r2,zero,813304 <alt_get_errno+0x3c>
  8132ec:	008020b4 	movhi	r2,130
  8132f0:	10a93c04 	addi	r2,r2,-23312
  8132f4:	10800017 	ldw	r2,0(r2)
  8132f8:	103ee83a 	callr	r2
  8132fc:	e0bfff15 	stw	r2,-4(fp)
  813300:	00000306 	br	813310 <alt_get_errno+0x48>
  813304:	008020b4 	movhi	r2,130
  813308:	10b02404 	addi	r2,r2,-16240
  81330c:	e0bfff15 	stw	r2,-4(fp)
  813310:	e0bfff17 	ldw	r2,-4(fp)
}
  813314:	e037883a 	mov	sp,fp
  813318:	dfc00117 	ldw	ra,4(sp)
  81331c:	df000017 	ldw	fp,0(sp)
  813320:	dec00204 	addi	sp,sp,8
  813324:	f800283a 	ret

00813328 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  813328:	defffe04 	addi	sp,sp,-8
  81332c:	dfc00115 	stw	ra,4(sp)
  813330:	df000015 	stw	fp,0(sp)
  813334:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  813338:	010020b4 	movhi	r4,130
  81333c:	21294104 	addi	r4,r4,-23292
  813340:	014020b4 	movhi	r5,130
  813344:	29626e04 	addi	r5,r5,-30280
  813348:	018020b4 	movhi	r6,130
  81334c:	31a94104 	addi	r6,r6,-23292
  813350:	08133a80 	call	8133a8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  813354:	01002034 	movhi	r4,128
  813358:	21000804 	addi	r4,r4,32
  81335c:	01402034 	movhi	r5,128
  813360:	29400804 	addi	r5,r5,32
  813364:	01802034 	movhi	r6,128
  813368:	31807104 	addi	r6,r6,452
  81336c:	08133a80 	call	8133a8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  813370:	01002074 	movhi	r4,129
  813374:	211d0a04 	addi	r4,r4,29736
  813378:	01402074 	movhi	r5,129
  81337c:	295d0a04 	addi	r5,r5,29736
  813380:	018020b4 	movhi	r6,130
  813384:	31a26e04 	addi	r6,r6,-30280
  813388:	08133a80 	call	8133a8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  81338c:	0815ad40 	call	815ad4 <alt_dcache_flush_all>
  alt_icache_flush_all();
  813390:	0815ccc0 	call	815ccc <alt_icache_flush_all>
}
  813394:	e037883a 	mov	sp,fp
  813398:	dfc00117 	ldw	ra,4(sp)
  81339c:	df000017 	ldw	fp,0(sp)
  8133a0:	dec00204 	addi	sp,sp,8
  8133a4:	f800283a 	ret

008133a8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  8133a8:	defffc04 	addi	sp,sp,-16
  8133ac:	df000315 	stw	fp,12(sp)
  8133b0:	df000304 	addi	fp,sp,12
  8133b4:	e13ffd15 	stw	r4,-12(fp)
  8133b8:	e17ffe15 	stw	r5,-8(fp)
  8133bc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  8133c0:	e0fffe17 	ldw	r3,-8(fp)
  8133c4:	e0bffd17 	ldw	r2,-12(fp)
  8133c8:	18800e26 	beq	r3,r2,813404 <alt_load_section+0x5c>
  {
    while( to != end )
  8133cc:	00000a06 	br	8133f8 <alt_load_section+0x50>
    {
      *to++ = *from++;
  8133d0:	e0bffd17 	ldw	r2,-12(fp)
  8133d4:	10c00017 	ldw	r3,0(r2)
  8133d8:	e0bffe17 	ldw	r2,-8(fp)
  8133dc:	10c00015 	stw	r3,0(r2)
  8133e0:	e0bffe17 	ldw	r2,-8(fp)
  8133e4:	10800104 	addi	r2,r2,4
  8133e8:	e0bffe15 	stw	r2,-8(fp)
  8133ec:	e0bffd17 	ldw	r2,-12(fp)
  8133f0:	10800104 	addi	r2,r2,4
  8133f4:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  8133f8:	e0fffe17 	ldw	r3,-8(fp)
  8133fc:	e0bfff17 	ldw	r2,-4(fp)
  813400:	18bff31e 	bne	r3,r2,8133d0 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  813404:	e037883a 	mov	sp,fp
  813408:	df000017 	ldw	fp,0(sp)
  81340c:	dec00104 	addi	sp,sp,4
  813410:	f800283a 	ret

00813414 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
  813414:	defff804 	addi	sp,sp,-32
  813418:	dfc00715 	stw	ra,28(sp)
  81341c:	df000615 	stw	fp,24(sp)
  813420:	df000604 	addi	fp,sp,24
  813424:	e13ffc15 	stw	r4,-16(fp)
  813428:	e17ffd15 	stw	r5,-12(fp)
  81342c:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
  813430:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  813434:	e0bffc17 	ldw	r2,-16(fp)
  813438:	1004803a 	cmplt	r2,r2,zero
  81343c:	1000091e 	bne	r2,zero,813464 <lseek+0x50>
  813440:	e13ffc17 	ldw	r4,-16(fp)
  813444:	01400304 	movi	r5,12
  813448:	08064840 	call	806484 <__mulsi3>
  81344c:	1007883a 	mov	r3,r2
  813450:	008020b4 	movhi	r2,130
  813454:	10a48304 	addi	r2,r2,-28148
  813458:	1887883a 	add	r3,r3,r2
  81345c:	e0ffff15 	stw	r3,-4(fp)
  813460:	00000106 	br	813468 <lseek+0x54>
  813464:	e03fff15 	stw	zero,-4(fp)
  813468:	e0bfff17 	ldw	r2,-4(fp)
  81346c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
  813470:	e0bffb17 	ldw	r2,-20(fp)
  813474:	1005003a 	cmpeq	r2,r2,zero
  813478:	1000111e 	bne	r2,zero,8134c0 <lseek+0xac>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  81347c:	e0bffb17 	ldw	r2,-20(fp)
  813480:	10800017 	ldw	r2,0(r2)
  813484:	10800717 	ldw	r2,28(r2)
  813488:	1005003a 	cmpeq	r2,r2,zero
  81348c:	1000091e 	bne	r2,zero,8134b4 <lseek+0xa0>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  813490:	e0bffb17 	ldw	r2,-20(fp)
  813494:	10800017 	ldw	r2,0(r2)
  813498:	10800717 	ldw	r2,28(r2)
  81349c:	e13ffb17 	ldw	r4,-20(fp)
  8134a0:	e17ffd17 	ldw	r5,-12(fp)
  8134a4:	e1bffe17 	ldw	r6,-8(fp)
  8134a8:	103ee83a 	callr	r2
  8134ac:	e0bffa15 	stw	r2,-24(fp)
  8134b0:	00000506 	br	8134c8 <lseek+0xb4>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  8134b4:	00bfde84 	movi	r2,-134
  8134b8:	e0bffa15 	stw	r2,-24(fp)
  8134bc:	00000206 	br	8134c8 <lseek+0xb4>
    }
  }
  else  
  {
    rc = -EBADFD;
  8134c0:	00bfebc4 	movi	r2,-81
  8134c4:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
  8134c8:	e0bffa17 	ldw	r2,-24(fp)
  8134cc:	1004403a 	cmpge	r2,r2,zero
  8134d0:	1000071e 	bne	r2,zero,8134f0 <lseek+0xdc>
  {
    ALT_ERRNO = -rc;
  8134d4:	08135080 	call	813508 <alt_get_errno>
  8134d8:	1007883a 	mov	r3,r2
  8134dc:	e0bffa17 	ldw	r2,-24(fp)
  8134e0:	0085c83a 	sub	r2,zero,r2
  8134e4:	18800015 	stw	r2,0(r3)
    rc = -1;
  8134e8:	00bfffc4 	movi	r2,-1
  8134ec:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
  8134f0:	e0bffa17 	ldw	r2,-24(fp)
}
  8134f4:	e037883a 	mov	sp,fp
  8134f8:	dfc00117 	ldw	ra,4(sp)
  8134fc:	df000017 	ldw	fp,0(sp)
  813500:	dec00204 	addi	sp,sp,8
  813504:	f800283a 	ret

00813508 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  813508:	defffd04 	addi	sp,sp,-12
  81350c:	dfc00215 	stw	ra,8(sp)
  813510:	df000115 	stw	fp,4(sp)
  813514:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  813518:	008020b4 	movhi	r2,130
  81351c:	10a93c04 	addi	r2,r2,-23312
  813520:	10800017 	ldw	r2,0(r2)
  813524:	1005003a 	cmpeq	r2,r2,zero
  813528:	1000061e 	bne	r2,zero,813544 <alt_get_errno+0x3c>
  81352c:	008020b4 	movhi	r2,130
  813530:	10a93c04 	addi	r2,r2,-23312
  813534:	10800017 	ldw	r2,0(r2)
  813538:	103ee83a 	callr	r2
  81353c:	e0bfff15 	stw	r2,-4(fp)
  813540:	00000306 	br	813550 <alt_get_errno+0x48>
  813544:	008020b4 	movhi	r2,130
  813548:	10b02404 	addi	r2,r2,-16240
  81354c:	e0bfff15 	stw	r2,-4(fp)
  813550:	e0bfff17 	ldw	r2,-4(fp)
}
  813554:	e037883a 	mov	sp,fp
  813558:	dfc00117 	ldw	ra,4(sp)
  81355c:	df000017 	ldw	fp,0(sp)
  813560:	dec00204 	addi	sp,sp,8
  813564:	f800283a 	ret

00813568 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  813568:	defffc04 	addi	sp,sp,-16
  81356c:	dfc00315 	stw	ra,12(sp)
  813570:	df000215 	stw	fp,8(sp)
  813574:	df000204 	addi	fp,sp,8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  813578:	0009883a 	mov	r4,zero
  81357c:	0813d040 	call	813d04 <alt_irq_init>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  813580:	0005303a 	rdctl	r2,status
  813584:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  813588:	e0fffe17 	ldw	r3,-8(fp)
  81358c:	00bfff84 	movi	r2,-2
  813590:	1884703a 	and	r2,r3,r2
  813594:	1001703a 	wrctl	status,r2

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  813598:	08157a40 	call	8157a4 <chSysInit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  81359c:	0813d380 	call	813d38 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  8135a0:	010020b4 	movhi	r4,130
  8135a4:	21221c04 	addi	r4,r4,-30608
  8135a8:	014020b4 	movhi	r5,130
  8135ac:	29621c04 	addi	r5,r5,-30608
  8135b0:	018020b4 	movhi	r6,130
  8135b4:	31a21f04 	addi	r6,r6,-30596
  8135b8:	081608c0 	call	81608c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  8135bc:	0815c040 	call	815c04 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  8135c0:	01002074 	movhi	r4,129
  8135c4:	21171a04 	addi	r4,r4,23656
  8135c8:	08168840 	call	816884 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  8135cc:	d126fb17 	ldw	r4,-25620(gp)
  8135d0:	d166fc17 	ldw	r5,-25616(gp)
  8135d4:	d1a6fd17 	ldw	r6,-25612(gp)
  8135d8:	080630c0 	call	80630c <main>
  8135dc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  8135e0:	01000044 	movi	r4,1
  8135e4:	0812f080 	call	812f08 <close>
  exit (result);
  8135e8:	e13fff17 	ldw	r4,-4(fp)
  8135ec:	08168980 	call	816898 <exit>

008135f0 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
  8135f0:	defffe04 	addi	sp,sp,-8
  8135f4:	df000115 	stw	fp,4(sp)
  8135f8:	df000104 	addi	fp,sp,4
  8135fc:	e13fff15 	stw	r4,-4(fp)
}
  813600:	e037883a 	mov	sp,fp
  813604:	df000017 	ldw	fp,0(sp)
  813608:	dec00104 	addi	sp,sp,4
  81360c:	f800283a 	ret

00813610 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
  813610:	defffe04 	addi	sp,sp,-8
  813614:	df000115 	stw	fp,4(sp)
  813618:	df000104 	addi	fp,sp,4
  81361c:	e13fff15 	stw	r4,-4(fp)
}
  813620:	e037883a 	mov	sp,fp
  813624:	df000017 	ldw	fp,0(sp)
  813628:	dec00104 	addi	sp,sp,4
  81362c:	f800283a 	ret

00813630 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  813630:	defff204 	addi	sp,sp,-56
  813634:	dfc00a15 	stw	ra,40(sp)
  813638:	df000915 	stw	fp,36(sp)
  81363c:	df000904 	addi	fp,sp,36
  813640:	e1400215 	stw	r5,8(fp)
  813644:	e1800315 	stw	r6,12(fp)
  813648:	e1c00415 	stw	r7,16(fp)
  81364c:	e13fff15 	stw	r4,-4(fp)
	va_list args;
	va_start(args, fmt);
  813650:	e0800204 	addi	r2,fp,8
  813654:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
  813658:	e0bfff17 	ldw	r2,-4(fp)
  81365c:	e0bffd15 	stw	r2,-12(fp)
    while ((c = *w++) != 0)
  813660:	00007806 	br	813844 <alt_printf+0x214>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  813664:	e0bffc07 	ldb	r2,-16(fp)
  813668:	10800960 	cmpeqi	r2,r2,37
  81366c:	1000031e 	bne	r2,zero,81367c <alt_printf+0x4c>
        {
            alt_putchar(c);
  813670:	e13ffc07 	ldb	r4,-16(fp)
  813674:	08138880 	call	813888 <alt_putchar>
  813678:	00007206 	br	813844 <alt_printf+0x214>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  81367c:	e0bffd17 	ldw	r2,-12(fp)
  813680:	10800003 	ldbu	r2,0(r2)
  813684:	e0bffc05 	stb	r2,-16(fp)
  813688:	e0bffc07 	ldb	r2,-16(fp)
  81368c:	1004c03a 	cmpne	r2,r2,zero
  813690:	1007883a 	mov	r3,r2
  813694:	e0bffd17 	ldw	r2,-12(fp)
  813698:	10800044 	addi	r2,r2,1
  81369c:	e0bffd15 	stw	r2,-12(fp)
  8136a0:	18803fcc 	andi	r2,r3,255
  8136a4:	1005003a 	cmpeq	r2,r2,zero
  8136a8:	1000721e 	bne	r2,zero,813874 <alt_printf+0x244>
            {
                if (c == '%')
  8136ac:	e0bffc07 	ldb	r2,-16(fp)
  8136b0:	10800958 	cmpnei	r2,r2,37
  8136b4:	1000031e 	bne	r2,zero,8136c4 <alt_printf+0x94>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  8136b8:	e13ffc07 	ldb	r4,-16(fp)
  8136bc:	08138880 	call	813888 <alt_putchar>
  8136c0:	00006006 	br	813844 <alt_printf+0x214>
                } 
                else if (c == 'c')
  8136c4:	e0bffc07 	ldb	r2,-16(fp)
  8136c8:	108018d8 	cmpnei	r2,r2,99
  8136cc:	1000091e 	bne	r2,zero,8136f4 <alt_printf+0xc4>
                {
                    int v = va_arg(args, int);
  8136d0:	e0fffe17 	ldw	r3,-8(fp)
  8136d4:	18800104 	addi	r2,r3,4
  8136d8:	e0bffe15 	stw	r2,-8(fp)
  8136dc:	1805883a 	mov	r2,r3
  8136e0:	10800017 	ldw	r2,0(r2)
  8136e4:	e0bffb15 	stw	r2,-20(fp)
                    alt_putchar(v);
  8136e8:	e13ffb17 	ldw	r4,-20(fp)
  8136ec:	08138880 	call	813888 <alt_putchar>
  8136f0:	00005406 	br	813844 <alt_printf+0x214>
                }
                else if (c == 'x')
  8136f4:	e0bffc07 	ldb	r2,-16(fp)
  8136f8:	10801e18 	cmpnei	r2,r2,120
  8136fc:	1000371e 	bne	r2,zero,8137dc <alt_printf+0x1ac>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  813700:	e0fffe17 	ldw	r3,-8(fp)
  813704:	18800104 	addi	r2,r3,4
  813708:	e0bffe15 	stw	r2,-8(fp)
  81370c:	1805883a 	mov	r2,r3
  813710:	10800017 	ldw	r2,0(r2)
  813714:	e0bffa15 	stw	r2,-24(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  813718:	e0bffa17 	ldw	r2,-24(fp)
  81371c:	1004c03a 	cmpne	r2,r2,zero
  813720:	1000031e 	bne	r2,zero,813730 <alt_printf+0x100>
                    {
                        alt_putchar('0');
  813724:	01000c04 	movi	r4,48
  813728:	08138880 	call	813888 <alt_putchar>
                        continue;
  81372c:	00004506 	br	813844 <alt_printf+0x214>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
  813730:	00800704 	movi	r2,28
  813734:	e0bff815 	stw	r2,-32(fp)
                    while (!(v & (0xF << digit_shift)))
  813738:	00000306 	br	813748 <alt_printf+0x118>
                        digit_shift -= 4;
  81373c:	e0bff817 	ldw	r2,-32(fp)
  813740:	10bfff04 	addi	r2,r2,-4
  813744:	e0bff815 	stw	r2,-32(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  813748:	00c003c4 	movi	r3,15
  81374c:	e0bff817 	ldw	r2,-32(fp)
  813750:	1884983a 	sll	r2,r3,r2
  813754:	1007883a 	mov	r3,r2
  813758:	e0bffa17 	ldw	r2,-24(fp)
  81375c:	1884703a 	and	r2,r3,r2
  813760:	1005003a 	cmpeq	r2,r2,zero
  813764:	103ff51e 	bne	r2,zero,81373c <alt_printf+0x10c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  813768:	00001806 	br	8137cc <alt_printf+0x19c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  81376c:	00c003c4 	movi	r3,15
  813770:	e0bff817 	ldw	r2,-32(fp)
  813774:	1884983a 	sll	r2,r3,r2
  813778:	1007883a 	mov	r3,r2
  81377c:	e0bffa17 	ldw	r2,-24(fp)
  813780:	1886703a 	and	r3,r3,r2
  813784:	e0bff817 	ldw	r2,-32(fp)
  813788:	1884d83a 	srl	r2,r3,r2
  81378c:	e0bff915 	stw	r2,-28(fp)
                        if (digit <= 9)
  813790:	e0bff917 	ldw	r2,-28(fp)
  813794:	108002a8 	cmpgeui	r2,r2,10
  813798:	1000041e 	bne	r2,zero,8137ac <alt_printf+0x17c>
                            c = '0' + digit;
  81379c:	e0bff917 	ldw	r2,-28(fp)
  8137a0:	10800c04 	addi	r2,r2,48
  8137a4:	e0bffc05 	stb	r2,-16(fp)
  8137a8:	00000306 	br	8137b8 <alt_printf+0x188>
                        else
                            c = 'a' + digit - 10;
  8137ac:	e0bff917 	ldw	r2,-28(fp)
  8137b0:	108015c4 	addi	r2,r2,87
  8137b4:	e0bffc05 	stb	r2,-16(fp)
                        alt_putchar(c);
  8137b8:	e13ffc07 	ldb	r4,-16(fp)
  8137bc:	08138880 	call	813888 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  8137c0:	e0bff817 	ldw	r2,-32(fp)
  8137c4:	10bfff04 	addi	r2,r2,-4
  8137c8:	e0bff815 	stw	r2,-32(fp)
  8137cc:	e0bff817 	ldw	r2,-32(fp)
  8137d0:	1004403a 	cmpge	r2,r2,zero
  8137d4:	103fe51e 	bne	r2,zero,81376c <alt_printf+0x13c>
  8137d8:	00001a06 	br	813844 <alt_printf+0x214>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  8137dc:	e0bffc07 	ldb	r2,-16(fp)
  8137e0:	10801cd8 	cmpnei	r2,r2,115
  8137e4:	1000171e 	bne	r2,zero,813844 <alt_printf+0x214>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  8137e8:	e0fffe17 	ldw	r3,-8(fp)
  8137ec:	18800104 	addi	r2,r3,4
  8137f0:	e0bffe15 	stw	r2,-8(fp)
  8137f4:	1805883a 	mov	r2,r3
  8137f8:	10800017 	ldw	r2,0(r2)
  8137fc:	e0bff715 	stw	r2,-36(fp)

                    while(*s)
  813800:	00000906 	br	813828 <alt_printf+0x1f8>
                      alt_putchar(*s++);
  813804:	e0bff717 	ldw	r2,-36(fp)
  813808:	10800003 	ldbu	r2,0(r2)
  81380c:	11003fcc 	andi	r4,r2,255
  813810:	2100201c 	xori	r4,r4,128
  813814:	213fe004 	addi	r4,r4,-128
  813818:	e0bff717 	ldw	r2,-36(fp)
  81381c:	10800044 	addi	r2,r2,1
  813820:	e0bff715 	stw	r2,-36(fp)
  813824:	08138880 	call	813888 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
  813828:	e0bff717 	ldw	r2,-36(fp)
  81382c:	10800003 	ldbu	r2,0(r2)
  813830:	10803fcc 	andi	r2,r2,255
  813834:	1080201c 	xori	r2,r2,128
  813838:	10bfe004 	addi	r2,r2,-128
  81383c:	1004c03a 	cmpne	r2,r2,zero
  813840:	103ff01e 	bne	r2,zero,813804 <alt_printf+0x1d4>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  813844:	e0bffd17 	ldw	r2,-12(fp)
  813848:	10800003 	ldbu	r2,0(r2)
  81384c:	e0bffc05 	stb	r2,-16(fp)
  813850:	e0bffc07 	ldb	r2,-16(fp)
  813854:	1004c03a 	cmpne	r2,r2,zero
  813858:	1007883a 	mov	r3,r2
  81385c:	e0bffd17 	ldw	r2,-12(fp)
  813860:	10800044 	addi	r2,r2,1
  813864:	e0bffd15 	stw	r2,-12(fp)
  813868:	18803fcc 	andi	r2,r3,255
  81386c:	1004c03a 	cmpne	r2,r2,zero
  813870:	103f7c1e 	bne	r2,zero,813664 <alt_printf+0x34>
            {
                break;
            }
        }
    }
}
  813874:	e037883a 	mov	sp,fp
  813878:	dfc00117 	ldw	ra,4(sp)
  81387c:	df000017 	ldw	fp,0(sp)
  813880:	dec00504 	addi	sp,sp,20
  813884:	f800283a 	ret

00813888 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  813888:	defffd04 	addi	sp,sp,-12
  81388c:	dfc00215 	stw	ra,8(sp)
  813890:	df000115 	stw	fp,4(sp)
  813894:	df000104 	addi	fp,sp,4
  813898:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
  81389c:	008020b4 	movhi	r2,130
  8138a0:	10a93104 	addi	r2,r2,-23356
  8138a4:	10800017 	ldw	r2,0(r2)
  8138a8:	11400217 	ldw	r5,8(r2)
  8138ac:	e13fff17 	ldw	r4,-4(fp)
  8138b0:	0816a6c0 	call	816a6c <putc>
#endif
}
  8138b4:	e037883a 	mov	sp,fp
  8138b8:	dfc00117 	ldw	ra,4(sp)
  8138bc:	df000017 	ldw	fp,0(sp)
  8138c0:	dec00204 	addi	sp,sp,8
  8138c4:	f800283a 	ret

008138c8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
  8138c8:	defff704 	addi	sp,sp,-36
  8138cc:	dfc00815 	stw	ra,32(sp)
  8138d0:	df000715 	stw	fp,28(sp)
  8138d4:	df000704 	addi	fp,sp,28
  8138d8:	e13ffb15 	stw	r4,-20(fp)
  8138dc:	e17ffc15 	stw	r5,-16(fp)
  8138e0:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  8138e4:	e0bffb17 	ldw	r2,-20(fp)
  8138e8:	1004803a 	cmplt	r2,r2,zero
  8138ec:	1000091e 	bne	r2,zero,813914 <read+0x4c>
  8138f0:	e13ffb17 	ldw	r4,-20(fp)
  8138f4:	01400304 	movi	r5,12
  8138f8:	08064840 	call	806484 <__mulsi3>
  8138fc:	1007883a 	mov	r3,r2
  813900:	008020b4 	movhi	r2,130
  813904:	10a48304 	addi	r2,r2,-28148
  813908:	1887883a 	add	r3,r3,r2
  81390c:	e0ffff15 	stw	r3,-4(fp)
  813910:	00000106 	br	813918 <read+0x50>
  813914:	e03fff15 	stw	zero,-4(fp)
  813918:	e0bfff17 	ldw	r2,-4(fp)
  81391c:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
  813920:	e0bffa17 	ldw	r2,-24(fp)
  813924:	1005003a 	cmpeq	r2,r2,zero
  813928:	1000241e 	bne	r2,zero,8139bc <read+0xf4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  81392c:	e0bffa17 	ldw	r2,-24(fp)
  813930:	10800217 	ldw	r2,8(r2)
  813934:	108000cc 	andi	r2,r2,3
  813938:	10800060 	cmpeqi	r2,r2,1
  81393c:	10001a1e 	bne	r2,zero,8139a8 <read+0xe0>
  813940:	e0bffa17 	ldw	r2,-24(fp)
  813944:	10800017 	ldw	r2,0(r2)
  813948:	10800517 	ldw	r2,20(r2)
  81394c:	1005003a 	cmpeq	r2,r2,zero
  813950:	1000151e 	bne	r2,zero,8139a8 <read+0xe0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  813954:	e0bffa17 	ldw	r2,-24(fp)
  813958:	10800017 	ldw	r2,0(r2)
  81395c:	10800517 	ldw	r2,20(r2)
  813960:	e17ffc17 	ldw	r5,-16(fp)
  813964:	e1bffd17 	ldw	r6,-12(fp)
  813968:	e13ffa17 	ldw	r4,-24(fp)
  81396c:	103ee83a 	callr	r2
  813970:	e0bff915 	stw	r2,-28(fp)
  813974:	e0bff917 	ldw	r2,-28(fp)
  813978:	1004403a 	cmpge	r2,r2,zero
  81397c:	1000071e 	bne	r2,zero,81399c <read+0xd4>
        {
          ALT_ERRNO = -rval;
  813980:	08139ec0 	call	8139ec <alt_get_errno>
  813984:	e0fff917 	ldw	r3,-28(fp)
  813988:	00c7c83a 	sub	r3,zero,r3
  81398c:	10c00015 	stw	r3,0(r2)
          return -1;
  813990:	00bfffc4 	movi	r2,-1
  813994:	e0bffe15 	stw	r2,-8(fp)
  813998:	00000e06 	br	8139d4 <read+0x10c>
        }
        return rval;
  81399c:	e0bff917 	ldw	r2,-28(fp)
  8139a0:	e0bffe15 	stw	r2,-8(fp)
  8139a4:	00000b06 	br	8139d4 <read+0x10c>
      }
      else
      {
        ALT_ERRNO = EACCES;
  8139a8:	08139ec0 	call	8139ec <alt_get_errno>
  8139ac:	1007883a 	mov	r3,r2
  8139b0:	00800344 	movi	r2,13
  8139b4:	18800015 	stw	r2,0(r3)
  8139b8:	00000406 	br	8139cc <read+0x104>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  8139bc:	08139ec0 	call	8139ec <alt_get_errno>
  8139c0:	1007883a 	mov	r3,r2
  8139c4:	00801444 	movi	r2,81
  8139c8:	18800015 	stw	r2,0(r3)
  }
  return -1;
  8139cc:	00bfffc4 	movi	r2,-1
  8139d0:	e0bffe15 	stw	r2,-8(fp)
  8139d4:	e0bffe17 	ldw	r2,-8(fp)
}
  8139d8:	e037883a 	mov	sp,fp
  8139dc:	dfc00117 	ldw	ra,4(sp)
  8139e0:	df000017 	ldw	fp,0(sp)
  8139e4:	dec00204 	addi	sp,sp,8
  8139e8:	f800283a 	ret

008139ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  8139ec:	defffd04 	addi	sp,sp,-12
  8139f0:	dfc00215 	stw	ra,8(sp)
  8139f4:	df000115 	stw	fp,4(sp)
  8139f8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  8139fc:	008020b4 	movhi	r2,130
  813a00:	10a93c04 	addi	r2,r2,-23312
  813a04:	10800017 	ldw	r2,0(r2)
  813a08:	1005003a 	cmpeq	r2,r2,zero
  813a0c:	1000061e 	bne	r2,zero,813a28 <alt_get_errno+0x3c>
  813a10:	008020b4 	movhi	r2,130
  813a14:	10a93c04 	addi	r2,r2,-23312
  813a18:	10800017 	ldw	r2,0(r2)
  813a1c:	103ee83a 	callr	r2
  813a20:	e0bfff15 	stw	r2,-4(fp)
  813a24:	00000306 	br	813a34 <alt_get_errno+0x48>
  813a28:	008020b4 	movhi	r2,130
  813a2c:	10b02404 	addi	r2,r2,-16240
  813a30:	e0bfff15 	stw	r2,-4(fp)
  813a34:	e0bfff17 	ldw	r2,-4(fp)
}
  813a38:	e037883a 	mov	sp,fp
  813a3c:	dfc00117 	ldw	ra,4(sp)
  813a40:	df000017 	ldw	fp,0(sp)
  813a44:	dec00204 	addi	sp,sp,8
  813a48:	f800283a 	ret

00813a4c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  813a4c:	defffc04 	addi	sp,sp,-16
  813a50:	dfc00315 	stw	ra,12(sp)
  813a54:	df000215 	stw	fp,8(sp)
  813a58:	dc000115 	stw	r16,4(sp)
  813a5c:	df000104 	addi	fp,sp,4
  813a60:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  813a64:	e0bfff17 	ldw	r2,-4(fp)
  813a68:	108000d0 	cmplti	r2,r2,3
  813a6c:	10000f1e 	bne	r2,zero,813aac <alt_release_fd+0x60>
  {
    alt_fd_list[fd].fd_flags = 0;
  813a70:	e13fff17 	ldw	r4,-4(fp)
  813a74:	040020b4 	movhi	r16,130
  813a78:	84248304 	addi	r16,r16,-28148
  813a7c:	01400304 	movi	r5,12
  813a80:	08064840 	call	806484 <__mulsi3>
  813a84:	1405883a 	add	r2,r2,r16
  813a88:	10800204 	addi	r2,r2,8
  813a8c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  813a90:	e13fff17 	ldw	r4,-4(fp)
  813a94:	040020b4 	movhi	r16,130
  813a98:	84248304 	addi	r16,r16,-28148
  813a9c:	01400304 	movi	r5,12
  813aa0:	08064840 	call	806484 <__mulsi3>
  813aa4:	1405883a 	add	r2,r2,r16
  813aa8:	10000015 	stw	zero,0(r2)
  }
}
  813aac:	e037883a 	mov	sp,fp
  813ab0:	dfc00217 	ldw	ra,8(sp)
  813ab4:	df000117 	ldw	fp,4(sp)
  813ab8:	dc000017 	ldw	r16,0(sp)
  813abc:	dec00304 	addi	sp,sp,12
  813ac0:	f800283a 	ret

00813ac4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  813ac4:	defff804 	addi	sp,sp,-32
  813ac8:	df000715 	stw	fp,28(sp)
  813acc:	df000704 	addi	fp,sp,28
  813ad0:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  813ad4:	0005303a 	rdctl	r2,status
  813ad8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  813adc:	e0fffb17 	ldw	r3,-20(fp)
  813ae0:	00bfff84 	movi	r2,-2
  813ae4:	1884703a 	and	r2,r3,r2
  813ae8:	1001703a 	wrctl	status,r2
  
  return context;
  813aec:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  813af0:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  813af4:	d0a01117 	ldw	r2,-32700(gp)
  813af8:	10c000c4 	addi	r3,r2,3
  813afc:	00bfff04 	movi	r2,-4
  813b00:	1884703a 	and	r2,r3,r2
  813b04:	d0a01115 	stw	r2,-32700(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  813b08:	d0e01117 	ldw	r3,-32700(gp)
  813b0c:	e0bffe17 	ldw	r2,-8(fp)
  813b10:	1887883a 	add	r3,r3,r2
  813b14:	00804034 	movhi	r2,256
  813b18:	10800004 	addi	r2,r2,0
  813b1c:	10c0072e 	bgeu	r2,r3,813b3c <sbrk+0x78>
  813b20:	e0bffd17 	ldw	r2,-12(fp)
  813b24:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  813b28:	e0bffa17 	ldw	r2,-24(fp)
  813b2c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  813b30:	00bfffc4 	movi	r2,-1
  813b34:	e0bfff15 	stw	r2,-4(fp)
  813b38:	00000c06 	br	813b6c <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
  813b3c:	d0a01117 	ldw	r2,-32700(gp)
  813b40:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
  813b44:	d0e01117 	ldw	r3,-32700(gp)
  813b48:	e0bffe17 	ldw	r2,-8(fp)
  813b4c:	1885883a 	add	r2,r3,r2
  813b50:	d0a01115 	stw	r2,-32700(gp)
  813b54:	e0bffd17 	ldw	r2,-12(fp)
  813b58:	e0bff915 	stw	r2,-28(fp)
  813b5c:	e0bff917 	ldw	r2,-28(fp)
  813b60:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  813b64:	e0bffc17 	ldw	r2,-16(fp)
  813b68:	e0bfff15 	stw	r2,-4(fp)
  813b6c:	e0bfff17 	ldw	r2,-4(fp)
} 
  813b70:	e037883a 	mov	sp,fp
  813b74:	df000017 	ldw	fp,0(sp)
  813b78:	dec00104 	addi	sp,sp,4
  813b7c:	f800283a 	ret

00813b80 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  813b80:	defff704 	addi	sp,sp,-36
  813b84:	dfc00815 	stw	ra,32(sp)
  813b88:	df000715 	stw	fp,28(sp)
  813b8c:	df000704 	addi	fp,sp,28
  813b90:	e13ffb15 	stw	r4,-20(fp)
  813b94:	e17ffc15 	stw	r5,-16(fp)
  813b98:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  813b9c:	e0bffb17 	ldw	r2,-20(fp)
  813ba0:	1004803a 	cmplt	r2,r2,zero
  813ba4:	1000091e 	bne	r2,zero,813bcc <write+0x4c>
  813ba8:	e13ffb17 	ldw	r4,-20(fp)
  813bac:	01400304 	movi	r5,12
  813bb0:	08064840 	call	806484 <__mulsi3>
  813bb4:	1007883a 	mov	r3,r2
  813bb8:	008020b4 	movhi	r2,130
  813bbc:	10a48304 	addi	r2,r2,-28148
  813bc0:	1887883a 	add	r3,r3,r2
  813bc4:	e0ffff15 	stw	r3,-4(fp)
  813bc8:	00000106 	br	813bd0 <write+0x50>
  813bcc:	e03fff15 	stw	zero,-4(fp)
  813bd0:	e0bfff17 	ldw	r2,-4(fp)
  813bd4:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
  813bd8:	e0bffa17 	ldw	r2,-24(fp)
  813bdc:	1005003a 	cmpeq	r2,r2,zero
  813be0:	1000241e 	bne	r2,zero,813c74 <write+0xf4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  813be4:	e0bffa17 	ldw	r2,-24(fp)
  813be8:	10800217 	ldw	r2,8(r2)
  813bec:	108000cc 	andi	r2,r2,3
  813bf0:	1005003a 	cmpeq	r2,r2,zero
  813bf4:	10001a1e 	bne	r2,zero,813c60 <write+0xe0>
  813bf8:	e0bffa17 	ldw	r2,-24(fp)
  813bfc:	10800017 	ldw	r2,0(r2)
  813c00:	10800617 	ldw	r2,24(r2)
  813c04:	1005003a 	cmpeq	r2,r2,zero
  813c08:	1000151e 	bne	r2,zero,813c60 <write+0xe0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  813c0c:	e0bffa17 	ldw	r2,-24(fp)
  813c10:	10800017 	ldw	r2,0(r2)
  813c14:	10800617 	ldw	r2,24(r2)
  813c18:	e17ffc17 	ldw	r5,-16(fp)
  813c1c:	e1bffd17 	ldw	r6,-12(fp)
  813c20:	e13ffa17 	ldw	r4,-24(fp)
  813c24:	103ee83a 	callr	r2
  813c28:	e0bff915 	stw	r2,-28(fp)
  813c2c:	e0bff917 	ldw	r2,-28(fp)
  813c30:	1004403a 	cmpge	r2,r2,zero
  813c34:	1000071e 	bne	r2,zero,813c54 <write+0xd4>
      {
        ALT_ERRNO = -rval;
  813c38:	0813ca40 	call	813ca4 <alt_get_errno>
  813c3c:	e0fff917 	ldw	r3,-28(fp)
  813c40:	00c7c83a 	sub	r3,zero,r3
  813c44:	10c00015 	stw	r3,0(r2)
        return -1;
  813c48:	00bfffc4 	movi	r2,-1
  813c4c:	e0bffe15 	stw	r2,-8(fp)
  813c50:	00000e06 	br	813c8c <write+0x10c>
      }
      return rval;
  813c54:	e0bff917 	ldw	r2,-28(fp)
  813c58:	e0bffe15 	stw	r2,-8(fp)
  813c5c:	00000b06 	br	813c8c <write+0x10c>
    }
    else
    {
      ALT_ERRNO = EACCES;
  813c60:	0813ca40 	call	813ca4 <alt_get_errno>
  813c64:	1007883a 	mov	r3,r2
  813c68:	00800344 	movi	r2,13
  813c6c:	18800015 	stw	r2,0(r3)
  813c70:	00000406 	br	813c84 <write+0x104>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  813c74:	0813ca40 	call	813ca4 <alt_get_errno>
  813c78:	1007883a 	mov	r3,r2
  813c7c:	00801444 	movi	r2,81
  813c80:	18800015 	stw	r2,0(r3)
  }
  return -1;
  813c84:	00bfffc4 	movi	r2,-1
  813c88:	e0bffe15 	stw	r2,-8(fp)
  813c8c:	e0bffe17 	ldw	r2,-8(fp)
}
  813c90:	e037883a 	mov	sp,fp
  813c94:	dfc00117 	ldw	ra,4(sp)
  813c98:	df000017 	ldw	fp,0(sp)
  813c9c:	dec00204 	addi	sp,sp,8
  813ca0:	f800283a 	ret

00813ca4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  813ca4:	defffd04 	addi	sp,sp,-12
  813ca8:	dfc00215 	stw	ra,8(sp)
  813cac:	df000115 	stw	fp,4(sp)
  813cb0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  813cb4:	008020b4 	movhi	r2,130
  813cb8:	10a93c04 	addi	r2,r2,-23312
  813cbc:	10800017 	ldw	r2,0(r2)
  813cc0:	1005003a 	cmpeq	r2,r2,zero
  813cc4:	1000061e 	bne	r2,zero,813ce0 <alt_get_errno+0x3c>
  813cc8:	008020b4 	movhi	r2,130
  813ccc:	10a93c04 	addi	r2,r2,-23312
  813cd0:	10800017 	ldw	r2,0(r2)
  813cd4:	103ee83a 	callr	r2
  813cd8:	e0bfff15 	stw	r2,-4(fp)
  813cdc:	00000306 	br	813cec <alt_get_errno+0x48>
  813ce0:	008020b4 	movhi	r2,130
  813ce4:	10b02404 	addi	r2,r2,-16240
  813ce8:	e0bfff15 	stw	r2,-4(fp)
  813cec:	e0bfff17 	ldw	r2,-4(fp)
}
  813cf0:	e037883a 	mov	sp,fp
  813cf4:	dfc00117 	ldw	ra,4(sp)
  813cf8:	df000017 	ldw	fp,0(sp)
  813cfc:	dec00204 	addi	sp,sp,8
  813d00:	f800283a 	ret

00813d04 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  813d04:	defffd04 	addi	sp,sp,-12
  813d08:	dfc00215 	stw	ra,8(sp)
  813d0c:	df000115 	stw	fp,4(sp)
  813d10:	df000104 	addi	fp,sp,4
  813d14:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
  813d18:	08165900 	call	816590 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  813d1c:	00800044 	movi	r2,1
  813d20:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  813d24:	e037883a 	mov	sp,fp
  813d28:	dfc00117 	ldw	ra,4(sp)
  813d2c:	df000017 	ldw	fp,0(sp)
  813d30:	dec00204 	addi	sp,sp,8
  813d34:	f800283a 	ret

00813d38 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  813d38:	defffe04 	addi	sp,sp,-8
  813d3c:	dfc00115 	stw	ra,4(sp)
  813d40:	df000015 	stw	fp,0(sp)
  813d44:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
  813d48:	01004434 	movhi	r4,272
  813d4c:	21081804 	addi	r4,r4,8288
  813d50:	000b883a 	mov	r5,zero
  813d54:	01800084 	movi	r6,2
  813d58:	01c0fa04 	movi	r7,1000
  813d5c:	0814aa00 	call	814aa0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_FIFO_INIT ( ACORTEX_DC_FIFO, acortex_dc_fifo);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
  813d60:	010020b4 	movhi	r4,130
  813d64:	2124ed04 	addi	r4,r4,-27724
  813d68:	000b883a 	mov	r5,zero
  813d6c:	000d883a 	mov	r6,zero
  813d70:	0813f440 	call	813f44 <altera_avalon_jtag_uart_init>
  813d74:	010020b4 	movhi	r4,130
  813d78:	2124e304 	addi	r4,r4,-27764
  813d7c:	0813dc40 	call	813dc4 <alt_dev_reg>
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERF_CNTR, perf_cntr);
  813d80:	00c04434 	movhi	r3,272
  813d84:	18c80004 	addi	r3,r3,8192
  813d88:	00800044 	movi	r2,1
  813d8c:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SPI_INIT ( SDCARD_SPI, sdcard_spi);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  813d90:	010020b4 	movhi	r4,130
  813d94:	21290504 	addi	r4,r4,-23532
  813d98:	000b883a 	mov	r5,zero
  813d9c:	01800044 	movi	r6,1
  813da0:	0814c280 	call	814c28 <altera_avalon_uart_init>
  813da4:	010020b4 	movhi	r4,130
  813da8:	2128fb04 	addi	r4,r4,-23572
  813dac:	0813dc40 	call	813dc4 <alt_dev_reg>
}
  813db0:	e037883a 	mov	sp,fp
  813db4:	dfc00117 	ldw	ra,4(sp)
  813db8:	df000017 	ldw	fp,0(sp)
  813dbc:	dec00204 	addi	sp,sp,8
  813dc0:	f800283a 	ret

00813dc4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  813dc4:	defffd04 	addi	sp,sp,-12
  813dc8:	dfc00215 	stw	ra,8(sp)
  813dcc:	df000115 	stw	fp,4(sp)
  813dd0:	df000104 	addi	fp,sp,4
  813dd4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  813dd8:	e13fff17 	ldw	r4,-4(fp)
  813ddc:	014020b4 	movhi	r5,130
  813de0:	29693904 	addi	r5,r5,-23324
  813de4:	0815af00 	call	815af0 <alt_dev_llist_insert>
}
  813de8:	e037883a 	mov	sp,fp
  813dec:	dfc00117 	ldw	ra,4(sp)
  813df0:	df000017 	ldw	fp,0(sp)
  813df4:	dec00204 	addi	sp,sp,8
  813df8:	f800283a 	ret

00813dfc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  813dfc:	defffa04 	addi	sp,sp,-24
  813e00:	dfc00515 	stw	ra,20(sp)
  813e04:	df000415 	stw	fp,16(sp)
  813e08:	df000404 	addi	fp,sp,16
  813e0c:	e13ffd15 	stw	r4,-12(fp)
  813e10:	e17ffe15 	stw	r5,-8(fp)
  813e14:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  813e18:	e0bffd17 	ldw	r2,-12(fp)
  813e1c:	10800017 	ldw	r2,0(r2)
  813e20:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  813e24:	e0bffc17 	ldw	r2,-16(fp)
  813e28:	11000a04 	addi	r4,r2,40
  813e2c:	e0bffd17 	ldw	r2,-12(fp)
  813e30:	11c00217 	ldw	r7,8(r2)
  813e34:	e17ffe17 	ldw	r5,-8(fp)
  813e38:	e1bfff17 	ldw	r6,-4(fp)
  813e3c:	08144440 	call	814444 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  813e40:	e037883a 	mov	sp,fp
  813e44:	dfc00117 	ldw	ra,4(sp)
  813e48:	df000017 	ldw	fp,0(sp)
  813e4c:	dec00204 	addi	sp,sp,8
  813e50:	f800283a 	ret

00813e54 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  813e54:	defffa04 	addi	sp,sp,-24
  813e58:	dfc00515 	stw	ra,20(sp)
  813e5c:	df000415 	stw	fp,16(sp)
  813e60:	df000404 	addi	fp,sp,16
  813e64:	e13ffd15 	stw	r4,-12(fp)
  813e68:	e17ffe15 	stw	r5,-8(fp)
  813e6c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  813e70:	e0bffd17 	ldw	r2,-12(fp)
  813e74:	10800017 	ldw	r2,0(r2)
  813e78:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  813e7c:	e0bffc17 	ldw	r2,-16(fp)
  813e80:	11000a04 	addi	r4,r2,40
  813e84:	e0bffd17 	ldw	r2,-12(fp)
  813e88:	11c00217 	ldw	r7,8(r2)
  813e8c:	e17ffe17 	ldw	r5,-8(fp)
  813e90:	e1bfff17 	ldw	r6,-4(fp)
  813e94:	08146680 	call	814668 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  813e98:	e037883a 	mov	sp,fp
  813e9c:	dfc00117 	ldw	ra,4(sp)
  813ea0:	df000017 	ldw	fp,0(sp)
  813ea4:	dec00204 	addi	sp,sp,8
  813ea8:	f800283a 	ret

00813eac <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  813eac:	defffc04 	addi	sp,sp,-16
  813eb0:	dfc00315 	stw	ra,12(sp)
  813eb4:	df000215 	stw	fp,8(sp)
  813eb8:	df000204 	addi	fp,sp,8
  813ebc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  813ec0:	e0bfff17 	ldw	r2,-4(fp)
  813ec4:	10800017 	ldw	r2,0(r2)
  813ec8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  813ecc:	e0bffe17 	ldw	r2,-8(fp)
  813ed0:	11000a04 	addi	r4,r2,40
  813ed4:	e0bfff17 	ldw	r2,-4(fp)
  813ed8:	11400217 	ldw	r5,8(r2)
  813edc:	08142dc0 	call	8142dc <altera_avalon_jtag_uart_close>
}
  813ee0:	e037883a 	mov	sp,fp
  813ee4:	dfc00117 	ldw	ra,4(sp)
  813ee8:	df000017 	ldw	fp,0(sp)
  813eec:	dec00204 	addi	sp,sp,8
  813ef0:	f800283a 	ret

00813ef4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  813ef4:	defffa04 	addi	sp,sp,-24
  813ef8:	dfc00515 	stw	ra,20(sp)
  813efc:	df000415 	stw	fp,16(sp)
  813f00:	df000404 	addi	fp,sp,16
  813f04:	e13ffd15 	stw	r4,-12(fp)
  813f08:	e17ffe15 	stw	r5,-8(fp)
  813f0c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  813f10:	e0bffd17 	ldw	r2,-12(fp)
  813f14:	10800017 	ldw	r2,0(r2)
  813f18:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  813f1c:	e0bffc17 	ldw	r2,-16(fp)
  813f20:	11000a04 	addi	r4,r2,40
  813f24:	e17ffe17 	ldw	r5,-8(fp)
  813f28:	e1bfff17 	ldw	r6,-4(fp)
  813f2c:	08143500 	call	814350 <altera_avalon_jtag_uart_ioctl>
}
  813f30:	e037883a 	mov	sp,fp
  813f34:	dfc00117 	ldw	ra,4(sp)
  813f38:	df000017 	ldw	fp,0(sp)
  813f3c:	dec00204 	addi	sp,sp,8
  813f40:	f800283a 	ret

00813f44 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  813f44:	defffa04 	addi	sp,sp,-24
  813f48:	dfc00515 	stw	ra,20(sp)
  813f4c:	df000415 	stw	fp,16(sp)
  813f50:	df000404 	addi	fp,sp,16
  813f54:	e13ffd15 	stw	r4,-12(fp)
  813f58:	e17ffe15 	stw	r5,-8(fp)
  813f5c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  813f60:	e0fffd17 	ldw	r3,-12(fp)
  813f64:	00800044 	movi	r2,1
  813f68:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  813f6c:	e0bffd17 	ldw	r2,-12(fp)
  813f70:	10800017 	ldw	r2,0(r2)
  813f74:	11000104 	addi	r4,r2,4
  813f78:	e0bffd17 	ldw	r2,-12(fp)
  813f7c:	10800817 	ldw	r2,32(r2)
  813f80:	1007883a 	mov	r3,r2
  813f84:	2005883a 	mov	r2,r4
  813f88:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  813f8c:	e13ffe17 	ldw	r4,-8(fp)
  813f90:	e17fff17 	ldw	r5,-4(fp)
  813f94:	d8000015 	stw	zero,0(sp)
  813f98:	01802074 	movhi	r6,129
  813f9c:	31900104 	addi	r6,r6,16388
  813fa0:	e1fffd17 	ldw	r7,-12(fp)
  813fa4:	0815ce80 	call	815ce8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  813fa8:	e0bffd17 	ldw	r2,-12(fp)
  813fac:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  813fb0:	e0bffd17 	ldw	r2,-12(fp)
  813fb4:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  813fb8:	008020b4 	movhi	r2,130
  813fbc:	10b02b04 	addi	r2,r2,-16212
  813fc0:	10800017 	ldw	r2,0(r2)
  813fc4:	100b883a 	mov	r5,r2
  813fc8:	01802074 	movhi	r6,129
  813fcc:	31908b04 	addi	r6,r6,16940
  813fd0:	e1fffd17 	ldw	r7,-12(fp)
  813fd4:	08159800 	call	815980 <alt_alarm_start>
  813fd8:	1004403a 	cmpge	r2,r2,zero
  813fdc:	1000041e 	bne	r2,zero,813ff0 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  813fe0:	e0fffd17 	ldw	r3,-12(fp)
  813fe4:	00a00034 	movhi	r2,32768
  813fe8:	10bfffc4 	addi	r2,r2,-1
  813fec:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  813ff0:	e037883a 	mov	sp,fp
  813ff4:	dfc00117 	ldw	ra,4(sp)
  813ff8:	df000017 	ldw	fp,0(sp)
  813ffc:	dec00204 	addi	sp,sp,8
  814000:	f800283a 	ret

00814004 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  814004:	defff804 	addi	sp,sp,-32
  814008:	df000715 	stw	fp,28(sp)
  81400c:	df000704 	addi	fp,sp,28
  814010:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  814014:	e0bfff17 	ldw	r2,-4(fp)
  814018:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
  81401c:	e0bffe17 	ldw	r2,-8(fp)
  814020:	10800017 	ldw	r2,0(r2)
  814024:	e0bffd15 	stw	r2,-12(fp)
  814028:	00000006 	br	81402c <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  81402c:	e0bffd17 	ldw	r2,-12(fp)
  814030:	10800104 	addi	r2,r2,4
  814034:	10800037 	ldwio	r2,0(r2)
  814038:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  81403c:	e0bffc17 	ldw	r2,-16(fp)
  814040:	1080c00c 	andi	r2,r2,768
  814044:	1005003a 	cmpeq	r2,r2,zero
  814048:	1000741e 	bne	r2,zero,81421c <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  81404c:	e0bffc17 	ldw	r2,-16(fp)
  814050:	1080400c 	andi	r2,r2,256
  814054:	1005003a 	cmpeq	r2,r2,zero
  814058:	1000351e 	bne	r2,zero,814130 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  81405c:	00800074 	movhi	r2,1
  814060:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  814064:	e0bffe17 	ldw	r2,-8(fp)
  814068:	10800a17 	ldw	r2,40(r2)
  81406c:	10800044 	addi	r2,r2,1
  814070:	1081ffcc 	andi	r2,r2,2047
  814074:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
  814078:	e0bffe17 	ldw	r2,-8(fp)
  81407c:	10c00b17 	ldw	r3,44(r2)
  814080:	e0bffa17 	ldw	r2,-24(fp)
  814084:	18801626 	beq	r3,r2,8140e0 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  814088:	e0bffd17 	ldw	r2,-12(fp)
  81408c:	10800037 	ldwio	r2,0(r2)
  814090:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  814094:	e0bffb17 	ldw	r2,-20(fp)
  814098:	10a0000c 	andi	r2,r2,32768
  81409c:	1005003a 	cmpeq	r2,r2,zero
  8140a0:	10000f1e 	bne	r2,zero,8140e0 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  8140a4:	e0bffe17 	ldw	r2,-8(fp)
  8140a8:	10c00a17 	ldw	r3,40(r2)
  8140ac:	e0bffb17 	ldw	r2,-20(fp)
  8140b0:	1009883a 	mov	r4,r2
  8140b4:	e0bffe17 	ldw	r2,-8(fp)
  8140b8:	1885883a 	add	r2,r3,r2
  8140bc:	10800e04 	addi	r2,r2,56
  8140c0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  8140c4:	e0bffe17 	ldw	r2,-8(fp)
  8140c8:	10800a17 	ldw	r2,40(r2)
  8140cc:	10800044 	addi	r2,r2,1
  8140d0:	10c1ffcc 	andi	r3,r2,2047
  8140d4:	e0bffe17 	ldw	r2,-8(fp)
  8140d8:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  8140dc:	003fe106 	br	814064 <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  8140e0:	e0bffb17 	ldw	r2,-20(fp)
  8140e4:	10bfffec 	andhi	r2,r2,65535
  8140e8:	1005003a 	cmpeq	r2,r2,zero
  8140ec:	1000101e 	bne	r2,zero,814130 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  8140f0:	e0bffe17 	ldw	r2,-8(fp)
  8140f4:	10c00817 	ldw	r3,32(r2)
  8140f8:	00bfff84 	movi	r2,-2
  8140fc:	1886703a 	and	r3,r3,r2
  814100:	e0bffe17 	ldw	r2,-8(fp)
  814104:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  814108:	e0bffd17 	ldw	r2,-12(fp)
  81410c:	11000104 	addi	r4,r2,4
  814110:	e0bffe17 	ldw	r2,-8(fp)
  814114:	10800817 	ldw	r2,32(r2)
  814118:	1007883a 	mov	r3,r2
  81411c:	2005883a 	mov	r2,r4
  814120:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  814124:	e0bffd17 	ldw	r2,-12(fp)
  814128:	10800104 	addi	r2,r2,4
  81412c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  814130:	e0bffc17 	ldw	r2,-16(fp)
  814134:	1080800c 	andi	r2,r2,512
  814138:	1005003a 	cmpeq	r2,r2,zero
  81413c:	103fbb1e 	bne	r2,zero,81402c <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  814140:	e0bffc17 	ldw	r2,-16(fp)
  814144:	10bfffec 	andhi	r2,r2,65535
  814148:	1004d43a 	srli	r2,r2,16
  81414c:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  814150:	00001506 	br	8141a8 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  814154:	e13ffd17 	ldw	r4,-12(fp)
  814158:	e0bffe17 	ldw	r2,-8(fp)
  81415c:	10c00d17 	ldw	r3,52(r2)
  814160:	e0bffe17 	ldw	r2,-8(fp)
  814164:	1885883a 	add	r2,r3,r2
  814168:	10820e04 	addi	r2,r2,2104
  81416c:	10800003 	ldbu	r2,0(r2)
  814170:	10c03fcc 	andi	r3,r2,255
  814174:	18c0201c 	xori	r3,r3,128
  814178:	18ffe004 	addi	r3,r3,-128
  81417c:	2005883a 	mov	r2,r4
  814180:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  814184:	e0bffe17 	ldw	r2,-8(fp)
  814188:	10800d17 	ldw	r2,52(r2)
  81418c:	10800044 	addi	r2,r2,1
  814190:	10c1ffcc 	andi	r3,r2,2047
  814194:	e0bffe17 	ldw	r2,-8(fp)
  814198:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  81419c:	e0bff917 	ldw	r2,-28(fp)
  8141a0:	10bfffc4 	addi	r2,r2,-1
  8141a4:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  8141a8:	e0bff917 	ldw	r2,-28(fp)
  8141ac:	1005003a 	cmpeq	r2,r2,zero
  8141b0:	1000051e 	bne	r2,zero,8141c8 <altera_avalon_jtag_uart_irq+0x1c4>
  8141b4:	e0bffe17 	ldw	r2,-8(fp)
  8141b8:	10c00d17 	ldw	r3,52(r2)
  8141bc:	e0bffe17 	ldw	r2,-8(fp)
  8141c0:	10800c17 	ldw	r2,48(r2)
  8141c4:	18bfe31e 	bne	r3,r2,814154 <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  8141c8:	e0bff917 	ldw	r2,-28(fp)
  8141cc:	1005003a 	cmpeq	r2,r2,zero
  8141d0:	103f961e 	bne	r2,zero,81402c <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  8141d4:	e0bffe17 	ldw	r2,-8(fp)
  8141d8:	10c00817 	ldw	r3,32(r2)
  8141dc:	00bfff44 	movi	r2,-3
  8141e0:	1886703a 	and	r3,r3,r2
  8141e4:	e0bffe17 	ldw	r2,-8(fp)
  8141e8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  8141ec:	e0bffe17 	ldw	r2,-8(fp)
  8141f0:	10800017 	ldw	r2,0(r2)
  8141f4:	11000104 	addi	r4,r2,4
  8141f8:	e0bffe17 	ldw	r2,-8(fp)
  8141fc:	10800817 	ldw	r2,32(r2)
  814200:	1007883a 	mov	r3,r2
  814204:	2005883a 	mov	r2,r4
  814208:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  81420c:	e0bffd17 	ldw	r2,-12(fp)
  814210:	10800104 	addi	r2,r2,4
  814214:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  814218:	003f8406 	br	81402c <altera_avalon_jtag_uart_irq+0x28>
}
  81421c:	e037883a 	mov	sp,fp
  814220:	df000017 	ldw	fp,0(sp)
  814224:	dec00104 	addi	sp,sp,4
  814228:	f800283a 	ret

0081422c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  81422c:	defffc04 	addi	sp,sp,-16
  814230:	df000315 	stw	fp,12(sp)
  814234:	df000304 	addi	fp,sp,12
  814238:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  81423c:	e0bfff17 	ldw	r2,-4(fp)
  814240:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  814244:	e0bffe17 	ldw	r2,-8(fp)
  814248:	10800017 	ldw	r2,0(r2)
  81424c:	10800104 	addi	r2,r2,4
  814250:	10800037 	ldwio	r2,0(r2)
  814254:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  814258:	e0bffd17 	ldw	r2,-12(fp)
  81425c:	1081000c 	andi	r2,r2,1024
  814260:	1005003a 	cmpeq	r2,r2,zero
  814264:	10000c1e 	bne	r2,zero,814298 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  814268:	e0bffe17 	ldw	r2,-8(fp)
  81426c:	10800017 	ldw	r2,0(r2)
  814270:	11000104 	addi	r4,r2,4
  814274:	e0bffe17 	ldw	r2,-8(fp)
  814278:	10800817 	ldw	r2,32(r2)
  81427c:	10810014 	ori	r2,r2,1024
  814280:	1007883a 	mov	r3,r2
  814284:	2005883a 	mov	r2,r4
  814288:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
  81428c:	e0bffe17 	ldw	r2,-8(fp)
  814290:	10000915 	stw	zero,36(r2)
  814294:	00000a06 	br	8142c0 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  814298:	e0bffe17 	ldw	r2,-8(fp)
  81429c:	10c00917 	ldw	r3,36(r2)
  8142a0:	00a00034 	movhi	r2,32768
  8142a4:	10bfff04 	addi	r2,r2,-4
  8142a8:	10c00536 	bltu	r2,r3,8142c0 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
  8142ac:	e0bffe17 	ldw	r2,-8(fp)
  8142b0:	10800917 	ldw	r2,36(r2)
  8142b4:	10c00044 	addi	r3,r2,1
  8142b8:	e0bffe17 	ldw	r2,-8(fp)
  8142bc:	10c00915 	stw	r3,36(r2)
  8142c0:	008020b4 	movhi	r2,130
  8142c4:	10b02b04 	addi	r2,r2,-16212
  8142c8:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  8142cc:	e037883a 	mov	sp,fp
  8142d0:	df000017 	ldw	fp,0(sp)
  8142d4:	dec00104 	addi	sp,sp,4
  8142d8:	f800283a 	ret

008142dc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  8142dc:	defffc04 	addi	sp,sp,-16
  8142e0:	df000315 	stw	fp,12(sp)
  8142e4:	df000304 	addi	fp,sp,12
  8142e8:	e13ffd15 	stw	r4,-12(fp)
  8142ec:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  8142f0:	00000706 	br	814310 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
  8142f4:	e0bffe17 	ldw	r2,-8(fp)
  8142f8:	1090000c 	andi	r2,r2,16384
  8142fc:	1005003a 	cmpeq	r2,r2,zero
  814300:	1000031e 	bne	r2,zero,814310 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
  814304:	00bffd44 	movi	r2,-11
  814308:	e0bfff15 	stw	r2,-4(fp)
  81430c:	00000b06 	br	81433c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  814310:	e0bffd17 	ldw	r2,-12(fp)
  814314:	10c00d17 	ldw	r3,52(r2)
  814318:	e0bffd17 	ldw	r2,-12(fp)
  81431c:	10800c17 	ldw	r2,48(r2)
  814320:	18800526 	beq	r3,r2,814338 <altera_avalon_jtag_uart_close+0x5c>
  814324:	e0bffd17 	ldw	r2,-12(fp)
  814328:	10c00917 	ldw	r3,36(r2)
  81432c:	e0bffd17 	ldw	r2,-12(fp)
  814330:	10800117 	ldw	r2,4(r2)
  814334:	18bfef36 	bltu	r3,r2,8142f4 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  814338:	e03fff15 	stw	zero,-4(fp)
  81433c:	e0bfff17 	ldw	r2,-4(fp)
}
  814340:	e037883a 	mov	sp,fp
  814344:	df000017 	ldw	fp,0(sp)
  814348:	dec00104 	addi	sp,sp,4
  81434c:	f800283a 	ret

00814350 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  814350:	defff804 	addi	sp,sp,-32
  814354:	df000715 	stw	fp,28(sp)
  814358:	df000704 	addi	fp,sp,28
  81435c:	e13ffb15 	stw	r4,-20(fp)
  814360:	e17ffc15 	stw	r5,-16(fp)
  814364:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
  814368:	00bff9c4 	movi	r2,-25
  81436c:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
  814370:	e0bffc17 	ldw	r2,-16(fp)
  814374:	e0bfff15 	stw	r2,-4(fp)
  814378:	e0ffff17 	ldw	r3,-4(fp)
  81437c:	189a8060 	cmpeqi	r2,r3,27137
  814380:	1000041e 	bne	r2,zero,814394 <altera_avalon_jtag_uart_ioctl+0x44>
  814384:	e0ffff17 	ldw	r3,-4(fp)
  814388:	189a80a0 	cmpeqi	r2,r3,27138
  81438c:	10001b1e 	bne	r2,zero,8143fc <altera_avalon_jtag_uart_ioctl+0xac>
  814390:	00002706 	br	814430 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  814394:	e0bffb17 	ldw	r2,-20(fp)
  814398:	10c00117 	ldw	r3,4(r2)
  81439c:	00a00034 	movhi	r2,32768
  8143a0:	10bfffc4 	addi	r2,r2,-1
  8143a4:	18802226 	beq	r3,r2,814430 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
  8143a8:	e0bffd17 	ldw	r2,-12(fp)
  8143ac:	10800017 	ldw	r2,0(r2)
  8143b0:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  8143b4:	e0bff917 	ldw	r2,-28(fp)
  8143b8:	10800090 	cmplti	r2,r2,2
  8143bc:	1000071e 	bne	r2,zero,8143dc <altera_avalon_jtag_uart_ioctl+0x8c>
  8143c0:	e0fff917 	ldw	r3,-28(fp)
  8143c4:	00a00034 	movhi	r2,32768
  8143c8:	10bfffc4 	addi	r2,r2,-1
  8143cc:	18800326 	beq	r3,r2,8143dc <altera_avalon_jtag_uart_ioctl+0x8c>
  8143d0:	e0bff917 	ldw	r2,-28(fp)
  8143d4:	e0bffe15 	stw	r2,-8(fp)
  8143d8:	00000306 	br	8143e8 <altera_avalon_jtag_uart_ioctl+0x98>
  8143dc:	00e00034 	movhi	r3,32768
  8143e0:	18ffff84 	addi	r3,r3,-2
  8143e4:	e0fffe15 	stw	r3,-8(fp)
  8143e8:	e0bffb17 	ldw	r2,-20(fp)
  8143ec:	e0fffe17 	ldw	r3,-8(fp)
  8143f0:	10c00115 	stw	r3,4(r2)
      rc = 0;
  8143f4:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
  8143f8:	00000d06 	br	814430 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  8143fc:	e0bffb17 	ldw	r2,-20(fp)
  814400:	10c00117 	ldw	r3,4(r2)
  814404:	00a00034 	movhi	r2,32768
  814408:	10bfffc4 	addi	r2,r2,-1
  81440c:	18800826 	beq	r3,r2,814430 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  814410:	e13ffd17 	ldw	r4,-12(fp)
  814414:	e0bffb17 	ldw	r2,-20(fp)
  814418:	10c00917 	ldw	r3,36(r2)
  81441c:	e0bffb17 	ldw	r2,-20(fp)
  814420:	10800117 	ldw	r2,4(r2)
  814424:	1885803a 	cmpltu	r2,r3,r2
  814428:	20800015 	stw	r2,0(r4)
      rc = 0;
  81442c:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
  814430:	e0bffa17 	ldw	r2,-24(fp)
}
  814434:	e037883a 	mov	sp,fp
  814438:	df000017 	ldw	fp,0(sp)
  81443c:	dec00104 	addi	sp,sp,4
  814440:	f800283a 	ret

00814444 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  814444:	defff204 	addi	sp,sp,-56
  814448:	dfc00d15 	stw	ra,52(sp)
  81444c:	df000c15 	stw	fp,48(sp)
  814450:	df000c04 	addi	fp,sp,48
  814454:	e13ffb15 	stw	r4,-20(fp)
  814458:	e17ffc15 	stw	r5,-16(fp)
  81445c:	e1bffd15 	stw	r6,-12(fp)
  814460:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
  814464:	e0bffc17 	ldw	r2,-16(fp)
  814468:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  81446c:	00004806 	br	814590 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  814470:	e0bffb17 	ldw	r2,-20(fp)
  814474:	10800a17 	ldw	r2,40(r2)
  814478:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  81447c:	e0bffb17 	ldw	r2,-20(fp)
  814480:	10800b17 	ldw	r2,44(r2)
  814484:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
  814488:	e0fff717 	ldw	r3,-36(fp)
  81448c:	e0bff617 	ldw	r2,-40(fp)
  814490:	18800536 	bltu	r3,r2,8144a8 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  814494:	e0bff717 	ldw	r2,-36(fp)
  814498:	e0fff617 	ldw	r3,-40(fp)
  81449c:	10c5c83a 	sub	r2,r2,r3
  8144a0:	e0bff815 	stw	r2,-32(fp)
  8144a4:	00000406 	br	8144b8 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  8144a8:	00820004 	movi	r2,2048
  8144ac:	e0fff617 	ldw	r3,-40(fp)
  8144b0:	10c5c83a 	sub	r2,r2,r3
  8144b4:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
  8144b8:	e0bff817 	ldw	r2,-32(fp)
  8144bc:	1005003a 	cmpeq	r2,r2,zero
  8144c0:	10001f1e 	bne	r2,zero,814540 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
  8144c4:	e0fffd17 	ldw	r3,-12(fp)
  8144c8:	e0bff817 	ldw	r2,-32(fp)
  8144cc:	1880022e 	bgeu	r3,r2,8144d8 <altera_avalon_jtag_uart_read+0x94>
        n = space;
  8144d0:	e0bffd17 	ldw	r2,-12(fp)
  8144d4:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  8144d8:	e0bffb17 	ldw	r2,-20(fp)
  8144dc:	10c00e04 	addi	r3,r2,56
  8144e0:	e0bff617 	ldw	r2,-40(fp)
  8144e4:	1887883a 	add	r3,r3,r2
  8144e8:	e0bffa17 	ldw	r2,-24(fp)
  8144ec:	1009883a 	mov	r4,r2
  8144f0:	180b883a 	mov	r5,r3
  8144f4:	e1bff817 	ldw	r6,-32(fp)
  8144f8:	080b8fc0 	call	80b8fc <memcpy>
      ptr   += n;
  8144fc:	e0fff817 	ldw	r3,-32(fp)
  814500:	e0bffa17 	ldw	r2,-24(fp)
  814504:	10c5883a 	add	r2,r2,r3
  814508:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
  81450c:	e0fffd17 	ldw	r3,-12(fp)
  814510:	e0bff817 	ldw	r2,-32(fp)
  814514:	1885c83a 	sub	r2,r3,r2
  814518:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  81451c:	e0fff617 	ldw	r3,-40(fp)
  814520:	e0bff817 	ldw	r2,-32(fp)
  814524:	1885883a 	add	r2,r3,r2
  814528:	10c1ffcc 	andi	r3,r2,2047
  81452c:	e0bffb17 	ldw	r2,-20(fp)
  814530:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  814534:	e0bffd17 	ldw	r2,-12(fp)
  814538:	10800048 	cmpgei	r2,r2,1
  81453c:	103fcc1e 	bne	r2,zero,814470 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
  814540:	e0fffa17 	ldw	r3,-24(fp)
  814544:	e0bffc17 	ldw	r2,-16(fp)
  814548:	1880141e 	bne	r3,r2,81459c <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  81454c:	e0bffe17 	ldw	r2,-8(fp)
  814550:	1090000c 	andi	r2,r2,16384
  814554:	1004c03a 	cmpne	r2,r2,zero
  814558:	1000101e 	bne	r2,zero,81459c <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  81455c:	e0bffb17 	ldw	r2,-20(fp)
  814560:	10c00a17 	ldw	r3,40(r2)
  814564:	e0bff717 	ldw	r2,-36(fp)
  814568:	1880051e 	bne	r3,r2,814580 <altera_avalon_jtag_uart_read+0x13c>
  81456c:	e0bffb17 	ldw	r2,-20(fp)
  814570:	10c00917 	ldw	r3,36(r2)
  814574:	e0bffb17 	ldw	r2,-20(fp)
  814578:	10800117 	ldw	r2,4(r2)
  81457c:	18bff736 	bltu	r3,r2,81455c <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  814580:	e0bffb17 	ldw	r2,-20(fp)
  814584:	10c00a17 	ldw	r3,40(r2)
  814588:	e0bff717 	ldw	r2,-36(fp)
  81458c:	18800326 	beq	r3,r2,81459c <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  814590:	e0bffd17 	ldw	r2,-12(fp)
  814594:	10800048 	cmpgei	r2,r2,1
  814598:	103fb51e 	bne	r2,zero,814470 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  81459c:	e0fffa17 	ldw	r3,-24(fp)
  8145a0:	e0bffc17 	ldw	r2,-16(fp)
  8145a4:	18801926 	beq	r3,r2,81460c <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8145a8:	0005303a 	rdctl	r2,status
  8145ac:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8145b0:	e0fff517 	ldw	r3,-44(fp)
  8145b4:	00bfff84 	movi	r2,-2
  8145b8:	1884703a 	and	r2,r3,r2
  8145bc:	1001703a 	wrctl	status,r2
  
  return context;
  8145c0:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  8145c4:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  8145c8:	e0bffb17 	ldw	r2,-20(fp)
  8145cc:	10800817 	ldw	r2,32(r2)
  8145d0:	10c00054 	ori	r3,r2,1
  8145d4:	e0bffb17 	ldw	r2,-20(fp)
  8145d8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  8145dc:	e0bffb17 	ldw	r2,-20(fp)
  8145e0:	10800017 	ldw	r2,0(r2)
  8145e4:	11000104 	addi	r4,r2,4
  8145e8:	e0bffb17 	ldw	r2,-20(fp)
  8145ec:	10800817 	ldw	r2,32(r2)
  8145f0:	1007883a 	mov	r3,r2
  8145f4:	2005883a 	mov	r2,r4
  8145f8:	10c00035 	stwio	r3,0(r2)
  8145fc:	e0bff917 	ldw	r2,-28(fp)
  814600:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  814604:	e0bff417 	ldw	r2,-48(fp)
  814608:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  81460c:	e0fffa17 	ldw	r3,-24(fp)
  814610:	e0bffc17 	ldw	r2,-16(fp)
  814614:	18800526 	beq	r3,r2,81462c <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
  814618:	e0fffa17 	ldw	r3,-24(fp)
  81461c:	e0bffc17 	ldw	r2,-16(fp)
  814620:	1887c83a 	sub	r3,r3,r2
  814624:	e0ffff15 	stw	r3,-4(fp)
  814628:	00000906 	br	814650 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
  81462c:	e0bffe17 	ldw	r2,-8(fp)
  814630:	1090000c 	andi	r2,r2,16384
  814634:	1005003a 	cmpeq	r2,r2,zero
  814638:	1000031e 	bne	r2,zero,814648 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
  81463c:	00bffd44 	movi	r2,-11
  814640:	e0bfff15 	stw	r2,-4(fp)
  814644:	00000206 	br	814650 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
  814648:	00bffec4 	movi	r2,-5
  81464c:	e0bfff15 	stw	r2,-4(fp)
  814650:	e0bfff17 	ldw	r2,-4(fp)
}
  814654:	e037883a 	mov	sp,fp
  814658:	dfc00117 	ldw	ra,4(sp)
  81465c:	df000017 	ldw	fp,0(sp)
  814660:	dec00204 	addi	sp,sp,8
  814664:	f800283a 	ret

00814668 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  814668:	defff204 	addi	sp,sp,-56
  81466c:	dfc00d15 	stw	ra,52(sp)
  814670:	df000c15 	stw	fp,48(sp)
  814674:	df000c04 	addi	fp,sp,48
  814678:	e13ffb15 	stw	r4,-20(fp)
  81467c:	e17ffc15 	stw	r5,-16(fp)
  814680:	e1bffd15 	stw	r6,-12(fp)
  814684:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  814688:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  81468c:	e0bffc17 	ldw	r2,-16(fp)
  814690:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  814694:	00003a06 	br	814780 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  814698:	e0bffb17 	ldw	r2,-20(fp)
  81469c:	10800c17 	ldw	r2,48(r2)
  8146a0:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
  8146a4:	e0bffb17 	ldw	r2,-20(fp)
  8146a8:	10800d17 	ldw	r2,52(r2)
  8146ac:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
  8146b0:	e0fffa17 	ldw	r3,-24(fp)
  8146b4:	e0bff917 	ldw	r2,-28(fp)
  8146b8:	1880062e 	bgeu	r3,r2,8146d4 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  8146bc:	e0fff917 	ldw	r3,-28(fp)
  8146c0:	e0bffa17 	ldw	r2,-24(fp)
  8146c4:	1885c83a 	sub	r2,r3,r2
  8146c8:	10bfffc4 	addi	r2,r2,-1
  8146cc:	e0bff815 	stw	r2,-32(fp)
  8146d0:	00000c06 	br	814704 <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
  8146d4:	e0bff917 	ldw	r2,-28(fp)
  8146d8:	1005003a 	cmpeq	r2,r2,zero
  8146dc:	1000051e 	bne	r2,zero,8146f4 <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  8146e0:	00820004 	movi	r2,2048
  8146e4:	e0fffa17 	ldw	r3,-24(fp)
  8146e8:	10c5c83a 	sub	r2,r2,r3
  8146ec:	e0bff815 	stw	r2,-32(fp)
  8146f0:	00000406 	br	814704 <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  8146f4:	0081ffc4 	movi	r2,2047
  8146f8:	e0fffa17 	ldw	r3,-24(fp)
  8146fc:	10c5c83a 	sub	r2,r2,r3
  814700:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
  814704:	e0bff817 	ldw	r2,-32(fp)
  814708:	1005003a 	cmpeq	r2,r2,zero
  81470c:	10001f1e 	bne	r2,zero,81478c <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
  814710:	e0fffd17 	ldw	r3,-12(fp)
  814714:	e0bff817 	ldw	r2,-32(fp)
  814718:	1880022e 	bgeu	r3,r2,814724 <altera_avalon_jtag_uart_write+0xbc>
        n = count;
  81471c:	e0bffd17 	ldw	r2,-12(fp)
  814720:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  814724:	e0bffb17 	ldw	r2,-20(fp)
  814728:	10c20e04 	addi	r3,r2,2104
  81472c:	e0bffa17 	ldw	r2,-24(fp)
  814730:	1885883a 	add	r2,r3,r2
  814734:	e0fffc17 	ldw	r3,-16(fp)
  814738:	1009883a 	mov	r4,r2
  81473c:	180b883a 	mov	r5,r3
  814740:	e1bff817 	ldw	r6,-32(fp)
  814744:	080b8fc0 	call	80b8fc <memcpy>
      ptr   += n;
  814748:	e0fff817 	ldw	r3,-32(fp)
  81474c:	e0bffc17 	ldw	r2,-16(fp)
  814750:	10c5883a 	add	r2,r2,r3
  814754:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
  814758:	e0fffd17 	ldw	r3,-12(fp)
  81475c:	e0bff817 	ldw	r2,-32(fp)
  814760:	1885c83a 	sub	r2,r3,r2
  814764:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  814768:	e0fffa17 	ldw	r3,-24(fp)
  81476c:	e0bff817 	ldw	r2,-32(fp)
  814770:	1885883a 	add	r2,r3,r2
  814774:	10c1ffcc 	andi	r3,r2,2047
  814778:	e0bffb17 	ldw	r2,-20(fp)
  81477c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  814780:	e0bffd17 	ldw	r2,-12(fp)
  814784:	10800048 	cmpgei	r2,r2,1
  814788:	103fc31e 	bne	r2,zero,814698 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  81478c:	0005303a 	rdctl	r2,status
  814790:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  814794:	e0fff517 	ldw	r3,-44(fp)
  814798:	00bfff84 	movi	r2,-2
  81479c:	1884703a 	and	r2,r3,r2
  8147a0:	1001703a 	wrctl	status,r2
  
  return context;
  8147a4:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  8147a8:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  8147ac:	e0bffb17 	ldw	r2,-20(fp)
  8147b0:	10800817 	ldw	r2,32(r2)
  8147b4:	10c00094 	ori	r3,r2,2
  8147b8:	e0bffb17 	ldw	r2,-20(fp)
  8147bc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  8147c0:	e0bffb17 	ldw	r2,-20(fp)
  8147c4:	10800017 	ldw	r2,0(r2)
  8147c8:	11000104 	addi	r4,r2,4
  8147cc:	e0bffb17 	ldw	r2,-20(fp)
  8147d0:	10800817 	ldw	r2,32(r2)
  8147d4:	1007883a 	mov	r3,r2
  8147d8:	2005883a 	mov	r2,r4
  8147dc:	10c00035 	stwio	r3,0(r2)
  8147e0:	e0bff717 	ldw	r2,-36(fp)
  8147e4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8147e8:	e0bff417 	ldw	r2,-48(fp)
  8147ec:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  8147f0:	e0bffd17 	ldw	r2,-12(fp)
  8147f4:	10800050 	cmplti	r2,r2,1
  8147f8:	1000111e 	bne	r2,zero,814840 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
  8147fc:	e0bffe17 	ldw	r2,-8(fp)
  814800:	1090000c 	andi	r2,r2,16384
  814804:	1004c03a 	cmpne	r2,r2,zero
  814808:	1000101e 	bne	r2,zero,81484c <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  81480c:	e0bffb17 	ldw	r2,-20(fp)
  814810:	10c00d17 	ldw	r3,52(r2)
  814814:	e0bff917 	ldw	r2,-28(fp)
  814818:	1880051e 	bne	r3,r2,814830 <altera_avalon_jtag_uart_write+0x1c8>
  81481c:	e0bffb17 	ldw	r2,-20(fp)
  814820:	10c00917 	ldw	r3,36(r2)
  814824:	e0bffb17 	ldw	r2,-20(fp)
  814828:	10800117 	ldw	r2,4(r2)
  81482c:	18bff736 	bltu	r3,r2,81480c <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
  814830:	e0bffb17 	ldw	r2,-20(fp)
  814834:	10c00d17 	ldw	r3,52(r2)
  814838:	e0bff917 	ldw	r2,-28(fp)
  81483c:	18800326 	beq	r3,r2,81484c <altera_avalon_jtag_uart_write+0x1e4>
        break;
    }
  }
  while (count > 0);
  814840:	e0bffd17 	ldw	r2,-12(fp)
  814844:	10800048 	cmpgei	r2,r2,1
  814848:	103fcd1e 	bne	r2,zero,814780 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  81484c:	e0fffc17 	ldw	r3,-16(fp)
  814850:	e0bff617 	ldw	r2,-40(fp)
  814854:	18800526 	beq	r3,r2,81486c <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
  814858:	e0fffc17 	ldw	r3,-16(fp)
  81485c:	e0bff617 	ldw	r2,-40(fp)
  814860:	1887c83a 	sub	r3,r3,r2
  814864:	e0ffff15 	stw	r3,-4(fp)
  814868:	00000906 	br	814890 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
  81486c:	e0bffe17 	ldw	r2,-8(fp)
  814870:	1090000c 	andi	r2,r2,16384
  814874:	1005003a 	cmpeq	r2,r2,zero
  814878:	1000031e 	bne	r2,zero,814888 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
  81487c:	00bffd44 	movi	r2,-11
  814880:	e0bfff15 	stw	r2,-4(fp)
  814884:	00000206 	br	814890 <altera_avalon_jtag_uart_write+0x228>
  else
    return -EIO; /* Host not connected */
  814888:	00bffec4 	movi	r2,-5
  81488c:	e0bfff15 	stw	r2,-4(fp)
  814890:	e0bfff17 	ldw	r2,-4(fp)
}
  814894:	e037883a 	mov	sp,fp
  814898:	dfc00117 	ldw	ra,4(sp)
  81489c:	df000017 	ldw	fp,0(sp)
  8148a0:	dec00204 	addi	sp,sp,8
  8148a4:	f800283a 	ret

008148a8 <perf_get_section_time>:

#include "altera_avalon_performance_counter.h"
#include "system.h"

alt_u64 perf_get_section_time (void* hw_base_address, int which_section)
{
  8148a8:	defff904 	addi	sp,sp,-28
  8148ac:	df000615 	stw	fp,24(sp)
  8148b0:	df000604 	addi	fp,sp,24
  8148b4:	e13ffe15 	stw	r4,-8(fp)
  8148b8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 lo;
  alt_u32 hi;
  alt_u64 result = 0;
  8148bc:	e03ffa15 	stw	zero,-24(fp)
  8148c0:	e03ffb15 	stw	zero,-20(fp)

  PERF_STOP_MEASURING(hw_base_address);
  8148c4:	e0bffe17 	ldw	r2,-8(fp)
  8148c8:	10000035 	stwio	zero,0(r2)
  lo = IORD(hw_base_address, ( which_section*4   ));
  8148cc:	e0bfff17 	ldw	r2,-4(fp)
  8148d0:	1004913a 	slli	r2,r2,4
  8148d4:	1007883a 	mov	r3,r2
  8148d8:	e0bffe17 	ldw	r2,-8(fp)
  8148dc:	1885883a 	add	r2,r3,r2
  8148e0:	10800037 	ldwio	r2,0(r2)
  8148e4:	e0bffd15 	stw	r2,-12(fp)
  hi = IORD(hw_base_address, ((which_section*4)+1));
  8148e8:	e0bfff17 	ldw	r2,-4(fp)
  8148ec:	1004913a 	slli	r2,r2,4
  8148f0:	1007883a 	mov	r3,r2
  8148f4:	e0bffe17 	ldw	r2,-8(fp)
  8148f8:	1885883a 	add	r2,r3,r2
  8148fc:	10800104 	addi	r2,r2,4
  814900:	10800037 	ldwio	r2,0(r2)
  814904:	e0bffc15 	stw	r2,-16(fp)

  result = ((alt_u64)(((alt_u64) hi) << ((alt_u64)32))) | 
  814908:	e0bffc17 	ldw	r2,-16(fp)
  81490c:	0007883a 	mov	r3,zero
  814910:	100a983a 	sll	r5,r2,zero
  814914:	0009883a 	mov	r4,zero
  814918:	e0bffd17 	ldw	r2,-12(fp)
  81491c:	0007883a 	mov	r3,zero
  814920:	208cb03a 	or	r6,r4,r2
  814924:	e1bffa15 	stw	r6,-24(fp)
  814928:	28c4b03a 	or	r2,r5,r3
  81492c:	e0bffb15 	stw	r2,-20(fp)
           ((alt_u64)(((alt_u64) lo)                 ))  ;
  return result;
  814930:	e17ffa17 	ldw	r5,-24(fp)
  814934:	e1bffb17 	ldw	r6,-20(fp)
  814938:	2807883a 	mov	r3,r5
  81493c:	3009883a 	mov	r4,r6
}
  814940:	1805883a 	mov	r2,r3
  814944:	2007883a 	mov	r3,r4
  814948:	e037883a 	mov	sp,fp
  81494c:	df000017 	ldw	fp,0(sp)
  814950:	dec00104 	addi	sp,sp,4
  814954:	f800283a 	ret

00814958 <perf_get_total_time>:

alt_u64 perf_get_total_time   (void* hw_base_address)
{
  814958:	defffd04 	addi	sp,sp,-12
  81495c:	dfc00215 	stw	ra,8(sp)
  814960:	df000115 	stw	fp,4(sp)
  814964:	df000104 	addi	fp,sp,4
  814968:	e13fff15 	stw	r4,-4(fp)
  return perf_get_section_time (hw_base_address, 0);
  81496c:	e13fff17 	ldw	r4,-4(fp)
  814970:	000b883a 	mov	r5,zero
  814974:	08148a80 	call	8148a8 <perf_get_section_time>
  814978:	1009883a 	mov	r4,r2
  81497c:	180b883a 	mov	r5,r3
  814980:	200d883a 	mov	r6,r4
  814984:	280f883a 	mov	r7,r5
  814988:	3007883a 	mov	r3,r6
  81498c:	3809883a 	mov	r4,r7
}
  814990:	1805883a 	mov	r2,r3
  814994:	2007883a 	mov	r3,r4
  814998:	e037883a 	mov	sp,fp
  81499c:	dfc00117 	ldw	ra,4(sp)
  8149a0:	df000017 	ldw	fp,0(sp)
  8149a4:	dec00204 	addi	sp,sp,8
  8149a8:	f800283a 	ret

008149ac <perf_get_num_starts>:

alt_u32 perf_get_num_starts   (void* hw_base_address, int which_section)
{
  8149ac:	defffd04 	addi	sp,sp,-12
  8149b0:	df000215 	stw	fp,8(sp)
  8149b4:	df000204 	addi	fp,sp,8
  8149b8:	e13ffe15 	stw	r4,-8(fp)
  8149bc:	e17fff15 	stw	r5,-4(fp)
  return IORD(hw_base_address, ((which_section*4)+2));
  8149c0:	e0bfff17 	ldw	r2,-4(fp)
  8149c4:	1004913a 	slli	r2,r2,4
  8149c8:	1007883a 	mov	r3,r2
  8149cc:	e0bffe17 	ldw	r2,-8(fp)
  8149d0:	1885883a 	add	r2,r3,r2
  8149d4:	10800204 	addi	r2,r2,8
  8149d8:	10800037 	ldwio	r2,0(r2)
}
  8149dc:	e037883a 	mov	sp,fp
  8149e0:	df000017 	ldw	fp,0(sp)
  8149e4:	dec00104 	addi	sp,sp,4
  8149e8:	f800283a 	ret

008149ec <alt_get_performance_counter_base>:
 * in Nios II IDE just like is done for the system clock timer and
 * timestamp timer.
 */
void* 
alt_get_performance_counter_base()
{
  8149ec:	deffff04 	addi	sp,sp,-4
  8149f0:	df000015 	stw	fp,0(sp)
  8149f4:	d839883a 	mov	fp,sp
#ifdef PERFORMANCE_COUNTER_0_BASE
    return (void*)PERFORMANCE_COUNTER_0_BASE;
#else
    return (void*)0;
  8149f8:	0005883a 	mov	r2,zero
#endif
}
  8149fc:	e037883a 	mov	sp,fp
  814a00:	df000017 	ldw	fp,0(sp)
  814a04:	dec00104 	addi	sp,sp,4
  814a08:	f800283a 	ret

00814a0c <alt_get_cpu_freq>:
 * If the performance counter peripheral is in a different time domain,
 * this won't necessarily be the same frequency of the CPU.
 */
alt_u32 
alt_get_cpu_freq()
{
  814a0c:	deffff04 	addi	sp,sp,-4
  814a10:	df000015 	stw	fp,0(sp)
  814a14:	d839883a 	mov	fp,sp
    return ALT_CPU_FREQ;
  814a18:	00817db4 	movhi	r2,1526
  814a1c:	10b84004 	addi	r2,r2,-7936
}
  814a20:	e037883a 	mov	sp,fp
  814a24:	df000017 	ldw	fp,0(sp)
  814a28:	dec00104 	addi	sp,sp,4
  814a2c:	f800283a 	ret

00814a30 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  814a30:	defffa04 	addi	sp,sp,-24
  814a34:	dfc00515 	stw	ra,20(sp)
  814a38:	df000415 	stw	fp,16(sp)
  814a3c:	df000404 	addi	fp,sp,16
  814a40:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  814a44:	e0bfff17 	ldw	r2,-4(fp)
  814a48:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  814a4c:	e0bfff17 	ldw	r2,-4(fp)
  814a50:	10800104 	addi	r2,r2,4
  814a54:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  814a58:	0005303a 	rdctl	r2,status
  814a5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  814a60:	e0fffd17 	ldw	r3,-12(fp)
  814a64:	00bfff84 	movi	r2,-2
  814a68:	1884703a 	and	r2,r3,r2
  814a6c:	1001703a 	wrctl	status,r2
  
  return context;
  814a70:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  814a74:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
  814a78:	08164800 	call	816480 <alt_tick>
  814a7c:	e0bffe17 	ldw	r2,-8(fp)
  814a80:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  814a84:	e0bffc17 	ldw	r2,-16(fp)
  814a88:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  814a8c:	e037883a 	mov	sp,fp
  814a90:	dfc00117 	ldw	ra,4(sp)
  814a94:	df000017 	ldw	fp,0(sp)
  814a98:	dec00204 	addi	sp,sp,8
  814a9c:	f800283a 	ret

00814aa0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  814aa0:	defff804 	addi	sp,sp,-32
  814aa4:	dfc00715 	stw	ra,28(sp)
  814aa8:	df000615 	stw	fp,24(sp)
  814aac:	df000604 	addi	fp,sp,24
  814ab0:	e13ffc15 	stw	r4,-16(fp)
  814ab4:	e17ffd15 	stw	r5,-12(fp)
  814ab8:	e1bffe15 	stw	r6,-8(fp)
  814abc:	e1ffff15 	stw	r7,-4(fp)
  814ac0:	e0bfff17 	ldw	r2,-4(fp)
  814ac4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  814ac8:	008020b4 	movhi	r2,130
  814acc:	10b02b04 	addi	r2,r2,-16212
  814ad0:	10800017 	ldw	r2,0(r2)
  814ad4:	1004c03a 	cmpne	r2,r2,zero
  814ad8:	1000041e 	bne	r2,zero,814aec <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
  814adc:	00c020b4 	movhi	r3,130
  814ae0:	18f02b04 	addi	r3,r3,-16212
  814ae4:	e0bffb17 	ldw	r2,-20(fp)
  814ae8:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  814aec:	e0bffc17 	ldw	r2,-16(fp)
  814af0:	10800104 	addi	r2,r2,4
  814af4:	1007883a 	mov	r3,r2
  814af8:	008001c4 	movi	r2,7
  814afc:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  814b00:	d8000015 	stw	zero,0(sp)
  814b04:	e13ffd17 	ldw	r4,-12(fp)
  814b08:	e17ffe17 	ldw	r5,-8(fp)
  814b0c:	01802074 	movhi	r6,129
  814b10:	31928c04 	addi	r6,r6,18992
  814b14:	e1fffc17 	ldw	r7,-16(fp)
  814b18:	0815ce80 	call	815ce8 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  814b1c:	e037883a 	mov	sp,fp
  814b20:	dfc00117 	ldw	ra,4(sp)
  814b24:	df000017 	ldw	fp,0(sp)
  814b28:	dec00204 	addi	sp,sp,8
  814b2c:	f800283a 	ret

00814b30 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  814b30:	defffa04 	addi	sp,sp,-24
  814b34:	dfc00515 	stw	ra,20(sp)
  814b38:	df000415 	stw	fp,16(sp)
  814b3c:	df000404 	addi	fp,sp,16
  814b40:	e13ffd15 	stw	r4,-12(fp)
  814b44:	e17ffe15 	stw	r5,-8(fp)
  814b48:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  814b4c:	e0bffd17 	ldw	r2,-12(fp)
  814b50:	10800017 	ldw	r2,0(r2)
  814b54:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  814b58:	e0bffc17 	ldw	r2,-16(fp)
  814b5c:	11000a04 	addi	r4,r2,40
  814b60:	e0bffd17 	ldw	r2,-12(fp)
  814b64:	11c00217 	ldw	r7,8(r2)
  814b68:	e17ffe17 	ldw	r5,-8(fp)
  814b6c:	e1bfff17 	ldw	r6,-4(fp)
  814b70:	08150280 	call	815028 <altera_avalon_uart_read>
      fd->fd_flags);
}
  814b74:	e037883a 	mov	sp,fp
  814b78:	dfc00117 	ldw	ra,4(sp)
  814b7c:	df000017 	ldw	fp,0(sp)
  814b80:	dec00204 	addi	sp,sp,8
  814b84:	f800283a 	ret

00814b88 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  814b88:	defffa04 	addi	sp,sp,-24
  814b8c:	dfc00515 	stw	ra,20(sp)
  814b90:	df000415 	stw	fp,16(sp)
  814b94:	df000404 	addi	fp,sp,16
  814b98:	e13ffd15 	stw	r4,-12(fp)
  814b9c:	e17ffe15 	stw	r5,-8(fp)
  814ba0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  814ba4:	e0bffd17 	ldw	r2,-12(fp)
  814ba8:	10800017 	ldw	r2,0(r2)
  814bac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  814bb0:	e0bffc17 	ldw	r2,-16(fp)
  814bb4:	11000a04 	addi	r4,r2,40
  814bb8:	e0bffd17 	ldw	r2,-12(fp)
  814bbc:	11c00217 	ldw	r7,8(r2)
  814bc0:	e17ffe17 	ldw	r5,-8(fp)
  814bc4:	e1bfff17 	ldw	r6,-4(fp)
  814bc8:	08152b80 	call	8152b8 <altera_avalon_uart_write>
      fd->fd_flags);
}
  814bcc:	e037883a 	mov	sp,fp
  814bd0:	dfc00117 	ldw	ra,4(sp)
  814bd4:	df000017 	ldw	fp,0(sp)
  814bd8:	dec00204 	addi	sp,sp,8
  814bdc:	f800283a 	ret

00814be0 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  814be0:	defffc04 	addi	sp,sp,-16
  814be4:	dfc00315 	stw	ra,12(sp)
  814be8:	df000215 	stw	fp,8(sp)
  814bec:	df000204 	addi	fp,sp,8
  814bf0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  814bf4:	e0bfff17 	ldw	r2,-4(fp)
  814bf8:	10800017 	ldw	r2,0(r2)
  814bfc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  814c00:	e0bffe17 	ldw	r2,-8(fp)
  814c04:	11000a04 	addi	r4,r2,40
  814c08:	e0bfff17 	ldw	r2,-4(fp)
  814c0c:	11400217 	ldw	r5,8(r2)
  814c10:	0814fc80 	call	814fc8 <altera_avalon_uart_close>
}
  814c14:	e037883a 	mov	sp,fp
  814c18:	dfc00117 	ldw	ra,4(sp)
  814c1c:	df000017 	ldw	fp,0(sp)
  814c20:	dec00204 	addi	sp,sp,8
  814c24:	f800283a 	ret

00814c28 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  814c28:	defff704 	addi	sp,sp,-36
  814c2c:	dfc00815 	stw	ra,32(sp)
  814c30:	df000715 	stw	fp,28(sp)
  814c34:	df000704 	addi	fp,sp,28
  814c38:	e13ffc15 	stw	r4,-16(fp)
  814c3c:	e17ffd15 	stw	r5,-12(fp)
  814c40:	e1bffe15 	stw	r6,-8(fp)
  void* base = sp->base;
  814c44:	e0bffc17 	ldw	r2,-16(fp)
  814c48:	10800017 	ldw	r2,0(r2)
  814c4c:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  814c50:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  814c54:	1004c03a 	cmpne	r2,r2,zero
  814c58:	1000061e 	bne	r2,zero,814c74 <altera_avalon_uart_init+0x4c>
  814c5c:	0005883a 	mov	r2,zero
  814c60:	1004c03a 	cmpne	r2,r2,zero
  814c64:	1000031e 	bne	r2,zero,814c74 <altera_avalon_uart_init+0x4c>
  814c68:	0005883a 	mov	r2,zero
  814c6c:	1005003a 	cmpeq	r2,r2,zero
  814c70:	1000031e 	bne	r2,zero,814c80 <altera_avalon_uart_init+0x58>
  814c74:	00800044 	movi	r2,1
  814c78:	e0bfff15 	stw	r2,-4(fp)
  814c7c:	00000106 	br	814c84 <altera_avalon_uart_init+0x5c>
  814c80:	e03fff15 	stw	zero,-4(fp)
  814c84:	e0bfff17 	ldw	r2,-4(fp)
  814c88:	e0bffa15 	stw	r2,-24(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  814c8c:	e0bffa17 	ldw	r2,-24(fp)
  814c90:	1004c03a 	cmpne	r2,r2,zero
  814c94:	1000111e 	bne	r2,zero,814cdc <altera_avalon_uart_init+0xb4>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  814c98:	e0fffc17 	ldw	r3,-16(fp)
  814c9c:	00832004 	movi	r2,3200
  814ca0:	18800115 	stw	r2,4(r3)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  814ca4:	e0bffb17 	ldw	r2,-20(fp)
  814ca8:	11000304 	addi	r4,r2,12
  814cac:	e0bffc17 	ldw	r2,-16(fp)
  814cb0:	10800117 	ldw	r2,4(r2)
  814cb4:	1007883a 	mov	r3,r2
  814cb8:	2005883a 	mov	r2,r4
  814cbc:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  814cc0:	d8000015 	stw	zero,0(sp)
  814cc4:	e13ffd17 	ldw	r4,-12(fp)
  814cc8:	e17ffe17 	ldw	r5,-8(fp)
  814ccc:	01802074 	movhi	r6,129
  814cd0:	31933c04 	addi	r6,r6,19696
  814cd4:	e1fffc17 	ldw	r7,-16(fp)
  814cd8:	0815ce80 	call	815ce8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  814cdc:	e037883a 	mov	sp,fp
  814ce0:	dfc00117 	ldw	ra,4(sp)
  814ce4:	df000017 	ldw	fp,0(sp)
  814ce8:	dec00204 	addi	sp,sp,8
  814cec:	f800283a 	ret

00814cf0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  814cf0:	defffa04 	addi	sp,sp,-24
  814cf4:	dfc00515 	stw	ra,20(sp)
  814cf8:	df000415 	stw	fp,16(sp)
  814cfc:	df000404 	addi	fp,sp,16
  814d00:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  814d04:	e0bfff17 	ldw	r2,-4(fp)
  814d08:	e0bffd15 	stw	r2,-12(fp)
  void* base               = sp->base;
  814d0c:	e0bffd17 	ldw	r2,-12(fp)
  814d10:	10800017 	ldw	r2,0(r2)
  814d14:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  814d18:	e0bffc17 	ldw	r2,-16(fp)
  814d1c:	10800204 	addi	r2,r2,8
  814d20:	10800037 	ldwio	r2,0(r2)
  814d24:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  814d28:	e0bffc17 	ldw	r2,-16(fp)
  814d2c:	10800204 	addi	r2,r2,8
  814d30:	10000035 	stwio	zero,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  814d34:	e0bffc17 	ldw	r2,-16(fp)
  814d38:	10800204 	addi	r2,r2,8
  814d3c:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  814d40:	e0bffe17 	ldw	r2,-8(fp)
  814d44:	1080200c 	andi	r2,r2,128
  814d48:	1005003a 	cmpeq	r2,r2,zero
  814d4c:	1000031e 	bne	r2,zero,814d5c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  814d50:	e13ffd17 	ldw	r4,-12(fp)
  814d54:	e17ffe17 	ldw	r5,-8(fp)
  814d58:	0814d8c0 	call	814d8c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  814d5c:	e0bffe17 	ldw	r2,-8(fp)
  814d60:	1081100c 	andi	r2,r2,1088
  814d64:	1005003a 	cmpeq	r2,r2,zero
  814d68:	1000031e 	bne	r2,zero,814d78 <altera_avalon_uart_irq+0x88>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  814d6c:	e13ffd17 	ldw	r4,-12(fp)
  814d70:	e17ffe17 	ldw	r5,-8(fp)
  814d74:	0814e6c0 	call	814e6c <altera_avalon_uart_txirq>
  }
  

}
  814d78:	e037883a 	mov	sp,fp
  814d7c:	dfc00117 	ldw	ra,4(sp)
  814d80:	df000017 	ldw	fp,0(sp)
  814d84:	dec00204 	addi	sp,sp,8
  814d88:	f800283a 	ret

00814d8c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  814d8c:	defffc04 	addi	sp,sp,-16
  814d90:	df000315 	stw	fp,12(sp)
  814d94:	df000304 	addi	fp,sp,12
  814d98:	e13ffe15 	stw	r4,-8(fp)
  814d9c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  814da0:	e0bfff17 	ldw	r2,-4(fp)
  814da4:	108000cc 	andi	r2,r2,3
  814da8:	1004c03a 	cmpne	r2,r2,zero
  814dac:	10002b1e 	bne	r2,zero,814e5c <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  814db0:	e0bffe17 	ldw	r2,-8(fp)
  814db4:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  814db8:	e0bffe17 	ldw	r2,-8(fp)
  814dbc:	10800317 	ldw	r2,12(r2)
  814dc0:	10800044 	addi	r2,r2,1
  814dc4:	10800fcc 	andi	r2,r2,63
  814dc8:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  814dcc:	e0bffe17 	ldw	r2,-8(fp)
  814dd0:	11000317 	ldw	r4,12(r2)
  814dd4:	e0bffe17 	ldw	r2,-8(fp)
  814dd8:	10800017 	ldw	r2,0(r2)
  814ddc:	10800037 	ldwio	r2,0(r2)
  814de0:	1007883a 	mov	r3,r2
  814de4:	e0bffe17 	ldw	r2,-8(fp)
  814de8:	2085883a 	add	r2,r4,r2
  814dec:	10800704 	addi	r2,r2,28
  814df0:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
  814df4:	e0fffe17 	ldw	r3,-8(fp)
  814df8:	e0bffd17 	ldw	r2,-12(fp)
  814dfc:	18800315 	stw	r2,12(r3)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  814e00:	e0bffe17 	ldw	r2,-8(fp)
  814e04:	10800317 	ldw	r2,12(r2)
  814e08:	10800044 	addi	r2,r2,1
  814e0c:	10800fcc 	andi	r2,r2,63
  814e10:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  814e14:	e0bffe17 	ldw	r2,-8(fp)
  814e18:	10c00217 	ldw	r3,8(r2)
  814e1c:	e0bffd17 	ldw	r2,-12(fp)
  814e20:	18800e1e 	bne	r3,r2,814e5c <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  814e24:	e0bffe17 	ldw	r2,-8(fp)
  814e28:	10c00117 	ldw	r3,4(r2)
  814e2c:	00bfdfc4 	movi	r2,-129
  814e30:	1886703a 	and	r3,r3,r2
  814e34:	e0bffe17 	ldw	r2,-8(fp)
  814e38:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  814e3c:	e0bffe17 	ldw	r2,-8(fp)
  814e40:	10800017 	ldw	r2,0(r2)
  814e44:	11000304 	addi	r4,r2,12
  814e48:	e0bffe17 	ldw	r2,-8(fp)
  814e4c:	10800117 	ldw	r2,4(r2)
  814e50:	1007883a 	mov	r3,r2
  814e54:	2005883a 	mov	r2,r4
  814e58:	10c00035 	stwio	r3,0(r2)
  }   
}
  814e5c:	e037883a 	mov	sp,fp
  814e60:	df000017 	ldw	fp,0(sp)
  814e64:	dec00104 	addi	sp,sp,4
  814e68:	f800283a 	ret

00814e6c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  814e6c:	defffd04 	addi	sp,sp,-12
  814e70:	df000215 	stw	fp,8(sp)
  814e74:	df000204 	addi	fp,sp,8
  814e78:	e13ffe15 	stw	r4,-8(fp)
  814e7c:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  814e80:	e0bffe17 	ldw	r2,-8(fp)
  814e84:	10c00417 	ldw	r3,16(r2)
  814e88:	e0bffe17 	ldw	r2,-8(fp)
  814e8c:	10800517 	ldw	r2,20(r2)
  814e90:	18803626 	beq	r3,r2,814f6c <altera_avalon_uart_txirq+0x100>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  814e94:	e0bffe17 	ldw	r2,-8(fp)
  814e98:	10800617 	ldw	r2,24(r2)
  814e9c:	1080008c 	andi	r2,r2,2
  814ea0:	1005003a 	cmpeq	r2,r2,zero
  814ea4:	1000041e 	bne	r2,zero,814eb8 <altera_avalon_uart_txirq+0x4c>
  814ea8:	e0bfff17 	ldw	r2,-4(fp)
  814eac:	1082000c 	andi	r2,r2,2048
  814eb0:	1005003a 	cmpeq	r2,r2,zero
  814eb4:	10001e1e 	bne	r2,zero,814f30 <altera_avalon_uart_txirq+0xc4>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  814eb8:	e0bffe17 	ldw	r2,-8(fp)
  814ebc:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  814ec0:	e0bffe17 	ldw	r2,-8(fp)
  814ec4:	10800017 	ldw	r2,0(r2)
  814ec8:	11000104 	addi	r4,r2,4
  814ecc:	e0bffe17 	ldw	r2,-8(fp)
  814ed0:	10c00417 	ldw	r3,16(r2)
  814ed4:	e0bffe17 	ldw	r2,-8(fp)
  814ed8:	1885883a 	add	r2,r3,r2
  814edc:	10801704 	addi	r2,r2,92
  814ee0:	10800003 	ldbu	r2,0(r2)
  814ee4:	10c03fcc 	andi	r3,r2,255
  814ee8:	2005883a 	mov	r2,r4
  814eec:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  814ef0:	e0bffe17 	ldw	r2,-8(fp)
  814ef4:	10800417 	ldw	r2,16(r2)
  814ef8:	10c00044 	addi	r3,r2,1
  814efc:	e0bffe17 	ldw	r2,-8(fp)
  814f00:	10c00415 	stw	r3,16(r2)
  814f04:	e0bffe17 	ldw	r2,-8(fp)
  814f08:	10800417 	ldw	r2,16(r2)
  814f0c:	10c00fcc 	andi	r3,r2,63
  814f10:	e0bffe17 	ldw	r2,-8(fp)
  814f14:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  814f18:	e0bffe17 	ldw	r2,-8(fp)
  814f1c:	10800117 	ldw	r2,4(r2)
  814f20:	10c01014 	ori	r3,r2,64
  814f24:	e0bffe17 	ldw	r2,-8(fp)
  814f28:	10c00115 	stw	r3,4(r2)
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  814f2c:	00000f06 	br	814f6c <altera_avalon_uart_txirq+0x100>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  814f30:	e0bffe17 	ldw	r2,-8(fp)
  814f34:	10800017 	ldw	r2,0(r2)
  814f38:	10800204 	addi	r2,r2,8
  814f3c:	10800037 	ldwio	r2,0(r2)
  814f40:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  814f44:	e0bfff17 	ldw	r2,-4(fp)
  814f48:	1082000c 	andi	r2,r2,2048
  814f4c:	1004c03a 	cmpne	r2,r2,zero
  814f50:	1000061e 	bne	r2,zero,814f6c <altera_avalon_uart_txirq+0x100>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  814f54:	e0bffe17 	ldw	r2,-8(fp)
  814f58:	10c00117 	ldw	r3,4(r2)
  814f5c:	00bfefc4 	movi	r2,-65
  814f60:	1886703a 	and	r3,r3,r2
  814f64:	e0bffe17 	ldw	r2,-8(fp)
  814f68:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  814f6c:	e0bffe17 	ldw	r2,-8(fp)
  814f70:	10c00417 	ldw	r3,16(r2)
  814f74:	e0bffe17 	ldw	r2,-8(fp)
  814f78:	10800517 	ldw	r2,20(r2)
  814f7c:	1880061e 	bne	r3,r2,814f98 <altera_avalon_uart_txirq+0x12c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  814f80:	e0bffe17 	ldw	r2,-8(fp)
  814f84:	10c00117 	ldw	r3,4(r2)
  814f88:	00beefc4 	movi	r2,-1089
  814f8c:	1886703a 	and	r3,r3,r2
  814f90:	e0bffe17 	ldw	r2,-8(fp)
  814f94:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  814f98:	e0bffe17 	ldw	r2,-8(fp)
  814f9c:	10800017 	ldw	r2,0(r2)
  814fa0:	11000304 	addi	r4,r2,12
  814fa4:	e0bffe17 	ldw	r2,-8(fp)
  814fa8:	10800117 	ldw	r2,4(r2)
  814fac:	1007883a 	mov	r3,r2
  814fb0:	2005883a 	mov	r2,r4
  814fb4:	10c00035 	stwio	r3,0(r2)
}
  814fb8:	e037883a 	mov	sp,fp
  814fbc:	df000017 	ldw	fp,0(sp)
  814fc0:	dec00104 	addi	sp,sp,4
  814fc4:	f800283a 	ret

00814fc8 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  814fc8:	defffc04 	addi	sp,sp,-16
  814fcc:	df000315 	stw	fp,12(sp)
  814fd0:	df000304 	addi	fp,sp,12
  814fd4:	e13ffd15 	stw	r4,-12(fp)
  814fd8:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  814fdc:	00000706 	br	814ffc <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
  814fe0:	e0bffe17 	ldw	r2,-8(fp)
  814fe4:	1090000c 	andi	r2,r2,16384
  814fe8:	1005003a 	cmpeq	r2,r2,zero
  814fec:	1000031e 	bne	r2,zero,814ffc <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
  814ff0:	00bffd44 	movi	r2,-11
  814ff4:	e0bfff15 	stw	r2,-4(fp)
  814ff8:	00000606 	br	815014 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  814ffc:	e0bffd17 	ldw	r2,-12(fp)
  815000:	10c00417 	ldw	r3,16(r2)
  815004:	e0bffd17 	ldw	r2,-12(fp)
  815008:	10800517 	ldw	r2,20(r2)
  81500c:	18bff41e 	bne	r3,r2,814fe0 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  815010:	e03fff15 	stw	zero,-4(fp)
  815014:	e0bfff17 	ldw	r2,-4(fp)
}
  815018:	e037883a 	mov	sp,fp
  81501c:	df000017 	ldw	fp,0(sp)
  815020:	dec00104 	addi	sp,sp,4
  815024:	f800283a 	ret

00815028 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  815028:	defff004 	addi	sp,sp,-64
  81502c:	dfc00f15 	stw	ra,60(sp)
  815030:	df000e15 	stw	fp,56(sp)
  815034:	df000e04 	addi	fp,sp,56
  815038:	e13ffb15 	stw	r4,-20(fp)
  81503c:	e17ffc15 	stw	r5,-16(fp)
  815040:	e1bffd15 	stw	r6,-12(fp)
  815044:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
  815048:	e03ff705 	stb	zero,-36(fp)
  int             count = 0;
  81504c:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  815050:	e0bffe17 	ldw	r2,-8(fp)
  815054:	1090000c 	andi	r2,r2,16384
  815058:	1005003a 	cmpeq	r2,r2,zero
  81505c:	e0bff915 	stw	r2,-28(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
  815060:	e0bffb17 	ldw	r2,-20(fp)
  815064:	10800217 	ldw	r2,8(r2)
  815068:	10800044 	addi	r2,r2,1
  81506c:	10800fcc 	andi	r2,r2,63
  815070:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  815074:	00001906 	br	8150dc <altera_avalon_uart_read+0xb4>
    {
      count++;
  815078:	e0bff617 	ldw	r2,-40(fp)
  81507c:	10800044 	addi	r2,r2,1
  815080:	e0bff615 	stw	r2,-40(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  815084:	e0bffb17 	ldw	r2,-20(fp)
  815088:	10c00217 	ldw	r3,8(r2)
  81508c:	e0bffb17 	ldw	r2,-20(fp)
  815090:	1885883a 	add	r2,r3,r2
  815094:	10800704 	addi	r2,r2,28
  815098:	10800003 	ldbu	r2,0(r2)
  81509c:	1007883a 	mov	r3,r2
  8150a0:	e0bffc17 	ldw	r2,-16(fp)
  8150a4:	10c00005 	stb	r3,0(r2)
  8150a8:	e0bffc17 	ldw	r2,-16(fp)
  8150ac:	10800044 	addi	r2,r2,1
  8150b0:	e0bffc15 	stw	r2,-16(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
  8150b4:	e0bffb17 	ldw	r2,-20(fp)
  8150b8:	10800217 	ldw	r2,8(r2)
  8150bc:	10c00044 	addi	r3,r2,1
  8150c0:	e0bffb17 	ldw	r2,-20(fp)
  8150c4:	10c00215 	stw	r3,8(r2)
  8150c8:	e0bffb17 	ldw	r2,-20(fp)
  8150cc:	10800217 	ldw	r2,8(r2)
  8150d0:	10c00fcc 	andi	r3,r2,63
  8150d4:	e0bffb17 	ldw	r2,-20(fp)
  8150d8:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  8150dc:	e0fff617 	ldw	r3,-40(fp)
  8150e0:	e0bffd17 	ldw	r2,-12(fp)
  8150e4:	1880050e 	bge	r3,r2,8150fc <altera_avalon_uart_read+0xd4>
  8150e8:	e0bffb17 	ldw	r2,-20(fp)
  8150ec:	10c00217 	ldw	r3,8(r2)
  8150f0:	e0bffb17 	ldw	r2,-20(fp)
  8150f4:	10800317 	ldw	r2,12(r2)
  8150f8:	18bfdf1e 	bne	r3,r2,815078 <altera_avalon_uart_read+0x50>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  8150fc:	e0bff617 	ldw	r2,-40(fp)
  815100:	1004c03a 	cmpne	r2,r2,zero
  815104:	1000271e 	bne	r2,zero,8151a4 <altera_avalon_uart_read+0x17c>
  815108:	e0bffb17 	ldw	r2,-20(fp)
  81510c:	10c00217 	ldw	r3,8(r2)
  815110:	e0bffb17 	ldw	r2,-20(fp)
  815114:	10800317 	ldw	r2,12(r2)
  815118:	1880221e 	bne	r3,r2,8151a4 <altera_avalon_uart_read+0x17c>
    {
      if (!block)
  81511c:	e0bff917 	ldw	r2,-28(fp)
  815120:	1004c03a 	cmpne	r2,r2,zero
  815124:	1000061e 	bne	r2,zero,815140 <altera_avalon_uart_read+0x118>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  815128:	08152580 	call	815258 <alt_get_errno>
  81512c:	00c002c4 	movi	r3,11
  815130:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
  815134:	00800044 	movi	r2,1
  815138:	e0bff705 	stb	r2,-36(fp)
        break;
  81513c:	00001f06 	br	8151bc <altera_avalon_uart_read+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  815140:	0005303a 	rdctl	r2,status
  815144:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  815148:	e0fff517 	ldw	r3,-44(fp)
  81514c:	00bfff84 	movi	r2,-2
  815150:	1884703a 	and	r2,r3,r2
  815154:	1001703a 	wrctl	status,r2
  
  return context;
  815158:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  81515c:	e0bffa15 	stw	r2,-24(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  815160:	e0bffb17 	ldw	r2,-20(fp)
  815164:	10800117 	ldw	r2,4(r2)
  815168:	10c02014 	ori	r3,r2,128
  81516c:	e0bffb17 	ldw	r2,-20(fp)
  815170:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  815174:	e0bffb17 	ldw	r2,-20(fp)
  815178:	10800017 	ldw	r2,0(r2)
  81517c:	11000304 	addi	r4,r2,12
  815180:	e0bffb17 	ldw	r2,-20(fp)
  815184:	10800117 	ldw	r2,4(r2)
  815188:	1007883a 	mov	r3,r2
  81518c:	2005883a 	mov	r2,r4
  815190:	10c00035 	stwio	r3,0(r2)
  815194:	e0bffa17 	ldw	r2,-24(fp)
  815198:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  81519c:	e0bff417 	ldw	r2,-48(fp)
  8151a0:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  8151a4:	e0bff617 	ldw	r2,-40(fp)
  8151a8:	1004c03a 	cmpne	r2,r2,zero
  8151ac:	1000031e 	bne	r2,zero,8151bc <altera_avalon_uart_read+0x194>
  8151b0:	e0bffd17 	ldw	r2,-12(fp)
  8151b4:	1004c03a 	cmpne	r2,r2,zero
  8151b8:	103fc81e 	bne	r2,zero,8150dc <altera_avalon_uart_read+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8151bc:	0005303a 	rdctl	r2,status
  8151c0:	e0bff315 	stw	r2,-52(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8151c4:	e0fff317 	ldw	r3,-52(fp)
  8151c8:	00bfff84 	movi	r2,-2
  8151cc:	1884703a 	and	r2,r3,r2
  8151d0:	1001703a 	wrctl	status,r2
  
  return context;
  8151d4:	e0bff317 	ldw	r2,-52(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  8151d8:	e0bffa15 	stw	r2,-24(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  8151dc:	e0bffb17 	ldw	r2,-20(fp)
  8151e0:	10800117 	ldw	r2,4(r2)
  8151e4:	10c02014 	ori	r3,r2,128
  8151e8:	e0bffb17 	ldw	r2,-20(fp)
  8151ec:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  8151f0:	e0bffb17 	ldw	r2,-20(fp)
  8151f4:	10800017 	ldw	r2,0(r2)
  8151f8:	11000304 	addi	r4,r2,12
  8151fc:	e0bffb17 	ldw	r2,-20(fp)
  815200:	10800117 	ldw	r2,4(r2)
  815204:	1007883a 	mov	r3,r2
  815208:	2005883a 	mov	r2,r4
  81520c:	10c00035 	stwio	r3,0(r2)
  815210:	e0bffa17 	ldw	r2,-24(fp)
  815214:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815218:	e0bff217 	ldw	r2,-56(fp)
  81521c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  815220:	e0bff703 	ldbu	r2,-36(fp)
  815224:	1005003a 	cmpeq	r2,r2,zero
  815228:	1000031e 	bne	r2,zero,815238 <altera_avalon_uart_read+0x210>
    return ~EWOULDBLOCK;
  81522c:	00bffd04 	movi	r2,-12
  815230:	e0bfff15 	stw	r2,-4(fp)
  815234:	00000206 	br	815240 <altera_avalon_uart_read+0x218>
  }
  else {
    return count;
  815238:	e0bff617 	ldw	r2,-40(fp)
  81523c:	e0bfff15 	stw	r2,-4(fp)
  815240:	e0bfff17 	ldw	r2,-4(fp)
  }
}
  815244:	e037883a 	mov	sp,fp
  815248:	dfc00117 	ldw	ra,4(sp)
  81524c:	df000017 	ldw	fp,0(sp)
  815250:	dec00204 	addi	sp,sp,8
  815254:	f800283a 	ret

00815258 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  815258:	defffd04 	addi	sp,sp,-12
  81525c:	dfc00215 	stw	ra,8(sp)
  815260:	df000115 	stw	fp,4(sp)
  815264:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  815268:	008020b4 	movhi	r2,130
  81526c:	10a93c04 	addi	r2,r2,-23312
  815270:	10800017 	ldw	r2,0(r2)
  815274:	1005003a 	cmpeq	r2,r2,zero
  815278:	1000061e 	bne	r2,zero,815294 <alt_get_errno+0x3c>
  81527c:	008020b4 	movhi	r2,130
  815280:	10a93c04 	addi	r2,r2,-23312
  815284:	10800017 	ldw	r2,0(r2)
  815288:	103ee83a 	callr	r2
  81528c:	e0bfff15 	stw	r2,-4(fp)
  815290:	00000306 	br	8152a0 <alt_get_errno+0x48>
  815294:	008020b4 	movhi	r2,130
  815298:	10b02404 	addi	r2,r2,-16240
  81529c:	e0bfff15 	stw	r2,-4(fp)
  8152a0:	e0bfff17 	ldw	r2,-4(fp)
}
  8152a4:	e037883a 	mov	sp,fp
  8152a8:	dfc00117 	ldw	ra,4(sp)
  8152ac:	df000017 	ldw	fp,0(sp)
  8152b0:	dec00204 	addi	sp,sp,8
  8152b4:	f800283a 	ret

008152b8 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  8152b8:	defff204 	addi	sp,sp,-56
  8152bc:	dfc00d15 	stw	ra,52(sp)
  8152c0:	df000c15 	stw	fp,48(sp)
  8152c4:	df000c04 	addi	fp,sp,48
  8152c8:	e13ffc15 	stw	r4,-16(fp)
  8152cc:	e17ffd15 	stw	r5,-12(fp)
  8152d0:	e1bffe15 	stw	r6,-8(fp)
  8152d4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  8152d8:	e0bffe17 	ldw	r2,-8(fp)
  8152dc:	e0bff815 	stw	r2,-32(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  8152e0:	e0bfff17 	ldw	r2,-4(fp)
  8152e4:	1090000c 	andi	r2,r2,16384
  8152e8:	e0bffa15 	stw	r2,-24(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  8152ec:	00004006 	br	8153f0 <altera_avalon_uart_write+0x138>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  8152f0:	e0bffc17 	ldw	r2,-16(fp)
  8152f4:	10800517 	ldw	r2,20(r2)
  8152f8:	10800044 	addi	r2,r2,1
  8152fc:	10800fcc 	andi	r2,r2,63
  815300:	e0bff915 	stw	r2,-28(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  815304:	e0bffc17 	ldw	r2,-16(fp)
  815308:	10c00417 	ldw	r3,16(r2)
  81530c:	e0bff917 	ldw	r2,-28(fp)
  815310:	1880251e 	bne	r3,r2,8153a8 <altera_avalon_uart_write+0xf0>
    {
      if (no_block)
  815314:	e0bffa17 	ldw	r2,-24(fp)
  815318:	1005003a 	cmpeq	r2,r2,zero
  81531c:	1000051e 	bne	r2,zero,815334 <altera_avalon_uart_write+0x7c>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  815320:	08154800 	call	815480 <alt_get_errno>
  815324:	1007883a 	mov	r3,r2
  815328:	008002c4 	movi	r2,11
  81532c:	18800015 	stw	r2,0(r3)
        break;
  815330:	00003206 	br	8153fc <altera_avalon_uart_write+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  815334:	0005303a 	rdctl	r2,status
  815338:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  81533c:	e0fff717 	ldw	r3,-36(fp)
  815340:	00bfff84 	movi	r2,-2
  815344:	1884703a 	and	r2,r3,r2
  815348:	1001703a 	wrctl	status,r2
  
  return context;
  81534c:	e0bff717 	ldw	r2,-36(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  815350:	e0bffb15 	stw	r2,-20(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  815354:	e0bffc17 	ldw	r2,-16(fp)
  815358:	10800117 	ldw	r2,4(r2)
  81535c:	10c11014 	ori	r3,r2,1088
  815360:	e0bffc17 	ldw	r2,-16(fp)
  815364:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  815368:	e0bffc17 	ldw	r2,-16(fp)
  81536c:	10800017 	ldw	r2,0(r2)
  815370:	11000304 	addi	r4,r2,12
  815374:	e0bffc17 	ldw	r2,-16(fp)
  815378:	10800117 	ldw	r2,4(r2)
  81537c:	1007883a 	mov	r3,r2
  815380:	2005883a 	mov	r2,r4
  815384:	10c00035 	stwio	r3,0(r2)
  815388:	e0bffb17 	ldw	r2,-20(fp)
  81538c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815390:	e0bff617 	ldw	r2,-40(fp)
  815394:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  815398:	e0bffc17 	ldw	r2,-16(fp)
  81539c:	10c00417 	ldw	r3,16(r2)
  8153a0:	e0bff917 	ldw	r2,-28(fp)
  8153a4:	18bffc26 	beq	r3,r2,815398 <altera_avalon_uart_write+0xe0>
      }
    }

    count--;
  8153a8:	e0bff817 	ldw	r2,-32(fp)
  8153ac:	10bfffc4 	addi	r2,r2,-1
  8153b0:	e0bff815 	stw	r2,-32(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  8153b4:	e0bffc17 	ldw	r2,-16(fp)
  8153b8:	10c00517 	ldw	r3,20(r2)
  8153bc:	e0bffd17 	ldw	r2,-12(fp)
  8153c0:	10800003 	ldbu	r2,0(r2)
  8153c4:	1009883a 	mov	r4,r2
  8153c8:	e0bffc17 	ldw	r2,-16(fp)
  8153cc:	1885883a 	add	r2,r3,r2
  8153d0:	10801704 	addi	r2,r2,92
  8153d4:	11000005 	stb	r4,0(r2)
  8153d8:	e0bffd17 	ldw	r2,-12(fp)
  8153dc:	10800044 	addi	r2,r2,1
  8153e0:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
  8153e4:	e0fffc17 	ldw	r3,-16(fp)
  8153e8:	e0bff917 	ldw	r2,-28(fp)
  8153ec:	18800515 	stw	r2,20(r3)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  8153f0:	e0bff817 	ldw	r2,-32(fp)
  8153f4:	1004c03a 	cmpne	r2,r2,zero
  8153f8:	103fbd1e 	bne	r2,zero,8152f0 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8153fc:	0005303a 	rdctl	r2,status
  815400:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  815404:	e0fff517 	ldw	r3,-44(fp)
  815408:	00bfff84 	movi	r2,-2
  81540c:	1884703a 	and	r2,r3,r2
  815410:	1001703a 	wrctl	status,r2
  
  return context;
  815414:	e0bff517 	ldw	r2,-44(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  815418:	e0bffb15 	stw	r2,-20(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  81541c:	e0bffc17 	ldw	r2,-16(fp)
  815420:	10800117 	ldw	r2,4(r2)
  815424:	10c11014 	ori	r3,r2,1088
  815428:	e0bffc17 	ldw	r2,-16(fp)
  81542c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  815430:	e0bffc17 	ldw	r2,-16(fp)
  815434:	10800017 	ldw	r2,0(r2)
  815438:	11000304 	addi	r4,r2,12
  81543c:	e0bffc17 	ldw	r2,-16(fp)
  815440:	10800117 	ldw	r2,4(r2)
  815444:	1007883a 	mov	r3,r2
  815448:	2005883a 	mov	r2,r4
  81544c:	10c00035 	stwio	r3,0(r2)
  815450:	e0bffb17 	ldw	r2,-20(fp)
  815454:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815458:	e0bff417 	ldw	r2,-48(fp)
  81545c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  815460:	e0fffe17 	ldw	r3,-8(fp)
  815464:	e0bff817 	ldw	r2,-32(fp)
  815468:	1885c83a 	sub	r2,r3,r2
}
  81546c:	e037883a 	mov	sp,fp
  815470:	dfc00117 	ldw	ra,4(sp)
  815474:	df000017 	ldw	fp,0(sp)
  815478:	dec00204 	addi	sp,sp,8
  81547c:	f800283a 	ret

00815480 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  815480:	defffd04 	addi	sp,sp,-12
  815484:	dfc00215 	stw	ra,8(sp)
  815488:	df000115 	stw	fp,4(sp)
  81548c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  815490:	008020b4 	movhi	r2,130
  815494:	10a93c04 	addi	r2,r2,-23312
  815498:	10800017 	ldw	r2,0(r2)
  81549c:	1005003a 	cmpeq	r2,r2,zero
  8154a0:	1000061e 	bne	r2,zero,8154bc <alt_get_errno+0x3c>
  8154a4:	008020b4 	movhi	r2,130
  8154a8:	10a93c04 	addi	r2,r2,-23312
  8154ac:	10800017 	ldw	r2,0(r2)
  8154b0:	103ee83a 	callr	r2
  8154b4:	e0bfff15 	stw	r2,-4(fp)
  8154b8:	00000306 	br	8154c8 <alt_get_errno+0x48>
  8154bc:	008020b4 	movhi	r2,130
  8154c0:	10b02404 	addi	r2,r2,-16240
  8154c4:	e0bfff15 	stw	r2,-4(fp)
  8154c8:	e0bfff17 	ldw	r2,-4(fp)
}
  8154cc:	e037883a 	mov	sp,fp
  8154d0:	dfc00117 	ldw	ra,4(sp)
  8154d4:	df000017 	ldw	fp,0(sp)
  8154d8:	dec00204 	addi	sp,sp,8
  8154dc:	f800283a 	ret

008154e0 <perf_print_formatted_report>:

#ifndef SMALL_C_LIB 
int perf_print_formatted_report (void* perf_base, 
                                 alt_u32 clock_freq_hertz,
                                 int num_sections, ...)
{
  8154e0:	deffe504 	addi	sp,sp,-108
  8154e4:	dfc01915 	stw	ra,100(sp)
  8154e8:	df001815 	stw	fp,96(sp)
  8154ec:	dcc01715 	stw	r19,92(sp)
  8154f0:	dc801615 	stw	r18,88(sp)
  8154f4:	dc401515 	stw	r17,84(sp)
  8154f8:	dc001415 	stw	r16,80(sp)
  8154fc:	df001404 	addi	fp,sp,80
  815500:	e13ffd15 	stw	r4,-12(fp)
  815504:	e17ffe15 	stw	r5,-8(fp)
  815508:	e1c00615 	stw	r7,24(fp)
  81550c:	e1bfff15 	stw	r6,-4(fp)
  va_list name_args;
  double total_sec;
  alt_u64 total_clocks;
  alt_u64 section_clocks;
  char* section_name;
  int section_num = 1;
  815510:	00800044 	movi	r2,1
  815514:	e0bff415 	stw	r2,-48(fp)

  const char* separator = 
    "+---------------+-----+-----------+---------------+-----------+\n";
  815518:	008020b4 	movhi	r2,130
  81551c:	10a22a04 	addi	r2,r2,-30552
  815520:	e0bff315 	stw	r2,-52(fp)
  const char* column_header = 
    "| Section       |  %  | Time (sec)|  Time (clocks)|Occurrences|\n";
  815524:	008020b4 	movhi	r2,130
  815528:	10a23b04 	addi	r2,r2,-30484
  81552c:	e0bff215 	stw	r2,-56(fp)

  PERF_STOP_MEASURING (perf_base);
  815530:	e0bffd17 	ldw	r2,-12(fp)
  815534:	10000035 	stwio	zero,0(r2)

  va_start (name_args, num_sections);
  815538:	e0800604 	addi	r2,fp,24
  81553c:	e0bffc15 	stw	r2,-16(fp)

  total_clocks = perf_get_total_time (perf_base);
  815540:	e13ffd17 	ldw	r4,-12(fp)
  815544:	08149580 	call	814958 <perf_get_total_time>
  815548:	1009883a 	mov	r4,r2
  81554c:	180b883a 	mov	r5,r3
  815550:	e13ff815 	stw	r4,-32(fp)
  815554:	e17ff915 	stw	r5,-28(fp)
  total_sec    = ((double)total_clocks) / clock_freq_hertz;
  815558:	e13ff817 	ldw	r4,-32(fp)
  81555c:	e17ff917 	ldw	r5,-28(fp)
  815560:	08172cc0 	call	8172cc <__floatundidf>
  815564:	1021883a 	mov	r16,r2
  815568:	1823883a 	mov	r17,r3
  81556c:	e13ffe17 	ldw	r4,-8(fp)
  815570:	080f5fc0 	call	80f5fc <__floatunsidf>
  815574:	100f883a 	mov	r7,r2
  815578:	1811883a 	mov	r8,r3
  81557c:	8009883a 	mov	r4,r16
  815580:	880b883a 	mov	r5,r17
  815584:	380d883a 	mov	r6,r7
  815588:	400f883a 	mov	r7,r8
  81558c:	080ef2c0 	call	80ef2c <__divdf3>
  815590:	1009883a 	mov	r4,r2
  815594:	180b883a 	mov	r5,r3
  815598:	e13ffa15 	stw	r4,-24(fp)
  81559c:	e17ffb15 	stw	r5,-20(fp)

  // Print the total at the top:
  printf ("--Performance Counter Report--\nTotal Time: %3G seconds  (%lld clock-cycles)\n%s%s%s",
  8155a0:	e0bff317 	ldw	r2,-52(fp)
  8155a4:	d8800115 	stw	r2,4(sp)
  8155a8:	e0bff217 	ldw	r2,-56(fp)
  8155ac:	d8800215 	stw	r2,8(sp)
  8155b0:	e0bff317 	ldw	r2,-52(fp)
  8155b4:	d8800315 	stw	r2,12(sp)
  8155b8:	e0bff917 	ldw	r2,-28(fp)
  8155bc:	d8800015 	stw	r2,0(sp)
  8155c0:	e1fff817 	ldw	r7,-32(fp)
  8155c4:	010020b4 	movhi	r4,130
  8155c8:	21224c04 	addi	r4,r4,-30416
  8155cc:	e17ffa17 	ldw	r5,-24(fp)
  8155d0:	e1bffb17 	ldw	r6,-20(fp)
  8155d4:	08064bc0 	call	8064bc <printf>
          total_sec, total_clocks, separator, column_header, separator);

  section_name = va_arg(name_args, char*);
  8155d8:	e0fffc17 	ldw	r3,-16(fp)
  8155dc:	18800104 	addi	r2,r3,4
  8155e0:	e0bffc15 	stw	r2,-16(fp)
  8155e4:	1805883a 	mov	r2,r3
  8155e8:	10800017 	ldw	r2,0(r2)
  8155ec:	e0bff515 	stw	r2,-44(fp)

  for (section_num = 1; section_num <= num_sections; section_num++)
  8155f0:	00800044 	movi	r2,1
  8155f4:	e0bff415 	stw	r2,-48(fp)
  8155f8:	00005106 	br	815740 <perf_print_formatted_report+0x260>
    {
      section_clocks = perf_get_section_time (perf_base, section_num);
  8155fc:	e13ffd17 	ldw	r4,-12(fp)
  815600:	e17ff417 	ldw	r5,-48(fp)
  815604:	08148a80 	call	8148a8 <perf_get_section_time>
  815608:	1009883a 	mov	r4,r2
  81560c:	180b883a 	mov	r5,r3
  815610:	e13ff615 	stw	r4,-40(fp)
  815614:	e17ff715 	stw	r5,-36(fp)

      printf ("|%-15s|%5.3g|%11.5f|%15lld|%11u|\n%s",
  815618:	e13ff617 	ldw	r4,-40(fp)
  81561c:	e17ff717 	ldw	r5,-36(fp)
  815620:	08172cc0 	call	8172cc <__floatundidf>
  815624:	100b883a 	mov	r5,r2
  815628:	180d883a 	mov	r6,r3
  81562c:	2809883a 	mov	r4,r5
  815630:	300b883a 	mov	r5,r6
  815634:	000d883a 	mov	r6,zero
  815638:	01d01674 	movhi	r7,16473
  81563c:	080eb680 	call	80eb68 <__muldf3>
  815640:	1009883a 	mov	r4,r2
  815644:	180b883a 	mov	r5,r3
  815648:	2021883a 	mov	r16,r4
  81564c:	2823883a 	mov	r17,r5
  815650:	e13ff817 	ldw	r4,-32(fp)
  815654:	e17ff917 	ldw	r5,-28(fp)
  815658:	08172cc0 	call	8172cc <__floatundidf>
  81565c:	100f883a 	mov	r7,r2
  815660:	1811883a 	mov	r8,r3
  815664:	8009883a 	mov	r4,r16
  815668:	880b883a 	mov	r5,r17
  81566c:	380d883a 	mov	r6,r7
  815670:	400f883a 	mov	r7,r8
  815674:	080ef2c0 	call	80ef2c <__divdf3>
  815678:	1009883a 	mov	r4,r2
  81567c:	180b883a 	mov	r5,r3
  815680:	2025883a 	mov	r18,r4
  815684:	2827883a 	mov	r19,r5
  815688:	e13ff617 	ldw	r4,-40(fp)
  81568c:	e17ff717 	ldw	r5,-36(fp)
  815690:	08172cc0 	call	8172cc <__floatundidf>
  815694:	1021883a 	mov	r16,r2
  815698:	1823883a 	mov	r17,r3
  81569c:	e13ffe17 	ldw	r4,-8(fp)
  8156a0:	080f5fc0 	call	80f5fc <__floatunsidf>
  8156a4:	100f883a 	mov	r7,r2
  8156a8:	1811883a 	mov	r8,r3
  8156ac:	8009883a 	mov	r4,r16
  8156b0:	880b883a 	mov	r5,r17
  8156b4:	380d883a 	mov	r6,r7
  8156b8:	400f883a 	mov	r7,r8
  8156bc:	080ef2c0 	call	80ef2c <__divdf3>
  8156c0:	1009883a 	mov	r4,r2
  8156c4:	180b883a 	mov	r5,r3
  8156c8:	2021883a 	mov	r16,r4
  8156cc:	2823883a 	mov	r17,r5
  8156d0:	e13ffd17 	ldw	r4,-12(fp)
  8156d4:	e17ff417 	ldw	r5,-48(fp)
  8156d8:	08149ac0 	call	8149ac <perf_get_num_starts>
  8156dc:	1007883a 	mov	r3,r2
  8156e0:	dc000015 	stw	r16,0(sp)
  8156e4:	dc400115 	stw	r17,4(sp)
  8156e8:	e0bff617 	ldw	r2,-40(fp)
  8156ec:	d8800215 	stw	r2,8(sp)
  8156f0:	e0bff717 	ldw	r2,-36(fp)
  8156f4:	d8800315 	stw	r2,12(sp)
  8156f8:	d8c00415 	stw	r3,16(sp)
  8156fc:	e0bff317 	ldw	r2,-52(fp)
  815700:	d8800515 	stw	r2,20(sp)
  815704:	010020b4 	movhi	r4,130
  815708:	21226104 	addi	r4,r4,-30332
  81570c:	e17ff517 	ldw	r5,-44(fp)
  815710:	900d883a 	mov	r6,r18
  815714:	980f883a 	mov	r7,r19
  815718:	08064bc0 	call	8064bc <printf>
              section_clocks,
              (unsigned int) perf_get_num_starts (perf_base, section_num),
              separator
              );

      section_name = va_arg(name_args, char*);
  81571c:	e0fffc17 	ldw	r3,-16(fp)
  815720:	18800104 	addi	r2,r3,4
  815724:	e0bffc15 	stw	r2,-16(fp)
  815728:	1805883a 	mov	r2,r3
  81572c:	10800017 	ldw	r2,0(r2)
  815730:	e0bff515 	stw	r2,-44(fp)
  printf ("--Performance Counter Report--\nTotal Time: %3G seconds  (%lld clock-cycles)\n%s%s%s",
          total_sec, total_clocks, separator, column_header, separator);

  section_name = va_arg(name_args, char*);

  for (section_num = 1; section_num <= num_sections; section_num++)
  815734:	e0bff417 	ldw	r2,-48(fp)
  815738:	10800044 	addi	r2,r2,1
  81573c:	e0bff415 	stw	r2,-48(fp)
  815740:	e0fff417 	ldw	r3,-48(fp)
  815744:	e0bfff17 	ldw	r2,-4(fp)
  815748:	10ffac0e 	bge	r2,r3,8155fc <perf_print_formatted_report+0x11c>
      section_name = va_arg(name_args, char*);
    }

  va_end (name_args);

  return 0;
  81574c:	0005883a 	mov	r2,zero
}
  815750:	e037883a 	mov	sp,fp
  815754:	dfc00517 	ldw	ra,20(sp)
  815758:	df000417 	ldw	fp,16(sp)
  81575c:	dcc00317 	ldw	r19,12(sp)
  815760:	dc800217 	ldw	r18,8(sp)
  815764:	dc400117 	ldw	r17,4(sp)
  815768:	dc000017 	ldw	r16,0(sp)
  81576c:	dec00704 	addi	sp,sp,28
  815770:	f800283a 	ret

00815774 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {
  815774:	defffe04 	addi	sp,sp,-8
  815778:	df000115 	stw	fp,4(sp)
  81577c:	df000104 	addi	fp,sp,4
  815780:	e13fff15 	stw	r4,-4(fp)

  (void)p;
  chRegSetThreadName("idle");
  815784:	00802134 	movhi	r2,132
  815788:	10ba9c04 	addi	r2,r2,-5520
  81578c:	10c00717 	ldw	r3,28(r2)
  815790:	008020b4 	movhi	r2,130
  815794:	10a26a04 	addi	r2,r2,-30296
  815798:	18800615 	stw	r2,24(r3)
  while (TRUE) {
    port_wait_for_interrupt();
  81579c:	0001883a 	nop
    IDLE_LOOP_HOOK();
  }
  8157a0:	003ffe06 	br	81579c <_idle_thread+0x28>

008157a4 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
  8157a4:	defffc04 	addi	sp,sp,-16
  8157a8:	dfc00315 	stw	ra,12(sp)
  8157ac:	df000215 	stw	fp,8(sp)
  8157b0:	df000204 	addi	fp,sp,8
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
  8157b4:	0811e340 	call	811e34 <_scheduler_init>
  _vt_init();
  8157b8:	0812bd40 	call	812bd4 <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
  8157bc:	08110e00 	call	8110e0 <_core_init>
#endif
#if CH_USE_HEAP
  _heap_init();
  8157c0:	0810bf40 	call	810bf4 <_heap_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
  8157c4:	010020f4 	movhi	r4,131
  8157c8:	2139e404 	addi	r4,r4,-6256
  8157cc:	01401004 	movi	r5,64
  8157d0:	08123f00 	call	8123f0 <_thread_init>
  8157d4:	1007883a 	mov	r3,r2
  8157d8:	00802134 	movhi	r2,132
  8157dc:	10ba9c04 	addi	r2,r2,-5520
  8157e0:	10c00715 	stw	r3,28(r2)
  currp->p_state = THD_STATE_CURRENT;
  8157e4:	00802134 	movhi	r2,132
  8157e8:	10ba9c04 	addi	r2,r2,-5520
  8157ec:	10c00717 	ldw	r3,28(r2)
  8157f0:	00800044 	movi	r2,1
  8157f4:	18800705 	stb	r2,28(r3)
  8157f8:	00800044 	movi	r2,1
  8157fc:	e0bfff15 	stw	r2,-4(fp)
  815800:	e0bfff17 	ldw	r2,-4(fp)
  815804:	1001703a 	wrctl	status,r2
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();

  chRegSetThreadName("main");
  815808:	00802134 	movhi	r2,132
  81580c:	10ba9c04 	addi	r2,r2,-5520
  815810:	10c00717 	ldw	r3,28(r2)
  815814:	008020b4 	movhi	r2,130
  815818:	10a26c04 	addi	r2,r2,-30288
  81581c:	18800615 	stw	r2,24(r3)

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
  815820:	01c02074 	movhi	r7,129
  815824:	39d5dd04 	addi	r7,r7,22388
  815828:	d8000015 	stw	zero,0(sp)
  81582c:	01002134 	movhi	r4,132
  815830:	213aa804 	addi	r4,r4,-5472
  815834:	01407004 	movi	r5,448
  815838:	01800044 	movi	r6,1
  81583c:	081264c0 	call	81264c <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
  815840:	e037883a 	mov	sp,fp
  815844:	dfc00117 	ldw	ra,4(sp)
  815848:	df000017 	ldw	fp,0(sp)
  81584c:	dec00204 	addi	sp,sp,8
  815850:	f800283a 	ret

00815854 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
  815854:	defffc04 	addi	sp,sp,-16
  815858:	dfc00315 	stw	ra,12(sp)
  81585c:	df000215 	stw	fp,8(sp)
  815860:	df000204 	addi	fp,sp,8

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (rlist.r_preempt > 0)
  815864:	00802134 	movhi	r2,132
  815868:	10ba9c04 	addi	r2,r2,-5520
  81586c:	10800617 	ldw	r2,24(r2)
  815870:	10800050 	cmplti	r2,r2,1
  815874:	1000071e 	bne	r2,zero,815894 <chSysTimerHandlerI+0x40>
    /* Decrement remaining quantum.*/
    rlist.r_preempt--;
  815878:	00802134 	movhi	r2,132
  81587c:	10ba9c04 	addi	r2,r2,-5520
  815880:	10800617 	ldw	r2,24(r2)
  815884:	10ffffc4 	addi	r3,r2,-1
  815888:	00802134 	movhi	r2,132
  81588c:	10ba9c04 	addi	r2,r2,-5520
  815890:	10c00615 	stw	r3,24(r2)
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
  815894:	00802134 	movhi	r2,132
  815898:	10ba9c04 	addi	r2,r2,-5520
  81589c:	10c00717 	ldw	r3,28(r2)
  8158a0:	18800817 	ldw	r2,32(r3)
  8158a4:	10800044 	addi	r2,r2,1
  8158a8:	18800815 	stw	r2,32(r3)
#endif
  chVTDoTickI();
  8158ac:	00802134 	movhi	r2,132
  8158b0:	10baa404 	addi	r2,r2,-5488
  8158b4:	10800317 	ldw	r2,12(r2)
  8158b8:	10c00044 	addi	r3,r2,1
  8158bc:	00802134 	movhi	r2,132
  8158c0:	10baa404 	addi	r2,r2,-5488
  8158c4:	10c00315 	stw	r3,12(r2)
  8158c8:	00802134 	movhi	r2,132
  8158cc:	10baa404 	addi	r2,r2,-5488
  8158d0:	10800017 	ldw	r2,0(r2)
  8158d4:	1007883a 	mov	r3,r2
  8158d8:	00802134 	movhi	r2,132
  8158dc:	10baa404 	addi	r2,r2,-5488
  8158e0:	18802226 	beq	r3,r2,81596c <chSysTimerHandlerI+0x118>
  8158e4:	00802134 	movhi	r2,132
  8158e8:	10baa404 	addi	r2,r2,-5488
  8158ec:	10c00017 	ldw	r3,0(r2)
  8158f0:	18800217 	ldw	r2,8(r3)
  8158f4:	10bfffc4 	addi	r2,r2,-1
  8158f8:	18800215 	stw	r2,8(r3)
  8158fc:	00001306 	br	81594c <chSysTimerHandlerI+0xf8>
  815900:	e0bfff17 	ldw	r2,-4(fp)
  815904:	10800317 	ldw	r2,12(r2)
  815908:	e0bffe15 	stw	r2,-8(fp)
  81590c:	e0bfff17 	ldw	r2,-4(fp)
  815910:	10000315 	stw	zero,12(r2)
  815914:	e0bfff17 	ldw	r2,-4(fp)
  815918:	10c00017 	ldw	r3,0(r2)
  81591c:	00802134 	movhi	r2,132
  815920:	10baa404 	addi	r2,r2,-5488
  815924:	18800115 	stw	r2,4(r3)
  815928:	e0bfff17 	ldw	r2,-4(fp)
  81592c:	10c00017 	ldw	r3,0(r2)
  815930:	00802134 	movhi	r2,132
  815934:	10baa404 	addi	r2,r2,-5488
  815938:	10c00015 	stw	r3,0(r2)
  81593c:	e0bfff17 	ldw	r2,-4(fp)
  815940:	11000417 	ldw	r4,16(r2)
  815944:	e0bffe17 	ldw	r2,-8(fp)
  815948:	103ee83a 	callr	r2
  81594c:	00802134 	movhi	r2,132
  815950:	10baa404 	addi	r2,r2,-5488
  815954:	10800017 	ldw	r2,0(r2)
  815958:	e0bfff15 	stw	r2,-4(fp)
  81595c:	e0bfff17 	ldw	r2,-4(fp)
  815960:	10800217 	ldw	r2,8(r2)
  815964:	1005003a 	cmpeq	r2,r2,zero
  815968:	103fe51e 	bne	r2,zero,815900 <chSysTimerHandlerI+0xac>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
  81596c:	e037883a 	mov	sp,fp
  815970:	dfc00117 	ldw	ra,4(sp)
  815974:	df000017 	ldw	fp,0(sp)
  815978:	dec00204 	addi	sp,sp,8
  81597c:	f800283a 	ret

00815980 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  815980:	defff404 	addi	sp,sp,-48
  815984:	df000b15 	stw	fp,44(sp)
  815988:	df000b04 	addi	fp,sp,44
  81598c:	e13ffb15 	stw	r4,-20(fp)
  815990:	e17ffc15 	stw	r5,-16(fp)
  815994:	e1bffd15 	stw	r6,-12(fp)
  815998:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  81599c:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  8159a0:	008020b4 	movhi	r2,130
  8159a4:	10b02b04 	addi	r2,r2,-16212
  8159a8:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  8159ac:	1005003a 	cmpeq	r2,r2,zero
  8159b0:	1000411e 	bne	r2,zero,815ab8 <alt_alarm_start+0x138>
  {
    if (alarm)
  8159b4:	e0bffb17 	ldw	r2,-20(fp)
  8159b8:	1005003a 	cmpeq	r2,r2,zero
  8159bc:	10003b1e 	bne	r2,zero,815aac <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
  8159c0:	e0fffb17 	ldw	r3,-20(fp)
  8159c4:	e0bffd17 	ldw	r2,-12(fp)
  8159c8:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
  8159cc:	e0fffb17 	ldw	r3,-20(fp)
  8159d0:	e0bffe17 	ldw	r2,-8(fp)
  8159d4:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8159d8:	0005303a 	rdctl	r2,status
  8159dc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8159e0:	e0fff817 	ldw	r3,-32(fp)
  8159e4:	00bfff84 	movi	r2,-2
  8159e8:	1884703a 	and	r2,r3,r2
  8159ec:	1001703a 	wrctl	status,r2
  
  return context;
  8159f0:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  8159f4:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  8159f8:	008020b4 	movhi	r2,130
  8159fc:	10b02c04 	addi	r2,r2,-16208
  815a00:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  815a04:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  815a08:	e0fffc17 	ldw	r3,-16(fp)
  815a0c:	e0bff917 	ldw	r2,-28(fp)
  815a10:	1885883a 	add	r2,r3,r2
  815a14:	10c00044 	addi	r3,r2,1
  815a18:	e0bffb17 	ldw	r2,-20(fp)
  815a1c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  815a20:	e0bffb17 	ldw	r2,-20(fp)
  815a24:	10c00217 	ldw	r3,8(r2)
  815a28:	e0bff917 	ldw	r2,-28(fp)
  815a2c:	1880042e 	bgeu	r3,r2,815a40 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
  815a30:	e0fffb17 	ldw	r3,-20(fp)
  815a34:	00800044 	movi	r2,1
  815a38:	18800405 	stb	r2,16(r3)
  815a3c:	00000206 	br	815a48 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
  815a40:	e0bffb17 	ldw	r2,-20(fp)
  815a44:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  815a48:	e0fffb17 	ldw	r3,-20(fp)
  815a4c:	008020b4 	movhi	r2,130
  815a50:	10a93f04 	addi	r2,r2,-23300
  815a54:	e0bff615 	stw	r2,-40(fp)
  815a58:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  815a5c:	e0fff717 	ldw	r3,-36(fp)
  815a60:	e0bff617 	ldw	r2,-40(fp)
  815a64:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
  815a68:	e0bff617 	ldw	r2,-40(fp)
  815a6c:	10c00017 	ldw	r3,0(r2)
  815a70:	e0bff717 	ldw	r2,-36(fp)
  815a74:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  815a78:	e0bff617 	ldw	r2,-40(fp)
  815a7c:	10c00017 	ldw	r3,0(r2)
  815a80:	e0bff717 	ldw	r2,-36(fp)
  815a84:	18800115 	stw	r2,4(r3)
  list->next           = entry;
  815a88:	e0fff617 	ldw	r3,-40(fp)
  815a8c:	e0bff717 	ldw	r2,-36(fp)
  815a90:	18800015 	stw	r2,0(r3)
  815a94:	e0bffa17 	ldw	r2,-24(fp)
  815a98:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815a9c:	e0bff517 	ldw	r2,-44(fp)
  815aa0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  815aa4:	e03fff15 	stw	zero,-4(fp)
  815aa8:	00000506 	br	815ac0 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
  815aac:	00bffa84 	movi	r2,-22
  815ab0:	e0bfff15 	stw	r2,-4(fp)
  815ab4:	00000206 	br	815ac0 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
  815ab8:	00bfde84 	movi	r2,-134
  815abc:	e0bfff15 	stw	r2,-4(fp)
  815ac0:	e0bfff17 	ldw	r2,-4(fp)
  }
}
  815ac4:	e037883a 	mov	sp,fp
  815ac8:	df000017 	ldw	fp,0(sp)
  815acc:	dec00104 	addi	sp,sp,4
  815ad0:	f800283a 	ret

00815ad4 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  815ad4:	deffff04 	addi	sp,sp,-4
  815ad8:	df000015 	stw	fp,0(sp)
  815adc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  815ae0:	e037883a 	mov	sp,fp
  815ae4:	df000017 	ldw	fp,0(sp)
  815ae8:	dec00104 	addi	sp,sp,4
  815aec:	f800283a 	ret

00815af0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  815af0:	defff904 	addi	sp,sp,-28
  815af4:	dfc00615 	stw	ra,24(sp)
  815af8:	df000515 	stw	fp,20(sp)
  815afc:	df000504 	addi	fp,sp,20
  815b00:	e13ffd15 	stw	r4,-12(fp)
  815b04:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  815b08:	e0bffd17 	ldw	r2,-12(fp)
  815b0c:	1005003a 	cmpeq	r2,r2,zero
  815b10:	1000041e 	bne	r2,zero,815b24 <alt_dev_llist_insert+0x34>
  815b14:	e0bffd17 	ldw	r2,-12(fp)
  815b18:	10800217 	ldw	r2,8(r2)
  815b1c:	1004c03a 	cmpne	r2,r2,zero
  815b20:	1000071e 	bne	r2,zero,815b40 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
  815b24:	0815ba40 	call	815ba4 <alt_get_errno>
  815b28:	1007883a 	mov	r3,r2
  815b2c:	00800584 	movi	r2,22
  815b30:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  815b34:	00bffa84 	movi	r2,-22
  815b38:	e0bfff15 	stw	r2,-4(fp)
  815b3c:	00001306 	br	815b8c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  815b40:	e0fffd17 	ldw	r3,-12(fp)
  815b44:	e0bffe17 	ldw	r2,-8(fp)
  815b48:	e0bffb15 	stw	r2,-20(fp)
  815b4c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  815b50:	e0fffc17 	ldw	r3,-16(fp)
  815b54:	e0bffb17 	ldw	r2,-20(fp)
  815b58:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
  815b5c:	e0bffb17 	ldw	r2,-20(fp)
  815b60:	10c00017 	ldw	r3,0(r2)
  815b64:	e0bffc17 	ldw	r2,-16(fp)
  815b68:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  815b6c:	e0bffb17 	ldw	r2,-20(fp)
  815b70:	10c00017 	ldw	r3,0(r2)
  815b74:	e0bffc17 	ldw	r2,-16(fp)
  815b78:	18800115 	stw	r2,4(r3)
  list->next           = entry;
  815b7c:	e0fffb17 	ldw	r3,-20(fp)
  815b80:	e0bffc17 	ldw	r2,-16(fp)
  815b84:	18800015 	stw	r2,0(r3)

  return 0;  
  815b88:	e03fff15 	stw	zero,-4(fp)
  815b8c:	e0bfff17 	ldw	r2,-4(fp)
}
  815b90:	e037883a 	mov	sp,fp
  815b94:	dfc00117 	ldw	ra,4(sp)
  815b98:	df000017 	ldw	fp,0(sp)
  815b9c:	dec00204 	addi	sp,sp,8
  815ba0:	f800283a 	ret

00815ba4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  815ba4:	defffd04 	addi	sp,sp,-12
  815ba8:	dfc00215 	stw	ra,8(sp)
  815bac:	df000115 	stw	fp,4(sp)
  815bb0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  815bb4:	008020b4 	movhi	r2,130
  815bb8:	10a93c04 	addi	r2,r2,-23312
  815bbc:	10800017 	ldw	r2,0(r2)
  815bc0:	1005003a 	cmpeq	r2,r2,zero
  815bc4:	1000061e 	bne	r2,zero,815be0 <alt_get_errno+0x3c>
  815bc8:	008020b4 	movhi	r2,130
  815bcc:	10a93c04 	addi	r2,r2,-23312
  815bd0:	10800017 	ldw	r2,0(r2)
  815bd4:	103ee83a 	callr	r2
  815bd8:	e0bfff15 	stw	r2,-4(fp)
  815bdc:	00000306 	br	815bec <alt_get_errno+0x48>
  815be0:	008020b4 	movhi	r2,130
  815be4:	10b02404 	addi	r2,r2,-16240
  815be8:	e0bfff15 	stw	r2,-4(fp)
  815bec:	e0bfff17 	ldw	r2,-4(fp)
}
  815bf0:	e037883a 	mov	sp,fp
  815bf4:	dfc00117 	ldw	ra,4(sp)
  815bf8:	df000017 	ldw	fp,0(sp)
  815bfc:	dec00204 	addi	sp,sp,8
  815c00:	f800283a 	ret

00815c04 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  815c04:	defffd04 	addi	sp,sp,-12
  815c08:	dfc00215 	stw	ra,8(sp)
  815c0c:	df000115 	stw	fp,4(sp)
  815c10:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  815c14:	00bfff04 	movi	r2,-4
  815c18:	00c02074 	movhi	r3,129
  815c1c:	18dd0a04 	addi	r3,r3,29736
  815c20:	1885883a 	add	r2,r3,r2
  815c24:	e0bfff15 	stw	r2,-4(fp)
  815c28:	00000606 	br	815c44 <_do_ctors+0x40>
        (*ctor) (); 
  815c2c:	e0bfff17 	ldw	r2,-4(fp)
  815c30:	10800017 	ldw	r2,0(r2)
  815c34:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  815c38:	e0bfff17 	ldw	r2,-4(fp)
  815c3c:	10bfff04 	addi	r2,r2,-4
  815c40:	e0bfff15 	stw	r2,-4(fp)
  815c44:	e0ffff17 	ldw	r3,-4(fp)
  815c48:	00802074 	movhi	r2,129
  815c4c:	109d0904 	addi	r2,r2,29732
  815c50:	18bff62e 	bgeu	r3,r2,815c2c <_do_ctors+0x28>
        (*ctor) (); 
}
  815c54:	e037883a 	mov	sp,fp
  815c58:	dfc00117 	ldw	ra,4(sp)
  815c5c:	df000017 	ldw	fp,0(sp)
  815c60:	dec00204 	addi	sp,sp,8
  815c64:	f800283a 	ret

00815c68 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  815c68:	defffd04 	addi	sp,sp,-12
  815c6c:	dfc00215 	stw	ra,8(sp)
  815c70:	df000115 	stw	fp,4(sp)
  815c74:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  815c78:	00bfff04 	movi	r2,-4
  815c7c:	00c02074 	movhi	r3,129
  815c80:	18dd0a04 	addi	r3,r3,29736
  815c84:	1885883a 	add	r2,r3,r2
  815c88:	e0bfff15 	stw	r2,-4(fp)
  815c8c:	00000606 	br	815ca8 <_do_dtors+0x40>
        (*dtor) (); 
  815c90:	e0bfff17 	ldw	r2,-4(fp)
  815c94:	10800017 	ldw	r2,0(r2)
  815c98:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  815c9c:	e0bfff17 	ldw	r2,-4(fp)
  815ca0:	10bfff04 	addi	r2,r2,-4
  815ca4:	e0bfff15 	stw	r2,-4(fp)
  815ca8:	e0ffff17 	ldw	r3,-4(fp)
  815cac:	00802074 	movhi	r2,129
  815cb0:	109d0a04 	addi	r2,r2,29736
  815cb4:	18bff62e 	bgeu	r3,r2,815c90 <_do_dtors+0x28>
        (*dtor) (); 
}
  815cb8:	e037883a 	mov	sp,fp
  815cbc:	dfc00117 	ldw	ra,4(sp)
  815cc0:	df000017 	ldw	fp,0(sp)
  815cc4:	dec00204 	addi	sp,sp,8
  815cc8:	f800283a 	ret

00815ccc <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  815ccc:	deffff04 	addi	sp,sp,-4
  815cd0:	df000015 	stw	fp,0(sp)
  815cd4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  815cd8:	e037883a 	mov	sp,fp
  815cdc:	df000017 	ldw	fp,0(sp)
  815ce0:	dec00104 	addi	sp,sp,4
  815ce4:	f800283a 	ret

00815ce8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  815ce8:	defff904 	addi	sp,sp,-28
  815cec:	dfc00615 	stw	ra,24(sp)
  815cf0:	df000515 	stw	fp,20(sp)
  815cf4:	df000504 	addi	fp,sp,20
  815cf8:	e13ffc15 	stw	r4,-16(fp)
  815cfc:	e17ffd15 	stw	r5,-12(fp)
  815d00:	e1bffe15 	stw	r6,-8(fp)
  815d04:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  815d08:	e0800217 	ldw	r2,8(fp)
  815d0c:	d8800015 	stw	r2,0(sp)
  815d10:	e13ffc17 	ldw	r4,-16(fp)
  815d14:	e17ffd17 	ldw	r5,-12(fp)
  815d18:	e1bffe17 	ldw	r6,-8(fp)
  815d1c:	e1ffff17 	ldw	r7,-4(fp)
  815d20:	0815ebc0 	call	815ebc <alt_iic_isr_register>
}  
  815d24:	e037883a 	mov	sp,fp
  815d28:	dfc00117 	ldw	ra,4(sp)
  815d2c:	df000017 	ldw	fp,0(sp)
  815d30:	dec00204 	addi	sp,sp,8
  815d34:	f800283a 	ret

00815d38 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  815d38:	defff904 	addi	sp,sp,-28
  815d3c:	df000615 	stw	fp,24(sp)
  815d40:	df000604 	addi	fp,sp,24
  815d44:	e13ffe15 	stw	r4,-8(fp)
  815d48:	e17fff15 	stw	r5,-4(fp)
  815d4c:	e0bfff17 	ldw	r2,-4(fp)
  815d50:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  815d54:	0005303a 	rdctl	r2,status
  815d58:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  815d5c:	e0fffb17 	ldw	r3,-20(fp)
  815d60:	00bfff84 	movi	r2,-2
  815d64:	1884703a 	and	r2,r3,r2
  815d68:	1001703a 	wrctl	status,r2
  
  return context;
  815d6c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  815d70:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
  815d74:	e0fffc17 	ldw	r3,-16(fp)
  815d78:	00800044 	movi	r2,1
  815d7c:	10c4983a 	sll	r2,r2,r3
  815d80:	1007883a 	mov	r3,r2
  815d84:	008020b4 	movhi	r2,130
  815d88:	10b02a04 	addi	r2,r2,-16216
  815d8c:	10800017 	ldw	r2,0(r2)
  815d90:	1886b03a 	or	r3,r3,r2
  815d94:	008020b4 	movhi	r2,130
  815d98:	10b02a04 	addi	r2,r2,-16216
  815d9c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  815da0:	008020b4 	movhi	r2,130
  815da4:	10b02a04 	addi	r2,r2,-16216
  815da8:	10800017 	ldw	r2,0(r2)
  815dac:	100170fa 	wrctl	ienable,r2
  815db0:	e0bffd17 	ldw	r2,-12(fp)
  815db4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815db8:	e0bffa17 	ldw	r2,-24(fp)
  815dbc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  815dc0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  815dc4:	e037883a 	mov	sp,fp
  815dc8:	df000017 	ldw	fp,0(sp)
  815dcc:	dec00104 	addi	sp,sp,4
  815dd0:	f800283a 	ret

00815dd4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  815dd4:	defff904 	addi	sp,sp,-28
  815dd8:	df000615 	stw	fp,24(sp)
  815ddc:	df000604 	addi	fp,sp,24
  815de0:	e13ffe15 	stw	r4,-8(fp)
  815de4:	e17fff15 	stw	r5,-4(fp)
  815de8:	e0bfff17 	ldw	r2,-4(fp)
  815dec:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  815df0:	0005303a 	rdctl	r2,status
  815df4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  815df8:	e0fffb17 	ldw	r3,-20(fp)
  815dfc:	00bfff84 	movi	r2,-2
  815e00:	1884703a 	and	r2,r3,r2
  815e04:	1001703a 	wrctl	status,r2
  
  return context;
  815e08:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  815e0c:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
  815e10:	e0fffc17 	ldw	r3,-16(fp)
  815e14:	00800044 	movi	r2,1
  815e18:	10c4983a 	sll	r2,r2,r3
  815e1c:	0084303a 	nor	r2,zero,r2
  815e20:	1007883a 	mov	r3,r2
  815e24:	008020b4 	movhi	r2,130
  815e28:	10b02a04 	addi	r2,r2,-16216
  815e2c:	10800017 	ldw	r2,0(r2)
  815e30:	1886703a 	and	r3,r3,r2
  815e34:	008020b4 	movhi	r2,130
  815e38:	10b02a04 	addi	r2,r2,-16216
  815e3c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  815e40:	008020b4 	movhi	r2,130
  815e44:	10b02a04 	addi	r2,r2,-16216
  815e48:	10800017 	ldw	r2,0(r2)
  815e4c:	100170fa 	wrctl	ienable,r2
  815e50:	e0bffd17 	ldw	r2,-12(fp)
  815e54:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815e58:	e0bffa17 	ldw	r2,-24(fp)
  815e5c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  815e60:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  815e64:	e037883a 	mov	sp,fp
  815e68:	df000017 	ldw	fp,0(sp)
  815e6c:	dec00104 	addi	sp,sp,4
  815e70:	f800283a 	ret

00815e74 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  815e74:	defffc04 	addi	sp,sp,-16
  815e78:	df000315 	stw	fp,12(sp)
  815e7c:	df000304 	addi	fp,sp,12
  815e80:	e13ffe15 	stw	r4,-8(fp)
  815e84:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  815e88:	000530fa 	rdctl	r2,ienable
  815e8c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  815e90:	e0ffff17 	ldw	r3,-4(fp)
  815e94:	00800044 	movi	r2,1
  815e98:	10c4983a 	sll	r2,r2,r3
  815e9c:	1007883a 	mov	r3,r2
  815ea0:	e0bffd17 	ldw	r2,-12(fp)
  815ea4:	1884703a 	and	r2,r3,r2
  815ea8:	1004c03a 	cmpne	r2,r2,zero
}
  815eac:	e037883a 	mov	sp,fp
  815eb0:	df000017 	ldw	fp,0(sp)
  815eb4:	dec00104 	addi	sp,sp,4
  815eb8:	f800283a 	ret

00815ebc <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  815ebc:	defff404 	addi	sp,sp,-48
  815ec0:	dfc00b15 	stw	ra,44(sp)
  815ec4:	df000a15 	stw	fp,40(sp)
  815ec8:	df000a04 	addi	fp,sp,40
  815ecc:	e13ffb15 	stw	r4,-20(fp)
  815ed0:	e17ffc15 	stw	r5,-16(fp)
  815ed4:	e1bffd15 	stw	r6,-12(fp)
  815ed8:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
  815edc:	00bffa84 	movi	r2,-22
  815ee0:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  815ee4:	e0bffc17 	ldw	r2,-16(fp)
  815ee8:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  815eec:	e0bff917 	ldw	r2,-28(fp)
  815ef0:	10800808 	cmpgei	r2,r2,32
  815ef4:	1000291e 	bne	r2,zero,815f9c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  815ef8:	0005303a 	rdctl	r2,status
  815efc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  815f00:	e0fff717 	ldw	r3,-36(fp)
  815f04:	00bfff84 	movi	r2,-2
  815f08:	1884703a 	and	r2,r3,r2
  815f0c:	1001703a 	wrctl	status,r2
  
  return context;
  815f10:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  815f14:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
  815f18:	e0bff917 	ldw	r2,-28(fp)
  815f1c:	00c02134 	movhi	r3,132
  815f20:	18fb1804 	addi	r3,r3,-5024
  815f24:	100490fa 	slli	r2,r2,3
  815f28:	10c7883a 	add	r3,r2,r3
  815f2c:	e0bffd17 	ldw	r2,-12(fp)
  815f30:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
  815f34:	e0bff917 	ldw	r2,-28(fp)
  815f38:	00c02134 	movhi	r3,132
  815f3c:	18fb1804 	addi	r3,r3,-5024
  815f40:	100490fa 	slli	r2,r2,3
  815f44:	10c5883a 	add	r2,r2,r3
  815f48:	10c00104 	addi	r3,r2,4
  815f4c:	e0bffe17 	ldw	r2,-8(fp)
  815f50:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  815f54:	e0bffd17 	ldw	r2,-12(fp)
  815f58:	1005003a 	cmpeq	r2,r2,zero
  815f5c:	1000051e 	bne	r2,zero,815f74 <alt_iic_isr_register+0xb8>
  815f60:	e17ff917 	ldw	r5,-28(fp)
  815f64:	e13ffb17 	ldw	r4,-20(fp)
  815f68:	0815d380 	call	815d38 <alt_ic_irq_enable>
  815f6c:	e0bfff15 	stw	r2,-4(fp)
  815f70:	00000406 	br	815f84 <alt_iic_isr_register+0xc8>
  815f74:	e17ff917 	ldw	r5,-28(fp)
  815f78:	e13ffb17 	ldw	r4,-20(fp)
  815f7c:	0815dd40 	call	815dd4 <alt_ic_irq_disable>
  815f80:	e0bfff15 	stw	r2,-4(fp)
  815f84:	e0bfff17 	ldw	r2,-4(fp)
  815f88:	e0bffa15 	stw	r2,-24(fp)
  815f8c:	e0bff817 	ldw	r2,-32(fp)
  815f90:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  815f94:	e0bff617 	ldw	r2,-40(fp)
  815f98:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  815f9c:	e0bffa17 	ldw	r2,-24(fp)
}
  815fa0:	e037883a 	mov	sp,fp
  815fa4:	dfc00117 	ldw	ra,4(sp)
  815fa8:	df000017 	ldw	fp,0(sp)
  815fac:	dec00204 	addi	sp,sp,8
  815fb0:	f800283a 	ret

00815fb4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  815fb4:	defff804 	addi	sp,sp,-32
  815fb8:	dfc00715 	stw	ra,28(sp)
  815fbc:	df000615 	stw	fp,24(sp)
  815fc0:	dc000515 	stw	r16,20(sp)
  815fc4:	df000504 	addi	fp,sp,20
  815fc8:	e13ffc15 	stw	r4,-16(fp)
  815fcc:	e17ffd15 	stw	r5,-12(fp)
  815fd0:	e1bffe15 	stw	r6,-8(fp)
  815fd4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  815fd8:	e13ffd17 	ldw	r4,-12(fp)
  815fdc:	e17ffe17 	ldw	r5,-8(fp)
  815fe0:	e1bfff17 	ldw	r6,-4(fp)
  815fe4:	08161fc0 	call	8161fc <open>
  815fe8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  815fec:	e0bffb17 	ldw	r2,-20(fp)
  815ff0:	1004803a 	cmplt	r2,r2,zero
  815ff4:	10001f1e 	bne	r2,zero,816074 <alt_open_fd+0xc0>
  {
    fd->dev      = alt_fd_list[old].dev;
  815ff8:	e13ffb17 	ldw	r4,-20(fp)
  815ffc:	040020b4 	movhi	r16,130
  816000:	84248304 	addi	r16,r16,-28148
  816004:	01400304 	movi	r5,12
  816008:	08064840 	call	806484 <__mulsi3>
  81600c:	1405883a 	add	r2,r2,r16
  816010:	10c00017 	ldw	r3,0(r2)
  816014:	e0bffc17 	ldw	r2,-16(fp)
  816018:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  81601c:	e13ffb17 	ldw	r4,-20(fp)
  816020:	040020b4 	movhi	r16,130
  816024:	84248304 	addi	r16,r16,-28148
  816028:	01400304 	movi	r5,12
  81602c:	08064840 	call	806484 <__mulsi3>
  816030:	1405883a 	add	r2,r2,r16
  816034:	10800104 	addi	r2,r2,4
  816038:	10c00017 	ldw	r3,0(r2)
  81603c:	e0bffc17 	ldw	r2,-16(fp)
  816040:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  816044:	e13ffb17 	ldw	r4,-20(fp)
  816048:	040020b4 	movhi	r16,130
  81604c:	84248304 	addi	r16,r16,-28148
  816050:	01400304 	movi	r5,12
  816054:	08064840 	call	806484 <__mulsi3>
  816058:	1405883a 	add	r2,r2,r16
  81605c:	10800204 	addi	r2,r2,8
  816060:	10c00017 	ldw	r3,0(r2)
  816064:	e0bffc17 	ldw	r2,-16(fp)
  816068:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  81606c:	e13ffb17 	ldw	r4,-20(fp)
  816070:	0813a4c0 	call	813a4c <alt_release_fd>
  }
} 
  816074:	e037883a 	mov	sp,fp
  816078:	dfc00217 	ldw	ra,8(sp)
  81607c:	df000117 	ldw	fp,4(sp)
  816080:	dc000017 	ldw	r16,0(sp)
  816084:	dec00304 	addi	sp,sp,12
  816088:	f800283a 	ret

0081608c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  81608c:	defffb04 	addi	sp,sp,-20
  816090:	dfc00415 	stw	ra,16(sp)
  816094:	df000315 	stw	fp,12(sp)
  816098:	df000304 	addi	fp,sp,12
  81609c:	e13ffd15 	stw	r4,-12(fp)
  8160a0:	e17ffe15 	stw	r5,-8(fp)
  8160a4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  8160a8:	010020b4 	movhi	r4,130
  8160ac:	21248604 	addi	r4,r4,-28136
  8160b0:	e17ffd17 	ldw	r5,-12(fp)
  8160b4:	01800044 	movi	r6,1
  8160b8:	01c07fc4 	movi	r7,511
  8160bc:	0815fb40 	call	815fb4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  8160c0:	010020b4 	movhi	r4,130
  8160c4:	21248304 	addi	r4,r4,-28148
  8160c8:	e17ffe17 	ldw	r5,-8(fp)
  8160cc:	000d883a 	mov	r6,zero
  8160d0:	01c07fc4 	movi	r7,511
  8160d4:	0815fb40 	call	815fb4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  8160d8:	010020b4 	movhi	r4,130
  8160dc:	21248904 	addi	r4,r4,-28124
  8160e0:	e17fff17 	ldw	r5,-4(fp)
  8160e4:	01800044 	movi	r6,1
  8160e8:	01c07fc4 	movi	r7,511
  8160ec:	0815fb40 	call	815fb4 <alt_open_fd>
}  
  8160f0:	e037883a 	mov	sp,fp
  8160f4:	dfc00117 	ldw	ra,4(sp)
  8160f8:	df000017 	ldw	fp,0(sp)
  8160fc:	dec00204 	addi	sp,sp,8
  816100:	f800283a 	ret

00816104 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  816104:	defffa04 	addi	sp,sp,-24
  816108:	dfc00515 	stw	ra,20(sp)
  81610c:	df000415 	stw	fp,16(sp)
  816110:	dc000315 	stw	r16,12(sp)
  816114:	df000304 	addi	fp,sp,12
  816118:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  81611c:	e0bffe17 	ldw	r2,-8(fp)
  816120:	10800217 	ldw	r2,8(r2)
  816124:	10d00034 	orhi	r3,r2,16384
  816128:	e0bffe17 	ldw	r2,-8(fp)
  81612c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  816130:	e03ffd15 	stw	zero,-12(fp)
  816134:	00002306 	br	8161c4 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  816138:	e13ffd17 	ldw	r4,-12(fp)
  81613c:	040020b4 	movhi	r16,130
  816140:	84248304 	addi	r16,r16,-28148
  816144:	01400304 	movi	r5,12
  816148:	08064840 	call	806484 <__mulsi3>
  81614c:	1405883a 	add	r2,r2,r16
  816150:	10c00017 	ldw	r3,0(r2)
  816154:	e0bffe17 	ldw	r2,-8(fp)
  816158:	10800017 	ldw	r2,0(r2)
  81615c:	1880161e 	bne	r3,r2,8161b8 <alt_file_locked+0xb4>
  816160:	e13ffd17 	ldw	r4,-12(fp)
  816164:	040020b4 	movhi	r16,130
  816168:	84248304 	addi	r16,r16,-28148
  81616c:	01400304 	movi	r5,12
  816170:	08064840 	call	806484 <__mulsi3>
  816174:	1405883a 	add	r2,r2,r16
  816178:	10800204 	addi	r2,r2,8
  81617c:	10800017 	ldw	r2,0(r2)
  816180:	1004403a 	cmpge	r2,r2,zero
  816184:	10000c1e 	bne	r2,zero,8161b8 <alt_file_locked+0xb4>
  816188:	e13ffd17 	ldw	r4,-12(fp)
  81618c:	01400304 	movi	r5,12
  816190:	08064840 	call	806484 <__mulsi3>
  816194:	1007883a 	mov	r3,r2
  816198:	008020b4 	movhi	r2,130
  81619c:	10a48304 	addi	r2,r2,-28148
  8161a0:	1887883a 	add	r3,r3,r2
  8161a4:	e0bffe17 	ldw	r2,-8(fp)
  8161a8:	18800326 	beq	r3,r2,8161b8 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  8161ac:	00bffcc4 	movi	r2,-13
  8161b0:	e0bfff15 	stw	r2,-4(fp)
  8161b4:	00000a06 	br	8161e0 <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  8161b8:	e0bffd17 	ldw	r2,-12(fp)
  8161bc:	10800044 	addi	r2,r2,1
  8161c0:	e0bffd15 	stw	r2,-12(fp)
  8161c4:	008020b4 	movhi	r2,130
  8161c8:	10a93b04 	addi	r2,r2,-23316
  8161cc:	10800017 	ldw	r2,0(r2)
  8161d0:	1007883a 	mov	r3,r2
  8161d4:	e0bffd17 	ldw	r2,-12(fp)
  8161d8:	18bfd72e 	bgeu	r3,r2,816138 <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  8161dc:	e03fff15 	stw	zero,-4(fp)
  8161e0:	e0bfff17 	ldw	r2,-4(fp)
}
  8161e4:	e037883a 	mov	sp,fp
  8161e8:	dfc00217 	ldw	ra,8(sp)
  8161ec:	df000117 	ldw	fp,4(sp)
  8161f0:	dc000017 	ldw	r16,0(sp)
  8161f4:	dec00304 	addi	sp,sp,12
  8161f8:	f800283a 	ret

008161fc <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  8161fc:	defff404 	addi	sp,sp,-48
  816200:	dfc00b15 	stw	ra,44(sp)
  816204:	df000a15 	stw	fp,40(sp)
  816208:	df000a04 	addi	fp,sp,40
  81620c:	e13ffb15 	stw	r4,-20(fp)
  816210:	e17ffc15 	stw	r5,-16(fp)
  816214:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  816218:	00bfffc4 	movi	r2,-1
  81621c:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
  816220:	00bffb44 	movi	r2,-19
  816224:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
  816228:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  81622c:	e13ffb17 	ldw	r4,-20(fp)
  816230:	014020b4 	movhi	r5,130
  816234:	29693904 	addi	r5,r5,-23324
  816238:	08166000 	call	816600 <alt_find_dev>
  81623c:	e0bffa15 	stw	r2,-24(fp)
  816240:	e0bffa17 	ldw	r2,-24(fp)
  816244:	1004c03a 	cmpne	r2,r2,zero
  816248:	1000051e 	bne	r2,zero,816260 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  81624c:	e13ffb17 	ldw	r4,-20(fp)
  816250:	08166940 	call	816694 <alt_find_file>
  816254:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
  816258:	00800044 	movi	r2,1
  81625c:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  816260:	e0bffa17 	ldw	r2,-24(fp)
  816264:	1005003a 	cmpeq	r2,r2,zero
  816268:	1000311e 	bne	r2,zero,816330 <open+0x134>
  {
    if ((index = alt_get_fd (dev)) < 0)
  81626c:	e13ffa17 	ldw	r4,-24(fp)
  816270:	08167b40 	call	8167b4 <alt_get_fd>
  816274:	e0bff815 	stw	r2,-32(fp)
  816278:	e0bff817 	ldw	r2,-32(fp)
  81627c:	1004403a 	cmpge	r2,r2,zero
  816280:	1000031e 	bne	r2,zero,816290 <open+0x94>
    {
      status = index;
  816284:	e0bff817 	ldw	r2,-32(fp)
  816288:	e0bff715 	stw	r2,-36(fp)
  81628c:	00002a06 	br	816338 <open+0x13c>
    }
    else
    {
      fd = &alt_fd_list[index];
  816290:	e13ff817 	ldw	r4,-32(fp)
  816294:	01400304 	movi	r5,12
  816298:	08064840 	call	806484 <__mulsi3>
  81629c:	1007883a 	mov	r3,r2
  8162a0:	008020b4 	movhi	r2,130
  8162a4:	10a48304 	addi	r2,r2,-28148
  8162a8:	1885883a 	add	r2,r3,r2
  8162ac:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  8162b0:	e0fffc17 	ldw	r3,-16(fp)
  8162b4:	00900034 	movhi	r2,16384
  8162b8:	10bfffc4 	addi	r2,r2,-1
  8162bc:	1886703a 	and	r3,r3,r2
  8162c0:	e0bff917 	ldw	r2,-28(fp)
  8162c4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  8162c8:	e0bff617 	ldw	r2,-40(fp)
  8162cc:	1004c03a 	cmpne	r2,r2,zero
  8162d0:	1000061e 	bne	r2,zero,8162ec <open+0xf0>
  8162d4:	e13ff917 	ldw	r4,-28(fp)
  8162d8:	08161040 	call	816104 <alt_file_locked>
  8162dc:	e0bff715 	stw	r2,-36(fp)
  8162e0:	e0bff717 	ldw	r2,-36(fp)
  8162e4:	1004803a 	cmplt	r2,r2,zero
  8162e8:	1000131e 	bne	r2,zero,816338 <open+0x13c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  8162ec:	e0bffa17 	ldw	r2,-24(fp)
  8162f0:	10800317 	ldw	r2,12(r2)
  8162f4:	1005003a 	cmpeq	r2,r2,zero
  8162f8:	1000091e 	bne	r2,zero,816320 <open+0x124>
  8162fc:	e0bffa17 	ldw	r2,-24(fp)
  816300:	10800317 	ldw	r2,12(r2)
  816304:	e13ff917 	ldw	r4,-28(fp)
  816308:	e17ffb17 	ldw	r5,-20(fp)
  81630c:	e1bffc17 	ldw	r6,-16(fp)
  816310:	e1fffd17 	ldw	r7,-12(fp)
  816314:	103ee83a 	callr	r2
  816318:	e0bfff15 	stw	r2,-4(fp)
  81631c:	00000106 	br	816324 <open+0x128>
  816320:	e03fff15 	stw	zero,-4(fp)
  816324:	e0bfff17 	ldw	r2,-4(fp)
  816328:	e0bff715 	stw	r2,-36(fp)
  81632c:	00000206 	br	816338 <open+0x13c>
      }
    }
  }
  else
  {
    status = -ENODEV;
  816330:	00bffb44 	movi	r2,-19
  816334:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  816338:	e0bff717 	ldw	r2,-36(fp)
  81633c:	1004403a 	cmpge	r2,r2,zero
  816340:	1000091e 	bne	r2,zero,816368 <open+0x16c>
  {
    alt_release_fd (index);  
  816344:	e13ff817 	ldw	r4,-32(fp)
  816348:	0813a4c0 	call	813a4c <alt_release_fd>
    ALT_ERRNO = -status;
  81634c:	08163880 	call	816388 <alt_get_errno>
  816350:	e0fff717 	ldw	r3,-36(fp)
  816354:	00c7c83a 	sub	r3,zero,r3
  816358:	10c00015 	stw	r3,0(r2)
    return -1;
  81635c:	00bfffc4 	movi	r2,-1
  816360:	e0bffe15 	stw	r2,-8(fp)
  816364:	00000206 	br	816370 <open+0x174>
  }
  
  /* return the reference upon success */

  return index;
  816368:	e0bff817 	ldw	r2,-32(fp)
  81636c:	e0bffe15 	stw	r2,-8(fp)
  816370:	e0bffe17 	ldw	r2,-8(fp)
}
  816374:	e037883a 	mov	sp,fp
  816378:	dfc00117 	ldw	ra,4(sp)
  81637c:	df000017 	ldw	fp,0(sp)
  816380:	dec00204 	addi	sp,sp,8
  816384:	f800283a 	ret

00816388 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  816388:	defffd04 	addi	sp,sp,-12
  81638c:	dfc00215 	stw	ra,8(sp)
  816390:	df000115 	stw	fp,4(sp)
  816394:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
  816398:	008020b4 	movhi	r2,130
  81639c:	10a93c04 	addi	r2,r2,-23312
  8163a0:	10800017 	ldw	r2,0(r2)
  8163a4:	1005003a 	cmpeq	r2,r2,zero
  8163a8:	1000061e 	bne	r2,zero,8163c4 <alt_get_errno+0x3c>
  8163ac:	008020b4 	movhi	r2,130
  8163b0:	10a93c04 	addi	r2,r2,-23312
  8163b4:	10800017 	ldw	r2,0(r2)
  8163b8:	103ee83a 	callr	r2
  8163bc:	e0bfff15 	stw	r2,-4(fp)
  8163c0:	00000306 	br	8163d0 <alt_get_errno+0x48>
  8163c4:	008020b4 	movhi	r2,130
  8163c8:	10b02404 	addi	r2,r2,-16240
  8163cc:	e0bfff15 	stw	r2,-4(fp)
  8163d0:	e0bfff17 	ldw	r2,-4(fp)
}
  8163d4:	e037883a 	mov	sp,fp
  8163d8:	dfc00117 	ldw	ra,4(sp)
  8163dc:	df000017 	ldw	fp,0(sp)
  8163e0:	dec00204 	addi	sp,sp,8
  8163e4:	f800283a 	ret

008163e8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  8163e8:	defffa04 	addi	sp,sp,-24
  8163ec:	df000515 	stw	fp,20(sp)
  8163f0:	df000504 	addi	fp,sp,20
  8163f4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8163f8:	0005303a 	rdctl	r2,status
  8163fc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  816400:	e0fffd17 	ldw	r3,-12(fp)
  816404:	00bfff84 	movi	r2,-2
  816408:	1884703a 	and	r2,r3,r2
  81640c:	1001703a 	wrctl	status,r2
  
  return context;
  816410:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  816414:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
  816418:	e0bfff17 	ldw	r2,-4(fp)
  81641c:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  816420:	e0bffc17 	ldw	r2,-16(fp)
  816424:	10c00017 	ldw	r3,0(r2)
  816428:	e0bffc17 	ldw	r2,-16(fp)
  81642c:	10800117 	ldw	r2,4(r2)
  816430:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
  816434:	e0bffc17 	ldw	r2,-16(fp)
  816438:	10c00117 	ldw	r3,4(r2)
  81643c:	e0bffc17 	ldw	r2,-16(fp)
  816440:	10800017 	ldw	r2,0(r2)
  816444:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  816448:	e0fffc17 	ldw	r3,-16(fp)
  81644c:	e0bffc17 	ldw	r2,-16(fp)
  816450:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
  816454:	e0fffc17 	ldw	r3,-16(fp)
  816458:	e0bffc17 	ldw	r2,-16(fp)
  81645c:	18800015 	stw	r2,0(r3)
  816460:	e0bffe17 	ldw	r2,-8(fp)
  816464:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  816468:	e0bffb17 	ldw	r2,-20(fp)
  81646c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  816470:	e037883a 	mov	sp,fp
  816474:	df000017 	ldw	fp,0(sp)
  816478:	dec00104 	addi	sp,sp,4
  81647c:	f800283a 	ret

00816480 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  816480:	defffb04 	addi	sp,sp,-20
  816484:	dfc00415 	stw	ra,16(sp)
  816488:	df000315 	stw	fp,12(sp)
  81648c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  816490:	d0a01317 	ldw	r2,-32692(gp)
  816494:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  816498:	d0a70017 	ldw	r2,-25600(gp)
  81649c:	10800044 	addi	r2,r2,1
  8164a0:	d0a70015 	stw	r2,-25600(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  8164a4:	00003106 	br	81656c <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
  8164a8:	e0bffe17 	ldw	r2,-8(fp)
  8164ac:	10800017 	ldw	r2,0(r2)
  8164b0:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  8164b4:	e0bffe17 	ldw	r2,-8(fp)
  8164b8:	10800403 	ldbu	r2,16(r2)
  8164bc:	10803fcc 	andi	r2,r2,255
  8164c0:	1005003a 	cmpeq	r2,r2,zero
  8164c4:	1000051e 	bne	r2,zero,8164dc <alt_tick+0x5c>
  8164c8:	d0a70017 	ldw	r2,-25600(gp)
  8164cc:	1004c03a 	cmpne	r2,r2,zero
  8164d0:	1000021e 	bne	r2,zero,8164dc <alt_tick+0x5c>
    {
      alarm->rollover = 0;
  8164d4:	e0bffe17 	ldw	r2,-8(fp)
  8164d8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  8164dc:	e0bffe17 	ldw	r2,-8(fp)
  8164e0:	10c00217 	ldw	r3,8(r2)
  8164e4:	d0a70017 	ldw	r2,-25600(gp)
  8164e8:	10c01e36 	bltu	r2,r3,816564 <alt_tick+0xe4>
  8164ec:	e0bffe17 	ldw	r2,-8(fp)
  8164f0:	10800403 	ldbu	r2,16(r2)
  8164f4:	10803fcc 	andi	r2,r2,255
  8164f8:	1004c03a 	cmpne	r2,r2,zero
  8164fc:	1000191e 	bne	r2,zero,816564 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
  816500:	e0bffe17 	ldw	r2,-8(fp)
  816504:	10c00317 	ldw	r3,12(r2)
  816508:	e0bffe17 	ldw	r2,-8(fp)
  81650c:	11000517 	ldw	r4,20(r2)
  816510:	183ee83a 	callr	r3
  816514:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  816518:	e0bffd17 	ldw	r2,-12(fp)
  81651c:	1004c03a 	cmpne	r2,r2,zero
  816520:	1000031e 	bne	r2,zero,816530 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
  816524:	e13ffe17 	ldw	r4,-8(fp)
  816528:	08163e80 	call	8163e8 <alt_alarm_stop>
  81652c:	00000d06 	br	816564 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
  816530:	e0bffe17 	ldw	r2,-8(fp)
  816534:	10c00217 	ldw	r3,8(r2)
  816538:	e0bffd17 	ldw	r2,-12(fp)
  81653c:	1887883a 	add	r3,r3,r2
  816540:	e0bffe17 	ldw	r2,-8(fp)
  816544:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  816548:	e0bffe17 	ldw	r2,-8(fp)
  81654c:	10c00217 	ldw	r3,8(r2)
  816550:	d0a70017 	ldw	r2,-25600(gp)
  816554:	1880032e 	bgeu	r3,r2,816564 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
  816558:	e0fffe17 	ldw	r3,-8(fp)
  81655c:	00800044 	movi	r2,1
  816560:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
  816564:	e0bfff17 	ldw	r2,-4(fp)
  816568:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  81656c:	d0e01304 	addi	r3,gp,-32692
  816570:	e0bffe17 	ldw	r2,-8(fp)
  816574:	10ffcc1e 	bne	r2,r3,8164a8 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  816578:	08165d80 	call	8165d8 <port_time_tick>
}
  81657c:	e037883a 	mov	sp,fp
  816580:	dfc00117 	ldw	ra,4(sp)
  816584:	df000017 	ldw	fp,0(sp)
  816588:	dec00204 	addi	sp,sp,8
  81658c:	f800283a 	ret

00816590 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  816590:	deffff04 	addi	sp,sp,-4
  816594:	df000015 	stw	fp,0(sp)
  816598:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  81659c:	000170fa 	wrctl	ienable,zero
}
  8165a0:	e037883a 	mov	sp,fp
  8165a4:	df000017 	ldw	fp,0(sp)
  8165a8:	dec00104 	addi	sp,sp,4
  8165ac:	f800283a 	ret

008165b0 <port_halt>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void port_halt (void) 
{
  8165b0:	defffe04 	addi	sp,sp,-8
  8165b4:	df000115 	stw	fp,4(sp)
  8165b8:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8165bc:	0005303a 	rdctl	r2,status
  8165c0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8165c4:	e0ffff17 	ldw	r3,-4(fp)
  8165c8:	00bfff84 	movi	r2,-2
  8165cc:	1884703a 	and	r2,r3,r2
  8165d0:	1001703a 	wrctl	status,r2
   port_disable();
   while (TRUE) 
   {
   }  
  8165d4:	003fff06 	br	8165d4 <port_halt+0x24>

008165d8 <port_time_tick>:
/*
 * ChibiOS time tick, called by the Nios
 * hal.sys_clk_timer.
 */
CH_IRQ_HANDLER (port_time_tick)
{
  8165d8:	defffe04 	addi	sp,sp,-8
  8165dc:	dfc00115 	stw	ra,4(sp)
  8165e0:	df000015 	stw	fp,0(sp)
  8165e4:	d839883a 	mov	fp,sp
   CH_IRQ_PROLOGUE();

   chSysLockFromIsr();
   chSysTimerHandlerI();
  8165e8:	08158540 	call	815854 <chSysTimerHandlerI>
   chSysUnlockFromIsr();

   CH_IRQ_EPILOGUE();
} /* port_time_tick */
  8165ec:	e037883a 	mov	sp,fp
  8165f0:	dfc00117 	ldw	ra,4(sp)
  8165f4:	df000017 	ldw	fp,0(sp)
  8165f8:	dec00204 	addi	sp,sp,8
  8165fc:	f800283a 	ret

00816600 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  816600:	defff904 	addi	sp,sp,-28
  816604:	dfc00615 	stw	ra,24(sp)
  816608:	df000515 	stw	fp,20(sp)
  81660c:	df000504 	addi	fp,sp,20
  816610:	e13ffd15 	stw	r4,-12(fp)
  816614:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
  816618:	e0bffe17 	ldw	r2,-8(fp)
  81661c:	10800017 	ldw	r2,0(r2)
  816620:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  816624:	e13ffd17 	ldw	r4,-12(fp)
  816628:	080d47c0 	call	80d47c <strlen>
  81662c:	10800044 	addi	r2,r2,1
  816630:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  816634:	00000d06 	br	81666c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  816638:	e0bffc17 	ldw	r2,-16(fp)
  81663c:	11000217 	ldw	r4,8(r2)
  816640:	e1bffb17 	ldw	r6,-20(fp)
  816644:	e17ffd17 	ldw	r5,-12(fp)
  816648:	08169f80 	call	8169f8 <memcmp>
  81664c:	1004c03a 	cmpne	r2,r2,zero
  816650:	1000031e 	bne	r2,zero,816660 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  816654:	e0bffc17 	ldw	r2,-16(fp)
  816658:	e0bfff15 	stw	r2,-4(fp)
  81665c:	00000706 	br	81667c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  816660:	e0bffc17 	ldw	r2,-16(fp)
  816664:	10800017 	ldw	r2,0(r2)
  816668:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  81666c:	e0fffe17 	ldw	r3,-8(fp)
  816670:	e0bffc17 	ldw	r2,-16(fp)
  816674:	10fff01e 	bne	r2,r3,816638 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  816678:	e03fff15 	stw	zero,-4(fp)
  81667c:	e0bfff17 	ldw	r2,-4(fp)
}
  816680:	e037883a 	mov	sp,fp
  816684:	dfc00117 	ldw	ra,4(sp)
  816688:	df000017 	ldw	fp,0(sp)
  81668c:	dec00204 	addi	sp,sp,8
  816690:	f800283a 	ret

00816694 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  816694:	defffa04 	addi	sp,sp,-24
  816698:	dfc00515 	stw	ra,20(sp)
  81669c:	df000415 	stw	fp,16(sp)
  8166a0:	df000404 	addi	fp,sp,16
  8166a4:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  8166a8:	008020b4 	movhi	r2,130
  8166ac:	10a93704 	addi	r2,r2,-23332
  8166b0:	10800017 	ldw	r2,0(r2)
  8166b4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  8166b8:	00003306 	br	816788 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
  8166bc:	e0bffd17 	ldw	r2,-12(fp)
  8166c0:	11000217 	ldw	r4,8(r2)
  8166c4:	080d47c0 	call	80d47c <strlen>
  8166c8:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
  8166cc:	e0bffd17 	ldw	r2,-12(fp)
  8166d0:	10c00217 	ldw	r3,8(r2)
  8166d4:	e0bffc17 	ldw	r2,-16(fp)
  8166d8:	1885883a 	add	r2,r3,r2
  8166dc:	10bfffc4 	addi	r2,r2,-1
  8166e0:	10800003 	ldbu	r2,0(r2)
  8166e4:	10803fcc 	andi	r2,r2,255
  8166e8:	1080201c 	xori	r2,r2,128
  8166ec:	10bfe004 	addi	r2,r2,-128
  8166f0:	10800bd8 	cmpnei	r2,r2,47
  8166f4:	1000031e 	bne	r2,zero,816704 <alt_find_file+0x70>
    {
      len -= 1;
  8166f8:	e0bffc17 	ldw	r2,-16(fp)
  8166fc:	10bfffc4 	addi	r2,r2,-1
  816700:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  816704:	e0bffc17 	ldw	r2,-16(fp)
  816708:	1007883a 	mov	r3,r2
  81670c:	e0bffe17 	ldw	r2,-8(fp)
  816710:	1885883a 	add	r2,r3,r2
  816714:	10800003 	ldbu	r2,0(r2)
  816718:	10803fcc 	andi	r2,r2,255
  81671c:	1080201c 	xori	r2,r2,128
  816720:	10bfe004 	addi	r2,r2,-128
  816724:	10800be0 	cmpeqi	r2,r2,47
  816728:	10000a1e 	bne	r2,zero,816754 <alt_find_file+0xc0>
  81672c:	e0bffc17 	ldw	r2,-16(fp)
  816730:	1007883a 	mov	r3,r2
  816734:	e0bffe17 	ldw	r2,-8(fp)
  816738:	1885883a 	add	r2,r3,r2
  81673c:	10800003 	ldbu	r2,0(r2)
  816740:	10803fcc 	andi	r2,r2,255
  816744:	1080201c 	xori	r2,r2,128
  816748:	10bfe004 	addi	r2,r2,-128
  81674c:	1004c03a 	cmpne	r2,r2,zero
  816750:	10000a1e 	bne	r2,zero,81677c <alt_find_file+0xe8>
  816754:	e0bffd17 	ldw	r2,-12(fp)
  816758:	11000217 	ldw	r4,8(r2)
  81675c:	e1bffc17 	ldw	r6,-16(fp)
  816760:	e17ffe17 	ldw	r5,-8(fp)
  816764:	08169f80 	call	8169f8 <memcmp>
  816768:	1004c03a 	cmpne	r2,r2,zero
  81676c:	1000031e 	bne	r2,zero,81677c <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  816770:	e0bffd17 	ldw	r2,-12(fp)
  816774:	e0bfff15 	stw	r2,-4(fp)
  816778:	00000806 	br	81679c <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
  81677c:	e0bffd17 	ldw	r2,-12(fp)
  816780:	10800017 	ldw	r2,0(r2)
  816784:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  816788:	00c020b4 	movhi	r3,130
  81678c:	18e93704 	addi	r3,r3,-23332
  816790:	e0bffd17 	ldw	r2,-12(fp)
  816794:	10ffc91e 	bne	r2,r3,8166bc <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  816798:	e03fff15 	stw	zero,-4(fp)
  81679c:	e0bfff17 	ldw	r2,-4(fp)
}
  8167a0:	e037883a 	mov	sp,fp
  8167a4:	dfc00117 	ldw	ra,4(sp)
  8167a8:	df000017 	ldw	fp,0(sp)
  8167ac:	dec00204 	addi	sp,sp,8
  8167b0:	f800283a 	ret

008167b4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  8167b4:	defffa04 	addi	sp,sp,-24
  8167b8:	dfc00515 	stw	ra,20(sp)
  8167bc:	df000415 	stw	fp,16(sp)
  8167c0:	dc000315 	stw	r16,12(sp)
  8167c4:	df000304 	addi	fp,sp,12
  8167c8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  8167cc:	00bffa04 	movi	r2,-24
  8167d0:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  8167d4:	e03ffe15 	stw	zero,-8(fp)
  8167d8:	00002006 	br	81685c <alt_get_fd+0xa8>
  {
    if (!alt_fd_list[i].dev)
  8167dc:	e13ffe17 	ldw	r4,-8(fp)
  8167e0:	040020b4 	movhi	r16,130
  8167e4:	84248304 	addi	r16,r16,-28148
  8167e8:	01400304 	movi	r5,12
  8167ec:	08064840 	call	806484 <__mulsi3>
  8167f0:	1405883a 	add	r2,r2,r16
  8167f4:	10800017 	ldw	r2,0(r2)
  8167f8:	1004c03a 	cmpne	r2,r2,zero
  8167fc:	1000141e 	bne	r2,zero,816850 <alt_get_fd+0x9c>
    {
      alt_fd_list[i].dev = dev;
  816800:	e13ffe17 	ldw	r4,-8(fp)
  816804:	040020b4 	movhi	r16,130
  816808:	84248304 	addi	r16,r16,-28148
  81680c:	01400304 	movi	r5,12
  816810:	08064840 	call	806484 <__mulsi3>
  816814:	1407883a 	add	r3,r2,r16
  816818:	e0bfff17 	ldw	r2,-4(fp)
  81681c:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
  816820:	008020b4 	movhi	r2,130
  816824:	10a93b04 	addi	r2,r2,-23316
  816828:	10c00017 	ldw	r3,0(r2)
  81682c:	e0bffe17 	ldw	r2,-8(fp)
  816830:	1880040e 	bge	r3,r2,816844 <alt_get_fd+0x90>
      {
        alt_max_fd = i;
  816834:	00c020b4 	movhi	r3,130
  816838:	18e93b04 	addi	r3,r3,-23316
  81683c:	e0bffe17 	ldw	r2,-8(fp)
  816840:	18800015 	stw	r2,0(r3)
      }
      rc = i;
  816844:	e0bffe17 	ldw	r2,-8(fp)
  816848:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  81684c:	00000606 	br	816868 <alt_get_fd+0xb4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  816850:	e0bffe17 	ldw	r2,-8(fp)
  816854:	10800044 	addi	r2,r2,1
  816858:	e0bffe15 	stw	r2,-8(fp)
  81685c:	e0bffe17 	ldw	r2,-8(fp)
  816860:	10800810 	cmplti	r2,r2,32
  816864:	103fdd1e 	bne	r2,zero,8167dc <alt_get_fd+0x28>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  816868:	e0bffd17 	ldw	r2,-12(fp)
}
  81686c:	e037883a 	mov	sp,fp
  816870:	dfc00217 	ldw	ra,8(sp)
  816874:	df000117 	ldw	fp,4(sp)
  816878:	dc000017 	ldw	r16,0(sp)
  81687c:	dec00304 	addi	sp,sp,12
  816880:	f800283a 	ret

00816884 <atexit>:
  816884:	200b883a 	mov	r5,r4
  816888:	000d883a 	mov	r6,zero
  81688c:	0009883a 	mov	r4,zero
  816890:	000f883a 	mov	r7,zero
  816894:	0816e041 	jmpi	816e04 <__register_exitproc>

00816898 <exit>:
  816898:	defffe04 	addi	sp,sp,-8
  81689c:	000b883a 	mov	r5,zero
  8168a0:	dc000015 	stw	r16,0(sp)
  8168a4:	dfc00115 	stw	ra,4(sp)
  8168a8:	2021883a 	mov	r16,r4
  8168ac:	0816f3c0 	call	816f3c <__call_exitprocs>
  8168b0:	008020b4 	movhi	r2,130
  8168b4:	10a93204 	addi	r2,r2,-23352
  8168b8:	11000017 	ldw	r4,0(r2)
  8168bc:	20800f17 	ldw	r2,60(r4)
  8168c0:	10000126 	beq	r2,zero,8168c8 <exit+0x30>
  8168c4:	103ee83a 	callr	r2
  8168c8:	8009883a 	mov	r4,r16
  8168cc:	08173940 	call	817394 <_exit>

008168d0 <getc>:
  8168d0:	defffd04 	addi	sp,sp,-12
  8168d4:	dc400115 	stw	r17,4(sp)
  8168d8:	044020b4 	movhi	r17,130
  8168dc:	8c693104 	addi	r17,r17,-23356
  8168e0:	88c00017 	ldw	r3,0(r17)
  8168e4:	dc000015 	stw	r16,0(sp)
  8168e8:	dfc00215 	stw	ra,8(sp)
  8168ec:	2021883a 	mov	r16,r4
  8168f0:	18000326 	beq	r3,zero,816900 <getc+0x30>
  8168f4:	18800e17 	ldw	r2,56(r3)
  8168f8:	1809883a 	mov	r4,r3
  8168fc:	10000e26 	beq	r2,zero,816938 <getc+0x68>
  816900:	80800117 	ldw	r2,4(r16)
  816904:	800b883a 	mov	r5,r16
  816908:	10bfffc4 	addi	r2,r2,-1
  81690c:	80800115 	stw	r2,4(r16)
  816910:	10000f16 	blt	r2,zero,816950 <getc+0x80>
  816914:	80c00017 	ldw	r3,0(r16)
  816918:	18800003 	ldbu	r2,0(r3)
  81691c:	18c00044 	addi	r3,r3,1
  816920:	80c00015 	stw	r3,0(r16)
  816924:	dfc00217 	ldw	ra,8(sp)
  816928:	dc400117 	ldw	r17,4(sp)
  81692c:	dc000017 	ldw	r16,0(sp)
  816930:	dec00304 	addi	sp,sp,12
  816934:	f800283a 	ret
  816938:	080a1980 	call	80a198 <__sinit>
  81693c:	80800117 	ldw	r2,4(r16)
  816940:	800b883a 	mov	r5,r16
  816944:	10bfffc4 	addi	r2,r2,-1
  816948:	80800115 	stw	r2,4(r16)
  81694c:	103ff10e 	bge	r2,zero,816914 <getc+0x44>
  816950:	89000017 	ldw	r4,0(r17)
  816954:	dfc00217 	ldw	ra,8(sp)
  816958:	dc400117 	ldw	r17,4(sp)
  81695c:	dc000017 	ldw	r16,0(sp)
  816960:	dec00304 	addi	sp,sp,12
  816964:	0816c581 	jmpi	816c58 <__srget_r>

00816968 <_getc_r>:
  816968:	defffd04 	addi	sp,sp,-12
  81696c:	dc400115 	stw	r17,4(sp)
  816970:	dc000015 	stw	r16,0(sp)
  816974:	dfc00215 	stw	ra,8(sp)
  816978:	2021883a 	mov	r16,r4
  81697c:	2823883a 	mov	r17,r5
  816980:	20000226 	beq	r4,zero,81698c <_getc_r+0x24>
  816984:	20800e17 	ldw	r2,56(r4)
  816988:	10000f26 	beq	r2,zero,8169c8 <_getc_r+0x60>
  81698c:	88800117 	ldw	r2,4(r17)
  816990:	8009883a 	mov	r4,r16
  816994:	880b883a 	mov	r5,r17
  816998:	10bfffc4 	addi	r2,r2,-1
  81699c:	88800115 	stw	r2,4(r17)
  8169a0:	10001016 	blt	r2,zero,8169e4 <_getc_r+0x7c>
  8169a4:	88c00017 	ldw	r3,0(r17)
  8169a8:	18800003 	ldbu	r2,0(r3)
  8169ac:	18c00044 	addi	r3,r3,1
  8169b0:	88c00015 	stw	r3,0(r17)
  8169b4:	dfc00217 	ldw	ra,8(sp)
  8169b8:	dc400117 	ldw	r17,4(sp)
  8169bc:	dc000017 	ldw	r16,0(sp)
  8169c0:	dec00304 	addi	sp,sp,12
  8169c4:	f800283a 	ret
  8169c8:	080a1980 	call	80a198 <__sinit>
  8169cc:	88800117 	ldw	r2,4(r17)
  8169d0:	8009883a 	mov	r4,r16
  8169d4:	880b883a 	mov	r5,r17
  8169d8:	10bfffc4 	addi	r2,r2,-1
  8169dc:	88800115 	stw	r2,4(r17)
  8169e0:	103ff00e 	bge	r2,zero,8169a4 <_getc_r+0x3c>
  8169e4:	dfc00217 	ldw	ra,8(sp)
  8169e8:	dc400117 	ldw	r17,4(sp)
  8169ec:	dc000017 	ldw	r16,0(sp)
  8169f0:	dec00304 	addi	sp,sp,12
  8169f4:	0816c581 	jmpi	816c58 <__srget_r>

008169f8 <memcmp>:
  8169f8:	00c000c4 	movi	r3,3
  8169fc:	1980032e 	bgeu	r3,r6,816a0c <memcmp+0x14>
  816a00:	2144b03a 	or	r2,r4,r5
  816a04:	10c4703a 	and	r2,r2,r3
  816a08:	10000f26 	beq	r2,zero,816a48 <memcmp+0x50>
  816a0c:	31ffffc4 	addi	r7,r6,-1
  816a10:	3000061e 	bne	r6,zero,816a2c <memcmp+0x34>
  816a14:	00000a06 	br	816a40 <memcmp+0x48>
  816a18:	39ffffc4 	addi	r7,r7,-1
  816a1c:	00bfffc4 	movi	r2,-1
  816a20:	21000044 	addi	r4,r4,1
  816a24:	29400044 	addi	r5,r5,1
  816a28:	38800526 	beq	r7,r2,816a40 <memcmp+0x48>
  816a2c:	20c00003 	ldbu	r3,0(r4)
  816a30:	28800003 	ldbu	r2,0(r5)
  816a34:	18bff826 	beq	r3,r2,816a18 <memcmp+0x20>
  816a38:	1885c83a 	sub	r2,r3,r2
  816a3c:	f800283a 	ret
  816a40:	0005883a 	mov	r2,zero
  816a44:	f800283a 	ret
  816a48:	180f883a 	mov	r7,r3
  816a4c:	20c00017 	ldw	r3,0(r4)
  816a50:	28800017 	ldw	r2,0(r5)
  816a54:	18bfed1e 	bne	r3,r2,816a0c <memcmp+0x14>
  816a58:	31bfff04 	addi	r6,r6,-4
  816a5c:	21000104 	addi	r4,r4,4
  816a60:	29400104 	addi	r5,r5,4
  816a64:	39bff936 	bltu	r7,r6,816a4c <memcmp+0x54>
  816a68:	003fe806 	br	816a0c <memcmp+0x14>

00816a6c <putc>:
  816a6c:	defffc04 	addi	sp,sp,-16
  816a70:	dc800215 	stw	r18,8(sp)
  816a74:	048020b4 	movhi	r18,130
  816a78:	94a93104 	addi	r18,r18,-23356
  816a7c:	90c00017 	ldw	r3,0(r18)
  816a80:	dc400115 	stw	r17,4(sp)
  816a84:	dc000015 	stw	r16,0(sp)
  816a88:	dfc00315 	stw	ra,12(sp)
  816a8c:	2023883a 	mov	r17,r4
  816a90:	2821883a 	mov	r16,r5
  816a94:	18000226 	beq	r3,zero,816aa0 <putc+0x34>
  816a98:	18800e17 	ldw	r2,56(r3)
  816a9c:	10001126 	beq	r2,zero,816ae4 <putc+0x78>
  816aa0:	80800217 	ldw	r2,8(r16)
  816aa4:	10ffffc4 	addi	r3,r2,-1
  816aa8:	80c00215 	stw	r3,8(r16)
  816aac:	18001316 	blt	r3,zero,816afc <putc+0x90>
  816ab0:	80800017 	ldw	r2,0(r16)
  816ab4:	14400005 	stb	r17,0(r2)
  816ab8:	80c00017 	ldw	r3,0(r16)
  816abc:	18800044 	addi	r2,r3,1
  816ac0:	18c00003 	ldbu	r3,0(r3)
  816ac4:	80800015 	stw	r2,0(r16)
  816ac8:	1805883a 	mov	r2,r3
  816acc:	dfc00317 	ldw	ra,12(sp)
  816ad0:	dc800217 	ldw	r18,8(sp)
  816ad4:	dc400117 	ldw	r17,4(sp)
  816ad8:	dc000017 	ldw	r16,0(sp)
  816adc:	dec00404 	addi	sp,sp,16
  816ae0:	f800283a 	ret
  816ae4:	1809883a 	mov	r4,r3
  816ae8:	080a1980 	call	80a198 <__sinit>
  816aec:	80800217 	ldw	r2,8(r16)
  816af0:	10ffffc4 	addi	r3,r2,-1
  816af4:	80c00215 	stw	r3,8(r16)
  816af8:	183fed0e 	bge	r3,zero,816ab0 <putc+0x44>
  816afc:	80800617 	ldw	r2,24(r16)
  816b00:	18800f16 	blt	r3,r2,816b40 <putc+0xd4>
  816b04:	80800017 	ldw	r2,0(r16)
  816b08:	14400005 	stb	r17,0(r2)
  816b0c:	81000017 	ldw	r4,0(r16)
  816b10:	00800284 	movi	r2,10
  816b14:	20c00003 	ldbu	r3,0(r4)
  816b18:	18801226 	beq	r3,r2,816b64 <putc+0xf8>
  816b1c:	20800044 	addi	r2,r4,1
  816b20:	80800015 	stw	r2,0(r16)
  816b24:	1805883a 	mov	r2,r3
  816b28:	dfc00317 	ldw	ra,12(sp)
  816b2c:	dc800217 	ldw	r18,8(sp)
  816b30:	dc400117 	ldw	r17,4(sp)
  816b34:	dc000017 	ldw	r16,0(sp)
  816b38:	dec00404 	addi	sp,sp,16
  816b3c:	f800283a 	ret
  816b40:	91000017 	ldw	r4,0(r18)
  816b44:	880b883a 	mov	r5,r17
  816b48:	800d883a 	mov	r6,r16
  816b4c:	dfc00317 	ldw	ra,12(sp)
  816b50:	dc800217 	ldw	r18,8(sp)
  816b54:	dc400117 	ldw	r17,4(sp)
  816b58:	dc000017 	ldw	r16,0(sp)
  816b5c:	dec00404 	addi	sp,sp,16
  816b60:	0816cb81 	jmpi	816cb8 <__swbuf_r>
  816b64:	91000017 	ldw	r4,0(r18)
  816b68:	180b883a 	mov	r5,r3
  816b6c:	003ff606 	br	816b48 <putc+0xdc>

00816b70 <_putc_r>:
  816b70:	defffc04 	addi	sp,sp,-16
  816b74:	dc400215 	stw	r17,8(sp)
  816b78:	dc000115 	stw	r16,4(sp)
  816b7c:	dfc00315 	stw	ra,12(sp)
  816b80:	2021883a 	mov	r16,r4
  816b84:	2823883a 	mov	r17,r5
  816b88:	20000226 	beq	r4,zero,816b94 <_putc_r+0x24>
  816b8c:	20800e17 	ldw	r2,56(r4)
  816b90:	10001026 	beq	r2,zero,816bd4 <_putc_r+0x64>
  816b94:	30800217 	ldw	r2,8(r6)
  816b98:	10ffffc4 	addi	r3,r2,-1
  816b9c:	30c00215 	stw	r3,8(r6)
  816ba0:	18001316 	blt	r3,zero,816bf0 <_putc_r+0x80>
  816ba4:	30800017 	ldw	r2,0(r6)
  816ba8:	14400005 	stb	r17,0(r2)
  816bac:	30c00017 	ldw	r3,0(r6)
  816bb0:	18800044 	addi	r2,r3,1
  816bb4:	18c00003 	ldbu	r3,0(r3)
  816bb8:	30800015 	stw	r2,0(r6)
  816bbc:	1805883a 	mov	r2,r3
  816bc0:	dfc00317 	ldw	ra,12(sp)
  816bc4:	dc400217 	ldw	r17,8(sp)
  816bc8:	dc000117 	ldw	r16,4(sp)
  816bcc:	dec00404 	addi	sp,sp,16
  816bd0:	f800283a 	ret
  816bd4:	d9800015 	stw	r6,0(sp)
  816bd8:	080a1980 	call	80a198 <__sinit>
  816bdc:	d9800017 	ldw	r6,0(sp)
  816be0:	30800217 	ldw	r2,8(r6)
  816be4:	10ffffc4 	addi	r3,r2,-1
  816be8:	30c00215 	stw	r3,8(r6)
  816bec:	183fed0e 	bge	r3,zero,816ba4 <_putc_r+0x34>
  816bf0:	30800617 	ldw	r2,24(r6)
  816bf4:	18800e16 	blt	r3,r2,816c30 <_putc_r+0xc0>
  816bf8:	30800017 	ldw	r2,0(r6)
  816bfc:	14400005 	stb	r17,0(r2)
  816c00:	31000017 	ldw	r4,0(r6)
  816c04:	00800284 	movi	r2,10
  816c08:	20c00003 	ldbu	r3,0(r4)
  816c0c:	18800f26 	beq	r3,r2,816c4c <_putc_r+0xdc>
  816c10:	20800044 	addi	r2,r4,1
  816c14:	30800015 	stw	r2,0(r6)
  816c18:	1805883a 	mov	r2,r3
  816c1c:	dfc00317 	ldw	ra,12(sp)
  816c20:	dc400217 	ldw	r17,8(sp)
  816c24:	dc000117 	ldw	r16,4(sp)
  816c28:	dec00404 	addi	sp,sp,16
  816c2c:	f800283a 	ret
  816c30:	8009883a 	mov	r4,r16
  816c34:	880b883a 	mov	r5,r17
  816c38:	dfc00317 	ldw	ra,12(sp)
  816c3c:	dc400217 	ldw	r17,8(sp)
  816c40:	dc000117 	ldw	r16,4(sp)
  816c44:	dec00404 	addi	sp,sp,16
  816c48:	0816cb81 	jmpi	816cb8 <__swbuf_r>
  816c4c:	8009883a 	mov	r4,r16
  816c50:	180b883a 	mov	r5,r3
  816c54:	003ff806 	br	816c38 <_putc_r+0xc8>

00816c58 <__srget_r>:
  816c58:	defffe04 	addi	sp,sp,-8
  816c5c:	dc000015 	stw	r16,0(sp)
  816c60:	dfc00115 	stw	ra,4(sp)
  816c64:	2821883a 	mov	r16,r5
  816c68:	08170ec0 	call	8170ec <__srefill_r>
  816c6c:	013fffc4 	movi	r4,-1
  816c70:	1000071e 	bne	r2,zero,816c90 <__srget_r+0x38>
  816c74:	80800117 	ldw	r2,4(r16)
  816c78:	81000017 	ldw	r4,0(r16)
  816c7c:	10bfffc4 	addi	r2,r2,-1
  816c80:	20c00044 	addi	r3,r4,1
  816c84:	80800115 	stw	r2,4(r16)
  816c88:	21000003 	ldbu	r4,0(r4)
  816c8c:	80c00015 	stw	r3,0(r16)
  816c90:	2005883a 	mov	r2,r4
  816c94:	dfc00117 	ldw	ra,4(sp)
  816c98:	dc000017 	ldw	r16,0(sp)
  816c9c:	dec00204 	addi	sp,sp,8
  816ca0:	f800283a 	ret

00816ca4 <__srget>:
  816ca4:	008020b4 	movhi	r2,130
  816ca8:	10a93104 	addi	r2,r2,-23356
  816cac:	200b883a 	mov	r5,r4
  816cb0:	11000017 	ldw	r4,0(r2)
  816cb4:	0816c581 	jmpi	816c58 <__srget_r>

00816cb8 <__swbuf_r>:
  816cb8:	defffc04 	addi	sp,sp,-16
  816cbc:	dc400215 	stw	r17,8(sp)
  816cc0:	dc000115 	stw	r16,4(sp)
  816cc4:	dfc00315 	stw	ra,12(sp)
  816cc8:	2023883a 	mov	r17,r4
  816ccc:	2821883a 	mov	r16,r5
  816cd0:	20000226 	beq	r4,zero,816cdc <__swbuf_r+0x24>
  816cd4:	20800e17 	ldw	r2,56(r4)
  816cd8:	10002f26 	beq	r2,zero,816d98 <__swbuf_r+0xe0>
  816cdc:	3080030b 	ldhu	r2,12(r6)
  816ce0:	30c00617 	ldw	r3,24(r6)
  816ce4:	1080020c 	andi	r2,r2,8
  816ce8:	30c00215 	stw	r3,8(r6)
  816cec:	10002226 	beq	r2,zero,816d78 <__swbuf_r+0xc0>
  816cf0:	30c00417 	ldw	r3,16(r6)
  816cf4:	18002026 	beq	r3,zero,816d78 <__swbuf_r+0xc0>
  816cf8:	31000017 	ldw	r4,0(r6)
  816cfc:	30800517 	ldw	r2,20(r6)
  816d00:	20c7c83a 	sub	r3,r4,r3
  816d04:	18802f0e 	bge	r3,r2,816dc4 <__swbuf_r+0x10c>
  816d08:	19400044 	addi	r5,r3,1
  816d0c:	30800217 	ldw	r2,8(r6)
  816d10:	84003fcc 	andi	r16,r16,255
  816d14:	20c00044 	addi	r3,r4,1
  816d18:	10bfffc4 	addi	r2,r2,-1
  816d1c:	30800215 	stw	r2,8(r6)
  816d20:	24000005 	stb	r16,0(r4)
  816d24:	30800517 	ldw	r2,20(r6)
  816d28:	30c00015 	stw	r3,0(r6)
  816d2c:	11400c26 	beq	r2,r5,816d60 <__swbuf_r+0xa8>
  816d30:	3080030b 	ldhu	r2,12(r6)
  816d34:	1080004c 	andi	r2,r2,1
  816d38:	1005003a 	cmpeq	r2,r2,zero
  816d3c:	10000626 	beq	r2,zero,816d58 <__swbuf_r+0xa0>
  816d40:	8005883a 	mov	r2,r16
  816d44:	dfc00317 	ldw	ra,12(sp)
  816d48:	dc400217 	ldw	r17,8(sp)
  816d4c:	dc000117 	ldw	r16,4(sp)
  816d50:	dec00404 	addi	sp,sp,16
  816d54:	f800283a 	ret
  816d58:	00800284 	movi	r2,10
  816d5c:	80bff81e 	bne	r16,r2,816d40 <__swbuf_r+0x88>
  816d60:	8809883a 	mov	r4,r17
  816d64:	300b883a 	mov	r5,r6
  816d68:	0809f000 	call	809f00 <_fflush_r>
  816d6c:	103ff426 	beq	r2,zero,816d40 <__swbuf_r+0x88>
  816d70:	043fffc4 	movi	r16,-1
  816d74:	003ff206 	br	816d40 <__swbuf_r+0x88>
  816d78:	300b883a 	mov	r5,r6
  816d7c:	8809883a 	mov	r4,r17
  816d80:	d9800015 	stw	r6,0(sp)
  816d84:	08085cc0 	call	8085cc <__swsetup_r>
  816d88:	d9800017 	ldw	r6,0(sp)
  816d8c:	1000061e 	bne	r2,zero,816da8 <__swbuf_r+0xf0>
  816d90:	30c00417 	ldw	r3,16(r6)
  816d94:	003fd806 	br	816cf8 <__swbuf_r+0x40>
  816d98:	d9800015 	stw	r6,0(sp)
  816d9c:	080a1980 	call	80a198 <__sinit>
  816da0:	d9800017 	ldw	r6,0(sp)
  816da4:	003fcd06 	br	816cdc <__swbuf_r+0x24>
  816da8:	3080030b 	ldhu	r2,12(r6)
  816dac:	00c00244 	movi	r3,9
  816db0:	043fffc4 	movi	r16,-1
  816db4:	10801014 	ori	r2,r2,64
  816db8:	3080030d 	sth	r2,12(r6)
  816dbc:	88c00015 	stw	r3,0(r17)
  816dc0:	003fdf06 	br	816d40 <__swbuf_r+0x88>
  816dc4:	300b883a 	mov	r5,r6
  816dc8:	8809883a 	mov	r4,r17
  816dcc:	d9800015 	stw	r6,0(sp)
  816dd0:	0809f000 	call	809f00 <_fflush_r>
  816dd4:	d9800017 	ldw	r6,0(sp)
  816dd8:	103fe51e 	bne	r2,zero,816d70 <__swbuf_r+0xb8>
  816ddc:	31000017 	ldw	r4,0(r6)
  816de0:	01400044 	movi	r5,1
  816de4:	003fc906 	br	816d0c <__swbuf_r+0x54>

00816de8 <__swbuf>:
  816de8:	018020b4 	movhi	r6,130
  816dec:	31a93104 	addi	r6,r6,-23356
  816df0:	2007883a 	mov	r3,r4
  816df4:	31000017 	ldw	r4,0(r6)
  816df8:	280d883a 	mov	r6,r5
  816dfc:	180b883a 	mov	r5,r3
  816e00:	0816cb81 	jmpi	816cb8 <__swbuf_r>

00816e04 <__register_exitproc>:
  816e04:	defffa04 	addi	sp,sp,-24
  816e08:	008020b4 	movhi	r2,130
  816e0c:	10a93204 	addi	r2,r2,-23352
  816e10:	dc000015 	stw	r16,0(sp)
  816e14:	14000017 	ldw	r16,0(r2)
  816e18:	dd000415 	stw	r20,16(sp)
  816e1c:	2829883a 	mov	r20,r5
  816e20:	81405217 	ldw	r5,328(r16)
  816e24:	dcc00315 	stw	r19,12(sp)
  816e28:	dc800215 	stw	r18,8(sp)
  816e2c:	dc400115 	stw	r17,4(sp)
  816e30:	dfc00515 	stw	ra,20(sp)
  816e34:	2023883a 	mov	r17,r4
  816e38:	3027883a 	mov	r19,r6
  816e3c:	3825883a 	mov	r18,r7
  816e40:	28002526 	beq	r5,zero,816ed8 <__register_exitproc+0xd4>
  816e44:	29000117 	ldw	r4,4(r5)
  816e48:	008007c4 	movi	r2,31
  816e4c:	11002716 	blt	r2,r4,816eec <__register_exitproc+0xe8>
  816e50:	8800101e 	bne	r17,zero,816e94 <__register_exitproc+0x90>
  816e54:	2105883a 	add	r2,r4,r4
  816e58:	1085883a 	add	r2,r2,r2
  816e5c:	20c00044 	addi	r3,r4,1
  816e60:	1145883a 	add	r2,r2,r5
  816e64:	0009883a 	mov	r4,zero
  816e68:	15000215 	stw	r20,8(r2)
  816e6c:	28c00115 	stw	r3,4(r5)
  816e70:	2005883a 	mov	r2,r4
  816e74:	dfc00517 	ldw	ra,20(sp)
  816e78:	dd000417 	ldw	r20,16(sp)
  816e7c:	dcc00317 	ldw	r19,12(sp)
  816e80:	dc800217 	ldw	r18,8(sp)
  816e84:	dc400117 	ldw	r17,4(sp)
  816e88:	dc000017 	ldw	r16,0(sp)
  816e8c:	dec00604 	addi	sp,sp,24
  816e90:	f800283a 	ret
  816e94:	29802204 	addi	r6,r5,136
  816e98:	00800044 	movi	r2,1
  816e9c:	110e983a 	sll	r7,r2,r4
  816ea0:	30c04017 	ldw	r3,256(r6)
  816ea4:	2105883a 	add	r2,r4,r4
  816ea8:	1085883a 	add	r2,r2,r2
  816eac:	1185883a 	add	r2,r2,r6
  816eb0:	19c6b03a 	or	r3,r3,r7
  816eb4:	14802015 	stw	r18,128(r2)
  816eb8:	14c00015 	stw	r19,0(r2)
  816ebc:	00800084 	movi	r2,2
  816ec0:	30c04015 	stw	r3,256(r6)
  816ec4:	88bfe31e 	bne	r17,r2,816e54 <__register_exitproc+0x50>
  816ec8:	30804117 	ldw	r2,260(r6)
  816ecc:	11c4b03a 	or	r2,r2,r7
  816ed0:	30804115 	stw	r2,260(r6)
  816ed4:	003fdf06 	br	816e54 <__register_exitproc+0x50>
  816ed8:	00802134 	movhi	r2,132
  816edc:	10bb5804 	addi	r2,r2,-4768
  816ee0:	100b883a 	mov	r5,r2
  816ee4:	80805215 	stw	r2,328(r16)
  816ee8:	003fd606 	br	816e44 <__register_exitproc+0x40>
  816eec:	00800034 	movhi	r2,0
  816ef0:	10800004 	addi	r2,r2,0
  816ef4:	1000021e 	bne	r2,zero,816f00 <__register_exitproc+0xfc>
  816ef8:	013fffc4 	movi	r4,-1
  816efc:	003fdc06 	br	816e70 <__register_exitproc+0x6c>
  816f00:	01006404 	movi	r4,400
  816f04:	103ee83a 	callr	r2
  816f08:	1007883a 	mov	r3,r2
  816f0c:	103ffa26 	beq	r2,zero,816ef8 <__register_exitproc+0xf4>
  816f10:	80805217 	ldw	r2,328(r16)
  816f14:	180b883a 	mov	r5,r3
  816f18:	18000115 	stw	zero,4(r3)
  816f1c:	18800015 	stw	r2,0(r3)
  816f20:	80c05215 	stw	r3,328(r16)
  816f24:	18006215 	stw	zero,392(r3)
  816f28:	18006315 	stw	zero,396(r3)
  816f2c:	0009883a 	mov	r4,zero
  816f30:	883fc826 	beq	r17,zero,816e54 <__register_exitproc+0x50>
  816f34:	003fd706 	br	816e94 <__register_exitproc+0x90>

00816f38 <register_fini>:
  816f38:	f800283a 	ret

00816f3c <__call_exitprocs>:
  816f3c:	008020b4 	movhi	r2,130
  816f40:	10a93204 	addi	r2,r2,-23352
  816f44:	10800017 	ldw	r2,0(r2)
  816f48:	defff304 	addi	sp,sp,-52
  816f4c:	df000b15 	stw	fp,44(sp)
  816f50:	d8800115 	stw	r2,4(sp)
  816f54:	00800034 	movhi	r2,0
  816f58:	10800004 	addi	r2,r2,0
  816f5c:	1005003a 	cmpeq	r2,r2,zero
  816f60:	d8800215 	stw	r2,8(sp)
  816f64:	d8800117 	ldw	r2,4(sp)
  816f68:	dd400815 	stw	r21,32(sp)
  816f6c:	dd000715 	stw	r20,28(sp)
  816f70:	10805204 	addi	r2,r2,328
  816f74:	dfc00c15 	stw	ra,48(sp)
  816f78:	ddc00a15 	stw	r23,40(sp)
  816f7c:	dd800915 	stw	r22,36(sp)
  816f80:	dcc00615 	stw	r19,24(sp)
  816f84:	dc800515 	stw	r18,20(sp)
  816f88:	dc400415 	stw	r17,16(sp)
  816f8c:	dc000315 	stw	r16,12(sp)
  816f90:	282b883a 	mov	r21,r5
  816f94:	2039883a 	mov	fp,r4
  816f98:	d8800015 	stw	r2,0(sp)
  816f9c:	2829003a 	cmpeq	r20,r5,zero
  816fa0:	d8800117 	ldw	r2,4(sp)
  816fa4:	14405217 	ldw	r17,328(r2)
  816fa8:	88001026 	beq	r17,zero,816fec <__call_exitprocs+0xb0>
  816fac:	ddc00017 	ldw	r23,0(sp)
  816fb0:	88800117 	ldw	r2,4(r17)
  816fb4:	8c802204 	addi	r18,r17,136
  816fb8:	143fffc4 	addi	r16,r2,-1
  816fbc:	80000916 	blt	r16,zero,816fe4 <__call_exitprocs+0xa8>
  816fc0:	05bfffc4 	movi	r22,-1
  816fc4:	a000151e 	bne	r20,zero,81701c <__call_exitprocs+0xe0>
  816fc8:	8409883a 	add	r4,r16,r16
  816fcc:	2105883a 	add	r2,r4,r4
  816fd0:	1485883a 	add	r2,r2,r18
  816fd4:	10c02017 	ldw	r3,128(r2)
  816fd8:	a8c01126 	beq	r21,r3,817020 <__call_exitprocs+0xe4>
  816fdc:	843fffc4 	addi	r16,r16,-1
  816fe0:	85bff81e 	bne	r16,r22,816fc4 <__call_exitprocs+0x88>
  816fe4:	d8800217 	ldw	r2,8(sp)
  816fe8:	10003126 	beq	r2,zero,8170b0 <__call_exitprocs+0x174>
  816fec:	dfc00c17 	ldw	ra,48(sp)
  816ff0:	df000b17 	ldw	fp,44(sp)
  816ff4:	ddc00a17 	ldw	r23,40(sp)
  816ff8:	dd800917 	ldw	r22,36(sp)
  816ffc:	dd400817 	ldw	r21,32(sp)
  817000:	dd000717 	ldw	r20,28(sp)
  817004:	dcc00617 	ldw	r19,24(sp)
  817008:	dc800517 	ldw	r18,20(sp)
  81700c:	dc400417 	ldw	r17,16(sp)
  817010:	dc000317 	ldw	r16,12(sp)
  817014:	dec00d04 	addi	sp,sp,52
  817018:	f800283a 	ret
  81701c:	8409883a 	add	r4,r16,r16
  817020:	88c00117 	ldw	r3,4(r17)
  817024:	2105883a 	add	r2,r4,r4
  817028:	1445883a 	add	r2,r2,r17
  81702c:	18ffffc4 	addi	r3,r3,-1
  817030:	11800217 	ldw	r6,8(r2)
  817034:	1c001526 	beq	r3,r16,81708c <__call_exitprocs+0x150>
  817038:	10000215 	stw	zero,8(r2)
  81703c:	303fe726 	beq	r6,zero,816fdc <__call_exitprocs+0xa0>
  817040:	00c00044 	movi	r3,1
  817044:	1c06983a 	sll	r3,r3,r16
  817048:	90804017 	ldw	r2,256(r18)
  81704c:	8cc00117 	ldw	r19,4(r17)
  817050:	1884703a 	and	r2,r3,r2
  817054:	10001426 	beq	r2,zero,8170a8 <__call_exitprocs+0x16c>
  817058:	90804117 	ldw	r2,260(r18)
  81705c:	1884703a 	and	r2,r3,r2
  817060:	10000c1e 	bne	r2,zero,817094 <__call_exitprocs+0x158>
  817064:	2105883a 	add	r2,r4,r4
  817068:	1485883a 	add	r2,r2,r18
  81706c:	11400017 	ldw	r5,0(r2)
  817070:	e009883a 	mov	r4,fp
  817074:	303ee83a 	callr	r6
  817078:	88800117 	ldw	r2,4(r17)
  81707c:	98bfc81e 	bne	r19,r2,816fa0 <__call_exitprocs+0x64>
  817080:	b8800017 	ldw	r2,0(r23)
  817084:	147fd526 	beq	r2,r17,816fdc <__call_exitprocs+0xa0>
  817088:	003fc506 	br	816fa0 <__call_exitprocs+0x64>
  81708c:	8c000115 	stw	r16,4(r17)
  817090:	003fea06 	br	81703c <__call_exitprocs+0x100>
  817094:	2105883a 	add	r2,r4,r4
  817098:	1485883a 	add	r2,r2,r18
  81709c:	11000017 	ldw	r4,0(r2)
  8170a0:	303ee83a 	callr	r6
  8170a4:	003ff406 	br	817078 <__call_exitprocs+0x13c>
  8170a8:	303ee83a 	callr	r6
  8170ac:	003ff206 	br	817078 <__call_exitprocs+0x13c>
  8170b0:	88800117 	ldw	r2,4(r17)
  8170b4:	1000081e 	bne	r2,zero,8170d8 <__call_exitprocs+0x19c>
  8170b8:	89000017 	ldw	r4,0(r17)
  8170bc:	20000726 	beq	r4,zero,8170dc <__call_exitprocs+0x1a0>
  8170c0:	b9000015 	stw	r4,0(r23)
  8170c4:	8809883a 	mov	r4,r17
  8170c8:	00000000 	call	0 <__reset-0x800000>
  8170cc:	bc400017 	ldw	r17,0(r23)
  8170d0:	883fb71e 	bne	r17,zero,816fb0 <__call_exitprocs+0x74>
  8170d4:	003fc506 	br	816fec <__call_exitprocs+0xb0>
  8170d8:	89000017 	ldw	r4,0(r17)
  8170dc:	882f883a 	mov	r23,r17
  8170e0:	2023883a 	mov	r17,r4
  8170e4:	883fb21e 	bne	r17,zero,816fb0 <__call_exitprocs+0x74>
  8170e8:	003fc006 	br	816fec <__call_exitprocs+0xb0>

008170ec <__srefill_r>:
  8170ec:	defffd04 	addi	sp,sp,-12
  8170f0:	dc400115 	stw	r17,4(sp)
  8170f4:	dc000015 	stw	r16,0(sp)
  8170f8:	dfc00215 	stw	ra,8(sp)
  8170fc:	2023883a 	mov	r17,r4
  817100:	2821883a 	mov	r16,r5
  817104:	20000226 	beq	r4,zero,817110 <__srefill_r+0x24>
  817108:	20800e17 	ldw	r2,56(r4)
  81710c:	10004126 	beq	r2,zero,817214 <__srefill_r+0x128>
  817110:	80c0030b 	ldhu	r3,12(r16)
  817114:	80000115 	stw	zero,4(r16)
  817118:	1880080c 	andi	r2,r3,32
  81711c:	1000361e 	bne	r2,zero,8171f8 <__srefill_r+0x10c>
  817120:	1880010c 	andi	r2,r3,4
  817124:	1000211e 	bne	r2,zero,8171ac <__srefill_r+0xc0>
  817128:	1880040c 	andi	r2,r3,16
  81712c:	10005026 	beq	r2,zero,817270 <__srefill_r+0x184>
  817130:	1880020c 	andi	r2,r3,8
  817134:	1000541e 	bne	r2,zero,817288 <__srefill_r+0x19c>
  817138:	8080030b 	ldhu	r2,12(r16)
  81713c:	10800114 	ori	r2,r2,4
  817140:	8080030d 	sth	r2,12(r16)
  817144:	80800417 	ldw	r2,16(r16)
  817148:	10004526 	beq	r2,zero,817260 <__srefill_r+0x174>
  81714c:	8080030b 	ldhu	r2,12(r16)
  817150:	108000cc 	andi	r2,r2,3
  817154:	1000361e 	bne	r2,zero,817230 <__srefill_r+0x144>
  817158:	81800417 	ldw	r6,16(r16)
  81715c:	80c00817 	ldw	r3,32(r16)
  817160:	81400717 	ldw	r5,28(r16)
  817164:	81c00517 	ldw	r7,20(r16)
  817168:	8809883a 	mov	r4,r17
  81716c:	81800015 	stw	r6,0(r16)
  817170:	183ee83a 	callr	r3
  817174:	80c0030b 	ldhu	r3,12(r16)
  817178:	1009883a 	mov	r4,r2
  81717c:	80800115 	stw	r2,4(r16)
  817180:	00b7ffc4 	movi	r2,-8193
  817184:	1884703a 	and	r2,r3,r2
  817188:	8080030d 	sth	r2,12(r16)
  81718c:	0100230e 	bge	zero,r4,81721c <__srefill_r+0x130>
  817190:	0009883a 	mov	r4,zero
  817194:	2005883a 	mov	r2,r4
  817198:	dfc00217 	ldw	ra,8(sp)
  81719c:	dc400117 	ldw	r17,4(sp)
  8171a0:	dc000017 	ldw	r16,0(sp)
  8171a4:	dec00304 	addi	sp,sp,12
  8171a8:	f800283a 	ret
  8171ac:	81400c17 	ldw	r5,48(r16)
  8171b0:	283fe426 	beq	r5,zero,817144 <__srefill_r+0x58>
  8171b4:	80801004 	addi	r2,r16,64
  8171b8:	28800226 	beq	r5,r2,8171c4 <__srefill_r+0xd8>
  8171bc:	8809883a 	mov	r4,r17
  8171c0:	080a5500 	call	80a550 <_free_r>
  8171c4:	80800f17 	ldw	r2,60(r16)
  8171c8:	80000c15 	stw	zero,48(r16)
  8171cc:	80800115 	stw	r2,4(r16)
  8171d0:	103fdc26 	beq	r2,zero,817144 <__srefill_r+0x58>
  8171d4:	80800e17 	ldw	r2,56(r16)
  8171d8:	0009883a 	mov	r4,zero
  8171dc:	80800015 	stw	r2,0(r16)
  8171e0:	2005883a 	mov	r2,r4
  8171e4:	dfc00217 	ldw	ra,8(sp)
  8171e8:	dc400117 	ldw	r17,4(sp)
  8171ec:	dc000017 	ldw	r16,0(sp)
  8171f0:	dec00304 	addi	sp,sp,12
  8171f4:	f800283a 	ret
  8171f8:	013fffc4 	movi	r4,-1
  8171fc:	2005883a 	mov	r2,r4
  817200:	dfc00217 	ldw	ra,8(sp)
  817204:	dc400117 	ldw	r17,4(sp)
  817208:	dc000017 	ldw	r16,0(sp)
  81720c:	dec00304 	addi	sp,sp,12
  817210:	f800283a 	ret
  817214:	080a1980 	call	80a198 <__sinit>
  817218:	003fbd06 	br	817110 <__srefill_r+0x24>
  81721c:	20000b1e 	bne	r4,zero,81724c <__srefill_r+0x160>
  817220:	10800814 	ori	r2,r2,32
  817224:	013fffc4 	movi	r4,-1
  817228:	8080030d 	sth	r2,12(r16)
  81722c:	003fd906 	br	817194 <__srefill_r+0xa8>
  817230:	008020b4 	movhi	r2,130
  817234:	10a93204 	addi	r2,r2,-23352
  817238:	11000017 	ldw	r4,0(r2)
  81723c:	01402074 	movhi	r5,129
  817240:	295cac04 	addi	r5,r5,29360
  817244:	080adc80 	call	80adc8 <_fwalk>
  817248:	003fc306 	br	817158 <__srefill_r+0x6c>
  81724c:	10801014 	ori	r2,r2,64
  817250:	013fffc4 	movi	r4,-1
  817254:	8080030d 	sth	r2,12(r16)
  817258:	80000115 	stw	zero,4(r16)
  81725c:	003fcd06 	br	817194 <__srefill_r+0xa8>
  817260:	8809883a 	mov	r4,r17
  817264:	800b883a 	mov	r5,r16
  817268:	080af440 	call	80af44 <__smakebuf_r>
  81726c:	003fb706 	br	81714c <__srefill_r+0x60>
  817270:	18c01014 	ori	r3,r3,64
  817274:	00800244 	movi	r2,9
  817278:	013fffc4 	movi	r4,-1
  81727c:	88800015 	stw	r2,0(r17)
  817280:	80c0030d 	sth	r3,12(r16)
  817284:	003fc306 	br	817194 <__srefill_r+0xa8>
  817288:	8809883a 	mov	r4,r17
  81728c:	800b883a 	mov	r5,r16
  817290:	0809f000 	call	809f00 <_fflush_r>
  817294:	103fd81e 	bne	r2,zero,8171f8 <__srefill_r+0x10c>
  817298:	8080030b 	ldhu	r2,12(r16)
  81729c:	80000215 	stw	zero,8(r16)
  8172a0:	80000615 	stw	zero,24(r16)
  8172a4:	10bffdcc 	andi	r2,r2,65527
  8172a8:	8080030d 	sth	r2,12(r16)
  8172ac:	003fa206 	br	817138 <__srefill_r+0x4c>

008172b0 <lflush>:
  8172b0:	20c0030b 	ldhu	r3,12(r4)
  8172b4:	01400244 	movi	r5,9
  8172b8:	0005883a 	mov	r2,zero
  8172bc:	18c0024c 	andi	r3,r3,9
  8172c0:	19400126 	beq	r3,r5,8172c8 <lflush+0x18>
  8172c4:	f800283a 	ret
  8172c8:	080a0fc1 	jmpi	80a0fc <fflush>

008172cc <__floatundidf>:
  8172cc:	defffb04 	addi	sp,sp,-20
  8172d0:	dc800215 	stw	r18,8(sp)
  8172d4:	2025883a 	mov	r18,r4
  8172d8:	2809883a 	mov	r4,r5
  8172dc:	dfc00415 	stw	ra,16(sp)
  8172e0:	dc400115 	stw	r17,4(sp)
  8172e4:	dc000015 	stw	r16,0(sp)
  8172e8:	dcc00315 	stw	r19,12(sp)
  8172ec:	080f5fc0 	call	80f5fc <__floatunsidf>
  8172f0:	100d883a 	mov	r6,r2
  8172f4:	180f883a 	mov	r7,r3
  8172f8:	0005883a 	mov	r2,zero
  8172fc:	00d07c34 	movhi	r3,16880
  817300:	380b883a 	mov	r5,r7
  817304:	3009883a 	mov	r4,r6
  817308:	180f883a 	mov	r7,r3
  81730c:	100d883a 	mov	r6,r2
  817310:	080eb680 	call	80eb68 <__muldf3>
  817314:	9009883a 	mov	r4,r18
  817318:	1021883a 	mov	r16,r2
  81731c:	1823883a 	mov	r17,r3
  817320:	080f5fc0 	call	80f5fc <__floatunsidf>
  817324:	880b883a 	mov	r5,r17
  817328:	8009883a 	mov	r4,r16
  81732c:	180f883a 	mov	r7,r3
  817330:	100d883a 	mov	r6,r2
  817334:	080eaf40 	call	80eaf4 <__adddf3>
  817338:	dfc00417 	ldw	ra,16(sp)
  81733c:	dcc00317 	ldw	r19,12(sp)
  817340:	dc800217 	ldw	r18,8(sp)
  817344:	dc400117 	ldw	r17,4(sp)
  817348:	dc000017 	ldw	r16,0(sp)
  81734c:	dec00504 	addi	sp,sp,20
  817350:	f800283a 	ret

00817354 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  817354:	defffd04 	addi	sp,sp,-12
  817358:	df000215 	stw	fp,8(sp)
  81735c:	df000204 	addi	fp,sp,8
  817360:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
  817364:	e0bfff17 	ldw	r2,-4(fp)
  817368:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  81736c:	e0bffe17 	ldw	r2,-8(fp)
  817370:	1005003a 	cmpeq	r2,r2,zero
  817374:	1000021e 	bne	r2,zero,817380 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
  817378:	002af070 	cmpltui	zero,zero,43969
  81737c:	00000106 	br	817384 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
  817380:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
  817384:	e037883a 	mov	sp,fp
  817388:	df000017 	ldw	fp,0(sp)
  81738c:	dec00104 	addi	sp,sp,4
  817390:	f800283a 	ret

00817394 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  817394:	defffd04 	addi	sp,sp,-12
  817398:	dfc00215 	stw	ra,8(sp)
  81739c:	df000115 	stw	fp,4(sp)
  8173a0:	df000104 	addi	fp,sp,4
  8173a4:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  8173a8:	08165b00 	call	8165b0 <port_halt>

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
  8173ac:	e13fff17 	ldw	r4,-4(fp)
  8173b0:	08173540 	call	817354 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  8173b4:	003fff06 	br	8173b4 <_exit+0x20>
  8173b8:	00000010 	cmplti	zero,zero,0
  8173bc:	00000000 	call	0 <__reset-0x800000>
  8173c0:	00527a01 	jmpi	527a0 <__reset-0x7ad860>
  8173c4:	011f7c01 	jmpi	11f7c0 <__reset-0x6e0840>
  8173c8:	001b0c0b 	ldhu	zero,27696(zero)
  8173cc:	00000028 	cmpgeui	zero,zero,0
  8173d0:	00000018 	cmpnei	zero,zero,0
  8173d4:	0080d998 	cmpnei	r2,zero,870
  8173d8:	0000066c 	andhi	zero,zero,25
  8173dc:	3c0e4400 	call	3c0e440 <__alt_data_end+0x2c0e440>
  8173e0:	910a9074 	orhi	r4,r18,10817
  8173e4:	94089209 	0x94089209
  8173e8:	97049606 	br	818644 <__mprec_tens+0x18>
  8173ec:	93019f03 	ldbu	r12,1660(r18)
  8173f0:	9c059507 	ldb	r16,5716(r19)
  8173f4:	00000002 	0x2
  8173f8:	00000028 	cmpgeui	zero,zero,0
  8173fc:	00000044 	movi	zero,1
  817400:	0080e004 	movi	r2,896
  817404:	00000660 	cmpeqi	zero,zero,25
  817408:	400e4400 	call	400e440 <__alt_data_end+0x300e440>
  81740c:	92099170 	cmpltui	r8,r18,9797
  817410:	96069408 	cmpgei	et,r18,6736
  817414:	9c039704 	addi	r16,r19,3676
  817418:	90019f02 	0x90019f02
  81741c:	9507930a 	0x9507930a
  817420:	00000005 	stb	zero,0(zero)
  817424:	00816f38 	rdprs	r2,zero,1468
